(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var vue = {exports: {}};

	/*!
	 * Vue.js v2.7.8
	 * (c) 2014-2022 Evan You
	 * Released under the MIT License.
	 */

	(function (module, exports) {
		(function (global, factory) {
		  module.exports = factory() ;
		})(commonjsGlobal, (function () {
		  var emptyObject = Object.freeze({});
		  var isArray = Array.isArray;
		  // These helpers produce better VM code in JS engines due to their
		  // explicitness and function inlining.
		  function isUndef(v) {
		      return v === undefined || v === null;
		  }
		  function isDef(v) {
		      return v !== undefined && v !== null;
		  }
		  function isTrue(v) {
		      return v === true;
		  }
		  function isFalse(v) {
		      return v === false;
		  }
		  /**
		   * Check if value is primitive.
		   */
		  function isPrimitive(value) {
		      return (typeof value === 'string' ||
		          typeof value === 'number' ||
		          // $flow-disable-line
		          typeof value === 'symbol' ||
		          typeof value === 'boolean');
		  }
		  function isFunction(value) {
		      return typeof value === 'function';
		  }
		  /**
		   * Quick object check - this is primarily used to tell
		   * objects from primitive values when we know the value
		   * is a JSON-compliant type.
		   */
		  function isObject(obj) {
		      return obj !== null && typeof obj === 'object';
		  }
		  /**
		   * Get the raw type string of a value, e.g., [object Object].
		   */
		  var _toString = Object.prototype.toString;
		  function toRawType(value) {
		      return _toString.call(value).slice(8, -1);
		  }
		  /**
		   * Strict object type check. Only returns true
		   * for plain JavaScript objects.
		   */
		  function isPlainObject(obj) {
		      return _toString.call(obj) === '[object Object]';
		  }
		  function isRegExp(v) {
		      return _toString.call(v) === '[object RegExp]';
		  }
		  /**
		   * Check if val is a valid array index.
		   */
		  function isValidArrayIndex(val) {
		      var n = parseFloat(String(val));
		      return n >= 0 && Math.floor(n) === n && isFinite(val);
		  }
		  function isPromise(val) {
		      return (isDef(val) &&
		          typeof val.then === 'function' &&
		          typeof val.catch === 'function');
		  }
		  /**
		   * Convert a value to a string that is actually rendered.
		   */
		  function toString(val) {
		      return val == null
		          ? ''
		          : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
		              ? JSON.stringify(val, null, 2)
		              : String(val);
		  }
		  /**
		   * Convert an input value to a number for persistence.
		   * If the conversion fails, return original string.
		   */
		  function toNumber(val) {
		      var n = parseFloat(val);
		      return isNaN(n) ? val : n;
		  }
		  /**
		   * Make a map and return a function for checking if a key
		   * is in that map.
		   */
		  function makeMap(str, expectsLowerCase) {
		      var map = Object.create(null);
		      var list = str.split(',');
		      for (var i = 0; i < list.length; i++) {
		          map[list[i]] = true;
		      }
		      return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
		  }
		  /**
		   * Check if a tag is a built-in tag.
		   */
		  var isBuiltInTag = makeMap('slot,component', true);
		  /**
		   * Check if an attribute is a reserved attribute.
		   */
		  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
		  /**
		   * Remove an item from an array.
		   */
		  function remove$2(arr, item) {
		      if (arr.length) {
		          var index = arr.indexOf(item);
		          if (index > -1) {
		              return arr.splice(index, 1);
		          }
		      }
		  }
		  /**
		   * Check whether an object has the property.
		   */
		  var hasOwnProperty = Object.prototype.hasOwnProperty;
		  function hasOwn(obj, key) {
		      return hasOwnProperty.call(obj, key);
		  }
		  /**
		   * Create a cached version of a pure function.
		   */
		  function cached(fn) {
		      var cache = Object.create(null);
		      return function cachedFn(str) {
		          var hit = cache[str];
		          return hit || (cache[str] = fn(str));
		      };
		  }
		  /**
		   * Camelize a hyphen-delimited string.
		   */
		  var camelizeRE = /-(\w)/g;
		  var camelize = cached(function (str) {
		      return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
		  });
		  /**
		   * Capitalize a string.
		   */
		  var capitalize = cached(function (str) {
		      return str.charAt(0).toUpperCase() + str.slice(1);
		  });
		  /**
		   * Hyphenate a camelCase string.
		   */
		  var hyphenateRE = /\B([A-Z])/g;
		  var hyphenate = cached(function (str) {
		      return str.replace(hyphenateRE, '-$1').toLowerCase();
		  });
		  /**
		   * Simple bind polyfill for environments that do not support it,
		   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
		   * since native bind is now performant enough in most browsers.
		   * But removing it would mean breaking code that was able to run in
		   * PhantomJS 1.x, so this must be kept for backward compatibility.
		   */
		  /* istanbul ignore next */
		  function polyfillBind(fn, ctx) {
		      function boundFn(a) {
		          var l = arguments.length;
		          return l
		              ? l > 1
		                  ? fn.apply(ctx, arguments)
		                  : fn.call(ctx, a)
		              : fn.call(ctx);
		      }
		      boundFn._length = fn.length;
		      return boundFn;
		  }
		  function nativeBind(fn, ctx) {
		      return fn.bind(ctx);
		  }
		  // @ts-expect-error bind cannot be `undefined`
		  var bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;
		  /**
		   * Convert an Array-like object to a real Array.
		   */
		  function toArray(list, start) {
		      start = start || 0;
		      var i = list.length - start;
		      var ret = new Array(i);
		      while (i--) {
		          ret[i] = list[i + start];
		      }
		      return ret;
		  }
		  /**
		   * Mix properties into target object.
		   */
		  function extend(to, _from) {
		      for (var key in _from) {
		          to[key] = _from[key];
		      }
		      return to;
		  }
		  /**
		   * Merge an Array of Objects into a single Object.
		   */
		  function toObject(arr) {
		      var res = {};
		      for (var i = 0; i < arr.length; i++) {
		          if (arr[i]) {
		              extend(res, arr[i]);
		          }
		      }
		      return res;
		  }
		  /* eslint-disable no-unused-vars */
		  /**
		   * Perform no operation.
		   * Stubbing args to make Flow happy without leaving useless transpiled code
		   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
		   */
		  function noop(a, b, c) { }
		  /**
		   * Always return false.
		   */
		  var no = function (a, b, c) { return false; };
		  /* eslint-enable no-unused-vars */
		  /**
		   * Return the same value.
		   */
		  var identity = function (_) { return _; };
		  /**
		   * Generate a string containing static keys from compiler modules.
		   */
		  function genStaticKeys$1(modules) {
		      return modules
		          .reduce(function (keys, m) {
		          return keys.concat(m.staticKeys || []);
		      }, [])
		          .join(',');
		  }
		  /**
		   * Check if two values are loosely equal - that is,
		   * if they are plain objects, do they have the same shape?
		   */
		  function looseEqual(a, b) {
		      if (a === b)
		          return true;
		      var isObjectA = isObject(a);
		      var isObjectB = isObject(b);
		      if (isObjectA && isObjectB) {
		          try {
		              var isArrayA = Array.isArray(a);
		              var isArrayB = Array.isArray(b);
		              if (isArrayA && isArrayB) {
		                  return (a.length === b.length &&
		                      a.every(function (e, i) {
		                          return looseEqual(e, b[i]);
		                      }));
		              }
		              else if (a instanceof Date && b instanceof Date) {
		                  return a.getTime() === b.getTime();
		              }
		              else if (!isArrayA && !isArrayB) {
		                  var keysA = Object.keys(a);
		                  var keysB = Object.keys(b);
		                  return (keysA.length === keysB.length &&
		                      keysA.every(function (key) {
		                          return looseEqual(a[key], b[key]);
		                      }));
		              }
		              else {
		                  /* istanbul ignore next */
		                  return false;
		              }
		          }
		          catch (e) {
		              /* istanbul ignore next */
		              return false;
		          }
		      }
		      else if (!isObjectA && !isObjectB) {
		          return String(a) === String(b);
		      }
		      else {
		          return false;
		      }
		  }
		  /**
		   * Return the first index at which a loosely equal value can be
		   * found in the array (if value is a plain object, the array must
		   * contain an object of the same shape), or -1 if it is not present.
		   */
		  function looseIndexOf(arr, val) {
		      for (var i = 0; i < arr.length; i++) {
		          if (looseEqual(arr[i], val))
		              return i;
		      }
		      return -1;
		  }
		  /**
		   * Ensure a function is called only once.
		   */
		  function once(fn) {
		      var called = false;
		      return function () {
		          if (!called) {
		              called = true;
		              fn.apply(this, arguments);
		          }
		      };
		  }
		  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
		  function hasChanged(x, y) {
		      if (x === y) {
		          return x === 0 && 1 / x !== 1 / y;
		      }
		      else {
		          return x === x || y === y;
		      }
		  }

		  var SSR_ATTR = 'data-server-rendered';
		  var ASSET_TYPES = ['component', 'directive', 'filter'];
		  var LIFECYCLE_HOOKS = [
		      'beforeCreate',
		      'created',
		      'beforeMount',
		      'mounted',
		      'beforeUpdate',
		      'updated',
		      'beforeDestroy',
		      'destroyed',
		      'activated',
		      'deactivated',
		      'errorCaptured',
		      'serverPrefetch',
		      'renderTracked',
		      'renderTriggered'
		  ];

		  var config = {
		      /**
		       * Option merge strategies (used in core/util/options)
		       */
		      // $flow-disable-line
		      optionMergeStrategies: Object.create(null),
		      /**
		       * Whether to suppress warnings.
		       */
		      silent: false,
		      /**
		       * Show production mode tip message on boot?
		       */
		      productionTip: true,
		      /**
		       * Whether to enable devtools
		       */
		      devtools: true,
		      /**
		       * Whether to record perf
		       */
		      performance: false,
		      /**
		       * Error handler for watcher errors
		       */
		      errorHandler: null,
		      /**
		       * Warn handler for watcher warns
		       */
		      warnHandler: null,
		      /**
		       * Ignore certain custom elements
		       */
		      ignoredElements: [],
		      /**
		       * Custom user key aliases for v-on
		       */
		      // $flow-disable-line
		      keyCodes: Object.create(null),
		      /**
		       * Check if a tag is reserved so that it cannot be registered as a
		       * component. This is platform-dependent and may be overwritten.
		       */
		      isReservedTag: no,
		      /**
		       * Check if an attribute is reserved so that it cannot be used as a component
		       * prop. This is platform-dependent and may be overwritten.
		       */
		      isReservedAttr: no,
		      /**
		       * Check if a tag is an unknown element.
		       * Platform-dependent.
		       */
		      isUnknownElement: no,
		      /**
		       * Get the namespace of an element
		       */
		      getTagNamespace: noop,
		      /**
		       * Parse the real tag name for the specific platform.
		       */
		      parsePlatformTagName: identity,
		      /**
		       * Check if an attribute must be bound using property, e.g. value
		       * Platform-dependent.
		       */
		      mustUseProp: no,
		      /**
		       * Perform updates asynchronously. Intended to be used by Vue Test Utils
		       * This will significantly reduce performance if set to false.
		       */
		      async: true,
		      /**
		       * Exposed for legacy reasons
		       */
		      _lifecycleHooks: LIFECYCLE_HOOKS
		  };

		  /**
		   * unicode letters used for parsing html tags, component names and property paths.
		   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
		   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
		   */
		  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
		  /**
		   * Check if a string starts with $ or _
		   */
		  function isReserved(str) {
		      var c = (str + '').charCodeAt(0);
		      return c === 0x24 || c === 0x5f;
		  }
		  /**
		   * Define a property.
		   */
		  function def(obj, key, val, enumerable) {
		      Object.defineProperty(obj, key, {
		          value: val,
		          enumerable: !!enumerable,
		          writable: true,
		          configurable: true
		      });
		  }
		  /**
		   * Parse simple path.
		   */
		  var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
		  function parsePath(path) {
		      if (bailRE.test(path)) {
		          return;
		      }
		      var segments = path.split('.');
		      return function (obj) {
		          for (var i = 0; i < segments.length; i++) {
		              if (!obj)
		                  return;
		              obj = obj[segments[i]];
		          }
		          return obj;
		      };
		  }

		  // can we use __proto__?
		  var hasProto = '__proto__' in {};
		  // Browser environment sniffing
		  var inBrowser = typeof window !== 'undefined';
		  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
		  var isIE = UA && /msie|trident/.test(UA);
		  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
		  var isEdge = UA && UA.indexOf('edge/') > 0;
		  UA && UA.indexOf('android') > 0;
		  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
		  UA && /chrome\/\d+/.test(UA) && !isEdge;
		  UA && /phantomjs/.test(UA);
		  var isFF = UA && UA.match(/firefox\/(\d+)/);
		  // Firefox has a "watch" function on Object.prototype...
		  // @ts-expect-error firebox support
		  var nativeWatch = {}.watch;
		  var supportsPassive = false;
		  if (inBrowser) {
		      try {
		          var opts = {};
		          Object.defineProperty(opts, 'passive', {
		              get: function () {
		                  /* istanbul ignore next */
		                  supportsPassive = true;
		              }
		          }); // https://github.com/facebook/flow/issues/285
		          window.addEventListener('test-passive', null, opts);
		      }
		      catch (e) { }
		  }
		  // this needs to be lazy-evaled because vue may be required before
		  // vue-server-renderer can set VUE_ENV
		  var _isServer;
		  var isServerRendering = function () {
		      if (_isServer === undefined) {
		          /* istanbul ignore if */
		          if (!inBrowser && typeof commonjsGlobal !== 'undefined') {
		              // detect presence of vue-server-renderer and avoid
		              // Webpack shimming the process
		              _isServer =
		                  commonjsGlobal['process'] && commonjsGlobal['process'].env.VUE_ENV === 'server';
		          }
		          else {
		              _isServer = false;
		          }
		      }
		      return _isServer;
		  };
		  // detect devtools
		  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
		  /* istanbul ignore next */
		  function isNative(Ctor) {
		      return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
		  }
		  var hasSymbol = typeof Symbol !== 'undefined' &&
		      isNative(Symbol) &&
		      typeof Reflect !== 'undefined' &&
		      isNative(Reflect.ownKeys);
		  var _Set; // $flow-disable-line
		  /* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
		      // use native Set when available.
		      _Set = Set;
		  }
		  else {
		      // a non-standard Set polyfill that only works with primitive keys.
		      _Set = /** @class */ (function () {
		          function Set() {
		              this.set = Object.create(null);
		          }
		          Set.prototype.has = function (key) {
		              return this.set[key] === true;
		          };
		          Set.prototype.add = function (key) {
		              this.set[key] = true;
		          };
		          Set.prototype.clear = function () {
		              this.set = Object.create(null);
		          };
		          return Set;
		      }());
		  }

		  var currentInstance = null;
		  /**
		   * This is exposed for compatibility with v3 (e.g. some functions in VueUse
		   * relies on it). Do not use this internally, just use `currentInstance`.
		   *
		   * @internal this function needs manual type declaration because it relies
		   * on previously manually authored types from Vue 2
		   */
		  function getCurrentInstance() {
		      return currentInstance && { proxy: currentInstance };
		  }
		  /**
		   * @internal
		   */
		  function setCurrentInstance(vm) {
		      if (vm === void 0) { vm = null; }
		      if (!vm)
		          currentInstance && currentInstance._scope.off();
		      currentInstance = vm;
		      vm && vm._scope.on();
		  }

		  /**
		   * @internal
		   */
		  var VNode = /** @class */ (function () {
		      function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
		          this.tag = tag;
		          this.data = data;
		          this.children = children;
		          this.text = text;
		          this.elm = elm;
		          this.ns = undefined;
		          this.context = context;
		          this.fnContext = undefined;
		          this.fnOptions = undefined;
		          this.fnScopeId = undefined;
		          this.key = data && data.key;
		          this.componentOptions = componentOptions;
		          this.componentInstance = undefined;
		          this.parent = undefined;
		          this.raw = false;
		          this.isStatic = false;
		          this.isRootInsert = true;
		          this.isComment = false;
		          this.isCloned = false;
		          this.isOnce = false;
		          this.asyncFactory = asyncFactory;
		          this.asyncMeta = undefined;
		          this.isAsyncPlaceholder = false;
		      }
		      Object.defineProperty(VNode.prototype, "child", {
		          // DEPRECATED: alias for componentInstance for backwards compat.
		          /* istanbul ignore next */
		          get: function () {
		              return this.componentInstance;
		          },
		          enumerable: false,
		          configurable: true
		      });
		      return VNode;
		  }());
		  var createEmptyVNode = function (text) {
		      if (text === void 0) { text = ''; }
		      var node = new VNode();
		      node.text = text;
		      node.isComment = true;
		      return node;
		  };
		  function createTextVNode(val) {
		      return new VNode(undefined, undefined, undefined, String(val));
		  }
		  // optimized shallow clone
		  // used for static nodes and slot nodes because they may be reused across
		  // multiple renders, cloning them avoids errors when DOM manipulations rely
		  // on their elm reference.
		  function cloneVNode(vnode) {
		      var cloned = new VNode(vnode.tag, vnode.data, 
		      // #7975
		      // clone children array to avoid mutating original in case of cloning
		      // a child.
		      vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
		      cloned.ns = vnode.ns;
		      cloned.isStatic = vnode.isStatic;
		      cloned.key = vnode.key;
		      cloned.isComment = vnode.isComment;
		      cloned.fnContext = vnode.fnContext;
		      cloned.fnOptions = vnode.fnOptions;
		      cloned.fnScopeId = vnode.fnScopeId;
		      cloned.asyncMeta = vnode.asyncMeta;
		      cloned.isCloned = true;
		      return cloned;
		  }

		  /* not type checking this file because flow doesn't play well with Proxy */
		  var initProxy;
		  {
		      var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
		          'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
		          'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
		          'require' // for Webpack/Browserify
		      );
		      var warnNonPresent_1 = function (target, key) {
		          warn$2("Property or method \"".concat(key, "\" is not defined on the instance but ") +
		              'referenced during render. Make sure that this property is reactive, ' +
		              'either in the data option, or for class-based components, by ' +
		              'initializing the property. ' +
		              'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
		      };
		      var warnReservedPrefix_1 = function (target, key) {
		          warn$2("Property \"".concat(key, "\" must be accessed with \"$data.").concat(key, "\" because ") +
		              'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
		              'prevent conflicts with Vue internals. ' +
		              'See: https://vuejs.org/v2/api/#data', target);
		      };
		      var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
		      if (hasProxy_1) {
		          var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
		          config.keyCodes = new Proxy(config.keyCodes, {
		              set: function (target, key, value) {
		                  if (isBuiltInModifier_1(key)) {
		                      warn$2("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
		                      return false;
		                  }
		                  else {
		                      target[key] = value;
		                      return true;
		                  }
		              }
		          });
		      }
		      var hasHandler_1 = {
		          has: function (target, key) {
		              var has = key in target;
		              var isAllowed = allowedGlobals_1(key) ||
		                  (typeof key === 'string' &&
		                      key.charAt(0) === '_' &&
		                      !(key in target.$data));
		              if (!has && !isAllowed) {
		                  if (key in target.$data)
		                      warnReservedPrefix_1(target, key);
		                  else
		                      warnNonPresent_1(target, key);
		              }
		              return has || !isAllowed;
		          }
		      };
		      var getHandler_1 = {
		          get: function (target, key) {
		              if (typeof key === 'string' && !(key in target)) {
		                  if (key in target.$data)
		                      warnReservedPrefix_1(target, key);
		                  else
		                      warnNonPresent_1(target, key);
		              }
		              return target[key];
		          }
		      };
		      initProxy = function initProxy(vm) {
		          if (hasProxy_1) {
		              // determine which proxy handler to use
		              var options = vm.$options;
		              var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
		              vm._renderProxy = new Proxy(vm, handlers);
		          }
		          else {
		              vm._renderProxy = vm;
		          }
		      };
		  }

		  /******************************************************************************
		  Copyright (c) Microsoft Corporation.

		  Permission to use, copy, modify, and/or distribute this software for any
		  purpose with or without fee is hereby granted.

		  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		  PERFORMANCE OF THIS SOFTWARE.
		  ***************************************************************************** */

		  var __assign = function() {
		      __assign = Object.assign || function __assign(t) {
		          for (var s, i = 1, n = arguments.length; i < n; i++) {
		              s = arguments[i];
		              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
		          }
		          return t;
		      };
		      return __assign.apply(this, arguments);
		  };

		  var uid$2 = 0;
		  /**
		   * A dep is an observable that can have multiple
		   * directives subscribing to it.
		   * @internal
		   */
		  var Dep = /** @class */ (function () {
		      function Dep() {
		          this.id = uid$2++;
		          this.subs = [];
		      }
		      Dep.prototype.addSub = function (sub) {
		          this.subs.push(sub);
		      };
		      Dep.prototype.removeSub = function (sub) {
		          remove$2(this.subs, sub);
		      };
		      Dep.prototype.depend = function (info) {
		          if (Dep.target) {
		              Dep.target.addDep(this);
		              if (info && Dep.target.onTrack) {
		                  Dep.target.onTrack(__assign({ effect: Dep.target }, info));
		              }
		          }
		      };
		      Dep.prototype.notify = function (info) {
		          // stabilize the subscriber list first
		          var subs = this.subs.slice();
		          if (!config.async) {
		              // subs aren't sorted in scheduler if not running async
		              // we need to sort them now to make sure they fire in correct
		              // order
		              subs.sort(function (a, b) { return a.id - b.id; });
		          }
		          for (var i = 0, l = subs.length; i < l; i++) {
		              if (info) {
		                  var sub = subs[i];
		                  sub.onTrigger &&
		                      sub.onTrigger(__assign({ effect: subs[i] }, info));
		              }
		              subs[i].update();
		          }
		      };
		      return Dep;
		  }());
		  // The current target watcher being evaluated.
		  // This is globally unique because only one watcher
		  // can be evaluated at a time.
		  Dep.target = null;
		  var targetStack = [];
		  function pushTarget(target) {
		      targetStack.push(target);
		      Dep.target = target;
		  }
		  function popTarget() {
		      targetStack.pop();
		      Dep.target = targetStack[targetStack.length - 1];
		  }

		  /*
		   * not type checking this file because flow doesn't play well with
		   * dynamically accessing methods on Array prototype
		   */
		  var arrayProto = Array.prototype;
		  var arrayMethods = Object.create(arrayProto);
		  var methodsToPatch = [
		      'push',
		      'pop',
		      'shift',
		      'unshift',
		      'splice',
		      'sort',
		      'reverse'
		  ];
		  /**
		   * Intercept mutating methods and emit events
		   */
		  methodsToPatch.forEach(function (method) {
		      // cache original method
		      var original = arrayProto[method];
		      def(arrayMethods, method, function mutator() {
		          var args = [];
		          for (var _i = 0; _i < arguments.length; _i++) {
		              args[_i] = arguments[_i];
		          }
		          var result = original.apply(this, args);
		          var ob = this.__ob__;
		          var inserted;
		          switch (method) {
		              case 'push':
		              case 'unshift':
		                  inserted = args;
		                  break;
		              case 'splice':
		                  inserted = args.slice(2);
		                  break;
		          }
		          if (inserted)
		              ob.observeArray(inserted);
		          // notify change
		          {
		              ob.dep.notify({
		                  type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
		                  target: this,
		                  key: method
		              });
		          }
		          return result;
		      });
		  });

		  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
		  var NO_INIITIAL_VALUE = {};
		  /**
		   * In some cases we may want to disable observation inside a component's
		   * update computation.
		   */
		  var shouldObserve = true;
		  function toggleObserving(value) {
		      shouldObserve = value;
		  }
		  // ssr mock dep
		  var mockDep = {
		      notify: noop,
		      depend: noop,
		      addSub: noop,
		      removeSub: noop
		  };
		  /**
		   * Observer class that is attached to each observed
		   * object. Once attached, the observer converts the target
		   * object's property keys into getter/setters that
		   * collect dependencies and dispatch updates.
		   */
		  var Observer = /** @class */ (function () {
		      function Observer(value, shallow, mock) {
		          if (shallow === void 0) { shallow = false; }
		          if (mock === void 0) { mock = false; }
		          this.value = value;
		          this.shallow = shallow;
		          this.mock = mock;
		          // this.value = value
		          this.dep = mock ? mockDep : new Dep();
		          this.vmCount = 0;
		          def(value, '__ob__', this);
		          if (isArray(value)) {
		              if (!mock) {
		                  if (hasProto) {
		                      value.__proto__ = arrayMethods;
		                      /* eslint-enable no-proto */
		                  }
		                  else {
		                      for (var i = 0, l = arrayKeys.length; i < l; i++) {
		                          var key = arrayKeys[i];
		                          def(value, key, arrayMethods[key]);
		                      }
		                  }
		              }
		              if (!shallow) {
		                  this.observeArray(value);
		              }
		          }
		          else {
		              /**
		               * Walk through all properties and convert them into
		               * getter/setters. This method should only be called when
		               * value type is Object.
		               */
		              var keys = Object.keys(value);
		              for (var i = 0; i < keys.length; i++) {
		                  var key = keys[i];
		                  defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);
		              }
		          }
		      }
		      /**
		       * Observe a list of Array items.
		       */
		      Observer.prototype.observeArray = function (value) {
		          for (var i = 0, l = value.length; i < l; i++) {
		              observe(value[i], false, this.mock);
		          }
		      };
		      return Observer;
		  }());
		  // helpers
		  /**
		   * Attempt to create an observer instance for a value,
		   * returns the new observer if successfully observed,
		   * or the existing observer if the value already has one.
		   */
		  function observe(value, shallow, ssrMockReactivity) {
		      if (!isObject(value) || isRef(value) || value instanceof VNode) {
		          return;
		      }
		      var ob;
		      if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
		          ob = value.__ob__;
		      }
		      else if (shouldObserve &&
		          (ssrMockReactivity || !isServerRendering()) &&
		          (isArray(value) || isPlainObject(value)) &&
		          Object.isExtensible(value) &&
		          !value.__v_skip /* ReactiveFlags.SKIP */) {
		          ob = new Observer(value, shallow, ssrMockReactivity);
		      }
		      return ob;
		  }
		  /**
		   * Define a reactive property on an Object.
		   */
		  function defineReactive(obj, key, val, customSetter, shallow, mock) {
		      var dep = new Dep();
		      var property = Object.getOwnPropertyDescriptor(obj, key);
		      if (property && property.configurable === false) {
		          return;
		      }
		      // cater for pre-defined getter/setters
		      var getter = property && property.get;
		      var setter = property && property.set;
		      if ((!getter || setter) &&
		          (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
		          val = obj[key];
		      }
		      var childOb = !shallow && observe(val, false, mock);
		      Object.defineProperty(obj, key, {
		          enumerable: true,
		          configurable: true,
		          get: function reactiveGetter() {
		              var value = getter ? getter.call(obj) : val;
		              if (Dep.target) {
		                  {
		                      dep.depend({
		                          target: obj,
		                          type: "get" /* TrackOpTypes.GET */,
		                          key: key
		                      });
		                  }
		                  if (childOb) {
		                      childOb.dep.depend();
		                      if (isArray(value)) {
		                          dependArray(value);
		                      }
		                  }
		              }
		              return isRef(value) && !shallow ? value.value : value;
		          },
		          set: function reactiveSetter(newVal) {
		              var value = getter ? getter.call(obj) : val;
		              if (!hasChanged(value, newVal)) {
		                  return;
		              }
		              if (customSetter) {
		                  customSetter();
		              }
		              if (setter) {
		                  setter.call(obj, newVal);
		              }
		              else if (getter) {
		                  // #7981: for accessor properties without setter
		                  return;
		              }
		              else if (!shallow && isRef(value) && !isRef(newVal)) {
		                  value.value = newVal;
		                  return;
		              }
		              else {
		                  val = newVal;
		              }
		              childOb = !shallow && observe(newVal, false, mock);
		              {
		                  dep.notify({
		                      type: "set" /* TriggerOpTypes.SET */,
		                      target: obj,
		                      key: key,
		                      newValue: newVal,
		                      oldValue: value
		                  });
		              }
		          }
		      });
		      return dep;
		  }
		  function set(target, key, val) {
		      if ((isUndef(target) || isPrimitive(target))) {
		          warn$2("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
		      }
		      if (isReadonly(target)) {
		          warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
		          return;
		      }
		      var ob = target.__ob__;
		      if (isArray(target) && isValidArrayIndex(key)) {
		          target.length = Math.max(target.length, key);
		          target.splice(key, 1, val);
		          // when mocking for SSR, array methods are not hijacked
		          if (ob && !ob.shallow && ob.mock) {
		              observe(val, false, true);
		          }
		          return val;
		      }
		      if (key in target && !(key in Object.prototype)) {
		          target[key] = val;
		          return val;
		      }
		      if (target._isVue || (ob && ob.vmCount)) {
		          warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +
		                  'at runtime - declare it upfront in the data option.');
		          return val;
		      }
		      if (!ob) {
		          target[key] = val;
		          return val;
		      }
		      defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
		      {
		          ob.dep.notify({
		              type: "add" /* TriggerOpTypes.ADD */,
		              target: target,
		              key: key,
		              newValue: val,
		              oldValue: undefined
		          });
		      }
		      return val;
		  }
		  function del(target, key) {
		      if ((isUndef(target) || isPrimitive(target))) {
		          warn$2("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target));
		      }
		      if (isArray(target) && isValidArrayIndex(key)) {
		          target.splice(key, 1);
		          return;
		      }
		      var ob = target.__ob__;
		      if (target._isVue || (ob && ob.vmCount)) {
		          warn$2('Avoid deleting properties on a Vue instance or its root $data ' +
		                  '- just set it to null.');
		          return;
		      }
		      if (isReadonly(target)) {
		          warn$2("Delete operation on key \"".concat(key, "\" failed: target is readonly."));
		          return;
		      }
		      if (!hasOwn(target, key)) {
		          return;
		      }
		      delete target[key];
		      if (!ob) {
		          return;
		      }
		      {
		          ob.dep.notify({
		              type: "delete" /* TriggerOpTypes.DELETE */,
		              target: target,
		              key: key
		          });
		      }
		  }
		  /**
		   * Collect dependencies on array elements when the array is touched, since
		   * we cannot intercept array element access like property getters.
		   */
		  function dependArray(value) {
		      for (var e = void 0, i = 0, l = value.length; i < l; i++) {
		          e = value[i];
		          if (e && e.__ob__) {
		              e.__ob__.dep.depend();
		          }
		          if (isArray(e)) {
		              dependArray(e);
		          }
		      }
		  }

		  function reactive(target) {
		      makeReactive(target, false);
		      return target;
		  }
		  /**
		   * Return a shallowly-reactive copy of the original object, where only the root
		   * level properties are reactive. It also does not auto-unwrap refs (even at the
		   * root level).
		   */
		  function shallowReactive(target) {
		      makeReactive(target, true);
		      def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
		      return target;
		  }
		  function makeReactive(target, shallow) {
		      // if trying to observe a readonly proxy, return the readonly version.
		      if (!isReadonly(target)) {
		          {
		              if (isArray(target)) {
		                  warn$2("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
		              }
		              var existingOb = target && target.__ob__;
		              if (existingOb && existingOb.shallow !== shallow) {
		                  warn$2("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
		              }
		          }
		          var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
		          if (!ob) {
		              if (target == null || isPrimitive(target)) {
		                  warn$2("value cannot be made reactive: ".concat(String(target)));
		              }
		              if (isCollectionType(target)) {
		                  warn$2("Vue 2 does not support reactive collection types such as Map or Set.");
		              }
		          }
		      }
		  }
		  function isReactive(value) {
		      if (isReadonly(value)) {
		          return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
		      }
		      return !!(value && value.__ob__);
		  }
		  function isShallow(value) {
		      return !!(value && value.__v_isShallow);
		  }
		  function isReadonly(value) {
		      return !!(value && value.__v_isReadonly);
		  }
		  function isProxy(value) {
		      return isReactive(value) || isReadonly(value);
		  }
		  function toRaw(observed) {
		      var raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
		      return raw ? toRaw(raw) : observed;
		  }
		  function markRaw(value) {
		      def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
		      return value;
		  }
		  /**
		   * @internal
		   */
		  function isCollectionType(value) {
		      var type = toRawType(value);
		      return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
		  }

		  /**
		   * @internal
		   */
		  var RefFlag = "__v_isRef";
		  function isRef(r) {
		      return !!(r && r.__v_isRef === true);
		  }
		  function ref$1(value) {
		      return createRef(value, false);
		  }
		  function shallowRef(value) {
		      return createRef(value, true);
		  }
		  function createRef(rawValue, shallow) {
		      if (isRef(rawValue)) {
		          return rawValue;
		      }
		      var ref = {};
		      def(ref, RefFlag, true);
		      def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
		      def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
		      return ref;
		  }
		  function triggerRef(ref) {
		      if (!ref.dep) {
		          warn$2("received object is not a triggerable ref.");
		      }
		      {
		          ref.dep &&
		              ref.dep.notify({
		                  type: "set" /* TriggerOpTypes.SET */,
		                  target: ref,
		                  key: 'value'
		              });
		      }
		  }
		  function unref(ref) {
		      return isRef(ref) ? ref.value : ref;
		  }
		  function proxyRefs(objectWithRefs) {
		      if (isReactive(objectWithRefs)) {
		          return objectWithRefs;
		      }
		      var proxy = {};
		      var keys = Object.keys(objectWithRefs);
		      for (var i = 0; i < keys.length; i++) {
		          proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
		      }
		      return proxy;
		  }
		  function proxyWithRefUnwrap(target, source, key) {
		      Object.defineProperty(target, key, {
		          enumerable: true,
		          configurable: true,
		          get: function () {
		              var val = source[key];
		              if (isRef(val)) {
		                  return val.value;
		              }
		              else {
		                  var ob = val && val.__ob__;
		                  if (ob)
		                      ob.dep.depend();
		                  return val;
		              }
		          },
		          set: function (value) {
		              var oldValue = source[key];
		              if (isRef(oldValue) && !isRef(value)) {
		                  oldValue.value = value;
		              }
		              else {
		                  source[key] = value;
		              }
		          }
		      });
		  }
		  function customRef(factory) {
		      var dep = new Dep();
		      var _a = factory(function () {
		          {
		              dep.depend({
		                  target: ref,
		                  type: "get" /* TrackOpTypes.GET */,
		                  key: 'value'
		              });
		          }
		      }, function () {
		          {
		              dep.notify({
		                  target: ref,
		                  type: "set" /* TriggerOpTypes.SET */,
		                  key: 'value'
		              });
		          }
		      }), get = _a.get, set = _a.set;
		      var ref = {
		          get value() {
		              return get();
		          },
		          set value(newVal) {
		              set(newVal);
		          }
		      };
		      def(ref, RefFlag, true);
		      return ref;
		  }
		  function toRefs(object) {
		      if (!isReactive(object)) {
		          warn$2("toRefs() expects a reactive object but received a plain one.");
		      }
		      var ret = isArray(object) ? new Array(object.length) : {};
		      for (var key in object) {
		          ret[key] = toRef(object, key);
		      }
		      return ret;
		  }
		  function toRef(object, key, defaultValue) {
		      var val = object[key];
		      if (isRef(val)) {
		          return val;
		      }
		      var ref = {
		          get value() {
		              var val = object[key];
		              return val === undefined ? defaultValue : val;
		          },
		          set value(newVal) {
		              object[key] = newVal;
		          }
		      };
		      def(ref, RefFlag, true);
		      return ref;
		  }

		  var rawToReadonlyFlag = "__v_rawToReadonly";
		  var rawToShallowReadonlyFlag = "__v_rawToShallowReadonly";
		  function readonly(target) {
		      return createReadonly(target, false);
		  }
		  function createReadonly(target, shallow) {
		      if (!isPlainObject(target)) {
		          {
		              if (isArray(target)) {
		                  warn$2("Vue 2 does not support readonly arrays.");
		              }
		              else if (isCollectionType(target)) {
		                  warn$2("Vue 2 does not support readonly collection types such as Map or Set.");
		              }
		              else {
		                  warn$2("value cannot be made readonly: ".concat(typeof target));
		              }
		          }
		          return target;
		      }
		      // already a readonly object
		      if (isReadonly(target)) {
		          return target;
		      }
		      // already has a readonly proxy
		      var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
		      var existingProxy = target[existingFlag];
		      if (existingProxy) {
		          return existingProxy;
		      }
		      var proxy = Object.create(Object.getPrototypeOf(target));
		      def(target, existingFlag, proxy);
		      def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
		      def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
		      if (isRef(target)) {
		          def(proxy, RefFlag, true);
		      }
		      if (shallow || isShallow(target)) {
		          def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
		      }
		      var keys = Object.keys(target);
		      for (var i = 0; i < keys.length; i++) {
		          defineReadonlyProperty(proxy, target, keys[i], shallow);
		      }
		      return proxy;
		  }
		  function defineReadonlyProperty(proxy, target, key, shallow) {
		      Object.defineProperty(proxy, key, {
		          enumerable: true,
		          configurable: true,
		          get: function () {
		              var val = target[key];
		              return shallow || !isPlainObject(val) ? val : readonly(val);
		          },
		          set: function () {
		              warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
		          }
		      });
		  }
		  /**
		   * Returns a reactive-copy of the original object, where only the root level
		   * properties are readonly, and does NOT unwrap refs nor recursively convert
		   * returned properties.
		   * This is used for creating the props proxy object for stateful components.
		   */
		  function shallowReadonly(target) {
		      return createReadonly(target, true);
		  }

		  function computed(getterOrOptions, debugOptions) {
		      var getter;
		      var setter;
		      var onlyGetter = isFunction(getterOrOptions);
		      if (onlyGetter) {
		          getter = getterOrOptions;
		          setter = function () {
		                  warn$2('Write operation failed: computed value is readonly');
		              }
		              ;
		      }
		      else {
		          getter = getterOrOptions.get;
		          setter = getterOrOptions.set;
		      }
		      var watcher = isServerRendering()
		          ? null
		          : new Watcher(currentInstance, getter, noop, { lazy: true });
		      if (watcher && debugOptions) {
		          watcher.onTrack = debugOptions.onTrack;
		          watcher.onTrigger = debugOptions.onTrigger;
		      }
		      var ref = {
		          // some libs rely on the presence effect for checking computed refs
		          // from normal refs, but the implementation doesn't matter
		          effect: watcher,
		          get value() {
		              if (watcher) {
		                  if (watcher.dirty) {
		                      watcher.evaluate();
		                  }
		                  if (Dep.target) {
		                      if (Dep.target.onTrack) {
		                          Dep.target.onTrack({
		                              effect: Dep.target,
		                              target: ref,
		                              type: "get" /* TrackOpTypes.GET */,
		                              key: 'value'
		                          });
		                      }
		                      watcher.depend();
		                  }
		                  return watcher.value;
		              }
		              else {
		                  return getter();
		              }
		          },
		          set value(newVal) {
		              setter(newVal);
		          }
		      };
		      def(ref, RefFlag, true);
		      def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
		      return ref;
		  }

		  var mark;
		  var measure;
		  {
		      var perf_1 = inBrowser && window.performance;
		      /* istanbul ignore if */
		      if (perf_1 &&
		          // @ts-ignore
		          perf_1.mark &&
		          // @ts-ignore
		          perf_1.measure &&
		          // @ts-ignore
		          perf_1.clearMarks &&
		          // @ts-ignore
		          perf_1.clearMeasures) {
		          mark = function (tag) { return perf_1.mark(tag); };
		          measure = function (name, startTag, endTag) {
		              perf_1.measure(name, startTag, endTag);
		              perf_1.clearMarks(startTag);
		              perf_1.clearMarks(endTag);
		              // perf.clearMeasures(name)
		          };
		      }
		  }

		  var normalizeEvent = cached(function (name) {
		      var passive = name.charAt(0) === '&';
		      name = passive ? name.slice(1) : name;
		      var once = name.charAt(0) === '~'; // Prefixed last, checked first
		      name = once ? name.slice(1) : name;
		      var capture = name.charAt(0) === '!';
		      name = capture ? name.slice(1) : name;
		      return {
		          name: name,
		          once: once,
		          capture: capture,
		          passive: passive
		      };
		  });
		  function createFnInvoker(fns, vm) {
		      function invoker() {
		          var fns = invoker.fns;
		          if (isArray(fns)) {
		              var cloned = fns.slice();
		              for (var i = 0; i < cloned.length; i++) {
		                  invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
		              }
		          }
		          else {
		              // return handler return value for single handlers
		              return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
		          }
		      }
		      invoker.fns = fns;
		      return invoker;
		  }
		  function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
		      var name, cur, old, event;
		      for (name in on) {
		          cur = on[name];
		          old = oldOn[name];
		          event = normalizeEvent(name);
		          if (isUndef(cur)) {
		              warn$2("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
		          }
		          else if (isUndef(old)) {
		              if (isUndef(cur.fns)) {
		                  cur = on[name] = createFnInvoker(cur, vm);
		              }
		              if (isTrue(event.once)) {
		                  cur = on[name] = createOnceHandler(event.name, cur, event.capture);
		              }
		              add(event.name, cur, event.capture, event.passive, event.params);
		          }
		          else if (cur !== old) {
		              old.fns = cur;
		              on[name] = old;
		          }
		      }
		      for (name in oldOn) {
		          if (isUndef(on[name])) {
		              event = normalizeEvent(name);
		              remove(event.name, oldOn[name], event.capture);
		          }
		      }
		  }

		  function mergeVNodeHook(def, hookKey, hook) {
		      if (def instanceof VNode) {
		          def = def.data.hook || (def.data.hook = {});
		      }
		      var invoker;
		      var oldHook = def[hookKey];
		      function wrappedHook() {
		          hook.apply(this, arguments);
		          // important: remove merged hook to ensure it's called only once
		          // and prevent memory leak
		          remove$2(invoker.fns, wrappedHook);
		      }
		      if (isUndef(oldHook)) {
		          // no existing hook
		          invoker = createFnInvoker([wrappedHook]);
		      }
		      else {
		          /* istanbul ignore if */
		          if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
		              // already a merged invoker
		              invoker = oldHook;
		              invoker.fns.push(wrappedHook);
		          }
		          else {
		              // existing plain hook
		              invoker = createFnInvoker([oldHook, wrappedHook]);
		          }
		      }
		      invoker.merged = true;
		      def[hookKey] = invoker;
		  }

		  function extractPropsFromVNodeData(data, Ctor, tag) {
		      // we are only extracting raw values here.
		      // validation and default values are handled in the child
		      // component itself.
		      var propOptions = Ctor.options.props;
		      if (isUndef(propOptions)) {
		          return;
		      }
		      var res = {};
		      var attrs = data.attrs, props = data.props;
		      if (isDef(attrs) || isDef(props)) {
		          for (var key in propOptions) {
		              var altKey = hyphenate(key);
		              {
		                  var keyInLowerCase = key.toLowerCase();
		                  if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
		                      tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
		                          "".concat(formatComponentName(
		                          // @ts-expect-error tag is string
		                          tag || Ctor), ", but the declared prop name is") +
		                          " \"".concat(key, "\". ") +
		                          "Note that HTML attributes are case-insensitive and camelCased " +
		                          "props need to use their kebab-case equivalents when using in-DOM " +
		                          "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
		                  }
		              }
		              checkProp(res, props, key, altKey, true) ||
		                  checkProp(res, attrs, key, altKey, false);
		          }
		      }
		      return res;
		  }
		  function checkProp(res, hash, key, altKey, preserve) {
		      if (isDef(hash)) {
		          if (hasOwn(hash, key)) {
		              res[key] = hash[key];
		              if (!preserve) {
		                  delete hash[key];
		              }
		              return true;
		          }
		          else if (hasOwn(hash, altKey)) {
		              res[key] = hash[altKey];
		              if (!preserve) {
		                  delete hash[altKey];
		              }
		              return true;
		          }
		      }
		      return false;
		  }

		  // The template compiler attempts to minimize the need for normalization by
		  // statically analyzing the template at compile time.
		  //
		  // For plain HTML markup, normalization can be completely skipped because the
		  // generated render function is guaranteed to return Array<VNode>. There are
		  // two cases where extra normalization is needed:
		  // 1. When the children contains components - because a functional component
		  // may return an Array instead of a single root. In this case, just a simple
		  // normalization is needed - if any child is an Array, we flatten the whole
		  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
		  // because functional components already normalize their own children.
		  function simpleNormalizeChildren(children) {
		      for (var i = 0; i < children.length; i++) {
		          if (isArray(children[i])) {
		              return Array.prototype.concat.apply([], children);
		          }
		      }
		      return children;
		  }
		  // 2. When the children contains constructs that always generated nested Arrays,
		  // e.g. <template>, <slot>, v-for, or when the children is provided by user
		  // with hand-written render functions / JSX. In such cases a full normalization
		  // is needed to cater to all possible types of children values.
		  function normalizeChildren(children) {
		      return isPrimitive(children)
		          ? [createTextVNode(children)]
		          : isArray(children)
		              ? normalizeArrayChildren(children)
		              : undefined;
		  }
		  function isTextNode(node) {
		      return isDef(node) && isDef(node.text) && isFalse(node.isComment);
		  }
		  function normalizeArrayChildren(children, nestedIndex) {
		      var res = [];
		      var i, c, lastIndex, last;
		      for (i = 0; i < children.length; i++) {
		          c = children[i];
		          if (isUndef(c) || typeof c === 'boolean')
		              continue;
		          lastIndex = res.length - 1;
		          last = res[lastIndex];
		          //  nested
		          if (isArray(c)) {
		              if (c.length > 0) {
		                  c = normalizeArrayChildren(c, "".concat(nestedIndex || '', "_").concat(i));
		                  // merge adjacent text nodes
		                  if (isTextNode(c[0]) && isTextNode(last)) {
		                      res[lastIndex] = createTextVNode(last.text + c[0].text);
		                      c.shift();
		                  }
		                  res.push.apply(res, c);
		              }
		          }
		          else if (isPrimitive(c)) {
		              if (isTextNode(last)) {
		                  // merge adjacent text nodes
		                  // this is necessary for SSR hydration because text nodes are
		                  // essentially merged when rendered to HTML strings
		                  res[lastIndex] = createTextVNode(last.text + c);
		              }
		              else if (c !== '') {
		                  // convert primitive to vnode
		                  res.push(createTextVNode(c));
		              }
		          }
		          else {
		              if (isTextNode(c) && isTextNode(last)) {
		                  // merge adjacent text nodes
		                  res[lastIndex] = createTextVNode(last.text + c.text);
		              }
		              else {
		                  // default key for nested array children (likely generated by v-for)
		                  if (isTrue(children._isVList) &&
		                      isDef(c.tag) &&
		                      isUndef(c.key) &&
		                      isDef(nestedIndex)) {
		                      c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
		                  }
		                  res.push(c);
		              }
		          }
		      }
		      return res;
		  }

		  var SIMPLE_NORMALIZE = 1;
		  var ALWAYS_NORMALIZE = 2;
		  // wrapper function for providing a more flexible interface
		  // without getting yelled at by flow
		  function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
		      if (isArray(data) || isPrimitive(data)) {
		          normalizationType = children;
		          children = data;
		          data = undefined;
		      }
		      if (isTrue(alwaysNormalize)) {
		          normalizationType = ALWAYS_NORMALIZE;
		      }
		      return _createElement(context, tag, data, children, normalizationType);
		  }
		  function _createElement(context, tag, data, children, normalizationType) {
		      if (isDef(data) && isDef(data.__ob__)) {
		          warn$2("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + 'Always create fresh vnode data objects in each render!', context);
		          return createEmptyVNode();
		      }
		      // object syntax in v-bind
		      if (isDef(data) && isDef(data.is)) {
		          tag = data.is;
		      }
		      if (!tag) {
		          // in case of component :is set to falsy value
		          return createEmptyVNode();
		      }
		      // warn against non-primitive key
		      if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
		          warn$2('Avoid using non-primitive value as key, ' +
		              'use string/number value instead.', context);
		      }
		      // support single function children as default scoped slot
		      if (isArray(children) && isFunction(children[0])) {
		          data = data || {};
		          data.scopedSlots = { default: children[0] };
		          children.length = 0;
		      }
		      if (normalizationType === ALWAYS_NORMALIZE) {
		          children = normalizeChildren(children);
		      }
		      else if (normalizationType === SIMPLE_NORMALIZE) {
		          children = simpleNormalizeChildren(children);
		      }
		      var vnode, ns;
		      if (typeof tag === 'string') {
		          var Ctor = void 0;
		          ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
		          if (config.isReservedTag(tag)) {
		              // platform built-in elements
		              if (isDef(data) &&
		                  isDef(data.nativeOn) &&
		                  data.tag !== 'component') {
		                  warn$2("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
		              }
		              vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
		          }
		          else if ((!data || !data.pre) &&
		              isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
		              // component
		              vnode = createComponent(Ctor, data, context, children, tag);
		          }
		          else {
		              // unknown or unlisted namespaced elements
		              // check at runtime because it may get assigned a namespace when its
		              // parent normalizes children
		              vnode = new VNode(tag, data, children, undefined, undefined, context);
		          }
		      }
		      else {
		          // direct component options / constructor
		          vnode = createComponent(tag, data, context, children);
		      }
		      if (isArray(vnode)) {
		          return vnode;
		      }
		      else if (isDef(vnode)) {
		          if (isDef(ns))
		              applyNS(vnode, ns);
		          if (isDef(data))
		              registerDeepBindings(data);
		          return vnode;
		      }
		      else {
		          return createEmptyVNode();
		      }
		  }
		  function applyNS(vnode, ns, force) {
		      vnode.ns = ns;
		      if (vnode.tag === 'foreignObject') {
		          // use default namespace inside foreignObject
		          ns = undefined;
		          force = true;
		      }
		      if (isDef(vnode.children)) {
		          for (var i = 0, l = vnode.children.length; i < l; i++) {
		              var child = vnode.children[i];
		              if (isDef(child.tag) &&
		                  (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
		                  applyNS(child, ns, force);
		              }
		          }
		      }
		  }
		  // ref #5318
		  // necessary to ensure parent re-render when deep bindings like :style and
		  // :class are used on slot nodes
		  function registerDeepBindings(data) {
		      if (isObject(data.style)) {
		          traverse(data.style);
		      }
		      if (isObject(data.class)) {
		          traverse(data.class);
		      }
		  }

		  /**
		   * Runtime helper for rendering v-for lists.
		   */
		  function renderList(val, render) {
		      var ret = null, i, l, keys, key;
		      if (isArray(val) || typeof val === 'string') {
		          ret = new Array(val.length);
		          for (i = 0, l = val.length; i < l; i++) {
		              ret[i] = render(val[i], i);
		          }
		      }
		      else if (typeof val === 'number') {
		          ret = new Array(val);
		          for (i = 0; i < val; i++) {
		              ret[i] = render(i + 1, i);
		          }
		      }
		      else if (isObject(val)) {
		          if (hasSymbol && val[Symbol.iterator]) {
		              ret = [];
		              var iterator = val[Symbol.iterator]();
		              var result = iterator.next();
		              while (!result.done) {
		                  ret.push(render(result.value, ret.length));
		                  result = iterator.next();
		              }
		          }
		          else {
		              keys = Object.keys(val);
		              ret = new Array(keys.length);
		              for (i = 0, l = keys.length; i < l; i++) {
		                  key = keys[i];
		                  ret[i] = render(val[key], key, i);
		              }
		          }
		      }
		      if (!isDef(ret)) {
		          ret = [];
		      }
		      ret._isVList = true;
		      return ret;
		  }

		  /**
		   * Runtime helper for rendering <slot>
		   */
		  function renderSlot(name, fallbackRender, props, bindObject) {
		      var scopedSlotFn = this.$scopedSlots[name];
		      var nodes;
		      if (scopedSlotFn) {
		          // scoped slot
		          props = props || {};
		          if (bindObject) {
		              if (!isObject(bindObject)) {
		                  warn$2('slot v-bind without argument expects an Object', this);
		              }
		              props = extend(extend({}, bindObject), props);
		          }
		          nodes =
		              scopedSlotFn(props) ||
		                  (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
		      }
		      else {
		          nodes =
		              this.$slots[name] ||
		                  (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
		      }
		      var target = props && props.slot;
		      if (target) {
		          return this.$createElement('template', { slot: target }, nodes);
		      }
		      else {
		          return nodes;
		      }
		  }

		  /**
		   * Runtime helper for resolving filters
		   */
		  function resolveFilter(id) {
		      return resolveAsset(this.$options, 'filters', id, true) || identity;
		  }

		  function isKeyNotMatch(expect, actual) {
		      if (isArray(expect)) {
		          return expect.indexOf(actual) === -1;
		      }
		      else {
		          return expect !== actual;
		      }
		  }
		  /**
		   * Runtime helper for checking keyCodes from config.
		   * exposed as Vue.prototype._k
		   * passing in eventKeyName as last argument separately for backwards compat
		   */
		  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
		      var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
		      if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
		          return isKeyNotMatch(builtInKeyName, eventKeyName);
		      }
		      else if (mappedKeyCode) {
		          return isKeyNotMatch(mappedKeyCode, eventKeyCode);
		      }
		      else if (eventKeyName) {
		          return hyphenate(eventKeyName) !== key;
		      }
		      return eventKeyCode === undefined;
		  }

		  /**
		   * Runtime helper for merging v-bind="object" into a VNode's data.
		   */
		  function bindObjectProps(data, tag, value, asProp, isSync) {
		      if (value) {
		          if (!isObject(value)) {
		              warn$2('v-bind without argument expects an Object or Array value', this);
		          }
		          else {
		              if (isArray(value)) {
		                  value = toObject(value);
		              }
		              var hash = void 0;
		              var _loop_1 = function (key) {
		                  if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
		                      hash = data;
		                  }
		                  else {
		                      var type = data.attrs && data.attrs.type;
		                      hash =
		                          asProp || config.mustUseProp(tag, type, key)
		                              ? data.domProps || (data.domProps = {})
		                              : data.attrs || (data.attrs = {});
		                  }
		                  var camelizedKey = camelize(key);
		                  var hyphenatedKey = hyphenate(key);
		                  if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
		                      hash[key] = value[key];
		                      if (isSync) {
		                          var on = data.on || (data.on = {});
		                          on["update:".concat(key)] = function ($event) {
		                              value[key] = $event;
		                          };
		                      }
		                  }
		              };
		              for (var key in value) {
		                  _loop_1(key);
		              }
		          }
		      }
		      return data;
		  }

		  /**
		   * Runtime helper for rendering static trees.
		   */
		  function renderStatic(index, isInFor) {
		      var cached = this._staticTrees || (this._staticTrees = []);
		      var tree = cached[index];
		      // if has already-rendered static tree and not inside v-for,
		      // we can reuse the same tree.
		      if (tree && !isInFor) {
		          return tree;
		      }
		      // otherwise, render a fresh tree.
		      tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
		      );
		      markStatic$1(tree, "__static__".concat(index), false);
		      return tree;
		  }
		  /**
		   * Runtime helper for v-once.
		   * Effectively it means marking the node as static with a unique key.
		   */
		  function markOnce(tree, index, key) {
		      markStatic$1(tree, "__once__".concat(index).concat(key ? "_".concat(key) : ""), true);
		      return tree;
		  }
		  function markStatic$1(tree, key, isOnce) {
		      if (isArray(tree)) {
		          for (var i = 0; i < tree.length; i++) {
		              if (tree[i] && typeof tree[i] !== 'string') {
		                  markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
		              }
		          }
		      }
		      else {
		          markStaticNode(tree, key, isOnce);
		      }
		  }
		  function markStaticNode(node, key, isOnce) {
		      node.isStatic = true;
		      node.key = key;
		      node.isOnce = isOnce;
		  }

		  function bindObjectListeners(data, value) {
		      if (value) {
		          if (!isPlainObject(value)) {
		              warn$2('v-on without argument expects an Object value', this);
		          }
		          else {
		              var on = (data.on = data.on ? extend({}, data.on) : {});
		              for (var key in value) {
		                  var existing = on[key];
		                  var ours = value[key];
		                  on[key] = existing ? [].concat(existing, ours) : ours;
		              }
		          }
		      }
		      return data;
		  }

		  function resolveScopedSlots(fns, res, 
		  // the following are added in 2.6
		  hasDynamicKeys, contentHashKey) {
		      res = res || { $stable: !hasDynamicKeys };
		      for (var i = 0; i < fns.length; i++) {
		          var slot = fns[i];
		          if (isArray(slot)) {
		              resolveScopedSlots(slot, res, hasDynamicKeys);
		          }
		          else if (slot) {
		              // marker for reverse proxying v-slot without scope on this.$slots
		              // @ts-expect-error
		              if (slot.proxy) {
		                  // @ts-expect-error
		                  slot.fn.proxy = true;
		              }
		              res[slot.key] = slot.fn;
		          }
		      }
		      if (contentHashKey) {
		          res.$key = contentHashKey;
		      }
		      return res;
		  }

		  // helper to process dynamic keys for dynamic arguments in v-bind and v-on.
		  function bindDynamicKeys(baseObj, values) {
		      for (var i = 0; i < values.length; i += 2) {
		          var key = values[i];
		          if (typeof key === 'string' && key) {
		              baseObj[values[i]] = values[i + 1];
		          }
		          else if (key !== '' && key !== null) {
		              // null is a special value for explicitly removing a binding
		              warn$2("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
		          }
		      }
		      return baseObj;
		  }
		  // helper to dynamically append modifier runtime markers to event names.
		  // ensure only append when value is already string, otherwise it will be cast
		  // to string and cause the type check to miss.
		  function prependModifier(value, symbol) {
		      return typeof value === 'string' ? symbol + value : value;
		  }

		  function installRenderHelpers(target) {
		      target._o = markOnce;
		      target._n = toNumber;
		      target._s = toString;
		      target._l = renderList;
		      target._t = renderSlot;
		      target._q = looseEqual;
		      target._i = looseIndexOf;
		      target._m = renderStatic;
		      target._f = resolveFilter;
		      target._k = checkKeyCodes;
		      target._b = bindObjectProps;
		      target._v = createTextVNode;
		      target._e = createEmptyVNode;
		      target._u = resolveScopedSlots;
		      target._g = bindObjectListeners;
		      target._d = bindDynamicKeys;
		      target._p = prependModifier;
		  }

		  /**
		   * Runtime helper for resolving raw children VNodes into a slot object.
		   */
		  function resolveSlots(children, context) {
		      if (!children || !children.length) {
		          return {};
		      }
		      var slots = {};
		      for (var i = 0, l = children.length; i < l; i++) {
		          var child = children[i];
		          var data = child.data;
		          // remove slot attribute if the node is resolved as a Vue slot node
		          if (data && data.attrs && data.attrs.slot) {
		              delete data.attrs.slot;
		          }
		          // named slots should only be respected if the vnode was rendered in the
		          // same context.
		          if ((child.context === context || child.fnContext === context) &&
		              data &&
		              data.slot != null) {
		              var name_1 = data.slot;
		              var slot = slots[name_1] || (slots[name_1] = []);
		              if (child.tag === 'template') {
		                  slot.push.apply(slot, child.children || []);
		              }
		              else {
		                  slot.push(child);
		              }
		          }
		          else {
		              (slots.default || (slots.default = [])).push(child);
		          }
		      }
		      // ignore slots that contains only whitespace
		      for (var name_2 in slots) {
		          if (slots[name_2].every(isWhitespace)) {
		              delete slots[name_2];
		          }
		      }
		      return slots;
		  }
		  function isWhitespace(node) {
		      return (node.isComment && !node.asyncFactory) || node.text === ' ';
		  }

		  function isAsyncPlaceholder(node) {
		      // @ts-expect-error not really boolean type
		      return node.isComment && node.asyncFactory;
		  }

		  function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
		      var res;
		      var hasNormalSlots = Object.keys(normalSlots).length > 0;
		      var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
		      var key = scopedSlots && scopedSlots.$key;
		      if (!scopedSlots) {
		          res = {};
		      }
		      else if (scopedSlots._normalized) {
		          // fast path 1: child component re-render only, parent did not change
		          return scopedSlots._normalized;
		      }
		      else if (isStable &&
		          prevScopedSlots &&
		          prevScopedSlots !== emptyObject &&
		          key === prevScopedSlots.$key &&
		          !hasNormalSlots &&
		          !prevScopedSlots.$hasNormal) {
		          // fast path 2: stable scoped slots w/ no normal slots to proxy,
		          // only need to normalize once
		          return prevScopedSlots;
		      }
		      else {
		          res = {};
		          for (var key_1 in scopedSlots) {
		              if (scopedSlots[key_1] && key_1[0] !== '$') {
		                  res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
		              }
		          }
		      }
		      // expose normal slots on scopedSlots
		      for (var key_2 in normalSlots) {
		          if (!(key_2 in res)) {
		              res[key_2] = proxyNormalSlot(normalSlots, key_2);
		          }
		      }
		      // avoriaz seems to mock a non-extensible $scopedSlots object
		      // and when that is passed down this would cause an error
		      if (scopedSlots && Object.isExtensible(scopedSlots)) {
		          scopedSlots._normalized = res;
		      }
		      def(res, '$stable', isStable);
		      def(res, '$key', key);
		      def(res, '$hasNormal', hasNormalSlots);
		      return res;
		  }
		  function normalizeScopedSlot(vm, normalSlots, key, fn) {
		      var normalized = function () {
		          var cur = currentInstance;
		          setCurrentInstance(vm);
		          var res = arguments.length ? fn.apply(null, arguments) : fn({});
		          res =
		              res && typeof res === 'object' && !isArray(res)
		                  ? [res] // single vnode
		                  : normalizeChildren(res);
		          var vnode = res && res[0];
		          setCurrentInstance(cur);
		          return res &&
		              (!vnode ||
		                  (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
		              ? undefined
		              : res;
		      };
		      // this is a slot using the new v-slot syntax without scope. although it is
		      // compiled as a scoped slot, render fn users would expect it to be present
		      // on this.$slots because the usage is semantically a normal slot.
		      if (fn.proxy) {
		          Object.defineProperty(normalSlots, key, {
		              get: normalized,
		              enumerable: true,
		              configurable: true
		          });
		      }
		      return normalized;
		  }
		  function proxyNormalSlot(slots, key) {
		      return function () { return slots[key]; };
		  }

		  function initSetup(vm) {
		      var options = vm.$options;
		      var setup = options.setup;
		      if (setup) {
		          var ctx = (vm._setupContext = createSetupContext(vm));
		          setCurrentInstance(vm);
		          pushTarget();
		          var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
		          popTarget();
		          setCurrentInstance();
		          if (isFunction(setupResult)) {
		              // render function
		              // @ts-ignore
		              options.render = setupResult;
		          }
		          else if (isObject(setupResult)) {
		              // bindings
		              if (setupResult instanceof VNode) {
		                  warn$2("setup() should not return VNodes directly - " +
		                      "return a render function instead.");
		              }
		              vm._setupState = setupResult;
		              // __sfc indicates compiled bindings from <script setup>
		              if (!setupResult.__sfc) {
		                  for (var key in setupResult) {
		                      if (!isReserved(key)) {
		                          proxyWithRefUnwrap(vm, setupResult, key);
		                      }
		                      else {
		                          warn$2("Avoid using variables that start with _ or $ in setup().");
		                      }
		                  }
		              }
		              else {
		                  // exposed for compiled render fn
		                  var proxy = (vm._setupProxy = {});
		                  for (var key in setupResult) {
		                      if (key !== '__sfc') {
		                          proxyWithRefUnwrap(proxy, setupResult, key);
		                      }
		                  }
		              }
		          }
		          else if (setupResult !== undefined) {
		              warn$2("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : typeof setupResult));
		          }
		      }
		  }
		  function createSetupContext(vm) {
		      var exposeCalled = false;
		      return {
		          get attrs() {
		              if (!vm._attrsProxy) {
		                  var proxy = (vm._attrsProxy = {});
		                  def(proxy, '_v_attr_proxy', true);
		                  syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
		              }
		              return vm._attrsProxy;
		          },
		          get listeners() {
		              if (!vm._listenersProxy) {
		                  var proxy = (vm._listenersProxy = {});
		                  syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
		              }
		              return vm._listenersProxy;
		          },
		          get slots() {
		              return initSlotsProxy(vm);
		          },
		          emit: bind$1(vm.$emit, vm),
		          expose: function (exposed) {
		              {
		                  if (exposeCalled) {
		                      warn$2("expose() should be called only once per setup().", vm);
		                  }
		                  exposeCalled = true;
		              }
		              if (exposed) {
		                  Object.keys(exposed).forEach(function (key) {
		                      return proxyWithRefUnwrap(vm, exposed, key);
		                  });
		              }
		          }
		      };
		  }
		  function syncSetupProxy(to, from, prev, instance, type) {
		      var changed = false;
		      for (var key in from) {
		          if (!(key in to)) {
		              changed = true;
		              defineProxyAttr(to, key, instance, type);
		          }
		          else if (from[key] !== prev[key]) {
		              changed = true;
		          }
		      }
		      for (var key in to) {
		          if (!(key in from)) {
		              changed = true;
		              delete to[key];
		          }
		      }
		      return changed;
		  }
		  function defineProxyAttr(proxy, key, instance, type) {
		      Object.defineProperty(proxy, key, {
		          enumerable: true,
		          configurable: true,
		          get: function () {
		              return instance[type][key];
		          }
		      });
		  }
		  function initSlotsProxy(vm) {
		      if (!vm._slotsProxy) {
		          syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
		      }
		      return vm._slotsProxy;
		  }
		  function syncSetupSlots(to, from) {
		      for (var key in from) {
		          to[key] = from[key];
		      }
		      for (var key in to) {
		          if (!(key in from)) {
		              delete to[key];
		          }
		      }
		  }
		  /**
		   * @internal use manual type def because public setup context type relies on
		   * legacy VNode types
		   */
		  function useSlots() {
		      return getContext().slots;
		  }
		  /**
		   * @internal use manual type def because public setup context type relies on
		   * legacy VNode types
		   */
		  function useAttrs() {
		      return getContext().attrs;
		  }
		  /**
		   * Vue 2 only
		   * @internal use manual type def because public setup context type relies on
		   * legacy VNode types
		   */
		  function useListeners() {
		      return getContext().listeners;
		  }
		  function getContext() {
		      if (!currentInstance) {
		          warn$2("useContext() called without active instance.");
		      }
		      var vm = currentInstance;
		      return vm._setupContext || (vm._setupContext = createSetupContext(vm));
		  }
		  /**
		   * Runtime helper for merging default declarations. Imported by compiled code
		   * only.
		   * @internal
		   */
		  function mergeDefaults(raw, defaults) {
		      var props = isArray(raw)
		          ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})
		          : raw;
		      for (var key in defaults) {
		          var opt = props[key];
		          if (opt) {
		              if (isArray(opt) || isFunction(opt)) {
		                  props[key] = { type: opt, default: defaults[key] };
		              }
		              else {
		                  opt.default = defaults[key];
		              }
		          }
		          else if (opt === null) {
		              props[key] = { default: defaults[key] };
		          }
		          else {
		              warn$2("props default key \"".concat(key, "\" has no corresponding declaration."));
		          }
		      }
		      return props;
		  }

		  function initRender(vm) {
		      vm._vnode = null; // the root of the child tree
		      vm._staticTrees = null; // v-once cached trees
		      var options = vm.$options;
		      var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
		      var renderContext = parentVnode && parentVnode.context;
		      vm.$slots = resolveSlots(options._renderChildren, renderContext);
		      vm.$scopedSlots = parentVnode
		          ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
		          : emptyObject;
		      // bind the createElement fn to this instance
		      // so that we get proper render context inside it.
		      // args order: tag, data, children, normalizationType, alwaysNormalize
		      // internal version is used by render functions compiled from templates
		      // @ts-expect-error
		      vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };
		      // normalization is always applied for the public version, used in
		      // user-written render functions.
		      // @ts-expect-error
		      vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };
		      // $attrs & $listeners are exposed for easier HOC creation.
		      // they need to be reactive so that HOCs using them are always updated
		      var parentData = parentVnode && parentVnode.data;
		      /* istanbul ignore else */
		      {
		          defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {
		              !isUpdatingChildComponent && warn$2("$attrs is readonly.", vm);
		          }, true);
		          defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
		              !isUpdatingChildComponent && warn$2("$listeners is readonly.", vm);
		          }, true);
		      }
		  }
		  var currentRenderingInstance = null;
		  function renderMixin(Vue) {
		      // install runtime convenience helpers
		      installRenderHelpers(Vue.prototype);
		      Vue.prototype.$nextTick = function (fn) {
		          return nextTick(fn, this);
		      };
		      Vue.prototype._render = function () {
		          var vm = this;
		          var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
		          if (_parentVnode && vm._isMounted) {
		              vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
		              if (vm._slotsProxy) {
		                  syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
		              }
		          }
		          // set parent vnode. this allows render functions to have access
		          // to the data on the placeholder node.
		          vm.$vnode = _parentVnode;
		          // render self
		          var vnode;
		          try {
		              // There's no need to maintain a stack because all render fns are called
		              // separately from one another. Nested component's render fns are called
		              // when parent component is patched.
		              setCurrentInstance(vm);
		              currentRenderingInstance = vm;
		              vnode = render.call(vm._renderProxy, vm.$createElement);
		          }
		          catch (e) {
		              handleError(e, vm, "render");
		              // return error render result,
		              // or previous vnode to prevent render error causing blank component
		              /* istanbul ignore else */
		              if (vm.$options.renderError) {
		                  try {
		                      vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
		                  }
		                  catch (e) {
		                      handleError(e, vm, "renderError");
		                      vnode = vm._vnode;
		                  }
		              }
		              else {
		                  vnode = vm._vnode;
		              }
		          }
		          finally {
		              currentRenderingInstance = null;
		              setCurrentInstance();
		          }
		          // if the returned array contains only a single node, allow it
		          if (isArray(vnode) && vnode.length === 1) {
		              vnode = vnode[0];
		          }
		          // return empty vnode in case the render function errored out
		          if (!(vnode instanceof VNode)) {
		              if (isArray(vnode)) {
		                  warn$2('Multiple root nodes returned from render function. Render function ' +
		                      'should return a single root node.', vm);
		              }
		              vnode = createEmptyVNode();
		          }
		          // set parent
		          vnode.parent = _parentVnode;
		          return vnode;
		      };
		  }

		  function ensureCtor(comp, base) {
		      if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
		          comp = comp.default;
		      }
		      return isObject(comp) ? base.extend(comp) : comp;
		  }
		  function createAsyncPlaceholder(factory, data, context, children, tag) {
		      var node = createEmptyVNode();
		      node.asyncFactory = factory;
		      node.asyncMeta = { data: data, context: context, children: children, tag: tag };
		      return node;
		  }
		  function resolveAsyncComponent(factory, baseCtor) {
		      if (isTrue(factory.error) && isDef(factory.errorComp)) {
		          return factory.errorComp;
		      }
		      if (isDef(factory.resolved)) {
		          return factory.resolved;
		      }
		      var owner = currentRenderingInstance;
		      if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
		          // already pending
		          factory.owners.push(owner);
		      }
		      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
		          return factory.loadingComp;
		      }
		      if (owner && !isDef(factory.owners)) {
		          var owners_1 = (factory.owners = [owner]);
		          var sync_1 = true;
		          var timerLoading_1 = null;
		          var timerTimeout_1 = null;
		          owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });
		          var forceRender_1 = function (renderCompleted) {
		              for (var i = 0, l = owners_1.length; i < l; i++) {
		                  owners_1[i].$forceUpdate();
		              }
		              if (renderCompleted) {
		                  owners_1.length = 0;
		                  if (timerLoading_1 !== null) {
		                      clearTimeout(timerLoading_1);
		                      timerLoading_1 = null;
		                  }
		                  if (timerTimeout_1 !== null) {
		                      clearTimeout(timerTimeout_1);
		                      timerTimeout_1 = null;
		                  }
		              }
		          };
		          var resolve = once(function (res) {
		              // cache resolved
		              factory.resolved = ensureCtor(res, baseCtor);
		              // invoke callbacks only if this is not a synchronous resolve
		              // (async resolves are shimmed as synchronous during SSR)
		              if (!sync_1) {
		                  forceRender_1(true);
		              }
		              else {
		                  owners_1.length = 0;
		              }
		          });
		          var reject_1 = once(function (reason) {
		              warn$2("Failed to resolve async component: ".concat(String(factory)) +
		                      (reason ? "\nReason: ".concat(reason) : ''));
		              if (isDef(factory.errorComp)) {
		                  factory.error = true;
		                  forceRender_1(true);
		              }
		          });
		          var res_1 = factory(resolve, reject_1);
		          if (isObject(res_1)) {
		              if (isPromise(res_1)) {
		                  // () => Promise
		                  if (isUndef(factory.resolved)) {
		                      res_1.then(resolve, reject_1);
		                  }
		              }
		              else if (isPromise(res_1.component)) {
		                  res_1.component.then(resolve, reject_1);
		                  if (isDef(res_1.error)) {
		                      factory.errorComp = ensureCtor(res_1.error, baseCtor);
		                  }
		                  if (isDef(res_1.loading)) {
		                      factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
		                      if (res_1.delay === 0) {
		                          factory.loading = true;
		                      }
		                      else {
		                          // @ts-expect-error NodeJS timeout type
		                          timerLoading_1 = setTimeout(function () {
		                              timerLoading_1 = null;
		                              if (isUndef(factory.resolved) && isUndef(factory.error)) {
		                                  factory.loading = true;
		                                  forceRender_1(false);
		                              }
		                          }, res_1.delay || 200);
		                      }
		                  }
		                  if (isDef(res_1.timeout)) {
		                      // @ts-expect-error NodeJS timeout type
		                      timerTimeout_1 = setTimeout(function () {
		                          timerTimeout_1 = null;
		                          if (isUndef(factory.resolved)) {
		                              reject_1("timeout (".concat(res_1.timeout, "ms)") );
		                          }
		                      }, res_1.timeout);
		                  }
		              }
		          }
		          sync_1 = false;
		          // return in case resolved synchronously
		          return factory.loading ? factory.loadingComp : factory.resolved;
		      }
		  }

		  function getFirstComponentChild(children) {
		      if (isArray(children)) {
		          for (var i = 0; i < children.length; i++) {
		              var c = children[i];
		              if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
		                  return c;
		              }
		          }
		      }
		  }

		  function initEvents(vm) {
		      vm._events = Object.create(null);
		      vm._hasHookEvent = false;
		      // init parent attached events
		      var listeners = vm.$options._parentListeners;
		      if (listeners) {
		          updateComponentListeners(vm, listeners);
		      }
		  }
		  var target$1;
		  function add$1(event, fn) {
		      target$1.$on(event, fn);
		  }
		  function remove$1(event, fn) {
		      target$1.$off(event, fn);
		  }
		  function createOnceHandler$1(event, fn) {
		      var _target = target$1;
		      return function onceHandler() {
		          var res = fn.apply(null, arguments);
		          if (res !== null) {
		              _target.$off(event, onceHandler);
		          }
		      };
		  }
		  function updateComponentListeners(vm, listeners, oldListeners) {
		      target$1 = vm;
		      updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
		      target$1 = undefined;
		  }
		  function eventsMixin(Vue) {
		      var hookRE = /^hook:/;
		      Vue.prototype.$on = function (event, fn) {
		          var vm = this;
		          if (isArray(event)) {
		              for (var i = 0, l = event.length; i < l; i++) {
		                  vm.$on(event[i], fn);
		              }
		          }
		          else {
		              (vm._events[event] || (vm._events[event] = [])).push(fn);
		              // optimize hook:event cost by using a boolean flag marked at registration
		              // instead of a hash lookup
		              if (hookRE.test(event)) {
		                  vm._hasHookEvent = true;
		              }
		          }
		          return vm;
		      };
		      Vue.prototype.$once = function (event, fn) {
		          var vm = this;
		          function on() {
		              vm.$off(event, on);
		              fn.apply(vm, arguments);
		          }
		          on.fn = fn;
		          vm.$on(event, on);
		          return vm;
		      };
		      Vue.prototype.$off = function (event, fn) {
		          var vm = this;
		          // all
		          if (!arguments.length) {
		              vm._events = Object.create(null);
		              return vm;
		          }
		          // array of events
		          if (isArray(event)) {
		              for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
		                  vm.$off(event[i_1], fn);
		              }
		              return vm;
		          }
		          // specific event
		          var cbs = vm._events[event];
		          if (!cbs) {
		              return vm;
		          }
		          if (!fn) {
		              vm._events[event] = null;
		              return vm;
		          }
		          // specific handler
		          var cb;
		          var i = cbs.length;
		          while (i--) {
		              cb = cbs[i];
		              if (cb === fn || cb.fn === fn) {
		                  cbs.splice(i, 1);
		                  break;
		              }
		          }
		          return vm;
		      };
		      Vue.prototype.$emit = function (event) {
		          var vm = this;
		          {
		              var lowerCaseEvent = event.toLowerCase();
		              if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
		                  tip("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") +
		                      "".concat(formatComponentName(vm), " but the handler is registered for \"").concat(event, "\". ") +
		                      "Note that HTML attributes are case-insensitive and you cannot use " +
		                      "v-on to listen to camelCase events when using in-DOM templates. " +
		                      "You should probably use \"".concat(hyphenate(event), "\" instead of \"").concat(event, "\"."));
		              }
		          }
		          var cbs = vm._events[event];
		          if (cbs) {
		              cbs = cbs.length > 1 ? toArray(cbs) : cbs;
		              var args = toArray(arguments, 1);
		              var info = "event handler for \"".concat(event, "\"");
		              for (var i = 0, l = cbs.length; i < l; i++) {
		                  invokeWithErrorHandling(cbs[i], vm, args, vm, info);
		              }
		          }
		          return vm;
		      };
		  }

		  var activeInstance = null;
		  var isUpdatingChildComponent = false;
		  function setActiveInstance(vm) {
		      var prevActiveInstance = activeInstance;
		      activeInstance = vm;
		      return function () {
		          activeInstance = prevActiveInstance;
		      };
		  }
		  function initLifecycle(vm) {
		      var options = vm.$options;
		      // locate first non-abstract parent
		      var parent = options.parent;
		      if (parent && !options.abstract) {
		          while (parent.$options.abstract && parent.$parent) {
		              parent = parent.$parent;
		          }
		          parent.$children.push(vm);
		      }
		      vm.$parent = parent;
		      vm.$root = parent ? parent.$root : vm;
		      vm.$children = [];
		      vm.$refs = {};
		      vm._provided = parent ? parent._provided : Object.create(null);
		      vm._watcher = null;
		      vm._inactive = null;
		      vm._directInactive = false;
		      vm._isMounted = false;
		      vm._isDestroyed = false;
		      vm._isBeingDestroyed = false;
		  }
		  function lifecycleMixin(Vue) {
		      Vue.prototype._update = function (vnode, hydrating) {
		          var vm = this;
		          var prevEl = vm.$el;
		          var prevVnode = vm._vnode;
		          var restoreActiveInstance = setActiveInstance(vm);
		          vm._vnode = vnode;
		          // Vue.prototype.__patch__ is injected in entry points
		          // based on the rendering backend used.
		          if (!prevVnode) {
		              // initial render
		              vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
		          }
		          else {
		              // updates
		              vm.$el = vm.__patch__(prevVnode, vnode);
		          }
		          restoreActiveInstance();
		          // update __vue__ reference
		          if (prevEl) {
		              prevEl.__vue__ = null;
		          }
		          if (vm.$el) {
		              vm.$el.__vue__ = vm;
		          }
		          // if parent is an HOC, update its $el as well
		          if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
		              vm.$parent.$el = vm.$el;
		          }
		          // updated hook is called by the scheduler to ensure that children are
		          // updated in a parent's updated hook.
		      };
		      Vue.prototype.$forceUpdate = function () {
		          var vm = this;
		          if (vm._watcher) {
		              vm._watcher.update();
		          }
		      };
		      Vue.prototype.$destroy = function () {
		          var vm = this;
		          if (vm._isBeingDestroyed) {
		              return;
		          }
		          callHook$1(vm, 'beforeDestroy');
		          vm._isBeingDestroyed = true;
		          // remove self from parent
		          var parent = vm.$parent;
		          if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
		              remove$2(parent.$children, vm);
		          }
		          // teardown scope. this includes both the render watcher and other
		          // watchers created
		          vm._scope.stop();
		          // remove reference from data ob
		          // frozen object may not have observer.
		          if (vm._data.__ob__) {
		              vm._data.__ob__.vmCount--;
		          }
		          // call the last hook...
		          vm._isDestroyed = true;
		          // invoke destroy hooks on current rendered tree
		          vm.__patch__(vm._vnode, null);
		          // fire destroyed hook
		          callHook$1(vm, 'destroyed');
		          // turn off all instance listeners.
		          vm.$off();
		          // remove __vue__ reference
		          if (vm.$el) {
		              vm.$el.__vue__ = null;
		          }
		          // release circular reference (#6759)
		          if (vm.$vnode) {
		              vm.$vnode.parent = null;
		          }
		      };
		  }
		  function mountComponent(vm, el, hydrating) {
		      vm.$el = el;
		      if (!vm.$options.render) {
		          // @ts-expect-error invalid type
		          vm.$options.render = createEmptyVNode;
		          {
		              /* istanbul ignore if */
		              if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
		                  vm.$options.el ||
		                  el) {
		                  warn$2('You are using the runtime-only build of Vue where the template ' +
		                      'compiler is not available. Either pre-compile the templates into ' +
		                      'render functions, or use the compiler-included build.', vm);
		              }
		              else {
		                  warn$2('Failed to mount component: template or render function not defined.', vm);
		              }
		          }
		      }
		      callHook$1(vm, 'beforeMount');
		      var updateComponent;
		      /* istanbul ignore if */
		      if (config.performance && mark) {
		          updateComponent = function () {
		              var name = vm._name;
		              var id = vm._uid;
		              var startTag = "vue-perf-start:".concat(id);
		              var endTag = "vue-perf-end:".concat(id);
		              mark(startTag);
		              var vnode = vm._render();
		              mark(endTag);
		              measure("vue ".concat(name, " render"), startTag, endTag);
		              mark(startTag);
		              vm._update(vnode, hydrating);
		              mark(endTag);
		              measure("vue ".concat(name, " patch"), startTag, endTag);
		          };
		      }
		      else {
		          updateComponent = function () {
		              vm._update(vm._render(), hydrating);
		          };
		      }
		      var watcherOptions = {
		          before: function () {
		              if (vm._isMounted && !vm._isDestroyed) {
		                  callHook$1(vm, 'beforeUpdate');
		              }
		          }
		      };
		      {
		          watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };
		          watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };
		      }
		      // we set this to vm._watcher inside the watcher's constructor
		      // since the watcher's initial patch may call $forceUpdate (e.g. inside child
		      // component's mounted hook), which relies on vm._watcher being already defined
		      new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
		      hydrating = false;
		      // flush buffer for flush: "pre" watchers queued in setup()
		      var preWatchers = vm._preWatchers;
		      if (preWatchers) {
		          for (var i = 0; i < preWatchers.length; i++) {
		              preWatchers[i].run();
		          }
		      }
		      // manually mounted instance, call mounted on self
		      // mounted is called for render-created child components in its inserted hook
		      if (vm.$vnode == null) {
		          vm._isMounted = true;
		          callHook$1(vm, 'mounted');
		      }
		      return vm;
		  }
		  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
		      {
		          isUpdatingChildComponent = true;
		      }
		      // determine whether component has slot children
		      // we need to do this before overwriting $options._renderChildren.
		      // check if there are dynamic scopedSlots (hand-written or compiled but with
		      // dynamic slot names). Static scoped slots compiled from template has the
		      // "$stable" marker.
		      var newScopedSlots = parentVnode.data.scopedSlots;
		      var oldScopedSlots = vm.$scopedSlots;
		      var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
		          (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
		          (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
		          (!newScopedSlots && vm.$scopedSlots.$key));
		      // Any static slot children from the parent may have changed during parent's
		      // update. Dynamic scoped slots may also have changed. In such cases, a forced
		      // update is necessary to ensure correctness.
		      var needsForceUpdate = !!(renderChildren || // has new static slots
		          vm.$options._renderChildren || // has old static slots
		          hasDynamicScopedSlot);
		      var prevVNode = vm.$vnode;
		      vm.$options._parentVnode = parentVnode;
		      vm.$vnode = parentVnode; // update vm's placeholder node without re-render
		      if (vm._vnode) {
		          // update child tree's parent
		          vm._vnode.parent = parentVnode;
		      }
		      vm.$options._renderChildren = renderChildren;
		      // update $attrs and $listeners hash
		      // these are also reactive so they may trigger child update if the child
		      // used them during render
		      var attrs = parentVnode.data.attrs || emptyObject;
		      if (vm._attrsProxy) {
		          // force update if attrs are accessed and has changed since it may be
		          // passed to a child component.
		          if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
		              needsForceUpdate = true;
		          }
		      }
		      vm.$attrs = attrs;
		      // update listeners
		      listeners = listeners || emptyObject;
		      var prevListeners = vm.$options._parentListeners;
		      if (vm._listenersProxy) {
		          syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
		      }
		      vm.$listeners = vm.$options._parentListeners = listeners;
		      updateComponentListeners(vm, listeners, prevListeners);
		      // update props
		      if (propsData && vm.$options.props) {
		          toggleObserving(false);
		          var props = vm._props;
		          var propKeys = vm.$options._propKeys || [];
		          for (var i = 0; i < propKeys.length; i++) {
		              var key = propKeys[i];
		              var propOptions = vm.$options.props; // wtf flow?
		              props[key] = validateProp(key, propOptions, propsData, vm);
		          }
		          toggleObserving(true);
		          // keep a copy of raw propsData
		          vm.$options.propsData = propsData;
		      }
		      // resolve slots + force update if has children
		      if (needsForceUpdate) {
		          vm.$slots = resolveSlots(renderChildren, parentVnode.context);
		          vm.$forceUpdate();
		      }
		      {
		          isUpdatingChildComponent = false;
		      }
		  }
		  function isInInactiveTree(vm) {
		      while (vm && (vm = vm.$parent)) {
		          if (vm._inactive)
		              return true;
		      }
		      return false;
		  }
		  function activateChildComponent(vm, direct) {
		      if (direct) {
		          vm._directInactive = false;
		          if (isInInactiveTree(vm)) {
		              return;
		          }
		      }
		      else if (vm._directInactive) {
		          return;
		      }
		      if (vm._inactive || vm._inactive === null) {
		          vm._inactive = false;
		          for (var i = 0; i < vm.$children.length; i++) {
		              activateChildComponent(vm.$children[i]);
		          }
		          callHook$1(vm, 'activated');
		      }
		  }
		  function deactivateChildComponent(vm, direct) {
		      if (direct) {
		          vm._directInactive = true;
		          if (isInInactiveTree(vm)) {
		              return;
		          }
		      }
		      if (!vm._inactive) {
		          vm._inactive = true;
		          for (var i = 0; i < vm.$children.length; i++) {
		              deactivateChildComponent(vm.$children[i]);
		          }
		          callHook$1(vm, 'deactivated');
		      }
		  }
		  function callHook$1(vm, hook, args, setContext) {
		      if (setContext === void 0) { setContext = true; }
		      // #7573 disable dep collection when invoking lifecycle hooks
		      pushTarget();
		      var prev = currentInstance;
		      setContext && setCurrentInstance(vm);
		      var handlers = vm.$options[hook];
		      var info = "".concat(hook, " hook");
		      if (handlers) {
		          for (var i = 0, j = handlers.length; i < j; i++) {
		              invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
		          }
		      }
		      if (vm._hasHookEvent) {
		          vm.$emit('hook:' + hook);
		      }
		      setContext && setCurrentInstance(prev);
		      popTarget();
		  }

		  var MAX_UPDATE_COUNT = 100;
		  var queue = [];
		  var activatedChildren = [];
		  var has = {};
		  var circular = {};
		  var waiting = false;
		  var flushing = false;
		  var index$1 = 0;
		  /**
		   * Reset the scheduler's state.
		   */
		  function resetSchedulerState() {
		      index$1 = queue.length = activatedChildren.length = 0;
		      has = {};
		      {
		          circular = {};
		      }
		      waiting = flushing = false;
		  }
		  // Async edge case #6566 requires saving the timestamp when event listeners are
		  // attached. However, calling performance.now() has a perf overhead especially
		  // if the page has thousands of event listeners. Instead, we take a timestamp
		  // every time the scheduler flushes and use that for all event listeners
		  // attached during that flush.
		  var currentFlushTimestamp = 0;
		  // Async edge case fix requires storing an event listener's attach timestamp.
		  var getNow = Date.now;
		  // Determine what event timestamp the browser is using. Annoyingly, the
		  // timestamp can either be hi-res (relative to page load) or low-res
		  // (relative to UNIX epoch), so in order to compare time we have to use the
		  // same timestamp type when saving the flush timestamp.
		  // All IE versions use low-res event timestamps, and have problematic clock
		  // implementations (#9632)
		  if (inBrowser && !isIE) {
		      var performance_1 = window.performance;
		      if (performance_1 &&
		          typeof performance_1.now === 'function' &&
		          getNow() > document.createEvent('Event').timeStamp) {
		          // if the event timestamp, although evaluated AFTER the Date.now(), is
		          // smaller than it, it means the event is using a hi-res timestamp,
		          // and we need to use the hi-res version for event listener timestamps as
		          // well.
		          getNow = function () { return performance_1.now(); };
		      }
		  }
		  var sortCompareFn = function (a, b) {
		      if (a.post) {
		          if (!b.post)
		              return 1;
		      }
		      else if (b.post) {
		          return -1;
		      }
		      return a.id - b.id;
		  };
		  /**
		   * Flush both queues and run the watchers.
		   */
		  function flushSchedulerQueue() {
		      currentFlushTimestamp = getNow();
		      flushing = true;
		      var watcher, id;
		      // Sort queue before flush.
		      // This ensures that:
		      // 1. Components are updated from parent to child. (because parent is always
		      //    created before the child)
		      // 2. A component's user watchers are run before its render watcher (because
		      //    user watchers are created before the render watcher)
		      // 3. If a component is destroyed during a parent component's watcher run,
		      //    its watchers can be skipped.
		      queue.sort(sortCompareFn);
		      // do not cache length because more watchers might be pushed
		      // as we run existing watchers
		      for (index$1 = 0; index$1 < queue.length; index$1++) {
		          watcher = queue[index$1];
		          if (watcher.before) {
		              watcher.before();
		          }
		          id = watcher.id;
		          has[id] = null;
		          watcher.run();
		          // in dev build, check and stop circular updates.
		          if (has[id] != null) {
		              circular[id] = (circular[id] || 0) + 1;
		              if (circular[id] > MAX_UPDATE_COUNT) {
		                  warn$2('You may have an infinite update loop ' +
		                      (watcher.user
		                          ? "in watcher with expression \"".concat(watcher.expression, "\"")
		                          : "in a component render function."), watcher.vm);
		                  break;
		              }
		          }
		      }
		      // keep copies of post queues before resetting state
		      var activatedQueue = activatedChildren.slice();
		      var updatedQueue = queue.slice();
		      resetSchedulerState();
		      // call component updated and activated hooks
		      callActivatedHooks(activatedQueue);
		      callUpdatedHooks(updatedQueue);
		      // devtool hook
		      /* istanbul ignore if */
		      if (devtools && config.devtools) {
		          devtools.emit('flush');
		      }
		  }
		  function callUpdatedHooks(queue) {
		      var i = queue.length;
		      while (i--) {
		          var watcher = queue[i];
		          var vm = watcher.vm;
		          if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
		              callHook$1(vm, 'updated');
		          }
		      }
		  }
		  /**
		   * Queue a kept-alive component that was activated during patch.
		   * The queue will be processed after the entire tree has been patched.
		   */
		  function queueActivatedComponent(vm) {
		      // setting _inactive to false here so that a render function can
		      // rely on checking whether it's in an inactive tree (e.g. router-view)
		      vm._inactive = false;
		      activatedChildren.push(vm);
		  }
		  function callActivatedHooks(queue) {
		      for (var i = 0; i < queue.length; i++) {
		          queue[i]._inactive = true;
		          activateChildComponent(queue[i], true /* true */);
		      }
		  }
		  /**
		   * Push a watcher into the watcher queue.
		   * Jobs with duplicate IDs will be skipped unless it's
		   * pushed when the queue is being flushed.
		   */
		  function queueWatcher(watcher) {
		      var id = watcher.id;
		      if (has[id] != null) {
		          return;
		      }
		      if (watcher === Dep.target && watcher.noRecurse) {
		          return;
		      }
		      has[id] = true;
		      if (!flushing) {
		          queue.push(watcher);
		      }
		      else {
		          // if already flushing, splice the watcher based on its id
		          // if already past its id, it will be run next immediately.
		          var i = queue.length - 1;
		          while (i > index$1 && queue[i].id > watcher.id) {
		              i--;
		          }
		          queue.splice(i + 1, 0, watcher);
		      }
		      // queue the flush
		      if (!waiting) {
		          waiting = true;
		          if (!config.async) {
		              flushSchedulerQueue();
		              return;
		          }
		          nextTick(flushSchedulerQueue);
		      }
		  }

		  var WATCHER = "watcher";
		  var WATCHER_CB = "".concat(WATCHER, " callback");
		  var WATCHER_GETTER = "".concat(WATCHER, " getter");
		  var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
		  // Simple effect.
		  function watchEffect(effect, options) {
		      return doWatch(effect, null, options);
		  }
		  function watchPostEffect(effect, options) {
		      return doWatch(effect, null, (__assign(__assign({}, options), { flush: 'post' }) ));
		  }
		  function watchSyncEffect(effect, options) {
		      return doWatch(effect, null, (__assign(__assign({}, options), { flush: 'sync' }) ));
		  }
		  // initial value for watchers to trigger on undefined initial values
		  var INITIAL_WATCHER_VALUE = {};
		  // implementation
		  function watch(source, cb, options) {
		      if (typeof cb !== 'function') {
		          warn$2("`watch(fn, options?)` signature has been moved to a separate API. " +
		              "Use `watchEffect(fn, options?)` instead. `watch` now only " +
		              "supports `watch(source, cb, options?) signature.");
		      }
		      return doWatch(source, cb, options);
		  }
		  function doWatch(source, cb, _a) {
		      var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;
		      if (!cb) {
		          if (immediate !== undefined) {
		              warn$2("watch() \"immediate\" option is only respected when using the " +
		                  "watch(source, callback, options?) signature.");
		          }
		          if (deep !== undefined) {
		              warn$2("watch() \"deep\" option is only respected when using the " +
		                  "watch(source, callback, options?) signature.");
		          }
		      }
		      var warnInvalidSource = function (s) {
		          warn$2("Invalid watch source: ".concat(s, ". A watch source can only be a getter/effect ") +
		              "function, a ref, a reactive object, or an array of these types.");
		      };
		      var instance = currentInstance;
		      var call = function (fn, type, args) {
		          if (args === void 0) { args = null; }
		          return invokeWithErrorHandling(fn, null, args, instance, type);
		      };
		      var getter;
		      var forceTrigger = false;
		      var isMultiSource = false;
		      if (isRef(source)) {
		          getter = function () { return source.value; };
		          forceTrigger = isShallow(source);
		      }
		      else if (isReactive(source)) {
		          getter = function () {
		              source.__ob__.dep.depend();
		              return source;
		          };
		          deep = true;
		      }
		      else if (isArray(source)) {
		          isMultiSource = true;
		          forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });
		          getter = function () {
		              return source.map(function (s) {
		                  if (isRef(s)) {
		                      return s.value;
		                  }
		                  else if (isReactive(s)) {
		                      return traverse(s);
		                  }
		                  else if (isFunction(s)) {
		                      return call(s, WATCHER_GETTER);
		                  }
		                  else {
		                      warnInvalidSource(s);
		                  }
		              });
		          };
		      }
		      else if (isFunction(source)) {
		          if (cb) {
		              // getter with cb
		              getter = function () { return call(source, WATCHER_GETTER); };
		          }
		          else {
		              // no cb -> simple effect
		              getter = function () {
		                  if (instance && instance._isDestroyed) {
		                      return;
		                  }
		                  if (cleanup) {
		                      cleanup();
		                  }
		                  return call(source, WATCHER, [onCleanup]);
		              };
		          }
		      }
		      else {
		          getter = noop;
		          warnInvalidSource(source);
		      }
		      if (cb && deep) {
		          var baseGetter_1 = getter;
		          getter = function () { return traverse(baseGetter_1()); };
		      }
		      var cleanup;
		      var onCleanup = function (fn) {
		          cleanup = watcher.onStop = function () {
		              call(fn, WATCHER_CLEANUP);
		          };
		      };
		      // in SSR there is no need to setup an actual effect, and it should be noop
		      // unless it's eager
		      if (isServerRendering()) {
		          // we will also not call the invalidate callback (+ runner is not set up)
		          onCleanup = noop;
		          if (!cb) {
		              getter();
		          }
		          else if (immediate) {
		              call(cb, WATCHER_CB, [
		                  getter(),
		                  isMultiSource ? [] : undefined,
		                  onCleanup
		              ]);
		          }
		          return noop;
		      }
		      var watcher = new Watcher(currentInstance, getter, noop, {
		          lazy: true
		      });
		      watcher.noRecurse = !cb;
		      var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
		      // overwrite default run
		      watcher.run = function () {
		          if (!watcher.active &&
		              !(flush === 'pre' && instance && instance._isBeingDestroyed)) {
		              return;
		          }
		          if (cb) {
		              // watch(source, cb)
		              var newValue = watcher.get();
		              if (deep ||
		                  forceTrigger ||
		                  (isMultiSource
		                      ? newValue.some(function (v, i) {
		                          return hasChanged(v, oldValue[i]);
		                      })
		                      : hasChanged(newValue, oldValue))) {
		                  // cleanup before running cb again
		                  if (cleanup) {
		                      cleanup();
		                  }
		                  call(cb, WATCHER_CB, [
		                      newValue,
		                      // pass undefined as the old value when it's changed for the first time
		                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
		                      onCleanup
		                  ]);
		                  oldValue = newValue;
		              }
		          }
		          else {
		              // watchEffect
		              watcher.get();
		          }
		      };
		      if (flush === 'sync') {
		          watcher.update = watcher.run;
		      }
		      else if (flush === 'post') {
		          watcher.post = true;
		          watcher.update = function () { return queueWatcher(watcher); };
		      }
		      else {
		          // pre
		          watcher.update = function () {
		              if (instance && instance === currentInstance && !instance._isMounted) {
		                  // pre-watcher triggered before
		                  var buffer = instance._preWatchers || (instance._preWatchers = []);
		                  if (buffer.indexOf(watcher) < 0)
		                      buffer.push(watcher);
		              }
		              else {
		                  queueWatcher(watcher);
		              }
		          };
		      }
		      {
		          watcher.onTrack = onTrack;
		          watcher.onTrigger = onTrigger;
		      }
		      // initial run
		      if (cb) {
		          if (immediate) {
		              watcher.run();
		          }
		          else {
		              oldValue = watcher.get();
		          }
		      }
		      else if (flush === 'post' && instance) {
		          instance.$once('hook:mounted', function () { return watcher.get(); });
		      }
		      else {
		          watcher.get();
		      }
		      return function () {
		          watcher.teardown();
		      };
		  }

		  var activeEffectScope;
		  var EffectScope = /** @class */ (function () {
		      function EffectScope(detached) {
		          if (detached === void 0) { detached = false; }
		          /**
		           * @internal
		           */
		          this.active = true;
		          /**
		           * @internal
		           */
		          this.effects = [];
		          /**
		           * @internal
		           */
		          this.cleanups = [];
		          if (!detached && activeEffectScope) {
		              this.parent = activeEffectScope;
		              this.index =
		                  (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
		          }
		      }
		      EffectScope.prototype.run = function (fn) {
		          if (this.active) {
		              var currentEffectScope = activeEffectScope;
		              try {
		                  activeEffectScope = this;
		                  return fn();
		              }
		              finally {
		                  activeEffectScope = currentEffectScope;
		              }
		          }
		          else {
		              warn$2("cannot run an inactive effect scope.");
		          }
		      };
		      /**
		       * This should only be called on non-detached scopes
		       * @internal
		       */
		      EffectScope.prototype.on = function () {
		          activeEffectScope = this;
		      };
		      /**
		       * This should only be called on non-detached scopes
		       * @internal
		       */
		      EffectScope.prototype.off = function () {
		          activeEffectScope = this.parent;
		      };
		      EffectScope.prototype.stop = function (fromParent) {
		          if (this.active) {
		              var i = void 0, l = void 0;
		              for (i = 0, l = this.effects.length; i < l; i++) {
		                  this.effects[i].teardown();
		              }
		              for (i = 0, l = this.cleanups.length; i < l; i++) {
		                  this.cleanups[i]();
		              }
		              if (this.scopes) {
		                  for (i = 0, l = this.scopes.length; i < l; i++) {
		                      this.scopes[i].stop(true);
		                  }
		              }
		              // nested scope, dereference from parent to avoid memory leaks
		              if (this.parent && !fromParent) {
		                  // optimized O(1) removal
		                  var last = this.parent.scopes.pop();
		                  if (last && last !== this) {
		                      this.parent.scopes[this.index] = last;
		                      last.index = this.index;
		                  }
		              }
		              this.active = false;
		          }
		      };
		      return EffectScope;
		  }());
		  function effectScope(detached) {
		      return new EffectScope(detached);
		  }
		  /**
		   * @internal
		   */
		  function recordEffectScope(effect, scope) {
		      if (scope === void 0) { scope = activeEffectScope; }
		      if (scope && scope.active) {
		          scope.effects.push(effect);
		      }
		  }
		  function getCurrentScope() {
		      return activeEffectScope;
		  }
		  function onScopeDispose(fn) {
		      if (activeEffectScope) {
		          activeEffectScope.cleanups.push(fn);
		      }
		      else {
		          warn$2("onScopeDispose() is called when there is no active effect scope" +
		              " to be associated with.");
		      }
		  }

		  function provide(key, value) {
		      if (!currentInstance) {
		          {
		              warn$2("provide() can only be used inside setup().");
		          }
		      }
		      else {
		          // TS doesn't allow symbol as index type
		          resolveProvided(currentInstance)[key] = value;
		      }
		  }
		  function resolveProvided(vm) {
		      // by default an instance inherits its parent's provides object
		      // but when it needs to provide values of its own, it creates its
		      // own provides object using parent provides object as prototype.
		      // this way in `inject` we can simply look up injections from direct
		      // parent and let the prototype chain do the work.
		      var existing = vm._provided;
		      var parentProvides = vm.$parent && vm.$parent._provided;
		      if (parentProvides === existing) {
		          return (vm._provided = Object.create(parentProvides));
		      }
		      else {
		          return existing;
		      }
		  }
		  function inject(key, defaultValue, treatDefaultAsFactory) {
		      if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }
		      // fallback to `currentRenderingInstance` so that this can be called in
		      // a functional component
		      var instance = currentInstance;
		      if (instance) {
		          // #2400
		          // to support `app.use` plugins,
		          // fallback to appContext's `provides` if the instance is at root
		          var provides = instance.$parent && instance.$parent._provided;
		          if (provides && key in provides) {
		              // TS doesn't allow symbol as index type
		              return provides[key];
		          }
		          else if (arguments.length > 1) {
		              return treatDefaultAsFactory && isFunction(defaultValue)
		                  ? defaultValue.call(instance)
		                  : defaultValue;
		          }
		          else {
		              warn$2("injection \"".concat(String(key), "\" not found."));
		          }
		      }
		      else {
		          warn$2("inject() can only be used inside setup() or functional components.");
		      }
		  }

		  /**
		   * @internal this function needs manual public type declaration because it relies
		   * on previously manually authored types from Vue 2
		   */
		  function h(type, props, children) {
		      if (!currentInstance) {
		          warn$2("globally imported h() can only be invoked when there is an active " +
		                  "component instance, e.g. synchronously in a component's render or setup function.");
		      }
		      return createElement$1(currentInstance, type, props, children, 2, true);
		  }

		  function handleError(err, vm, info) {
		      // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
		      // See: https://github.com/vuejs/vuex/issues/1505
		      pushTarget();
		      try {
		          if (vm) {
		              var cur = vm;
		              while ((cur = cur.$parent)) {
		                  var hooks = cur.$options.errorCaptured;
		                  if (hooks) {
		                      for (var i = 0; i < hooks.length; i++) {
		                          try {
		                              var capture = hooks[i].call(cur, err, vm, info) === false;
		                              if (capture)
		                                  return;
		                          }
		                          catch (e) {
		                              globalHandleError(e, cur, 'errorCaptured hook');
		                          }
		                      }
		                  }
		              }
		          }
		          globalHandleError(err, vm, info);
		      }
		      finally {
		          popTarget();
		      }
		  }
		  function invokeWithErrorHandling(handler, context, args, vm, info) {
		      var res;
		      try {
		          res = args ? handler.apply(context, args) : handler.call(context);
		          if (res && !res._isVue && isPromise(res) && !res._handled) {
		              res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
		              res._handled = true;
		          }
		      }
		      catch (e) {
		          handleError(e, vm, info);
		      }
		      return res;
		  }
		  function globalHandleError(err, vm, info) {
		      if (config.errorHandler) {
		          try {
		              return config.errorHandler.call(null, err, vm, info);
		          }
		          catch (e) {
		              // if the user intentionally throws the original error in the handler,
		              // do not log it twice
		              if (e !== err) {
		                  logError(e, null, 'config.errorHandler');
		              }
		          }
		      }
		      logError(err, vm, info);
		  }
		  function logError(err, vm, info) {
		      {
		          warn$2("Error in ".concat(info, ": \"").concat(err.toString(), "\""), vm);
		      }
		      /* istanbul ignore else */
		      if (inBrowser && typeof console !== 'undefined') {
		          console.error(err);
		      }
		      else {
		          throw err;
		      }
		  }

		  /* globals MutationObserver */
		  var isUsingMicroTask = false;
		  var callbacks = [];
		  var pending = false;
		  function flushCallbacks() {
		      pending = false;
		      var copies = callbacks.slice(0);
		      callbacks.length = 0;
		      for (var i = 0; i < copies.length; i++) {
		          copies[i]();
		      }
		  }
		  // Here we have async deferring wrappers using microtasks.
		  // In 2.5 we used (macro) tasks (in combination with microtasks).
		  // However, it has subtle problems when state is changed right before repaint
		  // (e.g. #6813, out-in transitions).
		  // Also, using (macro) tasks in event handler would cause some weird behaviors
		  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
		  // So we now use microtasks everywhere, again.
		  // A major drawback of this tradeoff is that there are some scenarios
		  // where microtasks have too high a priority and fire in between supposedly
		  // sequential events (e.g. #4521, #6690, which have workarounds)
		  // or even between bubbling of the same event (#6566).
		  var timerFunc;
		  // The nextTick behavior leverages the microtask queue, which can be accessed
		  // via either native Promise.then or MutationObserver.
		  // MutationObserver has wider support, however it is seriously bugged in
		  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
		  // completely stops working after triggering a few times... so, if native
		  // Promise is available, we will use it:
		  /* istanbul ignore next, $flow-disable-line */
		  if (typeof Promise !== 'undefined' && isNative(Promise)) {
		      var p_1 = Promise.resolve();
		      timerFunc = function () {
		          p_1.then(flushCallbacks);
		          // In problematic UIWebViews, Promise.then doesn't completely break, but
		          // it can get stuck in a weird state where callbacks are pushed into the
		          // microtask queue but the queue isn't being flushed, until the browser
		          // needs to do some other work, e.g. handle a timer. Therefore we can
		          // "force" the microtask queue to be flushed by adding an empty timer.
		          if (isIOS)
		              setTimeout(noop);
		      };
		      isUsingMicroTask = true;
		  }
		  else if (!isIE &&
		      typeof MutationObserver !== 'undefined' &&
		      (isNative(MutationObserver) ||
		          // PhantomJS and iOS 7.x
		          MutationObserver.toString() === '[object MutationObserverConstructor]')) {
		      // Use MutationObserver where native Promise is not available,
		      // e.g. PhantomJS, iOS7, Android 4.4
		      // (#6466 MutationObserver is unreliable in IE11)
		      var counter_1 = 1;
		      var observer = new MutationObserver(flushCallbacks);
		      var textNode_1 = document.createTextNode(String(counter_1));
		      observer.observe(textNode_1, {
		          characterData: true
		      });
		      timerFunc = function () {
		          counter_1 = (counter_1 + 1) % 2;
		          textNode_1.data = String(counter_1);
		      };
		      isUsingMicroTask = true;
		  }
		  else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
		      // Fallback to setImmediate.
		      // Technically it leverages the (macro) task queue,
		      // but it is still a better choice than setTimeout.
		      timerFunc = function () {
		          setImmediate(flushCallbacks);
		      };
		  }
		  else {
		      // Fallback to setTimeout.
		      timerFunc = function () {
		          setTimeout(flushCallbacks, 0);
		      };
		  }
		  /**
		   * @internal
		   */
		  function nextTick(cb, ctx) {
		      var _resolve;
		      callbacks.push(function () {
		          if (cb) {
		              try {
		                  cb.call(ctx);
		              }
		              catch (e) {
		                  handleError(e, ctx, 'nextTick');
		              }
		          }
		          else if (_resolve) {
		              _resolve(ctx);
		          }
		      });
		      if (!pending) {
		          pending = true;
		          timerFunc();
		      }
		      // $flow-disable-line
		      if (!cb && typeof Promise !== 'undefined') {
		          return new Promise(function (resolve) {
		              _resolve = resolve;
		          });
		      }
		  }

		  function useCssModule(name) {
		      /* istanbul ignore else */
		      {
		          {
		              warn$2("useCssModule() is not supported in the global build.");
		          }
		          return emptyObject;
		      }
		  }

		  /**
		   * Runtime helper for SFC's CSS variable injection feature.
		   * @private
		   */
		  function useCssVars(getter) {
		      if (!inBrowser && !false)
		          return;
		      var instance = currentInstance;
		      if (!instance) {
		          warn$2("useCssVars is called without current active component instance.");
		          return;
		      }
		      watchPostEffect(function () {
		          var el = instance.$el;
		          var vars = getter(instance, instance._setupProxy);
		          if (el && el.nodeType === 1) {
		              var style = el.style;
		              for (var key in vars) {
		                  style.setProperty("--".concat(key), vars[key]);
		              }
		          }
		      });
		  }

		  /**
		   * v3-compatible async component API.
		   * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
		   * because it relies on existing manual types
		   */
		  function defineAsyncComponent(source) {
		      if (isFunction(source)) {
		          source = { loader: source };
		      }
		      var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out
		      _b = source.suspensible, // undefined = never times out
		      suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true
		      userOnError = source.onError;
		      if (suspensible) {
		          warn$2("The suspensiblbe option for async components is not supported in Vue2. It is ignored.");
		      }
		      var pendingRequest = null;
		      var retries = 0;
		      var retry = function () {
		          retries++;
		          pendingRequest = null;
		          return load();
		      };
		      var load = function () {
		          var thisRequest;
		          return (pendingRequest ||
		              (thisRequest = pendingRequest =
		                  loader()
		                      .catch(function (err) {
		                      err = err instanceof Error ? err : new Error(String(err));
		                      if (userOnError) {
		                          return new Promise(function (resolve, reject) {
		                              var userRetry = function () { return resolve(retry()); };
		                              var userFail = function () { return reject(err); };
		                              userOnError(err, userRetry, userFail, retries + 1);
		                          });
		                      }
		                      else {
		                          throw err;
		                      }
		                  })
		                      .then(function (comp) {
		                      if (thisRequest !== pendingRequest && pendingRequest) {
		                          return pendingRequest;
		                      }
		                      if (!comp) {
		                          warn$2("Async component loader resolved to undefined. " +
		                              "If you are using retry(), make sure to return its return value.");
		                      }
		                      // interop module default
		                      if (comp &&
		                          (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
		                          comp = comp.default;
		                      }
		                      if (comp && !isObject(comp) && !isFunction(comp)) {
		                          throw new Error("Invalid async component load result: ".concat(comp));
		                      }
		                      return comp;
		                  })));
		      };
		      return function () {
		          var component = load();
		          return {
		              component: component,
		              delay: delay,
		              timeout: timeout,
		              error: errorComponent,
		              loading: loadingComponent
		          };
		      };
		  }

		  function createLifeCycle(hookName) {
		      return function (fn, target) {
		          if (target === void 0) { target = currentInstance; }
		          if (!target) {
		              warn$2("".concat(formatName(hookName), " is called when there is no active component instance to be ") +
		                      "associated with. " +
		                      "Lifecycle injection APIs can only be used during execution of setup().");
		              return;
		          }
		          return injectHook(target, hookName, fn);
		      };
		  }
		  function formatName(name) {
		      if (name === 'beforeDestroy') {
		          name = 'beforeUnmount';
		      }
		      else if (name === 'destroyed') {
		          name = 'unmounted';
		      }
		      return "on".concat(name[0].toUpperCase() + name.slice(1));
		  }
		  function injectHook(instance, hookName, fn) {
		      var options = instance.$options;
		      options[hookName] = mergeLifecycleHook(options[hookName], fn);
		  }
		  var onBeforeMount = createLifeCycle('beforeMount');
		  var onMounted = createLifeCycle('mounted');
		  var onBeforeUpdate = createLifeCycle('beforeUpdate');
		  var onUpdated = createLifeCycle('updated');
		  var onBeforeUnmount = createLifeCycle('beforeDestroy');
		  var onUnmounted = createLifeCycle('destroyed');
		  var onErrorCaptured = createLifeCycle('errorCaptured');
		  var onActivated = createLifeCycle('activated');
		  var onDeactivated = createLifeCycle('deactivated');
		  var onServerPrefetch = createLifeCycle('serverPrefetch');
		  var onRenderTracked = createLifeCycle('renderTracked');
		  var onRenderTriggered = createLifeCycle('renderTriggered');

		  /**
		   * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
		   */
		  var version = '2.7.8';
		  /**
		   * @internal type is manually declared in <root>/types/v3-define-component.d.ts
		   */
		  function defineComponent(options) {
		      return options;
		  }

		  var vca = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    version: version,
		    defineComponent: defineComponent,
		    ref: ref$1,
		    shallowRef: shallowRef,
		    isRef: isRef,
		    toRef: toRef,
		    toRefs: toRefs,
		    unref: unref,
		    proxyRefs: proxyRefs,
		    customRef: customRef,
		    triggerRef: triggerRef,
		    reactive: reactive,
		    isReactive: isReactive,
		    isReadonly: isReadonly,
		    isShallow: isShallow,
		    isProxy: isProxy,
		    shallowReactive: shallowReactive,
		    markRaw: markRaw,
		    toRaw: toRaw,
		    readonly: readonly,
		    shallowReadonly: shallowReadonly,
		    computed: computed,
		    watch: watch,
		    watchEffect: watchEffect,
		    watchPostEffect: watchPostEffect,
		    watchSyncEffect: watchSyncEffect,
		    EffectScope: EffectScope,
		    effectScope: effectScope,
		    onScopeDispose: onScopeDispose,
		    getCurrentScope: getCurrentScope,
		    provide: provide,
		    inject: inject,
		    h: h,
		    getCurrentInstance: getCurrentInstance,
		    useSlots: useSlots,
		    useAttrs: useAttrs,
		    useListeners: useListeners,
		    mergeDefaults: mergeDefaults,
		    nextTick: nextTick,
		    set: set,
		    del: del,
		    useCssModule: useCssModule,
		    useCssVars: useCssVars,
		    defineAsyncComponent: defineAsyncComponent,
		    onBeforeMount: onBeforeMount,
		    onMounted: onMounted,
		    onBeforeUpdate: onBeforeUpdate,
		    onUpdated: onUpdated,
		    onBeforeUnmount: onBeforeUnmount,
		    onUnmounted: onUnmounted,
		    onErrorCaptured: onErrorCaptured,
		    onActivated: onActivated,
		    onDeactivated: onDeactivated,
		    onServerPrefetch: onServerPrefetch,
		    onRenderTracked: onRenderTracked,
		    onRenderTriggered: onRenderTriggered
		  });

		  var seenObjects = new _Set();
		  /**
		   * Recursively traverse an object to evoke all converted
		   * getters, so that every nested property inside the object
		   * is collected as a "deep" dependency.
		   */
		  function traverse(val) {
		      _traverse(val, seenObjects);
		      seenObjects.clear();
		      return val;
		  }
		  function _traverse(val, seen) {
		      var i, keys;
		      var isA = isArray(val);
		      if ((!isA && !isObject(val)) ||
		          Object.isFrozen(val) ||
		          val instanceof VNode) {
		          return;
		      }
		      if (val.__ob__) {
		          var depId = val.__ob__.dep.id;
		          if (seen.has(depId)) {
		              return;
		          }
		          seen.add(depId);
		      }
		      if (isA) {
		          i = val.length;
		          while (i--)
		              _traverse(val[i], seen);
		      }
		      else if (isRef(val)) {
		          _traverse(val.value, seen);
		      }
		      else {
		          keys = Object.keys(val);
		          i = keys.length;
		          while (i--)
		              _traverse(val[keys[i]], seen);
		      }
		  }

		  var uid$1 = 0;
		  /**
		   * A watcher parses an expression, collects dependencies,
		   * and fires callback when the expression value changes.
		   * This is used for both the $watch() api and directives.
		   * @internal
		   */
		  var Watcher = /** @class */ (function () {
		      function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
		          recordEffectScope(this, activeEffectScope || (vm ? vm._scope : undefined));
		          if ((this.vm = vm)) {
		              if (isRenderWatcher) {
		                  vm._watcher = this;
		              }
		          }
		          // options
		          if (options) {
		              this.deep = !!options.deep;
		              this.user = !!options.user;
		              this.lazy = !!options.lazy;
		              this.sync = !!options.sync;
		              this.before = options.before;
		              {
		                  this.onTrack = options.onTrack;
		                  this.onTrigger = options.onTrigger;
		              }
		          }
		          else {
		              this.deep = this.user = this.lazy = this.sync = false;
		          }
		          this.cb = cb;
		          this.id = ++uid$1; // uid for batching
		          this.active = true;
		          this.post = false;
		          this.dirty = this.lazy; // for lazy watchers
		          this.deps = [];
		          this.newDeps = [];
		          this.depIds = new _Set();
		          this.newDepIds = new _Set();
		          this.expression = expOrFn.toString() ;
		          // parse expression for getter
		          if (isFunction(expOrFn)) {
		              this.getter = expOrFn;
		          }
		          else {
		              this.getter = parsePath(expOrFn);
		              if (!this.getter) {
		                  this.getter = noop;
		                  warn$2("Failed watching path: \"".concat(expOrFn, "\" ") +
		                          'Watcher only accepts simple dot-delimited paths. ' +
		                          'For full control, use a function instead.', vm);
		              }
		          }
		          this.value = this.lazy ? undefined : this.get();
		      }
		      /**
		       * Evaluate the getter, and re-collect dependencies.
		       */
		      Watcher.prototype.get = function () {
		          pushTarget(this);
		          var value;
		          var vm = this.vm;
		          try {
		              value = this.getter.call(vm, vm);
		          }
		          catch (e) {
		              if (this.user) {
		                  handleError(e, vm, "getter for watcher \"".concat(this.expression, "\""));
		              }
		              else {
		                  throw e;
		              }
		          }
		          finally {
		              // "touch" every property so they are all tracked as
		              // dependencies for deep watching
		              if (this.deep) {
		                  traverse(value);
		              }
		              popTarget();
		              this.cleanupDeps();
		          }
		          return value;
		      };
		      /**
		       * Add a dependency to this directive.
		       */
		      Watcher.prototype.addDep = function (dep) {
		          var id = dep.id;
		          if (!this.newDepIds.has(id)) {
		              this.newDepIds.add(id);
		              this.newDeps.push(dep);
		              if (!this.depIds.has(id)) {
		                  dep.addSub(this);
		              }
		          }
		      };
		      /**
		       * Clean up for dependency collection.
		       */
		      Watcher.prototype.cleanupDeps = function () {
		          var i = this.deps.length;
		          while (i--) {
		              var dep = this.deps[i];
		              if (!this.newDepIds.has(dep.id)) {
		                  dep.removeSub(this);
		              }
		          }
		          var tmp = this.depIds;
		          this.depIds = this.newDepIds;
		          this.newDepIds = tmp;
		          this.newDepIds.clear();
		          tmp = this.deps;
		          this.deps = this.newDeps;
		          this.newDeps = tmp;
		          this.newDeps.length = 0;
		      };
		      /**
		       * Subscriber interface.
		       * Will be called when a dependency changes.
		       */
		      Watcher.prototype.update = function () {
		          /* istanbul ignore else */
		          if (this.lazy) {
		              this.dirty = true;
		          }
		          else if (this.sync) {
		              this.run();
		          }
		          else {
		              queueWatcher(this);
		          }
		      };
		      /**
		       * Scheduler job interface.
		       * Will be called by the scheduler.
		       */
		      Watcher.prototype.run = function () {
		          if (this.active) {
		              var value = this.get();
		              if (value !== this.value ||
		                  // Deep watchers and watchers on Object/Arrays should fire even
		                  // when the value is the same, because the value may
		                  // have mutated.
		                  isObject(value) ||
		                  this.deep) {
		                  // set new value
		                  var oldValue = this.value;
		                  this.value = value;
		                  if (this.user) {
		                      var info = "callback for watcher \"".concat(this.expression, "\"");
		                      invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
		                  }
		                  else {
		                      this.cb.call(this.vm, value, oldValue);
		                  }
		              }
		          }
		      };
		      /**
		       * Evaluate the value of the watcher.
		       * This only gets called for lazy watchers.
		       */
		      Watcher.prototype.evaluate = function () {
		          this.value = this.get();
		          this.dirty = false;
		      };
		      /**
		       * Depend on all deps collected by this watcher.
		       */
		      Watcher.prototype.depend = function () {
		          var i = this.deps.length;
		          while (i--) {
		              this.deps[i].depend();
		          }
		      };
		      /**
		       * Remove self from all dependencies' subscriber list.
		       */
		      Watcher.prototype.teardown = function () {
		          if (this.vm && !this.vm._isBeingDestroyed) {
		              remove$2(this.vm._scope.effects, this);
		          }
		          if (this.active) {
		              var i = this.deps.length;
		              while (i--) {
		                  this.deps[i].removeSub(this);
		              }
		              this.active = false;
		              if (this.onStop) {
		                  this.onStop();
		              }
		          }
		      };
		      return Watcher;
		  }());

		  var sharedPropertyDefinition = {
		      enumerable: true,
		      configurable: true,
		      get: noop,
		      set: noop
		  };
		  function proxy(target, sourceKey, key) {
		      sharedPropertyDefinition.get = function proxyGetter() {
		          return this[sourceKey][key];
		      };
		      sharedPropertyDefinition.set = function proxySetter(val) {
		          this[sourceKey][key] = val;
		      };
		      Object.defineProperty(target, key, sharedPropertyDefinition);
		  }
		  function initState(vm) {
		      var opts = vm.$options;
		      if (opts.props)
		          initProps$1(vm, opts.props);
		      // Composition API
		      initSetup(vm);
		      if (opts.methods)
		          initMethods(vm, opts.methods);
		      if (opts.data) {
		          initData(vm);
		      }
		      else {
		          var ob = observe((vm._data = {}));
		          ob && ob.vmCount++;
		      }
		      if (opts.computed)
		          initComputed$1(vm, opts.computed);
		      if (opts.watch && opts.watch !== nativeWatch) {
		          initWatch(vm, opts.watch);
		      }
		  }
		  function initProps$1(vm, propsOptions) {
		      var propsData = vm.$options.propsData || {};
		      var props = (vm._props = shallowReactive({}));
		      // cache prop keys so that future props updates can iterate using Array
		      // instead of dynamic object key enumeration.
		      var keys = (vm.$options._propKeys = []);
		      var isRoot = !vm.$parent;
		      // root instance props should be converted
		      if (!isRoot) {
		          toggleObserving(false);
		      }
		      var _loop_1 = function (key) {
		          keys.push(key);
		          var value = validateProp(key, propsOptions, propsData, vm);
		          /* istanbul ignore else */
		          {
		              var hyphenatedKey = hyphenate(key);
		              if (isReservedAttribute(hyphenatedKey) ||
		                  config.isReservedAttr(hyphenatedKey)) {
		                  warn$2("\"".concat(hyphenatedKey, "\" is a reserved attribute and cannot be used as component prop."), vm);
		              }
		              defineReactive(props, key, value, function () {
		                  if (!isRoot && !isUpdatingChildComponent) {
		                      warn$2("Avoid mutating a prop directly since the value will be " +
		                          "overwritten whenever the parent component re-renders. " +
		                          "Instead, use a data or computed property based on the prop's " +
		                          "value. Prop being mutated: \"".concat(key, "\""), vm);
		                  }
		              });
		          }
		          // static props are already proxied on the component's prototype
		          // during Vue.extend(). We only need to proxy props defined at
		          // instantiation here.
		          if (!(key in vm)) {
		              proxy(vm, "_props", key);
		          }
		      };
		      for (var key in propsOptions) {
		          _loop_1(key);
		      }
		      toggleObserving(true);
		  }
		  function initData(vm) {
		      var data = vm.$options.data;
		      data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
		      if (!isPlainObject(data)) {
		          data = {};
		          warn$2('data functions should return an object:\n' +
		                  'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
		      }
		      // proxy data on instance
		      var keys = Object.keys(data);
		      var props = vm.$options.props;
		      var methods = vm.$options.methods;
		      var i = keys.length;
		      while (i--) {
		          var key = keys[i];
		          {
		              if (methods && hasOwn(methods, key)) {
		                  warn$2("Method \"".concat(key, "\" has already been defined as a data property."), vm);
		              }
		          }
		          if (props && hasOwn(props, key)) {
		              warn$2("The data property \"".concat(key, "\" is already declared as a prop. ") +
		                      "Use prop default value instead.", vm);
		          }
		          else if (!isReserved(key)) {
		              proxy(vm, "_data", key);
		          }
		      }
		      // observe data
		      var ob = observe(data);
		      ob && ob.vmCount++;
		  }
		  function getData(data, vm) {
		      // #7573 disable dep collection when invoking data getters
		      pushTarget();
		      try {
		          return data.call(vm, vm);
		      }
		      catch (e) {
		          handleError(e, vm, "data()");
		          return {};
		      }
		      finally {
		          popTarget();
		      }
		  }
		  var computedWatcherOptions = { lazy: true };
		  function initComputed$1(vm, computed) {
		      // $flow-disable-line
		      var watchers = (vm._computedWatchers = Object.create(null));
		      // computed properties are just getters during SSR
		      var isSSR = isServerRendering();
		      for (var key in computed) {
		          var userDef = computed[key];
		          var getter = isFunction(userDef) ? userDef : userDef.get;
		          if (getter == null) {
		              warn$2("Getter is missing for computed property \"".concat(key, "\"."), vm);
		          }
		          if (!isSSR) {
		              // create internal watcher for the computed property.
		              watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
		          }
		          // component-defined computed properties are already defined on the
		          // component prototype. We only need to define computed properties defined
		          // at instantiation here.
		          if (!(key in vm)) {
		              defineComputed(vm, key, userDef);
		          }
		          else {
		              if (key in vm.$data) {
		                  warn$2("The computed property \"".concat(key, "\" is already defined in data."), vm);
		              }
		              else if (vm.$options.props && key in vm.$options.props) {
		                  warn$2("The computed property \"".concat(key, "\" is already defined as a prop."), vm);
		              }
		              else if (vm.$options.methods && key in vm.$options.methods) {
		                  warn$2("The computed property \"".concat(key, "\" is already defined as a method."), vm);
		              }
		          }
		      }
		  }
		  function defineComputed(target, key, userDef) {
		      var shouldCache = !isServerRendering();
		      if (isFunction(userDef)) {
		          sharedPropertyDefinition.get = shouldCache
		              ? createComputedGetter(key)
		              : createGetterInvoker(userDef);
		          sharedPropertyDefinition.set = noop;
		      }
		      else {
		          sharedPropertyDefinition.get = userDef.get
		              ? shouldCache && userDef.cache !== false
		                  ? createComputedGetter(key)
		                  : createGetterInvoker(userDef.get)
		              : noop;
		          sharedPropertyDefinition.set = userDef.set || noop;
		      }
		      if (sharedPropertyDefinition.set === noop) {
		          sharedPropertyDefinition.set = function () {
		              warn$2("Computed property \"".concat(key, "\" was assigned to but it has no setter."), this);
		          };
		      }
		      Object.defineProperty(target, key, sharedPropertyDefinition);
		  }
		  function createComputedGetter(key) {
		      return function computedGetter() {
		          var watcher = this._computedWatchers && this._computedWatchers[key];
		          if (watcher) {
		              if (watcher.dirty) {
		                  watcher.evaluate();
		              }
		              if (Dep.target) {
		                  if (Dep.target.onTrack) {
		                      Dep.target.onTrack({
		                          effect: Dep.target,
		                          target: this,
		                          type: "get" /* TrackOpTypes.GET */,
		                          key: key
		                      });
		                  }
		                  watcher.depend();
		              }
		              return watcher.value;
		          }
		      };
		  }
		  function createGetterInvoker(fn) {
		      return function computedGetter() {
		          return fn.call(this, this);
		      };
		  }
		  function initMethods(vm, methods) {
		      var props = vm.$options.props;
		      for (var key in methods) {
		          {
		              if (typeof methods[key] !== 'function') {
		                  warn$2("Method \"".concat(key, "\" has type \"").concat(typeof methods[key], "\" in the component definition. ") +
		                      "Did you reference the function correctly?", vm);
		              }
		              if (props && hasOwn(props, key)) {
		                  warn$2("Method \"".concat(key, "\" has already been defined as a prop."), vm);
		              }
		              if (key in vm && isReserved(key)) {
		                  warn$2("Method \"".concat(key, "\" conflicts with an existing Vue instance method. ") +
		                      "Avoid defining component methods that start with _ or $.");
		              }
		          }
		          vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);
		      }
		  }
		  function initWatch(vm, watch) {
		      for (var key in watch) {
		          var handler = watch[key];
		          if (isArray(handler)) {
		              for (var i = 0; i < handler.length; i++) {
		                  createWatcher(vm, key, handler[i]);
		              }
		          }
		          else {
		              createWatcher(vm, key, handler);
		          }
		      }
		  }
		  function createWatcher(vm, expOrFn, handler, options) {
		      if (isPlainObject(handler)) {
		          options = handler;
		          handler = handler.handler;
		      }
		      if (typeof handler === 'string') {
		          handler = vm[handler];
		      }
		      return vm.$watch(expOrFn, handler, options);
		  }
		  function stateMixin(Vue) {
		      // flow somehow has problems with directly declared definition object
		      // when using Object.defineProperty, so we have to procedurally build up
		      // the object here.
		      var dataDef = {};
		      dataDef.get = function () {
		          return this._data;
		      };
		      var propsDef = {};
		      propsDef.get = function () {
		          return this._props;
		      };
		      {
		          dataDef.set = function () {
		              warn$2('Avoid replacing instance root $data. ' +
		                  'Use nested data properties instead.', this);
		          };
		          propsDef.set = function () {
		              warn$2("$props is readonly.", this);
		          };
		      }
		      Object.defineProperty(Vue.prototype, '$data', dataDef);
		      Object.defineProperty(Vue.prototype, '$props', propsDef);
		      Vue.prototype.$set = set;
		      Vue.prototype.$delete = del;
		      Vue.prototype.$watch = function (expOrFn, cb, options) {
		          var vm = this;
		          if (isPlainObject(cb)) {
		              return createWatcher(vm, expOrFn, cb, options);
		          }
		          options = options || {};
		          options.user = true;
		          var watcher = new Watcher(vm, expOrFn, cb, options);
		          if (options.immediate) {
		              var info = "callback for immediate watcher \"".concat(watcher.expression, "\"");
		              pushTarget();
		              invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
		              popTarget();
		          }
		          return function unwatchFn() {
		              watcher.teardown();
		          };
		      };
		  }

		  function initProvide(vm) {
		      var provideOption = vm.$options.provide;
		      if (provideOption) {
		          var provided = isFunction(provideOption)
		              ? provideOption.call(vm)
		              : provideOption;
		          if (!isObject(provided)) {
		              return;
		          }
		          var source = resolveProvided(vm);
		          // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
		          // iterate the keys ourselves.
		          var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
		          for (var i = 0; i < keys.length; i++) {
		              var key = keys[i];
		              Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
		          }
		      }
		  }
		  function initInjections(vm) {
		      var result = resolveInject(vm.$options.inject, vm);
		      if (result) {
		          toggleObserving(false);
		          Object.keys(result).forEach(function (key) {
		              /* istanbul ignore else */
		              {
		                  defineReactive(vm, key, result[key], function () {
		                      warn$2("Avoid mutating an injected value directly since the changes will be " +
		                          "overwritten whenever the provided component re-renders. " +
		                          "injection being mutated: \"".concat(key, "\""), vm);
		                  });
		              }
		          });
		          toggleObserving(true);
		      }
		  }
		  function resolveInject(inject, vm) {
		      if (inject) {
		          // inject is :any because flow is not smart enough to figure out cached
		          var result = Object.create(null);
		          var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
		          for (var i = 0; i < keys.length; i++) {
		              var key = keys[i];
		              // #6574 in case the inject object is observed...
		              if (key === '__ob__')
		                  continue;
		              var provideKey = inject[key].from;
		              if (provideKey in vm._provided) {
		                  result[key] = vm._provided[provideKey];
		              }
		              else if ('default' in inject[key]) {
		                  var provideDefault = inject[key].default;
		                  result[key] = isFunction(provideDefault)
		                      ? provideDefault.call(vm)
		                      : provideDefault;
		              }
		              else {
		                  warn$2("Injection \"".concat(key, "\" not found"), vm);
		              }
		          }
		          return result;
		      }
		  }

		  var uid = 0;
		  function initMixin$1(Vue) {
		      Vue.prototype._init = function (options) {
		          var vm = this;
		          // a uid
		          vm._uid = uid++;
		          var startTag, endTag;
		          /* istanbul ignore if */
		          if (config.performance && mark) {
		              startTag = "vue-perf-start:".concat(vm._uid);
		              endTag = "vue-perf-end:".concat(vm._uid);
		              mark(startTag);
		          }
		          // a flag to mark this as a Vue instance without having to do instanceof
		          // check
		          vm._isVue = true;
		          // avoid instances from being observed
		          vm.__v_skip = true;
		          // effect scope
		          vm._scope = new EffectScope(true /* detached */);
		          // merge options
		          if (options && options._isComponent) {
		              // optimize internal component instantiation
		              // since dynamic options merging is pretty slow, and none of the
		              // internal component options needs special treatment.
		              initInternalComponent(vm, options);
		          }
		          else {
		              vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
		          }
		          /* istanbul ignore else */
		          {
		              initProxy(vm);
		          }
		          // expose real self
		          vm._self = vm;
		          initLifecycle(vm);
		          initEvents(vm);
		          initRender(vm);
		          callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
		          initInjections(vm); // resolve injections before data/props
		          initState(vm);
		          initProvide(vm); // resolve provide after data/props
		          callHook$1(vm, 'created');
		          /* istanbul ignore if */
		          if (config.performance && mark) {
		              vm._name = formatComponentName(vm, false);
		              mark(endTag);
		              measure("vue ".concat(vm._name, " init"), startTag, endTag);
		          }
		          if (vm.$options.el) {
		              vm.$mount(vm.$options.el);
		          }
		      };
		  }
		  function initInternalComponent(vm, options) {
		      var opts = (vm.$options = Object.create(vm.constructor.options));
		      // doing this because it's faster than dynamic enumeration.
		      var parentVnode = options._parentVnode;
		      opts.parent = options.parent;
		      opts._parentVnode = parentVnode;
		      var vnodeComponentOptions = parentVnode.componentOptions;
		      opts.propsData = vnodeComponentOptions.propsData;
		      opts._parentListeners = vnodeComponentOptions.listeners;
		      opts._renderChildren = vnodeComponentOptions.children;
		      opts._componentTag = vnodeComponentOptions.tag;
		      if (options.render) {
		          opts.render = options.render;
		          opts.staticRenderFns = options.staticRenderFns;
		      }
		  }
		  function resolveConstructorOptions(Ctor) {
		      var options = Ctor.options;
		      if (Ctor.super) {
		          var superOptions = resolveConstructorOptions(Ctor.super);
		          var cachedSuperOptions = Ctor.superOptions;
		          if (superOptions !== cachedSuperOptions) {
		              // super option changed,
		              // need to resolve new options.
		              Ctor.superOptions = superOptions;
		              // check if there are any late-modified/attached options (#4976)
		              var modifiedOptions = resolveModifiedOptions(Ctor);
		              // update base extend options
		              if (modifiedOptions) {
		                  extend(Ctor.extendOptions, modifiedOptions);
		              }
		              options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
		              if (options.name) {
		                  options.components[options.name] = Ctor;
		              }
		          }
		      }
		      return options;
		  }
		  function resolveModifiedOptions(Ctor) {
		      var modified;
		      var latest = Ctor.options;
		      var sealed = Ctor.sealedOptions;
		      for (var key in latest) {
		          if (latest[key] !== sealed[key]) {
		              if (!modified)
		                  modified = {};
		              modified[key] = latest[key];
		          }
		      }
		      return modified;
		  }

		  function FunctionalRenderContext(data, props, children, parent, Ctor) {
		      var _this = this;
		      var options = Ctor.options;
		      // ensure the createElement function in functional components
		      // gets a unique context - this is necessary for correct named slot check
		      var contextVm;
		      if (hasOwn(parent, '_uid')) {
		          contextVm = Object.create(parent);
		          contextVm._original = parent;
		      }
		      else {
		          // the context vm passed in is a functional context as well.
		          // in this case we want to make sure we are able to get a hold to the
		          // real context instance.
		          contextVm = parent;
		          // @ts-ignore
		          parent = parent._original;
		      }
		      var isCompiled = isTrue(options._compiled);
		      var needNormalization = !isCompiled;
		      this.data = data;
		      this.props = props;
		      this.children = children;
		      this.parent = parent;
		      this.listeners = data.on || emptyObject;
		      this.injections = resolveInject(options.inject, parent);
		      this.slots = function () {
		          if (!_this.$slots) {
		              normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));
		          }
		          return _this.$slots;
		      };
		      Object.defineProperty(this, 'scopedSlots', {
		          enumerable: true,
		          get: function () {
		              return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
		          }
		      });
		      // support for compiled functional template
		      if (isCompiled) {
		          // exposing $options for renderStatic()
		          this.$options = options;
		          // pre-resolve slots for renderSlot()
		          this.$slots = this.slots();
		          this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
		      }
		      if (options._scopeId) {
		          this._c = function (a, b, c, d) {
		              var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
		              if (vnode && !isArray(vnode)) {
		                  vnode.fnScopeId = options._scopeId;
		                  vnode.fnContext = parent;
		              }
		              return vnode;
		          };
		      }
		      else {
		          this._c = function (a, b, c, d) {
		              return createElement$1(contextVm, a, b, c, d, needNormalization);
		          };
		      }
		  }
		  installRenderHelpers(FunctionalRenderContext.prototype);
		  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
		      var options = Ctor.options;
		      var props = {};
		      var propOptions = options.props;
		      if (isDef(propOptions)) {
		          for (var key in propOptions) {
		              props[key] = validateProp(key, propOptions, propsData || emptyObject);
		          }
		      }
		      else {
		          if (isDef(data.attrs))
		              mergeProps(props, data.attrs);
		          if (isDef(data.props))
		              mergeProps(props, data.props);
		      }
		      var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
		      var vnode = options.render.call(null, renderContext._c, renderContext);
		      if (vnode instanceof VNode) {
		          return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
		      }
		      else if (isArray(vnode)) {
		          var vnodes = normalizeChildren(vnode) || [];
		          var res = new Array(vnodes.length);
		          for (var i = 0; i < vnodes.length; i++) {
		              res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
		          }
		          return res;
		      }
		  }
		  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
		      // #7817 clone node before setting fnContext, otherwise if the node is reused
		      // (e.g. it was from a cached normal slot) the fnContext causes named slots
		      // that should not be matched to match.
		      var clone = cloneVNode(vnode);
		      clone.fnContext = contextVm;
		      clone.fnOptions = options;
		      {
		          (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
		              renderContext;
		      }
		      if (data.slot) {
		          (clone.data || (clone.data = {})).slot = data.slot;
		      }
		      return clone;
		  }
		  function mergeProps(to, from) {
		      for (var key in from) {
		          to[camelize(key)] = from[key];
		      }
		  }

		  function getComponentName(options) {
		      return options.name || options.__name || options._componentTag;
		  }
		  // inline hooks to be invoked on component VNodes during patch
		  var componentVNodeHooks = {
		      init: function (vnode, hydrating) {
		          if (vnode.componentInstance &&
		              !vnode.componentInstance._isDestroyed &&
		              vnode.data.keepAlive) {
		              // kept-alive components, treat as a patch
		              var mountedNode = vnode; // work around flow
		              componentVNodeHooks.prepatch(mountedNode, mountedNode);
		          }
		          else {
		              var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
		              child.$mount(hydrating ? vnode.elm : undefined, hydrating);
		          }
		      },
		      prepatch: function (oldVnode, vnode) {
		          var options = vnode.componentOptions;
		          var child = (vnode.componentInstance = oldVnode.componentInstance);
		          updateChildComponent(child, options.propsData, // updated props
		          options.listeners, // updated listeners
		          vnode, // new parent vnode
		          options.children // new children
		          );
		      },
		      insert: function (vnode) {
		          var context = vnode.context, componentInstance = vnode.componentInstance;
		          if (!componentInstance._isMounted) {
		              componentInstance._isMounted = true;
		              callHook$1(componentInstance, 'mounted');
		          }
		          if (vnode.data.keepAlive) {
		              if (context._isMounted) {
		                  // vue-router#1212
		                  // During updates, a kept-alive component's child components may
		                  // change, so directly walking the tree here may call activated hooks
		                  // on incorrect children. Instead we push them into a queue which will
		                  // be processed after the whole patch process ended.
		                  queueActivatedComponent(componentInstance);
		              }
		              else {
		                  activateChildComponent(componentInstance, true /* direct */);
		              }
		          }
		      },
		      destroy: function (vnode) {
		          var componentInstance = vnode.componentInstance;
		          if (!componentInstance._isDestroyed) {
		              if (!vnode.data.keepAlive) {
		                  componentInstance.$destroy();
		              }
		              else {
		                  deactivateChildComponent(componentInstance, true /* direct */);
		              }
		          }
		      }
		  };
		  var hooksToMerge = Object.keys(componentVNodeHooks);
		  function createComponent(Ctor, data, context, children, tag) {
		      if (isUndef(Ctor)) {
		          return;
		      }
		      var baseCtor = context.$options._base;
		      // plain options object: turn it into a constructor
		      if (isObject(Ctor)) {
		          Ctor = baseCtor.extend(Ctor);
		      }
		      // if at this stage it's not a constructor or an async component factory,
		      // reject.
		      if (typeof Ctor !== 'function') {
		          {
		              warn$2("Invalid Component definition: ".concat(String(Ctor)), context);
		          }
		          return;
		      }
		      // async component
		      var asyncFactory;
		      // @ts-expect-error
		      if (isUndef(Ctor.cid)) {
		          asyncFactory = Ctor;
		          Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
		          if (Ctor === undefined) {
		              // return a placeholder node for async component, which is rendered
		              // as a comment node but preserves all the raw information for the node.
		              // the information will be used for async server-rendering and hydration.
		              return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
		          }
		      }
		      data = data || {};
		      // resolve constructor options in case global mixins are applied after
		      // component constructor creation
		      resolveConstructorOptions(Ctor);
		      // transform component v-model data into props & events
		      if (isDef(data.model)) {
		          // @ts-expect-error
		          transformModel(Ctor.options, data);
		      }
		      // extract props
		      // @ts-expect-error
		      var propsData = extractPropsFromVNodeData(data, Ctor, tag);
		      // functional component
		      // @ts-expect-error
		      if (isTrue(Ctor.options.functional)) {
		          return createFunctionalComponent(Ctor, propsData, data, context, children);
		      }
		      // extract listeners, since these needs to be treated as
		      // child component listeners instead of DOM listeners
		      var listeners = data.on;
		      // replace with listeners with .native modifier
		      // so it gets processed during parent component patch.
		      data.on = data.nativeOn;
		      // @ts-expect-error
		      if (isTrue(Ctor.options.abstract)) {
		          // abstract components do not keep anything
		          // other than props & listeners & slot
		          // work around flow
		          var slot = data.slot;
		          data = {};
		          if (slot) {
		              data.slot = slot;
		          }
		      }
		      // install component management hooks onto the placeholder node
		      installComponentHooks(data);
		      // return a placeholder vnode
		      // @ts-expect-error
		      var name = getComponentName(Ctor.options) || tag;
		      var vnode = new VNode(
		      // @ts-expect-error
		      "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ''), data, undefined, undefined, undefined, context, 
		      // @ts-expect-error
		      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
		      return vnode;
		  }
		  function createComponentInstanceForVnode(
		  // we know it's MountedComponentVNode but flow doesn't
		  vnode, 
		  // activeInstance in lifecycle state
		  parent) {
		      var options = {
		          _isComponent: true,
		          _parentVnode: vnode,
		          parent: parent
		      };
		      // check inline-template render functions
		      var inlineTemplate = vnode.data.inlineTemplate;
		      if (isDef(inlineTemplate)) {
		          options.render = inlineTemplate.render;
		          options.staticRenderFns = inlineTemplate.staticRenderFns;
		      }
		      return new vnode.componentOptions.Ctor(options);
		  }
		  function installComponentHooks(data) {
		      var hooks = data.hook || (data.hook = {});
		      for (var i = 0; i < hooksToMerge.length; i++) {
		          var key = hooksToMerge[i];
		          var existing = hooks[key];
		          var toMerge = componentVNodeHooks[key];
		          // @ts-expect-error
		          if (existing !== toMerge && !(existing && existing._merged)) {
		              hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
		          }
		      }
		  }
		  function mergeHook(f1, f2) {
		      var merged = function (a, b) {
		          // flow complains about extra args which is why we use any
		          f1(a, b);
		          f2(a, b);
		      };
		      merged._merged = true;
		      return merged;
		  }
		  // transform component v-model info (value and callback) into
		  // prop and event handler respectively.
		  function transformModel(options, data) {
		      var prop = (options.model && options.model.prop) || 'value';
		      var event = (options.model && options.model.event) || 'input';
		      (data.attrs || (data.attrs = {}))[prop] = data.model.value;
		      var on = data.on || (data.on = {});
		      var existing = on[event];
		      var callback = data.model.callback;
		      if (isDef(existing)) {
		          if (isArray(existing)
		              ? existing.indexOf(callback) === -1
		              : existing !== callback) {
		              on[event] = [callback].concat(existing);
		          }
		      }
		      else {
		          on[event] = callback;
		      }
		  }

		  var warn$2 = noop;
		  var tip = noop;
		  var generateComponentTrace; // work around flow check
		  var formatComponentName;
		  {
		      var hasConsole_1 = typeof console !== 'undefined';
		      var classifyRE_1 = /(?:^|[-_])(\w)/g;
		      var classify_1 = function (str) {
		          return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');
		      };
		      warn$2 = function (msg, vm) {
		          if (vm === void 0) { vm = currentInstance; }
		          var trace = vm ? generateComponentTrace(vm) : '';
		          if (config.warnHandler) {
		              config.warnHandler.call(null, msg, vm, trace);
		          }
		          else if (hasConsole_1 && !config.silent) {
		              console.error("[Vue warn]: ".concat(msg).concat(trace));
		          }
		      };
		      tip = function (msg, vm) {
		          if (hasConsole_1 && !config.silent) {
		              console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ''));
		          }
		      };
		      formatComponentName = function (vm, includeFile) {
		          if (vm.$root === vm) {
		              return '<Root>';
		          }
		          var options = isFunction(vm) && vm.cid != null
		              ? vm.options
		              : vm._isVue
		                  ? vm.$options || vm.constructor.options
		                  : vm;
		          var name = getComponentName(options);
		          var file = options.__file;
		          if (!name && file) {
		              var match = file.match(/([^/\\]+)\.vue$/);
		              name = match && match[1];
		          }
		          return ((name ? "<".concat(classify_1(name), ">") : "<Anonymous>") +
		              (file && includeFile !== false ? " at ".concat(file) : ''));
		      };
		      var repeat_1 = function (str, n) {
		          var res = '';
		          while (n) {
		              if (n % 2 === 1)
		                  res += str;
		              if (n > 1)
		                  str += str;
		              n >>= 1;
		          }
		          return res;
		      };
		      generateComponentTrace = function (vm) {
		          if (vm._isVue && vm.$parent) {
		              var tree = [];
		              var currentRecursiveSequence = 0;
		              while (vm) {
		                  if (tree.length > 0) {
		                      var last = tree[tree.length - 1];
		                      if (last.constructor === vm.constructor) {
		                          currentRecursiveSequence++;
		                          vm = vm.$parent;
		                          continue;
		                      }
		                      else if (currentRecursiveSequence > 0) {
		                          tree[tree.length - 1] = [last, currentRecursiveSequence];
		                          currentRecursiveSequence = 0;
		                      }
		                  }
		                  tree.push(vm);
		                  vm = vm.$parent;
		              }
		              return ('\n\nfound in\n\n' +
		                  tree
		                      .map(function (vm, i) {
		                      return "".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)
		                          ? "".concat(formatComponentName(vm[0]), "... (").concat(vm[1], " recursive calls)")
		                          : formatComponentName(vm));
		                  })
		                      .join('\n'));
		          }
		          else {
		              return "\n\n(found in ".concat(formatComponentName(vm), ")");
		          }
		      };
		  }

		  /**
		   * Option overwriting strategies are functions that handle
		   * how to merge a parent option value and a child option
		   * value into the final value.
		   */
		  var strats = config.optionMergeStrategies;
		  /**
		   * Options with restrictions
		   */
		  {
		      strats.el = strats.propsData = function (parent, child, vm, key) {
		          if (!vm) {
		              warn$2("option \"".concat(key, "\" can only be used during instance ") +
		                  'creation with the `new` keyword.');
		          }
		          return defaultStrat(parent, child);
		      };
		  }
		  /**
		   * Helper that recursively merges two data objects together.
		   */
		  function mergeData(to, from) {
		      if (!from)
		          return to;
		      var key, toVal, fromVal;
		      var keys = hasSymbol
		          ? Reflect.ownKeys(from)
		          : Object.keys(from);
		      for (var i = 0; i < keys.length; i++) {
		          key = keys[i];
		          // in case the object is already observed...
		          if (key === '__ob__')
		              continue;
		          toVal = to[key];
		          fromVal = from[key];
		          if (!hasOwn(to, key)) {
		              set(to, key, fromVal);
		          }
		          else if (toVal !== fromVal &&
		              isPlainObject(toVal) &&
		              isPlainObject(fromVal)) {
		              mergeData(toVal, fromVal);
		          }
		      }
		      return to;
		  }
		  /**
		   * Data
		   */
		  function mergeDataOrFn(parentVal, childVal, vm) {
		      if (!vm) {
		          // in a Vue.extend merge, both should be functions
		          if (!childVal) {
		              return parentVal;
		          }
		          if (!parentVal) {
		              return childVal;
		          }
		          // when parentVal & childVal are both present,
		          // we need to return a function that returns the
		          // merged result of both functions... no need to
		          // check if parentVal is a function here because
		          // it has to be a function to pass previous merges.
		          return function mergedDataFn() {
		              return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
		          };
		      }
		      else {
		          return function mergedInstanceDataFn() {
		              // instance merge
		              var instanceData = isFunction(childVal)
		                  ? childVal.call(vm, vm)
		                  : childVal;
		              var defaultData = isFunction(parentVal)
		                  ? parentVal.call(vm, vm)
		                  : parentVal;
		              if (instanceData) {
		                  return mergeData(instanceData, defaultData);
		              }
		              else {
		                  return defaultData;
		              }
		          };
		      }
		  }
		  strats.data = function (parentVal, childVal, vm) {
		      if (!vm) {
		          if (childVal && typeof childVal !== 'function') {
		              warn$2('The "data" option should be a function ' +
		                      'that returns a per-instance value in component ' +
		                      'definitions.', vm);
		              return parentVal;
		          }
		          return mergeDataOrFn(parentVal, childVal);
		      }
		      return mergeDataOrFn(parentVal, childVal, vm);
		  };
		  /**
		   * Hooks and props are merged as arrays.
		   */
		  function mergeLifecycleHook(parentVal, childVal) {
		      var res = childVal
		          ? parentVal
		              ? parentVal.concat(childVal)
		              : isArray(childVal)
		                  ? childVal
		                  : [childVal]
		          : parentVal;
		      return res ? dedupeHooks(res) : res;
		  }
		  function dedupeHooks(hooks) {
		      var res = [];
		      for (var i = 0; i < hooks.length; i++) {
		          if (res.indexOf(hooks[i]) === -1) {
		              res.push(hooks[i]);
		          }
		      }
		      return res;
		  }
		  LIFECYCLE_HOOKS.forEach(function (hook) {
		      strats[hook] = mergeLifecycleHook;
		  });
		  /**
		   * Assets
		   *
		   * When a vm is present (instance creation), we need to do
		   * a three-way merge between constructor options, instance
		   * options and parent options.
		   */
		  function mergeAssets(parentVal, childVal, vm, key) {
		      var res = Object.create(parentVal || null);
		      if (childVal) {
		          assertObjectType(key, childVal, vm);
		          return extend(res, childVal);
		      }
		      else {
		          return res;
		      }
		  }
		  ASSET_TYPES.forEach(function (type) {
		      strats[type + 's'] = mergeAssets;
		  });
		  /**
		   * Watchers.
		   *
		   * Watchers hashes should not overwrite one
		   * another, so we merge them as arrays.
		   */
		  strats.watch = function (parentVal, childVal, vm, key) {
		      // work around Firefox's Object.prototype.watch...
		      //@ts-expect-error work around
		      if (parentVal === nativeWatch)
		          parentVal = undefined;
		      //@ts-expect-error work around
		      if (childVal === nativeWatch)
		          childVal = undefined;
		      /* istanbul ignore if */
		      if (!childVal)
		          return Object.create(parentVal || null);
		      {
		          assertObjectType(key, childVal, vm);
		      }
		      if (!parentVal)
		          return childVal;
		      var ret = {};
		      extend(ret, parentVal);
		      for (var key_1 in childVal) {
		          var parent_1 = ret[key_1];
		          var child = childVal[key_1];
		          if (parent_1 && !isArray(parent_1)) {
		              parent_1 = [parent_1];
		          }
		          ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
		      }
		      return ret;
		  };
		  /**
		   * Other object hashes.
		   */
		  strats.props =
		      strats.methods =
		          strats.inject =
		              strats.computed =
		                  function (parentVal, childVal, vm, key) {
		                      if (childVal && true) {
		                          assertObjectType(key, childVal, vm);
		                      }
		                      if (!parentVal)
		                          return childVal;
		                      var ret = Object.create(null);
		                      extend(ret, parentVal);
		                      if (childVal)
		                          extend(ret, childVal);
		                      return ret;
		                  };
		  strats.provide = mergeDataOrFn;
		  /**
		   * Default strategy.
		   */
		  var defaultStrat = function (parentVal, childVal) {
		      return childVal === undefined ? parentVal : childVal;
		  };
		  /**
		   * Validate component names
		   */
		  function checkComponents(options) {
		      for (var key in options.components) {
		          validateComponentName(key);
		      }
		  }
		  function validateComponentName(name) {
		      if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
		          warn$2('Invalid component name: "' +
		              name +
		              '". Component names ' +
		              'should conform to valid custom element name in html5 specification.');
		      }
		      if (isBuiltInTag(name) || config.isReservedTag(name)) {
		          warn$2('Do not use built-in or reserved HTML elements as component ' +
		              'id: ' +
		              name);
		      }
		  }
		  /**
		   * Ensure all props option syntax are normalized into the
		   * Object-based format.
		   */
		  function normalizeProps(options, vm) {
		      var props = options.props;
		      if (!props)
		          return;
		      var res = {};
		      var i, val, name;
		      if (isArray(props)) {
		          i = props.length;
		          while (i--) {
		              val = props[i];
		              if (typeof val === 'string') {
		                  name = camelize(val);
		                  res[name] = { type: null };
		              }
		              else {
		                  warn$2('props must be strings when using array syntax.');
		              }
		          }
		      }
		      else if (isPlainObject(props)) {
		          for (var key in props) {
		              val = props[key];
		              name = camelize(key);
		              res[name] = isPlainObject(val) ? val : { type: val };
		          }
		      }
		      else {
		          warn$2("Invalid value for option \"props\": expected an Array or an Object, " +
		              "but got ".concat(toRawType(props), "."), vm);
		      }
		      options.props = res;
		  }
		  /**
		   * Normalize all injections into Object-based format
		   */
		  function normalizeInject(options, vm) {
		      var inject = options.inject;
		      if (!inject)
		          return;
		      var normalized = (options.inject = {});
		      if (isArray(inject)) {
		          for (var i = 0; i < inject.length; i++) {
		              normalized[inject[i]] = { from: inject[i] };
		          }
		      }
		      else if (isPlainObject(inject)) {
		          for (var key in inject) {
		              var val = inject[key];
		              normalized[key] = isPlainObject(val)
		                  ? extend({ from: key }, val)
		                  : { from: val };
		          }
		      }
		      else {
		          warn$2("Invalid value for option \"inject\": expected an Array or an Object, " +
		              "but got ".concat(toRawType(inject), "."), vm);
		      }
		  }
		  /**
		   * Normalize raw function directives into object format.
		   */
		  function normalizeDirectives$1(options) {
		      var dirs = options.directives;
		      if (dirs) {
		          for (var key in dirs) {
		              var def = dirs[key];
		              if (isFunction(def)) {
		                  dirs[key] = { bind: def, update: def };
		              }
		          }
		      }
		  }
		  function assertObjectType(name, value, vm) {
		      if (!isPlainObject(value)) {
		          warn$2("Invalid value for option \"".concat(name, "\": expected an Object, ") +
		              "but got ".concat(toRawType(value), "."), vm);
		      }
		  }
		  /**
		   * Merge two option objects into a new one.
		   * Core utility used in both instantiation and inheritance.
		   */
		  function mergeOptions(parent, child, vm) {
		      {
		          checkComponents(child);
		      }
		      if (isFunction(child)) {
		          // @ts-expect-error
		          child = child.options;
		      }
		      normalizeProps(child, vm);
		      normalizeInject(child, vm);
		      normalizeDirectives$1(child);
		      // Apply extends and mixins on the child options,
		      // but only if it is a raw options object that isn't
		      // the result of another mergeOptions call.
		      // Only merged options has the _base property.
		      if (!child._base) {
		          if (child.extends) {
		              parent = mergeOptions(parent, child.extends, vm);
		          }
		          if (child.mixins) {
		              for (var i = 0, l = child.mixins.length; i < l; i++) {
		                  parent = mergeOptions(parent, child.mixins[i], vm);
		              }
		          }
		      }
		      var options = {};
		      var key;
		      for (key in parent) {
		          mergeField(key);
		      }
		      for (key in child) {
		          if (!hasOwn(parent, key)) {
		              mergeField(key);
		          }
		      }
		      function mergeField(key) {
		          var strat = strats[key] || defaultStrat;
		          options[key] = strat(parent[key], child[key], vm, key);
		      }
		      return options;
		  }
		  /**
		   * Resolve an asset.
		   * This function is used because child instances need access
		   * to assets defined in its ancestor chain.
		   */
		  function resolveAsset(options, type, id, warnMissing) {
		      /* istanbul ignore if */
		      if (typeof id !== 'string') {
		          return;
		      }
		      var assets = options[type];
		      // check local registration variations first
		      if (hasOwn(assets, id))
		          return assets[id];
		      var camelizedId = camelize(id);
		      if (hasOwn(assets, camelizedId))
		          return assets[camelizedId];
		      var PascalCaseId = capitalize(camelizedId);
		      if (hasOwn(assets, PascalCaseId))
		          return assets[PascalCaseId];
		      // fallback to prototype chain
		      var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
		      if (warnMissing && !res) {
		          warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
		      }
		      return res;
		  }

		  function validateProp(key, propOptions, propsData, vm) {
		      var prop = propOptions[key];
		      var absent = !hasOwn(propsData, key);
		      var value = propsData[key];
		      // boolean casting
		      var booleanIndex = getTypeIndex(Boolean, prop.type);
		      if (booleanIndex > -1) {
		          if (absent && !hasOwn(prop, 'default')) {
		              value = false;
		          }
		          else if (value === '' || value === hyphenate(key)) {
		              // only cast empty string / same name to boolean if
		              // boolean has higher priority
		              var stringIndex = getTypeIndex(String, prop.type);
		              if (stringIndex < 0 || booleanIndex < stringIndex) {
		                  value = true;
		              }
		          }
		      }
		      // check default value
		      if (value === undefined) {
		          value = getPropDefaultValue(vm, prop, key);
		          // since the default value is a fresh copy,
		          // make sure to observe it.
		          var prevShouldObserve = shouldObserve;
		          toggleObserving(true);
		          observe(value);
		          toggleObserving(prevShouldObserve);
		      }
		      {
		          assertProp(prop, key, value, vm, absent);
		      }
		      return value;
		  }
		  /**
		   * Get the default value of a prop.
		   */
		  function getPropDefaultValue(vm, prop, key) {
		      // no default, return undefined
		      if (!hasOwn(prop, 'default')) {
		          return undefined;
		      }
		      var def = prop.default;
		      // warn against non-factory defaults for Object & Array
		      if (isObject(def)) {
		          warn$2('Invalid default value for prop "' +
		              key +
		              '": ' +
		              'Props with type Object/Array must use a factory function ' +
		              'to return the default value.', vm);
		      }
		      // the raw prop value was also undefined from previous render,
		      // return previous default value to avoid unnecessary watcher trigger
		      if (vm &&
		          vm.$options.propsData &&
		          vm.$options.propsData[key] === undefined &&
		          vm._props[key] !== undefined) {
		          return vm._props[key];
		      }
		      // call factory function for non-Function types
		      // a value is Function if its prototype is function even across different execution context
		      return isFunction(def) && getType(prop.type) !== 'Function'
		          ? def.call(vm)
		          : def;
		  }
		  /**
		   * Assert whether a prop is valid.
		   */
		  function assertProp(prop, name, value, vm, absent) {
		      if (prop.required && absent) {
		          warn$2('Missing required prop: "' + name + '"', vm);
		          return;
		      }
		      if (value == null && !prop.required) {
		          return;
		      }
		      var type = prop.type;
		      var valid = !type || type === true;
		      var expectedTypes = [];
		      if (type) {
		          if (!isArray(type)) {
		              type = [type];
		          }
		          for (var i = 0; i < type.length && !valid; i++) {
		              var assertedType = assertType(value, type[i], vm);
		              expectedTypes.push(assertedType.expectedType || '');
		              valid = assertedType.valid;
		          }
		      }
		      var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
		      if (!valid && haveExpectedTypes) {
		          warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);
		          return;
		      }
		      var validator = prop.validator;
		      if (validator) {
		          if (!validator(value)) {
		              warn$2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
		          }
		      }
		  }
		  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
		  function assertType(value, type, vm) {
		      var valid;
		      var expectedType = getType(type);
		      if (simpleCheckRE.test(expectedType)) {
		          var t = typeof value;
		          valid = t === expectedType.toLowerCase();
		          // for primitive wrapper objects
		          if (!valid && t === 'object') {
		              valid = value instanceof type;
		          }
		      }
		      else if (expectedType === 'Object') {
		          valid = isPlainObject(value);
		      }
		      else if (expectedType === 'Array') {
		          valid = isArray(value);
		      }
		      else {
		          try {
		              valid = value instanceof type;
		          }
		          catch (e) {
		              warn$2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
		              valid = false;
		          }
		      }
		      return {
		          valid: valid,
		          expectedType: expectedType
		      };
		  }
		  var functionTypeCheckRE = /^\s*function (\w+)/;
		  /**
		   * Use function string name to check built-in types,
		   * because a simple equality check will fail when running
		   * across different vms / iframes.
		   */
		  function getType(fn) {
		      var match = fn && fn.toString().match(functionTypeCheckRE);
		      return match ? match[1] : '';
		  }
		  function isSameType(a, b) {
		      return getType(a) === getType(b);
		  }
		  function getTypeIndex(type, expectedTypes) {
		      if (!isArray(expectedTypes)) {
		          return isSameType(expectedTypes, type) ? 0 : -1;
		      }
		      for (var i = 0, len = expectedTypes.length; i < len; i++) {
		          if (isSameType(expectedTypes[i], type)) {
		              return i;
		          }
		      }
		      return -1;
		  }
		  function getInvalidTypeMessage(name, value, expectedTypes) {
		      var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") +
		          " Expected ".concat(expectedTypes.map(capitalize).join(', '));
		      var expectedType = expectedTypes[0];
		      var receivedType = toRawType(value);
		      // check if we need to specify expected value
		      if (expectedTypes.length === 1 &&
		          isExplicable(expectedType) &&
		          isExplicable(typeof value) &&
		          !isBoolean(expectedType, receivedType)) {
		          message += " with value ".concat(styleValue(value, expectedType));
		      }
		      message += ", got ".concat(receivedType, " ");
		      // check if we need to specify received value
		      if (isExplicable(receivedType)) {
		          message += "with value ".concat(styleValue(value, receivedType), ".");
		      }
		      return message;
		  }
		  function styleValue(value, type) {
		      if (type === 'String') {
		          return "\"".concat(value, "\"");
		      }
		      else if (type === 'Number') {
		          return "".concat(Number(value));
		      }
		      else {
		          return "".concat(value);
		      }
		  }
		  var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
		  function isExplicable(value) {
		      return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });
		  }
		  function isBoolean() {
		      var args = [];
		      for (var _i = 0; _i < arguments.length; _i++) {
		          args[_i] = arguments[_i];
		      }
		      return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });
		  }

		  function Vue(options) {
		      if (!(this instanceof Vue)) {
		          warn$2('Vue is a constructor and should be called with the `new` keyword');
		      }
		      this._init(options);
		  }
		  //@ts-expect-error Vue has function type
		  initMixin$1(Vue);
		  //@ts-expect-error Vue has function type
		  stateMixin(Vue);
		  //@ts-expect-error Vue has function type
		  eventsMixin(Vue);
		  //@ts-expect-error Vue has function type
		  lifecycleMixin(Vue);
		  //@ts-expect-error Vue has function type
		  renderMixin(Vue);

		  function initUse(Vue) {
		      Vue.use = function (plugin) {
		          var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
		          if (installedPlugins.indexOf(plugin) > -1) {
		              return this;
		          }
		          // additional parameters
		          var args = toArray(arguments, 1);
		          args.unshift(this);
		          if (isFunction(plugin.install)) {
		              plugin.install.apply(plugin, args);
		          }
		          else if (isFunction(plugin)) {
		              plugin.apply(null, args);
		          }
		          installedPlugins.push(plugin);
		          return this;
		      };
		  }

		  function initMixin(Vue) {
		      Vue.mixin = function (mixin) {
		          this.options = mergeOptions(this.options, mixin);
		          return this;
		      };
		  }

		  function initExtend(Vue) {
		      /**
		       * Each instance constructor, including Vue, has a unique
		       * cid. This enables us to create wrapped "child
		       * constructors" for prototypal inheritance and cache them.
		       */
		      Vue.cid = 0;
		      var cid = 1;
		      /**
		       * Class inheritance
		       */
		      Vue.extend = function (extendOptions) {
		          extendOptions = extendOptions || {};
		          var Super = this;
		          var SuperId = Super.cid;
		          var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
		          if (cachedCtors[SuperId]) {
		              return cachedCtors[SuperId];
		          }
		          var name = getComponentName(extendOptions) || getComponentName(Super.options);
		          if (name) {
		              validateComponentName(name);
		          }
		          var Sub = function VueComponent(options) {
		              this._init(options);
		          };
		          Sub.prototype = Object.create(Super.prototype);
		          Sub.prototype.constructor = Sub;
		          Sub.cid = cid++;
		          Sub.options = mergeOptions(Super.options, extendOptions);
		          Sub['super'] = Super;
		          // For props and computed properties, we define the proxy getters on
		          // the Vue instances at extension time, on the extended prototype. This
		          // avoids Object.defineProperty calls for each instance created.
		          if (Sub.options.props) {
		              initProps(Sub);
		          }
		          if (Sub.options.computed) {
		              initComputed(Sub);
		          }
		          // allow further extension/mixin/plugin usage
		          Sub.extend = Super.extend;
		          Sub.mixin = Super.mixin;
		          Sub.use = Super.use;
		          // create asset registers, so extended classes
		          // can have their private assets too.
		          ASSET_TYPES.forEach(function (type) {
		              Sub[type] = Super[type];
		          });
		          // enable recursive self-lookup
		          if (name) {
		              Sub.options.components[name] = Sub;
		          }
		          // keep a reference to the super options at extension time.
		          // later at instantiation we can check if Super's options have
		          // been updated.
		          Sub.superOptions = Super.options;
		          Sub.extendOptions = extendOptions;
		          Sub.sealedOptions = extend({}, Sub.options);
		          // cache constructor
		          cachedCtors[SuperId] = Sub;
		          return Sub;
		      };
		  }
		  function initProps(Comp) {
		      var props = Comp.options.props;
		      for (var key in props) {
		          proxy(Comp.prototype, "_props", key);
		      }
		  }
		  function initComputed(Comp) {
		      var computed = Comp.options.computed;
		      for (var key in computed) {
		          defineComputed(Comp.prototype, key, computed[key]);
		      }
		  }

		  function initAssetRegisters(Vue) {
		      /**
		       * Create asset registration methods.
		       */
		      ASSET_TYPES.forEach(function (type) {
		          // @ts-expect-error function is not exact same type
		          Vue[type] = function (id, definition) {
		              if (!definition) {
		                  return this.options[type + 's'][id];
		              }
		              else {
		                  /* istanbul ignore if */
		                  if (type === 'component') {
		                      validateComponentName(id);
		                  }
		                  if (type === 'component' && isPlainObject(definition)) {
		                      // @ts-expect-error
		                      definition.name = definition.name || id;
		                      definition = this.options._base.extend(definition);
		                  }
		                  if (type === 'directive' && isFunction(definition)) {
		                      definition = { bind: definition, update: definition };
		                  }
		                  this.options[type + 's'][id] = definition;
		                  return definition;
		              }
		          };
		      });
		  }

		  function _getComponentName(opts) {
		      return opts && (getComponentName(opts.Ctor.options) || opts.tag);
		  }
		  function matches(pattern, name) {
		      if (isArray(pattern)) {
		          return pattern.indexOf(name) > -1;
		      }
		      else if (typeof pattern === 'string') {
		          return pattern.split(',').indexOf(name) > -1;
		      }
		      else if (isRegExp(pattern)) {
		          return pattern.test(name);
		      }
		      /* istanbul ignore next */
		      return false;
		  }
		  function pruneCache(keepAliveInstance, filter) {
		      var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
		      for (var key in cache) {
		          var entry = cache[key];
		          if (entry) {
		              var name_1 = entry.name;
		              if (name_1 && !filter(name_1)) {
		                  pruneCacheEntry(cache, key, keys, _vnode);
		              }
		          }
		      }
		  }
		  function pruneCacheEntry(cache, key, keys, current) {
		      var entry = cache[key];
		      if (entry && (!current || entry.tag !== current.tag)) {
		          // @ts-expect-error can be undefined
		          entry.componentInstance.$destroy();
		      }
		      cache[key] = null;
		      remove$2(keys, key);
		  }
		  var patternTypes = [String, RegExp, Array];
		  // TODO defineComponent
		  var KeepAlive = {
		      name: 'keep-alive',
		      abstract: true,
		      props: {
		          include: patternTypes,
		          exclude: patternTypes,
		          max: [String, Number]
		      },
		      methods: {
		          cacheVNode: function () {
		              var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
		              if (vnodeToCache) {
		                  var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
		                  cache[keyToCache] = {
		                      name: _getComponentName(componentOptions),
		                      tag: tag,
		                      componentInstance: componentInstance
		                  };
		                  keys.push(keyToCache);
		                  // prune oldest entry
		                  if (this.max && keys.length > parseInt(this.max)) {
		                      pruneCacheEntry(cache, keys[0], keys, this._vnode);
		                  }
		                  this.vnodeToCache = null;
		              }
		          }
		      },
		      created: function () {
		          this.cache = Object.create(null);
		          this.keys = [];
		      },
		      destroyed: function () {
		          for (var key in this.cache) {
		              pruneCacheEntry(this.cache, key, this.keys);
		          }
		      },
		      mounted: function () {
		          var _this = this;
		          this.cacheVNode();
		          this.$watch('include', function (val) {
		              pruneCache(_this, function (name) { return matches(val, name); });
		          });
		          this.$watch('exclude', function (val) {
		              pruneCache(_this, function (name) { return !matches(val, name); });
		          });
		      },
		      updated: function () {
		          this.cacheVNode();
		      },
		      render: function () {
		          var slot = this.$slots.default;
		          var vnode = getFirstComponentChild(slot);
		          var componentOptions = vnode && vnode.componentOptions;
		          if (componentOptions) {
		              // check pattern
		              var name_2 = _getComponentName(componentOptions);
		              var _a = this, include = _a.include, exclude = _a.exclude;
		              if (
		              // not included
		              (include && (!name_2 || !matches(include, name_2))) ||
		                  // excluded
		                  (exclude && name_2 && matches(exclude, name_2))) {
		                  return vnode;
		              }
		              var _b = this, cache = _b.cache, keys = _b.keys;
		              var key = vnode.key == null
		                  ? // same constructor may get registered as different local components
		                      // so cid alone is not enough (#3269)
		                      componentOptions.Ctor.cid +
		                          (componentOptions.tag ? "::".concat(componentOptions.tag) : '')
		                  : vnode.key;
		              if (cache[key]) {
		                  vnode.componentInstance = cache[key].componentInstance;
		                  // make current key freshest
		                  remove$2(keys, key);
		                  keys.push(key);
		              }
		              else {
		                  // delay setting the cache until update
		                  this.vnodeToCache = vnode;
		                  this.keyToCache = key;
		              }
		              // @ts-expect-error can vnode.data can be undefined
		              vnode.data.keepAlive = true;
		          }
		          return vnode || (slot && slot[0]);
		      }
		  };

		  var builtInComponents = {
		      KeepAlive: KeepAlive
		  };

		  function initGlobalAPI(Vue) {
		      // config
		      var configDef = {};
		      configDef.get = function () { return config; };
		      {
		          configDef.set = function () {
		              warn$2('Do not replace the Vue.config object, set individual fields instead.');
		          };
		      }
		      Object.defineProperty(Vue, 'config', configDef);
		      // exposed util methods.
		      // NOTE: these are not considered part of the public API - avoid relying on
		      // them unless you are aware of the risk.
		      Vue.util = {
		          warn: warn$2,
		          extend: extend,
		          mergeOptions: mergeOptions,
		          defineReactive: defineReactive
		      };
		      Vue.set = set;
		      Vue.delete = del;
		      Vue.nextTick = nextTick;
		      // 2.6 explicit observable API
		      Vue.observable = function (obj) {
		          observe(obj);
		          return obj;
		      };
		      Vue.options = Object.create(null);
		      ASSET_TYPES.forEach(function (type) {
		          Vue.options[type + 's'] = Object.create(null);
		      });
		      // this is used to identify the "base" constructor to extend all plain-object
		      // components with in Weex's multi-instance scenarios.
		      Vue.options._base = Vue;
		      extend(Vue.options.components, builtInComponents);
		      initUse(Vue);
		      initMixin(Vue);
		      initExtend(Vue);
		      initAssetRegisters(Vue);
		  }

		  initGlobalAPI(Vue);
		  Object.defineProperty(Vue.prototype, '$isServer', {
		      get: isServerRendering
		  });
		  Object.defineProperty(Vue.prototype, '$ssrContext', {
		      get: function () {
		          /* istanbul ignore next */
		          return this.$vnode && this.$vnode.ssrContext;
		      }
		  });
		  // expose FunctionalRenderContext for ssr runtime helper installation
		  Object.defineProperty(Vue, 'FunctionalRenderContext', {
		      value: FunctionalRenderContext
		  });
		  Vue.version = version;

		  // these are reserved for web because they are directly compiled away
		  // during template compilation
		  var isReservedAttr = makeMap('style,class');
		  // attributes that should be using props for binding
		  var acceptValue = makeMap('input,textarea,option,select,progress');
		  var mustUseProp = function (tag, type, attr) {
		      return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
		          (attr === 'selected' && tag === 'option') ||
		          (attr === 'checked' && tag === 'input') ||
		          (attr === 'muted' && tag === 'video'));
		  };
		  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
		  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
		  var convertEnumeratedValue = function (key, value) {
		      return isFalsyAttrValue(value) || value === 'false'
		          ? 'false'
		          : // allow arbitrary string value for contenteditable
		              key === 'contenteditable' && isValidContentEditableValue(value)
		                  ? value
		                  : 'true';
		  };
		  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
		      'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
		      'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
		      'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
		      'required,reversed,scoped,seamless,selected,sortable,' +
		      'truespeed,typemustmatch,visible');
		  var xlinkNS = 'http://www.w3.org/1999/xlink';
		  var isXlink = function (name) {
		      return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
		  };
		  var getXlinkProp = function (name) {
		      return isXlink(name) ? name.slice(6, name.length) : '';
		  };
		  var isFalsyAttrValue = function (val) {
		      return val == null || val === false;
		  };

		  function genClassForVnode(vnode) {
		      var data = vnode.data;
		      var parentNode = vnode;
		      var childNode = vnode;
		      while (isDef(childNode.componentInstance)) {
		          childNode = childNode.componentInstance._vnode;
		          if (childNode && childNode.data) {
		              data = mergeClassData(childNode.data, data);
		          }
		      }
		      // @ts-expect-error parentNode.parent not VNodeWithData
		      while (isDef((parentNode = parentNode.parent))) {
		          if (parentNode && parentNode.data) {
		              data = mergeClassData(data, parentNode.data);
		          }
		      }
		      return renderClass(data.staticClass, data.class);
		  }
		  function mergeClassData(child, parent) {
		      return {
		          staticClass: concat(child.staticClass, parent.staticClass),
		          class: isDef(child.class) ? [child.class, parent.class] : parent.class
		      };
		  }
		  function renderClass(staticClass, dynamicClass) {
		      if (isDef(staticClass) || isDef(dynamicClass)) {
		          return concat(staticClass, stringifyClass(dynamicClass));
		      }
		      /* istanbul ignore next */
		      return '';
		  }
		  function concat(a, b) {
		      return a ? (b ? a + ' ' + b : a) : b || '';
		  }
		  function stringifyClass(value) {
		      if (Array.isArray(value)) {
		          return stringifyArray(value);
		      }
		      if (isObject(value)) {
		          return stringifyObject(value);
		      }
		      if (typeof value === 'string') {
		          return value;
		      }
		      /* istanbul ignore next */
		      return '';
		  }
		  function stringifyArray(value) {
		      var res = '';
		      var stringified;
		      for (var i = 0, l = value.length; i < l; i++) {
		          if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
		              if (res)
		                  res += ' ';
		              res += stringified;
		          }
		      }
		      return res;
		  }
		  function stringifyObject(value) {
		      var res = '';
		      for (var key in value) {
		          if (value[key]) {
		              if (res)
		                  res += ' ';
		              res += key;
		          }
		      }
		      return res;
		  }

		  var namespaceMap = {
		      svg: 'http://www.w3.org/2000/svg',
		      math: 'http://www.w3.org/1998/Math/MathML'
		  };
		  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
		      'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
		      'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
		      'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
		      's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
		      'embed,object,param,source,canvas,script,noscript,del,ins,' +
		      'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
		      'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
		      'output,progress,select,textarea,' +
		      'details,dialog,menu,menuitem,summary,' +
		      'content,element,shadow,template,blockquote,iframe,tfoot');
		  // this map is intentionally selective, only covering SVG elements that may
		  // contain child elements.
		  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
		      'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
		      'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
		  var isPreTag = function (tag) { return tag === 'pre'; };
		  var isReservedTag = function (tag) {
		      return isHTMLTag(tag) || isSVG(tag);
		  };
		  function getTagNamespace(tag) {
		      if (isSVG(tag)) {
		          return 'svg';
		      }
		      // basic support for MathML
		      // note it doesn't support other MathML elements being component roots
		      if (tag === 'math') {
		          return 'math';
		      }
		  }
		  var unknownElementCache = Object.create(null);
		  function isUnknownElement(tag) {
		      /* istanbul ignore if */
		      if (!inBrowser) {
		          return true;
		      }
		      if (isReservedTag(tag)) {
		          return false;
		      }
		      tag = tag.toLowerCase();
		      /* istanbul ignore if */
		      if (unknownElementCache[tag] != null) {
		          return unknownElementCache[tag];
		      }
		      var el = document.createElement(tag);
		      if (tag.indexOf('-') > -1) {
		          // http://stackoverflow.com/a/28210364/1070244
		          return (unknownElementCache[tag] =
		              el.constructor === window.HTMLUnknownElement ||
		                  el.constructor === window.HTMLElement);
		      }
		      else {
		          return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
		      }
		  }
		  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

		  /**
		   * Query an element selector if it's not an element already.
		   */
		  function query(el) {
		      if (typeof el === 'string') {
		          var selected = document.querySelector(el);
		          if (!selected) {
		              warn$2('Cannot find element: ' + el);
		              return document.createElement('div');
		          }
		          return selected;
		      }
		      else {
		          return el;
		      }
		  }

		  function createElement(tagName, vnode) {
		      var elm = document.createElement(tagName);
		      if (tagName !== 'select') {
		          return elm;
		      }
		      // false or null will remove the attribute but undefined will not
		      if (vnode.data &&
		          vnode.data.attrs &&
		          vnode.data.attrs.multiple !== undefined) {
		          elm.setAttribute('multiple', 'multiple');
		      }
		      return elm;
		  }
		  function createElementNS(namespace, tagName) {
		      return document.createElementNS(namespaceMap[namespace], tagName);
		  }
		  function createTextNode(text) {
		      return document.createTextNode(text);
		  }
		  function createComment(text) {
		      return document.createComment(text);
		  }
		  function insertBefore(parentNode, newNode, referenceNode) {
		      parentNode.insertBefore(newNode, referenceNode);
		  }
		  function removeChild(node, child) {
		      node.removeChild(child);
		  }
		  function appendChild(node, child) {
		      node.appendChild(child);
		  }
		  function parentNode(node) {
		      return node.parentNode;
		  }
		  function nextSibling(node) {
		      return node.nextSibling;
		  }
		  function tagName(node) {
		      return node.tagName;
		  }
		  function setTextContent(node, text) {
		      node.textContent = text;
		  }
		  function setStyleScope(node, scopeId) {
		      node.setAttribute(scopeId, '');
		  }

		  var nodeOps = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    createElement: createElement,
		    createElementNS: createElementNS,
		    createTextNode: createTextNode,
		    createComment: createComment,
		    insertBefore: insertBefore,
		    removeChild: removeChild,
		    appendChild: appendChild,
		    parentNode: parentNode,
		    nextSibling: nextSibling,
		    tagName: tagName,
		    setTextContent: setTextContent,
		    setStyleScope: setStyleScope
		  });

		  var ref = {
		      create: function (_, vnode) {
		          registerRef(vnode);
		      },
		      update: function (oldVnode, vnode) {
		          if (oldVnode.data.ref !== vnode.data.ref) {
		              registerRef(oldVnode, true);
		              registerRef(vnode);
		          }
		      },
		      destroy: function (vnode) {
		          registerRef(vnode, true);
		      }
		  };
		  function registerRef(vnode, isRemoval) {
		      var ref = vnode.data.ref;
		      if (!isDef(ref))
		          return;
		      var vm = vnode.context;
		      var refValue = vnode.componentInstance || vnode.elm;
		      var value = isRemoval ? null : refValue;
		      var $refsValue = isRemoval ? undefined : refValue;
		      if (isFunction(ref)) {
		          invokeWithErrorHandling(ref, vm, [value], vm, "template ref function");
		          return;
		      }
		      var isFor = vnode.data.refInFor;
		      var _isString = typeof ref === 'string' || typeof ref === 'number';
		      var _isRef = isRef(ref);
		      var refs = vm.$refs;
		      if (_isString || _isRef) {
		          if (isFor) {
		              var existing = _isString ? refs[ref] : ref.value;
		              if (isRemoval) {
		                  isArray(existing) && remove$2(existing, refValue);
		              }
		              else {
		                  if (!isArray(existing)) {
		                      if (_isString) {
		                          refs[ref] = [refValue];
		                          setSetupRef(vm, ref, refs[ref]);
		                      }
		                      else {
		                          ref.value = [refValue];
		                      }
		                  }
		                  else if (!existing.includes(refValue)) {
		                      existing.push(refValue);
		                  }
		              }
		          }
		          else if (_isString) {
		              if (isRemoval && refs[ref] !== refValue) {
		                  return;
		              }
		              refs[ref] = $refsValue;
		              setSetupRef(vm, ref, value);
		          }
		          else if (_isRef) {
		              if (isRemoval && ref.value !== refValue) {
		                  return;
		              }
		              ref.value = value;
		          }
		          else {
		              warn$2("Invalid template ref type: ".concat(typeof ref));
		          }
		      }
		  }
		  function setSetupRef(_a, key, val) {
		      var _setupState = _a._setupState;
		      if (_setupState && hasOwn(_setupState, key)) {
		          if (isRef(_setupState[key])) {
		              _setupState[key].value = val;
		          }
		          else {
		              _setupState[key] = val;
		          }
		      }
		  }

		  /**
		   * Virtual DOM patching algorithm based on Snabbdom by
		   * Simon Friis Vindum (@paldepind)
		   * Licensed under the MIT License
		   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
		   *
		   * modified by Evan You (@yyx990803)
		   *
		   * Not type-checking this because this file is perf-critical and the cost
		   * of making flow understand it is not worth it.
		   */
		  var emptyNode = new VNode('', {}, []);
		  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
		  function sameVnode(a, b) {
		      return (a.key === b.key &&
		          a.asyncFactory === b.asyncFactory &&
		          ((a.tag === b.tag &&
		              a.isComment === b.isComment &&
		              isDef(a.data) === isDef(b.data) &&
		              sameInputType(a, b)) ||
		              (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
		  }
		  function sameInputType(a, b) {
		      if (a.tag !== 'input')
		          return true;
		      var i;
		      var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
		      var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
		      return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
		  }
		  function createKeyToOldIdx(children, beginIdx, endIdx) {
		      var i, key;
		      var map = {};
		      for (i = beginIdx; i <= endIdx; ++i) {
		          key = children[i].key;
		          if (isDef(key))
		              map[key] = i;
		      }
		      return map;
		  }
		  function createPatchFunction(backend) {
		      var i, j;
		      var cbs = {};
		      var modules = backend.modules, nodeOps = backend.nodeOps;
		      for (i = 0; i < hooks.length; ++i) {
		          cbs[hooks[i]] = [];
		          for (j = 0; j < modules.length; ++j) {
		              if (isDef(modules[j][hooks[i]])) {
		                  cbs[hooks[i]].push(modules[j][hooks[i]]);
		              }
		          }
		      }
		      function emptyNodeAt(elm) {
		          return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
		      }
		      function createRmCb(childElm, listeners) {
		          function remove() {
		              if (--remove.listeners === 0) {
		                  removeNode(childElm);
		              }
		          }
		          remove.listeners = listeners;
		          return remove;
		      }
		      function removeNode(el) {
		          var parent = nodeOps.parentNode(el);
		          // element may have already been removed due to v-html / v-text
		          if (isDef(parent)) {
		              nodeOps.removeChild(parent, el);
		          }
		      }
		      function isUnknownElement(vnode, inVPre) {
		          return (!inVPre &&
		              !vnode.ns &&
		              !(config.ignoredElements.length &&
		                  config.ignoredElements.some(function (ignore) {
		                      return isRegExp(ignore)
		                          ? ignore.test(vnode.tag)
		                          : ignore === vnode.tag;
		                  })) &&
		              config.isUnknownElement(vnode.tag));
		      }
		      var creatingElmInVPre = 0;
		      function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
		          if (isDef(vnode.elm) && isDef(ownerArray)) {
		              // This vnode was used in a previous render!
		              // now it's used as a new node, overwriting its elm would cause
		              // potential patch errors down the road when it's used as an insertion
		              // reference node. Instead, we clone the node on-demand before creating
		              // associated DOM element for it.
		              vnode = ownerArray[index] = cloneVNode(vnode);
		          }
		          vnode.isRootInsert = !nested; // for transition enter check
		          if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
		              return;
		          }
		          var data = vnode.data;
		          var children = vnode.children;
		          var tag = vnode.tag;
		          if (isDef(tag)) {
		              {
		                  if (data && data.pre) {
		                      creatingElmInVPre++;
		                  }
		                  if (isUnknownElement(vnode, creatingElmInVPre)) {
		                      warn$2('Unknown custom element: <' +
		                          tag +
		                          '> - did you ' +
		                          'register the component correctly? For recursive components, ' +
		                          'make sure to provide the "name" option.', vnode.context);
		                  }
		              }
		              vnode.elm = vnode.ns
		                  ? nodeOps.createElementNS(vnode.ns, tag)
		                  : nodeOps.createElement(tag, vnode);
		              setScope(vnode);
		              createChildren(vnode, children, insertedVnodeQueue);
		              if (isDef(data)) {
		                  invokeCreateHooks(vnode, insertedVnodeQueue);
		              }
		              insert(parentElm, vnode.elm, refElm);
		              if (data && data.pre) {
		                  creatingElmInVPre--;
		              }
		          }
		          else if (isTrue(vnode.isComment)) {
		              vnode.elm = nodeOps.createComment(vnode.text);
		              insert(parentElm, vnode.elm, refElm);
		          }
		          else {
		              vnode.elm = nodeOps.createTextNode(vnode.text);
		              insert(parentElm, vnode.elm, refElm);
		          }
		      }
		      function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
		          var i = vnode.data;
		          if (isDef(i)) {
		              var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
		              if (isDef((i = i.hook)) && isDef((i = i.init))) {
		                  i(vnode, false /* hydrating */);
		              }
		              // after calling the init hook, if the vnode is a child component
		              // it should've created a child instance and mounted it. the child
		              // component also has set the placeholder vnode's elm.
		              // in that case we can just return the element and be done.
		              if (isDef(vnode.componentInstance)) {
		                  initComponent(vnode, insertedVnodeQueue);
		                  insert(parentElm, vnode.elm, refElm);
		                  if (isTrue(isReactivated)) {
		                      reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
		                  }
		                  return true;
		              }
		          }
		      }
		      function initComponent(vnode, insertedVnodeQueue) {
		          if (isDef(vnode.data.pendingInsert)) {
		              insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
		              vnode.data.pendingInsert = null;
		          }
		          vnode.elm = vnode.componentInstance.$el;
		          if (isPatchable(vnode)) {
		              invokeCreateHooks(vnode, insertedVnodeQueue);
		              setScope(vnode);
		          }
		          else {
		              // empty component root.
		              // skip all element-related modules except for ref (#3455)
		              registerRef(vnode);
		              // make sure to invoke the insert hook
		              insertedVnodeQueue.push(vnode);
		          }
		      }
		      function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
		          var i;
		          // hack for #4339: a reactivated component with inner transition
		          // does not trigger because the inner node's created hooks are not called
		          // again. It's not ideal to involve module-specific logic in here but
		          // there doesn't seem to be a better way to do it.
		          var innerNode = vnode;
		          while (innerNode.componentInstance) {
		              innerNode = innerNode.componentInstance._vnode;
		              if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
		                  for (i = 0; i < cbs.activate.length; ++i) {
		                      cbs.activate[i](emptyNode, innerNode);
		                  }
		                  insertedVnodeQueue.push(innerNode);
		                  break;
		              }
		          }
		          // unlike a newly created component,
		          // a reactivated keep-alive component doesn't insert itself
		          insert(parentElm, vnode.elm, refElm);
		      }
		      function insert(parent, elm, ref) {
		          if (isDef(parent)) {
		              if (isDef(ref)) {
		                  if (nodeOps.parentNode(ref) === parent) {
		                      nodeOps.insertBefore(parent, elm, ref);
		                  }
		              }
		              else {
		                  nodeOps.appendChild(parent, elm);
		              }
		          }
		      }
		      function createChildren(vnode, children, insertedVnodeQueue) {
		          if (isArray(children)) {
		              {
		                  checkDuplicateKeys(children);
		              }
		              for (var i_1 = 0; i_1 < children.length; ++i_1) {
		                  createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
		              }
		          }
		          else if (isPrimitive(vnode.text)) {
		              nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
		          }
		      }
		      function isPatchable(vnode) {
		          while (vnode.componentInstance) {
		              vnode = vnode.componentInstance._vnode;
		          }
		          return isDef(vnode.tag);
		      }
		      function invokeCreateHooks(vnode, insertedVnodeQueue) {
		          for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
		              cbs.create[i_2](emptyNode, vnode);
		          }
		          i = vnode.data.hook; // Reuse variable
		          if (isDef(i)) {
		              if (isDef(i.create))
		                  i.create(emptyNode, vnode);
		              if (isDef(i.insert))
		                  insertedVnodeQueue.push(vnode);
		          }
		      }
		      // set scope id attribute for scoped CSS.
		      // this is implemented as a special case to avoid the overhead
		      // of going through the normal attribute patching process.
		      function setScope(vnode) {
		          var i;
		          if (isDef((i = vnode.fnScopeId))) {
		              nodeOps.setStyleScope(vnode.elm, i);
		          }
		          else {
		              var ancestor = vnode;
		              while (ancestor) {
		                  if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
		                      nodeOps.setStyleScope(vnode.elm, i);
		                  }
		                  ancestor = ancestor.parent;
		              }
		          }
		          // for slot content they should also get the scopeId from the host instance.
		          if (isDef((i = activeInstance)) &&
		              i !== vnode.context &&
		              i !== vnode.fnContext &&
		              isDef((i = i.$options._scopeId))) {
		              nodeOps.setStyleScope(vnode.elm, i);
		          }
		      }
		      function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
		          for (; startIdx <= endIdx; ++startIdx) {
		              createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
		          }
		      }
		      function invokeDestroyHook(vnode) {
		          var i, j;
		          var data = vnode.data;
		          if (isDef(data)) {
		              if (isDef((i = data.hook)) && isDef((i = i.destroy)))
		                  i(vnode);
		              for (i = 0; i < cbs.destroy.length; ++i)
		                  cbs.destroy[i](vnode);
		          }
		          if (isDef((i = vnode.children))) {
		              for (j = 0; j < vnode.children.length; ++j) {
		                  invokeDestroyHook(vnode.children[j]);
		              }
		          }
		      }
		      function removeVnodes(vnodes, startIdx, endIdx) {
		          for (; startIdx <= endIdx; ++startIdx) {
		              var ch = vnodes[startIdx];
		              if (isDef(ch)) {
		                  if (isDef(ch.tag)) {
		                      removeAndInvokeRemoveHook(ch);
		                      invokeDestroyHook(ch);
		                  }
		                  else {
		                      // Text node
		                      removeNode(ch.elm);
		                  }
		              }
		          }
		      }
		      function removeAndInvokeRemoveHook(vnode, rm) {
		          if (isDef(rm) || isDef(vnode.data)) {
		              var i_3;
		              var listeners = cbs.remove.length + 1;
		              if (isDef(rm)) {
		                  // we have a recursively passed down rm callback
		                  // increase the listeners count
		                  rm.listeners += listeners;
		              }
		              else {
		                  // directly removing
		                  rm = createRmCb(vnode.elm, listeners);
		              }
		              // recursively invoke hooks on child component root node
		              if (isDef((i_3 = vnode.componentInstance)) &&
		                  isDef((i_3 = i_3._vnode)) &&
		                  isDef(i_3.data)) {
		                  removeAndInvokeRemoveHook(i_3, rm);
		              }
		              for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
		                  cbs.remove[i_3](vnode, rm);
		              }
		              if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
		                  i_3(vnode, rm);
		              }
		              else {
		                  rm();
		              }
		          }
		          else {
		              removeNode(vnode.elm);
		          }
		      }
		      function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
		          var oldStartIdx = 0;
		          var newStartIdx = 0;
		          var oldEndIdx = oldCh.length - 1;
		          var oldStartVnode = oldCh[0];
		          var oldEndVnode = oldCh[oldEndIdx];
		          var newEndIdx = newCh.length - 1;
		          var newStartVnode = newCh[0];
		          var newEndVnode = newCh[newEndIdx];
		          var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
		          // removeOnly is a special flag used only by <transition-group>
		          // to ensure removed elements stay in correct relative positions
		          // during leaving transitions
		          var canMove = !removeOnly;
		          {
		              checkDuplicateKeys(newCh);
		          }
		          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		              if (isUndef(oldStartVnode)) {
		                  oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
		              }
		              else if (isUndef(oldEndVnode)) {
		                  oldEndVnode = oldCh[--oldEndIdx];
		              }
		              else if (sameVnode(oldStartVnode, newStartVnode)) {
		                  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
		                  oldStartVnode = oldCh[++oldStartIdx];
		                  newStartVnode = newCh[++newStartIdx];
		              }
		              else if (sameVnode(oldEndVnode, newEndVnode)) {
		                  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
		                  oldEndVnode = oldCh[--oldEndIdx];
		                  newEndVnode = newCh[--newEndIdx];
		              }
		              else if (sameVnode(oldStartVnode, newEndVnode)) {
		                  // Vnode moved right
		                  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
		                  canMove &&
		                      nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
		                  oldStartVnode = oldCh[++oldStartIdx];
		                  newEndVnode = newCh[--newEndIdx];
		              }
		              else if (sameVnode(oldEndVnode, newStartVnode)) {
		                  // Vnode moved left
		                  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
		                  canMove &&
		                      nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
		                  oldEndVnode = oldCh[--oldEndIdx];
		                  newStartVnode = newCh[++newStartIdx];
		              }
		              else {
		                  if (isUndef(oldKeyToIdx))
		                      oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
		                  idxInOld = isDef(newStartVnode.key)
		                      ? oldKeyToIdx[newStartVnode.key]
		                      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
		                  if (isUndef(idxInOld)) {
		                      // New element
		                      createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
		                  }
		                  else {
		                      vnodeToMove = oldCh[idxInOld];
		                      if (sameVnode(vnodeToMove, newStartVnode)) {
		                          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
		                          oldCh[idxInOld] = undefined;
		                          canMove &&
		                              nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
		                      }
		                      else {
		                          // same key but different element. treat as new element
		                          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
		                      }
		                  }
		                  newStartVnode = newCh[++newStartIdx];
		              }
		          }
		          if (oldStartIdx > oldEndIdx) {
		              refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
		              addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
		          }
		          else if (newStartIdx > newEndIdx) {
		              removeVnodes(oldCh, oldStartIdx, oldEndIdx);
		          }
		      }
		      function checkDuplicateKeys(children) {
		          var seenKeys = {};
		          for (var i_4 = 0; i_4 < children.length; i_4++) {
		              var vnode = children[i_4];
		              var key = vnode.key;
		              if (isDef(key)) {
		                  if (seenKeys[key]) {
		                      warn$2("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
		                  }
		                  else {
		                      seenKeys[key] = true;
		                  }
		              }
		          }
		      }
		      function findIdxInOld(node, oldCh, start, end) {
		          for (var i_5 = start; i_5 < end; i_5++) {
		              var c = oldCh[i_5];
		              if (isDef(c) && sameVnode(node, c))
		                  return i_5;
		          }
		      }
		      function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
		          if (oldVnode === vnode) {
		              return;
		          }
		          if (isDef(vnode.elm) && isDef(ownerArray)) {
		              // clone reused vnode
		              vnode = ownerArray[index] = cloneVNode(vnode);
		          }
		          var elm = (vnode.elm = oldVnode.elm);
		          if (isTrue(oldVnode.isAsyncPlaceholder)) {
		              if (isDef(vnode.asyncFactory.resolved)) {
		                  hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
		              }
		              else {
		                  vnode.isAsyncPlaceholder = true;
		              }
		              return;
		          }
		          // reuse element for static trees.
		          // note we only do this if the vnode is cloned -
		          // if the new node is not cloned it means the render functions have been
		          // reset by the hot-reload-api and we need to do a proper re-render.
		          if (isTrue(vnode.isStatic) &&
		              isTrue(oldVnode.isStatic) &&
		              vnode.key === oldVnode.key &&
		              (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
		              vnode.componentInstance = oldVnode.componentInstance;
		              return;
		          }
		          var i;
		          var data = vnode.data;
		          if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
		              i(oldVnode, vnode);
		          }
		          var oldCh = oldVnode.children;
		          var ch = vnode.children;
		          if (isDef(data) && isPatchable(vnode)) {
		              for (i = 0; i < cbs.update.length; ++i)
		                  cbs.update[i](oldVnode, vnode);
		              if (isDef((i = data.hook)) && isDef((i = i.update)))
		                  i(oldVnode, vnode);
		          }
		          if (isUndef(vnode.text)) {
		              if (isDef(oldCh) && isDef(ch)) {
		                  if (oldCh !== ch)
		                      updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
		              }
		              else if (isDef(ch)) {
		                  {
		                      checkDuplicateKeys(ch);
		                  }
		                  if (isDef(oldVnode.text))
		                      nodeOps.setTextContent(elm, '');
		                  addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
		              }
		              else if (isDef(oldCh)) {
		                  removeVnodes(oldCh, 0, oldCh.length - 1);
		              }
		              else if (isDef(oldVnode.text)) {
		                  nodeOps.setTextContent(elm, '');
		              }
		          }
		          else if (oldVnode.text !== vnode.text) {
		              nodeOps.setTextContent(elm, vnode.text);
		          }
		          if (isDef(data)) {
		              if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
		                  i(oldVnode, vnode);
		          }
		      }
		      function invokeInsertHook(vnode, queue, initial) {
		          // delay insert hooks for component root nodes, invoke them after the
		          // element is really inserted
		          if (isTrue(initial) && isDef(vnode.parent)) {
		              vnode.parent.data.pendingInsert = queue;
		          }
		          else {
		              for (var i_6 = 0; i_6 < queue.length; ++i_6) {
		                  queue[i_6].data.hook.insert(queue[i_6]);
		              }
		          }
		      }
		      var hydrationBailed = false;
		      // list of modules that can skip create hook during hydration because they
		      // are already rendered on the client or has no need for initialization
		      // Note: style is excluded because it relies on initial clone for future
		      // deep updates (#7063).
		      var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
		      // Note: this is a browser-only function so we can assume elms are DOM nodes.
		      function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
		          var i;
		          var tag = vnode.tag, data = vnode.data, children = vnode.children;
		          inVPre = inVPre || (data && data.pre);
		          vnode.elm = elm;
		          if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
		              vnode.isAsyncPlaceholder = true;
		              return true;
		          }
		          // assert node match
		          {
		              if (!assertNodeMatch(elm, vnode, inVPre)) {
		                  return false;
		              }
		          }
		          if (isDef(data)) {
		              if (isDef((i = data.hook)) && isDef((i = i.init)))
		                  i(vnode, true /* hydrating */);
		              if (isDef((i = vnode.componentInstance))) {
		                  // child component. it should have hydrated its own tree.
		                  initComponent(vnode, insertedVnodeQueue);
		                  return true;
		              }
		          }
		          if (isDef(tag)) {
		              if (isDef(children)) {
		                  // empty element, allow client to pick up and populate children
		                  if (!elm.hasChildNodes()) {
		                      createChildren(vnode, children, insertedVnodeQueue);
		                  }
		                  else {
		                      // v-html and domProps: innerHTML
		                      if (isDef((i = data)) &&
		                          isDef((i = i.domProps)) &&
		                          isDef((i = i.innerHTML))) {
		                          if (i !== elm.innerHTML) {
		                              /* istanbul ignore if */
		                              if (typeof console !== 'undefined' &&
		                                  !hydrationBailed) {
		                                  hydrationBailed = true;
		                                  console.warn('Parent: ', elm);
		                                  console.warn('server innerHTML: ', i);
		                                  console.warn('client innerHTML: ', elm.innerHTML);
		                              }
		                              return false;
		                          }
		                      }
		                      else {
		                          // iterate and compare children lists
		                          var childrenMatch = true;
		                          var childNode = elm.firstChild;
		                          for (var i_7 = 0; i_7 < children.length; i_7++) {
		                              if (!childNode ||
		                                  !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
		                                  childrenMatch = false;
		                                  break;
		                              }
		                              childNode = childNode.nextSibling;
		                          }
		                          // if childNode is not null, it means the actual childNodes list is
		                          // longer than the virtual children list.
		                          if (!childrenMatch || childNode) {
		                              /* istanbul ignore if */
		                              if (typeof console !== 'undefined' &&
		                                  !hydrationBailed) {
		                                  hydrationBailed = true;
		                                  console.warn('Parent: ', elm);
		                                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
		                              }
		                              return false;
		                          }
		                      }
		                  }
		              }
		              if (isDef(data)) {
		                  var fullInvoke = false;
		                  for (var key in data) {
		                      if (!isRenderedModule(key)) {
		                          fullInvoke = true;
		                          invokeCreateHooks(vnode, insertedVnodeQueue);
		                          break;
		                      }
		                  }
		                  if (!fullInvoke && data['class']) {
		                      // ensure collecting deps for deep class bindings for future updates
		                      traverse(data['class']);
		                  }
		              }
		          }
		          else if (elm.data !== vnode.text) {
		              elm.data = vnode.text;
		          }
		          return true;
		      }
		      function assertNodeMatch(node, vnode, inVPre) {
		          if (isDef(vnode.tag)) {
		              return (vnode.tag.indexOf('vue-component') === 0 ||
		                  (!isUnknownElement(vnode, inVPre) &&
		                      vnode.tag.toLowerCase() ===
		                          (node.tagName && node.tagName.toLowerCase())));
		          }
		          else {
		              return node.nodeType === (vnode.isComment ? 8 : 3);
		          }
		      }
		      return function patch(oldVnode, vnode, hydrating, removeOnly) {
		          if (isUndef(vnode)) {
		              if (isDef(oldVnode))
		                  invokeDestroyHook(oldVnode);
		              return;
		          }
		          var isInitialPatch = false;
		          var insertedVnodeQueue = [];
		          if (isUndef(oldVnode)) {
		              // empty mount (likely as component), create new root element
		              isInitialPatch = true;
		              createElm(vnode, insertedVnodeQueue);
		          }
		          else {
		              var isRealElement = isDef(oldVnode.nodeType);
		              if (!isRealElement && sameVnode(oldVnode, vnode)) {
		                  // patch existing root node
		                  patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
		              }
		              else {
		                  if (isRealElement) {
		                      // mounting to a real element
		                      // check if this is server-rendered content and if we can perform
		                      // a successful hydration.
		                      if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
		                          oldVnode.removeAttribute(SSR_ATTR);
		                          hydrating = true;
		                      }
		                      if (isTrue(hydrating)) {
		                          if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
		                              invokeInsertHook(vnode, insertedVnodeQueue, true);
		                              return oldVnode;
		                          }
		                          else {
		                              warn$2('The client-side rendered virtual DOM tree is not matching ' +
		                                  'server-rendered content. This is likely caused by incorrect ' +
		                                  'HTML markup, for example nesting block-level elements inside ' +
		                                  '<p>, or missing <tbody>. Bailing hydration and performing ' +
		                                  'full client-side render.');
		                          }
		                      }
		                      // either not server-rendered, or hydration failed.
		                      // create an empty node and replace it
		                      oldVnode = emptyNodeAt(oldVnode);
		                  }
		                  // replacing existing element
		                  var oldElm = oldVnode.elm;
		                  var parentElm = nodeOps.parentNode(oldElm);
		                  // create new node
		                  createElm(vnode, insertedVnodeQueue, 
		                  // extremely rare edge case: do not insert if old element is in a
		                  // leaving transition. Only happens when combining transition +
		                  // keep-alive + HOCs. (#4590)
		                  oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
		                  // update parent placeholder node element, recursively
		                  if (isDef(vnode.parent)) {
		                      var ancestor = vnode.parent;
		                      var patchable = isPatchable(vnode);
		                      while (ancestor) {
		                          for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
		                              cbs.destroy[i_8](ancestor);
		                          }
		                          ancestor.elm = vnode.elm;
		                          if (patchable) {
		                              for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
		                                  cbs.create[i_9](emptyNode, ancestor);
		                              }
		                              // #6513
		                              // invoke insert hooks that may have been merged by create hooks.
		                              // e.g. for directives that uses the "inserted" hook.
		                              var insert_1 = ancestor.data.hook.insert;
		                              if (insert_1.merged) {
		                                  // start at index 1 to avoid re-invoking component mounted hook
		                                  for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
		                                      insert_1.fns[i_10]();
		                                  }
		                              }
		                          }
		                          else {
		                              registerRef(ancestor);
		                          }
		                          ancestor = ancestor.parent;
		                      }
		                  }
		                  // destroy old node
		                  if (isDef(parentElm)) {
		                      removeVnodes([oldVnode], 0, 0);
		                  }
		                  else if (isDef(oldVnode.tag)) {
		                      invokeDestroyHook(oldVnode);
		                  }
		              }
		          }
		          invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
		          return vnode.elm;
		      };
		  }

		  var directives$1 = {
		      create: updateDirectives,
		      update: updateDirectives,
		      destroy: function unbindDirectives(vnode) {
		          // @ts-expect-error emptyNode is not VNodeWithData
		          updateDirectives(vnode, emptyNode);
		      }
		  };
		  function updateDirectives(oldVnode, vnode) {
		      if (oldVnode.data.directives || vnode.data.directives) {
		          _update(oldVnode, vnode);
		      }
		  }
		  function _update(oldVnode, vnode) {
		      var isCreate = oldVnode === emptyNode;
		      var isDestroy = vnode === emptyNode;
		      var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
		      var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
		      var dirsWithInsert = [];
		      var dirsWithPostpatch = [];
		      var key, oldDir, dir;
		      for (key in newDirs) {
		          oldDir = oldDirs[key];
		          dir = newDirs[key];
		          if (!oldDir) {
		              // new directive, bind
		              callHook(dir, 'bind', vnode, oldVnode);
		              if (dir.def && dir.def.inserted) {
		                  dirsWithInsert.push(dir);
		              }
		          }
		          else {
		              // existing directive, update
		              dir.oldValue = oldDir.value;
		              dir.oldArg = oldDir.arg;
		              callHook(dir, 'update', vnode, oldVnode);
		              if (dir.def && dir.def.componentUpdated) {
		                  dirsWithPostpatch.push(dir);
		              }
		          }
		      }
		      if (dirsWithInsert.length) {
		          var callInsert = function () {
		              for (var i = 0; i < dirsWithInsert.length; i++) {
		                  callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
		              }
		          };
		          if (isCreate) {
		              mergeVNodeHook(vnode, 'insert', callInsert);
		          }
		          else {
		              callInsert();
		          }
		      }
		      if (dirsWithPostpatch.length) {
		          mergeVNodeHook(vnode, 'postpatch', function () {
		              for (var i = 0; i < dirsWithPostpatch.length; i++) {
		                  callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
		              }
		          });
		      }
		      if (!isCreate) {
		          for (key in oldDirs) {
		              if (!newDirs[key]) {
		                  // no longer present, unbind
		                  callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
		              }
		          }
		      }
		  }
		  var emptyModifiers = Object.create(null);
		  function normalizeDirectives(dirs, vm) {
		      var res = Object.create(null);
		      if (!dirs) {
		          // $flow-disable-line
		          return res;
		      }
		      var i, dir;
		      for (i = 0; i < dirs.length; i++) {
		          dir = dirs[i];
		          if (!dir.modifiers) {
		              // $flow-disable-line
		              dir.modifiers = emptyModifiers;
		          }
		          res[getRawDirName(dir)] = dir;
		          if (vm._setupState && vm._setupState.__sfc) {
		              dir.def = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
		          }
		          dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
		      }
		      // $flow-disable-line
		      return res;
		  }
		  function getRawDirName(dir) {
		      return (dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join('.')));
		  }
		  function callHook(dir, hook, vnode, oldVnode, isDestroy) {
		      var fn = dir.def && dir.def[hook];
		      if (fn) {
		          try {
		              fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
		          }
		          catch (e) {
		              handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
		          }
		      }
		  }

		  var baseModules = [ref, directives$1];

		  function updateAttrs(oldVnode, vnode) {
		      var opts = vnode.componentOptions;
		      if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
		          return;
		      }
		      if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
		          return;
		      }
		      var key, cur, old;
		      var elm = vnode.elm;
		      var oldAttrs = oldVnode.data.attrs || {};
		      var attrs = vnode.data.attrs || {};
		      // clone observed objects, as the user probably wants to mutate it
		      if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
		          attrs = vnode.data.attrs = extend({}, attrs);
		      }
		      for (key in attrs) {
		          cur = attrs[key];
		          old = oldAttrs[key];
		          if (old !== cur) {
		              setAttr(elm, key, cur, vnode.data.pre);
		          }
		      }
		      // #4391: in IE9, setting type can reset value for input[type=radio]
		      // #6666: IE/Edge forces progress value down to 1 before setting a max
		      /* istanbul ignore if */
		      if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
		          setAttr(elm, 'value', attrs.value);
		      }
		      for (key in oldAttrs) {
		          if (isUndef(attrs[key])) {
		              if (isXlink(key)) {
		                  elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
		              }
		              else if (!isEnumeratedAttr(key)) {
		                  elm.removeAttribute(key);
		              }
		          }
		      }
		  }
		  function setAttr(el, key, value, isInPre) {
		      if (isInPre || el.tagName.indexOf('-') > -1) {
		          baseSetAttr(el, key, value);
		      }
		      else if (isBooleanAttr(key)) {
		          // set attribute for blank value
		          // e.g. <option disabled>Select one</option>
		          if (isFalsyAttrValue(value)) {
		              el.removeAttribute(key);
		          }
		          else {
		              // technically allowfullscreen is a boolean attribute for <iframe>,
		              // but Flash expects a value of "true" when used on <embed> tag
		              value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
		              el.setAttribute(key, value);
		          }
		      }
		      else if (isEnumeratedAttr(key)) {
		          el.setAttribute(key, convertEnumeratedValue(key, value));
		      }
		      else if (isXlink(key)) {
		          if (isFalsyAttrValue(value)) {
		              el.removeAttributeNS(xlinkNS, getXlinkProp(key));
		          }
		          else {
		              el.setAttributeNS(xlinkNS, key, value);
		          }
		      }
		      else {
		          baseSetAttr(el, key, value);
		      }
		  }
		  function baseSetAttr(el, key, value) {
		      if (isFalsyAttrValue(value)) {
		          el.removeAttribute(key);
		      }
		      else {
		          // #7138: IE10 & 11 fires input event when setting placeholder on
		          // <textarea>... block the first input event and remove the blocker
		          // immediately.
		          /* istanbul ignore if */
		          if (isIE &&
		              !isIE9 &&
		              el.tagName === 'TEXTAREA' &&
		              key === 'placeholder' &&
		              value !== '' &&
		              !el.__ieph) {
		              var blocker_1 = function (e) {
		                  e.stopImmediatePropagation();
		                  el.removeEventListener('input', blocker_1);
		              };
		              el.addEventListener('input', blocker_1);
		              // $flow-disable-line
		              el.__ieph = true; /* IE placeholder patched */
		          }
		          el.setAttribute(key, value);
		      }
		  }
		  var attrs = {
		      create: updateAttrs,
		      update: updateAttrs
		  };

		  function updateClass(oldVnode, vnode) {
		      var el = vnode.elm;
		      var data = vnode.data;
		      var oldData = oldVnode.data;
		      if (isUndef(data.staticClass) &&
		          isUndef(data.class) &&
		          (isUndef(oldData) ||
		              (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
		          return;
		      }
		      var cls = genClassForVnode(vnode);
		      // handle transition classes
		      var transitionClass = el._transitionClasses;
		      if (isDef(transitionClass)) {
		          cls = concat(cls, stringifyClass(transitionClass));
		      }
		      // set the class
		      if (cls !== el._prevClass) {
		          el.setAttribute('class', cls);
		          el._prevClass = cls;
		      }
		  }
		  var klass$1 = {
		      create: updateClass,
		      update: updateClass
		  };

		  var validDivisionCharRE = /[\w).+\-_$\]]/;
		  function parseFilters(exp) {
		      var inSingle = false;
		      var inDouble = false;
		      var inTemplateString = false;
		      var inRegex = false;
		      var curly = 0;
		      var square = 0;
		      var paren = 0;
		      var lastFilterIndex = 0;
		      var c, prev, i, expression, filters;
		      for (i = 0; i < exp.length; i++) {
		          prev = c;
		          c = exp.charCodeAt(i);
		          if (inSingle) {
		              if (c === 0x27 && prev !== 0x5c)
		                  inSingle = false;
		          }
		          else if (inDouble) {
		              if (c === 0x22 && prev !== 0x5c)
		                  inDouble = false;
		          }
		          else if (inTemplateString) {
		              if (c === 0x60 && prev !== 0x5c)
		                  inTemplateString = false;
		          }
		          else if (inRegex) {
		              if (c === 0x2f && prev !== 0x5c)
		                  inRegex = false;
		          }
		          else if (c === 0x7c && // pipe
		              exp.charCodeAt(i + 1) !== 0x7c &&
		              exp.charCodeAt(i - 1) !== 0x7c &&
		              !curly &&
		              !square &&
		              !paren) {
		              if (expression === undefined) {
		                  // first filter, end of expression
		                  lastFilterIndex = i + 1;
		                  expression = exp.slice(0, i).trim();
		              }
		              else {
		                  pushFilter();
		              }
		          }
		          else {
		              switch (c) {
		                  case 0x22:
		                      inDouble = true;
		                      break; // "
		                  case 0x27:
		                      inSingle = true;
		                      break; // '
		                  case 0x60:
		                      inTemplateString = true;
		                      break; // `
		                  case 0x28:
		                      paren++;
		                      break; // (
		                  case 0x29:
		                      paren--;
		                      break; // )
		                  case 0x5b:
		                      square++;
		                      break; // [
		                  case 0x5d:
		                      square--;
		                      break; // ]
		                  case 0x7b:
		                      curly++;
		                      break; // {
		                  case 0x7d:
		                      curly--;
		                      break; // }
		              }
		              if (c === 0x2f) {
		                  // /
		                  var j = i - 1;
		                  var p 
		                  // find first non-whitespace prev char
		                  = void 0;
		                  // find first non-whitespace prev char
		                  for (; j >= 0; j--) {
		                      p = exp.charAt(j);
		                      if (p !== ' ')
		                          break;
		                  }
		                  if (!p || !validDivisionCharRE.test(p)) {
		                      inRegex = true;
		                  }
		              }
		          }
		      }
		      if (expression === undefined) {
		          expression = exp.slice(0, i).trim();
		      }
		      else if (lastFilterIndex !== 0) {
		          pushFilter();
		      }
		      function pushFilter() {
		          (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
		          lastFilterIndex = i + 1;
		      }
		      if (filters) {
		          for (i = 0; i < filters.length; i++) {
		              expression = wrapFilter(expression, filters[i]);
		          }
		      }
		      return expression;
		  }
		  function wrapFilter(exp, filter) {
		      var i = filter.indexOf('(');
		      if (i < 0) {
		          // _f: resolveFilter
		          return "_f(\"".concat(filter, "\")(").concat(exp, ")");
		      }
		      else {
		          var name_1 = filter.slice(0, i);
		          var args = filter.slice(i + 1);
		          return "_f(\"".concat(name_1, "\")(").concat(exp).concat(args !== ')' ? ',' + args : args);
		      }
		  }

		  /* eslint-disable no-unused-vars */
		  function baseWarn(msg, range) {
		      console.error("[Vue compiler]: ".concat(msg));
		  }
		  /* eslint-enable no-unused-vars */
		  function pluckModuleFunction(modules, key) {
		      return modules ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; }) : [];
		  }
		  function addProp(el, name, value, range, dynamic) {
		      (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
		      el.plain = false;
		  }
		  function addAttr(el, name, value, range, dynamic) {
		      var attrs = dynamic
		          ? el.dynamicAttrs || (el.dynamicAttrs = [])
		          : el.attrs || (el.attrs = []);
		      attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
		      el.plain = false;
		  }
		  // add a raw attr (use this in preTransforms)
		  function addRawAttr(el, name, value, range) {
		      el.attrsMap[name] = value;
		      el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
		  }
		  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
		      (el.directives || (el.directives = [])).push(rangeSetItem({
		          name: name,
		          rawName: rawName,
		          value: value,
		          arg: arg,
		          isDynamicArg: isDynamicArg,
		          modifiers: modifiers
		      }, range));
		      el.plain = false;
		  }
		  function prependModifierMarker(symbol, name, dynamic) {
		      return dynamic ? "_p(".concat(name, ",\"").concat(symbol, "\")") : symbol + name; // mark the event as captured
		  }
		  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
		      modifiers = modifiers || emptyObject;
		      // warn prevent and passive modifier
		      /* istanbul ignore if */
		      if (warn && modifiers.prevent && modifiers.passive) {
		          warn("passive and prevent can't be used together. " +
		              "Passive handler can't prevent default event.", range);
		      }
		      // normalize click.right and click.middle since they don't actually fire
		      // this is technically browser-specific, but at least for now browsers are
		      // the only target envs that have right/middle clicks.
		      if (modifiers.right) {
		          if (dynamic) {
		              name = "(".concat(name, ")==='click'?'contextmenu':(").concat(name, ")");
		          }
		          else if (name === 'click') {
		              name = 'contextmenu';
		              delete modifiers.right;
		          }
		      }
		      else if (modifiers.middle) {
		          if (dynamic) {
		              name = "(".concat(name, ")==='click'?'mouseup':(").concat(name, ")");
		          }
		          else if (name === 'click') {
		              name = 'mouseup';
		          }
		      }
		      // check capture modifier
		      if (modifiers.capture) {
		          delete modifiers.capture;
		          name = prependModifierMarker('!', name, dynamic);
		      }
		      if (modifiers.once) {
		          delete modifiers.once;
		          name = prependModifierMarker('~', name, dynamic);
		      }
		      /* istanbul ignore if */
		      if (modifiers.passive) {
		          delete modifiers.passive;
		          name = prependModifierMarker('&', name, dynamic);
		      }
		      var events;
		      if (modifiers.native) {
		          delete modifiers.native;
		          events = el.nativeEvents || (el.nativeEvents = {});
		      }
		      else {
		          events = el.events || (el.events = {});
		      }
		      var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
		      if (modifiers !== emptyObject) {
		          newHandler.modifiers = modifiers;
		      }
		      var handlers = events[name];
		      /* istanbul ignore if */
		      if (Array.isArray(handlers)) {
		          important ? handlers.unshift(newHandler) : handlers.push(newHandler);
		      }
		      else if (handlers) {
		          events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
		      }
		      else {
		          events[name] = newHandler;
		      }
		      el.plain = false;
		  }
		  function getRawBindingAttr(el, name) {
		      return (el.rawAttrsMap[':' + name] ||
		          el.rawAttrsMap['v-bind:' + name] ||
		          el.rawAttrsMap[name]);
		  }
		  function getBindingAttr(el, name, getStatic) {
		      var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
		      if (dynamicValue != null) {
		          return parseFilters(dynamicValue);
		      }
		      else if (getStatic !== false) {
		          var staticValue = getAndRemoveAttr(el, name);
		          if (staticValue != null) {
		              return JSON.stringify(staticValue);
		          }
		      }
		  }
		  // note: this only removes the attr from the Array (attrsList) so that it
		  // doesn't get processed by processAttrs.
		  // By default it does NOT remove it from the map (attrsMap) because the map is
		  // needed during codegen.
		  function getAndRemoveAttr(el, name, removeFromMap) {
		      var val;
		      if ((val = el.attrsMap[name]) != null) {
		          var list = el.attrsList;
		          for (var i = 0, l = list.length; i < l; i++) {
		              if (list[i].name === name) {
		                  list.splice(i, 1);
		                  break;
		              }
		          }
		      }
		      if (removeFromMap) {
		          delete el.attrsMap[name];
		      }
		      return val;
		  }
		  function getAndRemoveAttrByRegex(el, name) {
		      var list = el.attrsList;
		      for (var i = 0, l = list.length; i < l; i++) {
		          var attr = list[i];
		          if (name.test(attr.name)) {
		              list.splice(i, 1);
		              return attr;
		          }
		      }
		  }
		  function rangeSetItem(item, range) {
		      if (range) {
		          if (range.start != null) {
		              item.start = range.start;
		          }
		          if (range.end != null) {
		              item.end = range.end;
		          }
		      }
		      return item;
		  }

		  /**
		   * Cross-platform code generation for component v-model
		   */
		  function genComponentModel(el, value, modifiers) {
		      var _a = modifiers || {}, number = _a.number, trim = _a.trim;
		      var baseValueExpression = '$$v';
		      var valueExpression = baseValueExpression;
		      if (trim) {
		          valueExpression =
		              "(typeof ".concat(baseValueExpression, " === 'string'") +
		                  "? ".concat(baseValueExpression, ".trim()") +
		                  ": ".concat(baseValueExpression, ")");
		      }
		      if (number) {
		          valueExpression = "_n(".concat(valueExpression, ")");
		      }
		      var assignment = genAssignmentCode(value, valueExpression);
		      el.model = {
		          value: "(".concat(value, ")"),
		          expression: JSON.stringify(value),
		          callback: "function (".concat(baseValueExpression, ") {").concat(assignment, "}")
		      };
		  }
		  /**
		   * Cross-platform codegen helper for generating v-model value assignment code.
		   */
		  function genAssignmentCode(value, assignment) {
		      var res = parseModel(value);
		      if (res.key === null) {
		          return "".concat(value, "=").concat(assignment);
		      }
		      else {
		          return "$set(".concat(res.exp, ", ").concat(res.key, ", ").concat(assignment, ")");
		      }
		  }
		  /**
		   * Parse a v-model expression into a base path and a final key segment.
		   * Handles both dot-path and possible square brackets.
		   *
		   * Possible cases:
		   *
		   * - test
		   * - test[key]
		   * - test[test1[key]]
		   * - test["a"][key]
		   * - xxx.test[a[a].test1[key]]
		   * - test.xxx.a["asa"][test1[key]]
		   *
		   */
		  var len, str, chr, index, expressionPos, expressionEndPos;
		  function parseModel(val) {
		      // Fix https://github.com/vuejs/vue/pull/7730
		      // allow v-model="obj.val " (trailing whitespace)
		      val = val.trim();
		      len = val.length;
		      if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
		          index = val.lastIndexOf('.');
		          if (index > -1) {
		              return {
		                  exp: val.slice(0, index),
		                  key: '"' + val.slice(index + 1) + '"'
		              };
		          }
		          else {
		              return {
		                  exp: val,
		                  key: null
		              };
		          }
		      }
		      str = val;
		      index = expressionPos = expressionEndPos = 0;
		      while (!eof()) {
		          chr = next();
		          /* istanbul ignore if */
		          if (isStringStart(chr)) {
		              parseString(chr);
		          }
		          else if (chr === 0x5b) {
		              parseBracket(chr);
		          }
		      }
		      return {
		          exp: val.slice(0, expressionPos),
		          key: val.slice(expressionPos + 1, expressionEndPos)
		      };
		  }
		  function next() {
		      return str.charCodeAt(++index);
		  }
		  function eof() {
		      return index >= len;
		  }
		  function isStringStart(chr) {
		      return chr === 0x22 || chr === 0x27;
		  }
		  function parseBracket(chr) {
		      var inBracket = 1;
		      expressionPos = index;
		      while (!eof()) {
		          chr = next();
		          if (isStringStart(chr)) {
		              parseString(chr);
		              continue;
		          }
		          if (chr === 0x5b)
		              inBracket++;
		          if (chr === 0x5d)
		              inBracket--;
		          if (inBracket === 0) {
		              expressionEndPos = index;
		              break;
		          }
		      }
		  }
		  function parseString(chr) {
		      var stringQuote = chr;
		      while (!eof()) {
		          chr = next();
		          if (chr === stringQuote) {
		              break;
		          }
		      }
		  }

		  var warn$1;
		  // in some cases, the event used has to be determined at runtime
		  // so we used some reserved tokens during compile.
		  var RANGE_TOKEN = '__r';
		  var CHECKBOX_RADIO_TOKEN = '__c';
		  function model$1(el, dir, _warn) {
		      warn$1 = _warn;
		      var value = dir.value;
		      var modifiers = dir.modifiers;
		      var tag = el.tag;
		      var type = el.attrsMap.type;
		      {
		          // inputs with type="file" are read only and setting the input's
		          // value will throw an error.
		          if (tag === 'input' && type === 'file') {
		              warn$1("<".concat(el.tag, " v-model=\"").concat(value, "\" type=\"file\">:\n") +
		                  "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
		          }
		      }
		      if (el.component) {
		          genComponentModel(el, value, modifiers);
		          // component v-model doesn't need extra runtime
		          return false;
		      }
		      else if (tag === 'select') {
		          genSelect(el, value, modifiers);
		      }
		      else if (tag === 'input' && type === 'checkbox') {
		          genCheckboxModel(el, value, modifiers);
		      }
		      else if (tag === 'input' && type === 'radio') {
		          genRadioModel(el, value, modifiers);
		      }
		      else if (tag === 'input' || tag === 'textarea') {
		          genDefaultModel(el, value, modifiers);
		      }
		      else if (!config.isReservedTag(tag)) {
		          genComponentModel(el, value, modifiers);
		          // component v-model doesn't need extra runtime
		          return false;
		      }
		      else {
		          warn$1("<".concat(el.tag, " v-model=\"").concat(value, "\">: ") +
		              "v-model is not supported on this element type. " +
		              "If you are working with contenteditable, it's recommended to " +
		              'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
		      }
		      // ensure runtime directive metadata
		      return true;
		  }
		  function genCheckboxModel(el, value, modifiers) {
		      var number = modifiers && modifiers.number;
		      var valueBinding = getBindingAttr(el, 'value') || 'null';
		      var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
		      var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
		      addProp(el, 'checked', "Array.isArray(".concat(value, ")") +
		          "?_i(".concat(value, ",").concat(valueBinding, ")>-1") +
		          (trueValueBinding === 'true'
		              ? ":(".concat(value, ")")
		              : ":_q(".concat(value, ",").concat(trueValueBinding, ")")));
		      addHandler(el, 'change', "var $$a=".concat(value, ",") +
		          '$$el=$event.target,' +
		          "$$c=$$el.checked?(".concat(trueValueBinding, "):(").concat(falseValueBinding, ");") +
		          'if(Array.isArray($$a)){' +
		          "var $$v=".concat(number ? '_n(' + valueBinding + ')' : valueBinding, ",") +
		          '$$i=_i($$a,$$v);' +
		          "if($$el.checked){$$i<0&&(".concat(genAssignmentCode(value, '$$a.concat([$$v])'), ")}") +
		          "else{$$i>-1&&(".concat(genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))'), ")}") +
		          "}else{".concat(genAssignmentCode(value, '$$c'), "}"), null, true);
		  }
		  function genRadioModel(el, value, modifiers) {
		      var number = modifiers && modifiers.number;
		      var valueBinding = getBindingAttr(el, 'value') || 'null';
		      valueBinding = number ? "_n(".concat(valueBinding, ")") : valueBinding;
		      addProp(el, 'checked', "_q(".concat(value, ",").concat(valueBinding, ")"));
		      addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
		  }
		  function genSelect(el, value, modifiers) {
		      var number = modifiers && modifiers.number;
		      var selectedVal = "Array.prototype.filter" +
		          ".call($event.target.options,function(o){return o.selected})" +
		          ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
		          "return ".concat(number ? '_n(val)' : 'val', "})");
		      var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
		      var code = "var $$selectedVal = ".concat(selectedVal, ";");
		      code = "".concat(code, " ").concat(genAssignmentCode(value, assignment));
		      addHandler(el, 'change', code, null, true);
		  }
		  function genDefaultModel(el, value, modifiers) {
		      var type = el.attrsMap.type;
		      // warn if v-bind:value conflicts with v-model
		      // except for inputs with v-bind:type
		      {
		          var value_1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
		          var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
		          if (value_1 && !typeBinding) {
		              var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
		              warn$1("".concat(binding, "=\"").concat(value_1, "\" conflicts with v-model on the same element ") +
		                  'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
		          }
		      }
		      var _a = modifiers || {}, lazy = _a.lazy, number = _a.number, trim = _a.trim;
		      var needCompositionGuard = !lazy && type !== 'range';
		      var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
		      var valueExpression = '$event.target.value';
		      if (trim) {
		          valueExpression = "$event.target.value.trim()";
		      }
		      if (number) {
		          valueExpression = "_n(".concat(valueExpression, ")");
		      }
		      var code = genAssignmentCode(value, valueExpression);
		      if (needCompositionGuard) {
		          code = "if($event.target.composing)return;".concat(code);
		      }
		      addProp(el, 'value', "(".concat(value, ")"));
		      addHandler(el, event, code, null, true);
		      if (trim || number) {
		          addHandler(el, 'blur', '$forceUpdate()');
		      }
		  }

		  // normalize v-model event tokens that can only be determined at runtime.
		  // it's important to place the event as the first in the array because
		  // the whole point is ensuring the v-model callback gets called before
		  // user-attached handlers.
		  function normalizeEvents(on) {
		      /* istanbul ignore if */
		      if (isDef(on[RANGE_TOKEN])) {
		          // IE input[type=range] only supports `change` event
		          var event_1 = isIE ? 'change' : 'input';
		          on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
		          delete on[RANGE_TOKEN];
		      }
		      // This was originally intended to fix #4521 but no longer necessary
		      // after 2.5. Keeping it for backwards compat with generated code from < 2.4
		      /* istanbul ignore if */
		      if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
		          on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
		          delete on[CHECKBOX_RADIO_TOKEN];
		      }
		  }
		  var target;
		  function createOnceHandler(event, handler, capture) {
		      var _target = target; // save current target element in closure
		      return function onceHandler() {
		          var res = handler.apply(null, arguments);
		          if (res !== null) {
		              remove(event, onceHandler, capture, _target);
		          }
		      };
		  }
		  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
		  // implementation and does not fire microtasks in between event propagation, so
		  // safe to exclude.
		  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
		  function add(name, handler, capture, passive) {
		      // async edge case #6566: inner click event triggers patch, event handler
		      // attached to outer element during patch, and triggered again. This
		      // happens because browsers fire microtask ticks between event propagation.
		      // the solution is simple: we save the timestamp when a handler is attached,
		      // and the handler would only fire if the event passed to it was fired
		      // AFTER it was attached.
		      if (useMicrotaskFix) {
		          var attachedTimestamp_1 = currentFlushTimestamp;
		          var original_1 = handler;
		          //@ts-expect-error
		          handler = original_1._wrapper = function (e) {
		              if (
		              // no bubbling, should always fire.
		              // this is just a safety net in case event.timeStamp is unreliable in
		              // certain weird environments...
		              e.target === e.currentTarget ||
		                  // event is fired after handler attachment
		                  e.timeStamp >= attachedTimestamp_1 ||
		                  // bail for environments that have buggy event.timeStamp implementations
		                  // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
		                  // #9681 QtWebEngine event.timeStamp is negative value
		                  e.timeStamp <= 0 ||
		                  // #9448 bail if event is fired in another document in a multi-page
		                  // electron/nw.js app, since event.timeStamp will be using a different
		                  // starting reference
		                  e.target.ownerDocument !== document) {
		                  return original_1.apply(this, arguments);
		              }
		          };
		      }
		      target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
		  }
		  function remove(name, handler, capture, _target) {
		      (_target || target).removeEventListener(name, 
		      //@ts-expect-error
		      handler._wrapper || handler, capture);
		  }
		  function updateDOMListeners(oldVnode, vnode) {
		      if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
		          return;
		      }
		      var on = vnode.data.on || {};
		      var oldOn = oldVnode.data.on || {};
		      // vnode is empty when removing all listeners,
		      // and use old vnode dom element
		      target = vnode.elm || oldVnode.elm;
		      normalizeEvents(on);
		      updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
		      target = undefined;
		  }
		  var events = {
		      create: updateDOMListeners,
		      update: updateDOMListeners,
		      // @ts-expect-error emptyNode has actually data
		      destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }
		  };

		  var svgContainer;
		  function updateDOMProps(oldVnode, vnode) {
		      if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
		          return;
		      }
		      var key, cur;
		      var elm = vnode.elm;
		      var oldProps = oldVnode.data.domProps || {};
		      var props = vnode.data.domProps || {};
		      // clone observed objects, as the user probably wants to mutate it
		      if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
		          props = vnode.data.domProps = extend({}, props);
		      }
		      for (key in oldProps) {
		          if (!(key in props)) {
		              elm[key] = '';
		          }
		      }
		      for (key in props) {
		          cur = props[key];
		          // ignore children if the node has textContent or innerHTML,
		          // as these will throw away existing DOM nodes and cause removal errors
		          // on subsequent patches (#3360)
		          if (key === 'textContent' || key === 'innerHTML') {
		              if (vnode.children)
		                  vnode.children.length = 0;
		              if (cur === oldProps[key])
		                  continue;
		              // #6601 work around Chrome version <= 55 bug where single textNode
		              // replaced by innerHTML/textContent retains its parentNode property
		              if (elm.childNodes.length === 1) {
		                  elm.removeChild(elm.childNodes[0]);
		              }
		          }
		          if (key === 'value' && elm.tagName !== 'PROGRESS') {
		              // store value as _value as well since
		              // non-string values will be stringified
		              elm._value = cur;
		              // avoid resetting cursor position when value is the same
		              var strCur = isUndef(cur) ? '' : String(cur);
		              if (shouldUpdateValue(elm, strCur)) {
		                  elm.value = strCur;
		              }
		          }
		          else if (key === 'innerHTML' &&
		              isSVG(elm.tagName) &&
		              isUndef(elm.innerHTML)) {
		              // IE doesn't support innerHTML for SVG elements
		              svgContainer = svgContainer || document.createElement('div');
		              svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
		              var svg = svgContainer.firstChild;
		              while (elm.firstChild) {
		                  elm.removeChild(elm.firstChild);
		              }
		              while (svg.firstChild) {
		                  elm.appendChild(svg.firstChild);
		              }
		          }
		          else if (
		          // skip the update if old and new VDOM state is the same.
		          // `value` is handled separately because the DOM value may be temporarily
		          // out of sync with VDOM state due to focus, composition and modifiers.
		          // This  #4521 by skipping the unnecessary `checked` update.
		          cur !== oldProps[key]) {
		              // some property updates can throw
		              // e.g. `value` on <progress> w/ non-finite value
		              try {
		                  elm[key] = cur;
		              }
		              catch (e) { }
		          }
		      }
		  }
		  function shouldUpdateValue(elm, checkVal) {
		      return (
		      //@ts-expect-error
		      !elm.composing &&
		          (elm.tagName === 'OPTION' ||
		              isNotInFocusAndDirty(elm, checkVal) ||
		              isDirtyWithModifiers(elm, checkVal)));
		  }
		  function isNotInFocusAndDirty(elm, checkVal) {
		      // return true when textbox (.number and .trim) loses focus and its value is
		      // not equal to the updated value
		      var notInFocus = true;
		      // #6157
		      // work around IE bug when accessing document.activeElement in an iframe
		      try {
		          notInFocus = document.activeElement !== elm;
		      }
		      catch (e) { }
		      return notInFocus && elm.value !== checkVal;
		  }
		  function isDirtyWithModifiers(elm, newVal) {
		      var value = elm.value;
		      var modifiers = elm._vModifiers; // injected by v-model runtime
		      if (isDef(modifiers)) {
		          if (modifiers.number) {
		              return toNumber(value) !== toNumber(newVal);
		          }
		          if (modifiers.trim) {
		              return value.trim() !== newVal.trim();
		          }
		      }
		      return value !== newVal;
		  }
		  var domProps = {
		      create: updateDOMProps,
		      update: updateDOMProps
		  };

		  var parseStyleText = cached(function (cssText) {
		      var res = {};
		      var listDelimiter = /;(?![^(]*\))/g;
		      var propertyDelimiter = /:(.+)/;
		      cssText.split(listDelimiter).forEach(function (item) {
		          if (item) {
		              var tmp = item.split(propertyDelimiter);
		              tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
		          }
		      });
		      return res;
		  });
		  // merge static and dynamic style data on the same vnode
		  function normalizeStyleData(data) {
		      var style = normalizeStyleBinding(data.style);
		      // static style is pre-processed into an object during compilation
		      // and is always a fresh object, so it's safe to merge into it
		      return data.staticStyle ? extend(data.staticStyle, style) : style;
		  }
		  // normalize possible array / string values into Object
		  function normalizeStyleBinding(bindingStyle) {
		      if (Array.isArray(bindingStyle)) {
		          return toObject(bindingStyle);
		      }
		      if (typeof bindingStyle === 'string') {
		          return parseStyleText(bindingStyle);
		      }
		      return bindingStyle;
		  }
		  /**
		   * parent component style should be after child's
		   * so that parent component's style could override it
		   */
		  function getStyle(vnode, checkChild) {
		      var res = {};
		      var styleData;
		      if (checkChild) {
		          var childNode = vnode;
		          while (childNode.componentInstance) {
		              childNode = childNode.componentInstance._vnode;
		              if (childNode &&
		                  childNode.data &&
		                  (styleData = normalizeStyleData(childNode.data))) {
		                  extend(res, styleData);
		              }
		          }
		      }
		      if ((styleData = normalizeStyleData(vnode.data))) {
		          extend(res, styleData);
		      }
		      var parentNode = vnode;
		      // @ts-expect-error parentNode.parent not VNodeWithData
		      while ((parentNode = parentNode.parent)) {
		          if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
		              extend(res, styleData);
		          }
		      }
		      return res;
		  }

		  var cssVarRE = /^--/;
		  var importantRE = /\s*!important$/;
		  var setProp = function (el, name, val) {
		      /* istanbul ignore if */
		      if (cssVarRE.test(name)) {
		          el.style.setProperty(name, val);
		      }
		      else if (importantRE.test(val)) {
		          el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
		      }
		      else {
		          var normalizedName = normalize(name);
		          if (Array.isArray(val)) {
		              // Support values array created by autoprefixer, e.g.
		              // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
		              // Set them one by one, and the browser will only set those it can recognize
		              for (var i = 0, len = val.length; i < len; i++) {
		                  el.style[normalizedName] = val[i];
		              }
		          }
		          else {
		              el.style[normalizedName] = val;
		          }
		      }
		  };
		  var vendorNames = ['Webkit', 'Moz', 'ms'];
		  var emptyStyle;
		  var normalize = cached(function (prop) {
		      emptyStyle = emptyStyle || document.createElement('div').style;
		      prop = camelize(prop);
		      if (prop !== 'filter' && prop in emptyStyle) {
		          return prop;
		      }
		      var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
		      for (var i = 0; i < vendorNames.length; i++) {
		          var name_1 = vendorNames[i] + capName;
		          if (name_1 in emptyStyle) {
		              return name_1;
		          }
		      }
		  });
		  function updateStyle(oldVnode, vnode) {
		      var data = vnode.data;
		      var oldData = oldVnode.data;
		      if (isUndef(data.staticStyle) &&
		          isUndef(data.style) &&
		          isUndef(oldData.staticStyle) &&
		          isUndef(oldData.style)) {
		          return;
		      }
		      var cur, name;
		      var el = vnode.elm;
		      var oldStaticStyle = oldData.staticStyle;
		      var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
		      // if static style exists, stylebinding already merged into it when doing normalizeStyleData
		      var oldStyle = oldStaticStyle || oldStyleBinding;
		      var style = normalizeStyleBinding(vnode.data.style) || {};
		      // store normalized style under a different key for next diff
		      // make sure to clone it if it's reactive, since the user likely wants
		      // to mutate it.
		      vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
		      var newStyle = getStyle(vnode, true);
		      for (name in oldStyle) {
		          if (isUndef(newStyle[name])) {
		              setProp(el, name, '');
		          }
		      }
		      for (name in newStyle) {
		          cur = newStyle[name];
		          if (cur !== oldStyle[name]) {
		              // ie9 setting to null has no effect, must use empty string
		              setProp(el, name, cur == null ? '' : cur);
		          }
		      }
		  }
		  var style$1 = {
		      create: updateStyle,
		      update: updateStyle
		  };

		  var whitespaceRE$1 = /\s+/;
		  /**
		   * Add class with compatibility for SVG since classList is not supported on
		   * SVG elements in IE
		   */
		  function addClass(el, cls) {
		      /* istanbul ignore if */
		      if (!cls || !(cls = cls.trim())) {
		          return;
		      }
		      /* istanbul ignore else */
		      if (el.classList) {
		          if (cls.indexOf(' ') > -1) {
		              cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.add(c); });
		          }
		          else {
		              el.classList.add(cls);
		          }
		      }
		      else {
		          var cur = " ".concat(el.getAttribute('class') || '', " ");
		          if (cur.indexOf(' ' + cls + ' ') < 0) {
		              el.setAttribute('class', (cur + cls).trim());
		          }
		      }
		  }
		  /**
		   * Remove class with compatibility for SVG since classList is not supported on
		   * SVG elements in IE
		   */
		  function removeClass(el, cls) {
		      /* istanbul ignore if */
		      if (!cls || !(cls = cls.trim())) {
		          return;
		      }
		      /* istanbul ignore else */
		      if (el.classList) {
		          if (cls.indexOf(' ') > -1) {
		              cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.remove(c); });
		          }
		          else {
		              el.classList.remove(cls);
		          }
		          if (!el.classList.length) {
		              el.removeAttribute('class');
		          }
		      }
		      else {
		          var cur = " ".concat(el.getAttribute('class') || '', " ");
		          var tar = ' ' + cls + ' ';
		          while (cur.indexOf(tar) >= 0) {
		              cur = cur.replace(tar, ' ');
		          }
		          cur = cur.trim();
		          if (cur) {
		              el.setAttribute('class', cur);
		          }
		          else {
		              el.removeAttribute('class');
		          }
		      }
		  }

		  function resolveTransition(def) {
		      if (!def) {
		          return;
		      }
		      /* istanbul ignore else */
		      if (typeof def === 'object') {
		          var res = {};
		          if (def.css !== false) {
		              extend(res, autoCssTransition(def.name || 'v'));
		          }
		          extend(res, def);
		          return res;
		      }
		      else if (typeof def === 'string') {
		          return autoCssTransition(def);
		      }
		  }
		  var autoCssTransition = cached(function (name) {
		      return {
		          enterClass: "".concat(name, "-enter"),
		          enterToClass: "".concat(name, "-enter-to"),
		          enterActiveClass: "".concat(name, "-enter-active"),
		          leaveClass: "".concat(name, "-leave"),
		          leaveToClass: "".concat(name, "-leave-to"),
		          leaveActiveClass: "".concat(name, "-leave-active")
		      };
		  });
		  var hasTransition = inBrowser && !isIE9;
		  var TRANSITION = 'transition';
		  var ANIMATION = 'animation';
		  // Transition property/event sniffing
		  var transitionProp = 'transition';
		  var transitionEndEvent = 'transitionend';
		  var animationProp = 'animation';
		  var animationEndEvent = 'animationend';
		  if (hasTransition) {
		      /* istanbul ignore if */
		      if (window.ontransitionend === undefined &&
		          window.onwebkittransitionend !== undefined) {
		          transitionProp = 'WebkitTransition';
		          transitionEndEvent = 'webkitTransitionEnd';
		      }
		      if (window.onanimationend === undefined &&
		          window.onwebkitanimationend !== undefined) {
		          animationProp = 'WebkitAnimation';
		          animationEndEvent = 'webkitAnimationEnd';
		      }
		  }
		  // binding to window is necessary to make hot reload work in IE in strict mode
		  var raf = inBrowser
		      ? window.requestAnimationFrame
		          ? window.requestAnimationFrame.bind(window)
		          : setTimeout
		      : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };
		  function nextFrame(fn) {
		      raf(function () {
		          // @ts-expect-error
		          raf(fn);
		      });
		  }
		  function addTransitionClass(el, cls) {
		      var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
		      if (transitionClasses.indexOf(cls) < 0) {
		          transitionClasses.push(cls);
		          addClass(el, cls);
		      }
		  }
		  function removeTransitionClass(el, cls) {
		      if (el._transitionClasses) {
		          remove$2(el._transitionClasses, cls);
		      }
		      removeClass(el, cls);
		  }
		  function whenTransitionEnds(el, expectedType, cb) {
		      var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
		      if (!type)
		          return cb();
		      var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
		      var ended = 0;
		      var end = function () {
		          el.removeEventListener(event, onEnd);
		          cb();
		      };
		      var onEnd = function (e) {
		          if (e.target === el) {
		              if (++ended >= propCount) {
		                  end();
		              }
		          }
		      };
		      setTimeout(function () {
		          if (ended < propCount) {
		              end();
		          }
		      }, timeout + 1);
		      el.addEventListener(event, onEnd);
		  }
		  var transformRE = /\b(transform|all)(,|$)/;
		  function getTransitionInfo(el, expectedType) {
		      var styles = window.getComputedStyle(el);
		      // JSDOM may return undefined for transition properties
		      var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
		      var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
		      var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
		      var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
		      var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
		      var animationTimeout = getTimeout(animationDelays, animationDurations);
		      var type;
		      var timeout = 0;
		      var propCount = 0;
		      /* istanbul ignore if */
		      if (expectedType === TRANSITION) {
		          if (transitionTimeout > 0) {
		              type = TRANSITION;
		              timeout = transitionTimeout;
		              propCount = transitionDurations.length;
		          }
		      }
		      else if (expectedType === ANIMATION) {
		          if (animationTimeout > 0) {
		              type = ANIMATION;
		              timeout = animationTimeout;
		              propCount = animationDurations.length;
		          }
		      }
		      else {
		          timeout = Math.max(transitionTimeout, animationTimeout);
		          type =
		              timeout > 0
		                  ? transitionTimeout > animationTimeout
		                      ? TRANSITION
		                      : ANIMATION
		                  : null;
		          propCount = type
		              ? type === TRANSITION
		                  ? transitionDurations.length
		                  : animationDurations.length
		              : 0;
		      }
		      var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
		      return {
		          type: type,
		          timeout: timeout,
		          propCount: propCount,
		          hasTransform: hasTransform
		      };
		  }
		  function getTimeout(delays, durations) {
		      /* istanbul ignore next */
		      while (delays.length < durations.length) {
		          delays = delays.concat(delays);
		      }
		      return Math.max.apply(null, durations.map(function (d, i) {
		          return toMs(d) + toMs(delays[i]);
		      }));
		  }
		  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
		  // in a locale-dependent way, using a comma instead of a dot.
		  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
		  // as a floor function) causing unexpected behaviors
		  function toMs(s) {
		      return Number(s.slice(0, -1).replace(',', '.')) * 1000;
		  }

		  function enter(vnode, toggleDisplay) {
		      var el = vnode.elm;
		      // call leave callback now
		      if (isDef(el._leaveCb)) {
		          el._leaveCb.cancelled = true;
		          el._leaveCb();
		      }
		      var data = resolveTransition(vnode.data.transition);
		      if (isUndef(data)) {
		          return;
		      }
		      /* istanbul ignore if */
		      if (isDef(el._enterCb) || el.nodeType !== 1) {
		          return;
		      }
		      var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
		      // activeInstance will always be the <transition> component managing this
		      // transition. One edge case to check is when the <transition> is placed
		      // as the root node of a child component. In that case we need to check
		      // <transition>'s parent for appear check.
		      var context = activeInstance;
		      var transitionNode = activeInstance.$vnode;
		      while (transitionNode && transitionNode.parent) {
		          context = transitionNode.context;
		          transitionNode = transitionNode.parent;
		      }
		      var isAppear = !context._isMounted || !vnode.isRootInsert;
		      if (isAppear && !appear && appear !== '') {
		          return;
		      }
		      var startClass = isAppear && appearClass ? appearClass : enterClass;
		      var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
		      var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
		      var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
		      var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
		      var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
		      var enterCancelledHook = isAppear
		          ? appearCancelled || enterCancelled
		          : enterCancelled;
		      var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
		      if (explicitEnterDuration != null) {
		          checkDuration(explicitEnterDuration, 'enter', vnode);
		      }
		      var expectsCSS = css !== false && !isIE9;
		      var userWantsControl = getHookArgumentsLength(enterHook);
		      var cb = (el._enterCb = once(function () {
		          if (expectsCSS) {
		              removeTransitionClass(el, toClass);
		              removeTransitionClass(el, activeClass);
		          }
		          // @ts-expect-error
		          if (cb.cancelled) {
		              if (expectsCSS) {
		                  removeTransitionClass(el, startClass);
		              }
		              enterCancelledHook && enterCancelledHook(el);
		          }
		          else {
		              afterEnterHook && afterEnterHook(el);
		          }
		          el._enterCb = null;
		      }));
		      if (!vnode.data.show) {
		          // remove pending leave element on enter by injecting an insert hook
		          mergeVNodeHook(vnode, 'insert', function () {
		              var parent = el.parentNode;
		              var pendingNode = parent && parent._pending && parent._pending[vnode.key];
		              if (pendingNode &&
		                  pendingNode.tag === vnode.tag &&
		                  pendingNode.elm._leaveCb) {
		                  pendingNode.elm._leaveCb();
		              }
		              enterHook && enterHook(el, cb);
		          });
		      }
		      // start enter transition
		      beforeEnterHook && beforeEnterHook(el);
		      if (expectsCSS) {
		          addTransitionClass(el, startClass);
		          addTransitionClass(el, activeClass);
		          nextFrame(function () {
		              removeTransitionClass(el, startClass);
		              // @ts-expect-error
		              if (!cb.cancelled) {
		                  addTransitionClass(el, toClass);
		                  if (!userWantsControl) {
		                      if (isValidDuration(explicitEnterDuration)) {
		                          setTimeout(cb, explicitEnterDuration);
		                      }
		                      else {
		                          whenTransitionEnds(el, type, cb);
		                      }
		                  }
		              }
		          });
		      }
		      if (vnode.data.show) {
		          toggleDisplay && toggleDisplay();
		          enterHook && enterHook(el, cb);
		      }
		      if (!expectsCSS && !userWantsControl) {
		          cb();
		      }
		  }
		  function leave(vnode, rm) {
		      var el = vnode.elm;
		      // call enter callback now
		      if (isDef(el._enterCb)) {
		          el._enterCb.cancelled = true;
		          el._enterCb();
		      }
		      var data = resolveTransition(vnode.data.transition);
		      if (isUndef(data) || el.nodeType !== 1) {
		          return rm();
		      }
		      /* istanbul ignore if */
		      if (isDef(el._leaveCb)) {
		          return;
		      }
		      var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
		      var expectsCSS = css !== false && !isIE9;
		      var userWantsControl = getHookArgumentsLength(leave);
		      var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
		      if (isDef(explicitLeaveDuration)) {
		          checkDuration(explicitLeaveDuration, 'leave', vnode);
		      }
		      var cb = (el._leaveCb = once(function () {
		          if (el.parentNode && el.parentNode._pending) {
		              el.parentNode._pending[vnode.key] = null;
		          }
		          if (expectsCSS) {
		              removeTransitionClass(el, leaveToClass);
		              removeTransitionClass(el, leaveActiveClass);
		          }
		          // @ts-expect-error
		          if (cb.cancelled) {
		              if (expectsCSS) {
		                  removeTransitionClass(el, leaveClass);
		              }
		              leaveCancelled && leaveCancelled(el);
		          }
		          else {
		              rm();
		              afterLeave && afterLeave(el);
		          }
		          el._leaveCb = null;
		      }));
		      if (delayLeave) {
		          delayLeave(performLeave);
		      }
		      else {
		          performLeave();
		      }
		      function performLeave() {
		          // the delayed leave may have already been cancelled
		          // @ts-expect-error
		          if (cb.cancelled) {
		              return;
		          }
		          // record leaving element
		          if (!vnode.data.show && el.parentNode) {
		              (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
		                  vnode;
		          }
		          beforeLeave && beforeLeave(el);
		          if (expectsCSS) {
		              addTransitionClass(el, leaveClass);
		              addTransitionClass(el, leaveActiveClass);
		              nextFrame(function () {
		                  removeTransitionClass(el, leaveClass);
		                  // @ts-expect-error
		                  if (!cb.cancelled) {
		                      addTransitionClass(el, leaveToClass);
		                      if (!userWantsControl) {
		                          if (isValidDuration(explicitLeaveDuration)) {
		                              setTimeout(cb, explicitLeaveDuration);
		                          }
		                          else {
		                              whenTransitionEnds(el, type, cb);
		                          }
		                      }
		                  }
		              });
		          }
		          leave && leave(el, cb);
		          if (!expectsCSS && !userWantsControl) {
		              cb();
		          }
		      }
		  }
		  // only used in dev mode
		  function checkDuration(val, name, vnode) {
		      if (typeof val !== 'number') {
		          warn$2("<transition> explicit ".concat(name, " duration is not a valid number - ") +
		              "got ".concat(JSON.stringify(val), "."), vnode.context);
		      }
		      else if (isNaN(val)) {
		          warn$2("<transition> explicit ".concat(name, " duration is NaN - ") +
		              'the duration expression might be incorrect.', vnode.context);
		      }
		  }
		  function isValidDuration(val) {
		      return typeof val === 'number' && !isNaN(val);
		  }
		  /**
		   * Normalize a transition hook's argument length. The hook may be:
		   * - a merged hook (invoker) with the original in .fns
		   * - a wrapped component method (check ._length)
		   * - a plain function (.length)
		   */
		  function getHookArgumentsLength(fn) {
		      if (isUndef(fn)) {
		          return false;
		      }
		      // @ts-expect-error
		      var invokerFns = fn.fns;
		      if (isDef(invokerFns)) {
		          // invoker
		          return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
		      }
		      else {
		          // @ts-expect-error
		          return (fn._length || fn.length) > 1;
		      }
		  }
		  function _enter(_, vnode) {
		      if (vnode.data.show !== true) {
		          enter(vnode);
		      }
		  }
		  var transition = inBrowser
		      ? {
		          create: _enter,
		          activate: _enter,
		          remove: function (vnode, rm) {
		              /* istanbul ignore else */
		              if (vnode.data.show !== true) {
		                  // @ts-expect-error
		                  leave(vnode, rm);
		              }
		              else {
		                  rm();
		              }
		          }
		      }
		      : {};

		  var platformModules = [attrs, klass$1, events, domProps, style$1, transition];

		  // the directive module should be applied last, after all
		  // built-in modules have been applied.
		  var modules$1 = platformModules.concat(baseModules);
		  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 });

		  /**
		   * Not type checking this file because flow doesn't like attaching
		   * properties to Elements.
		   */
		  /* istanbul ignore if */
		  if (isIE9) {
		      // http://www.matts411.com/post/internet-explorer-9-oninput/
		      document.addEventListener('selectionchange', function () {
		          var el = document.activeElement;
		          // @ts-expect-error
		          if (el && el.vmodel) {
		              trigger(el, 'input');
		          }
		      });
		  }
		  var directive = {
		      inserted: function (el, binding, vnode, oldVnode) {
		          if (vnode.tag === 'select') {
		              // #6903
		              if (oldVnode.elm && !oldVnode.elm._vOptions) {
		                  mergeVNodeHook(vnode, 'postpatch', function () {
		                      directive.componentUpdated(el, binding, vnode);
		                  });
		              }
		              else {
		                  setSelected(el, binding, vnode.context);
		              }
		              el._vOptions = [].map.call(el.options, getValue);
		          }
		          else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
		              el._vModifiers = binding.modifiers;
		              if (!binding.modifiers.lazy) {
		                  el.addEventListener('compositionstart', onCompositionStart);
		                  el.addEventListener('compositionend', onCompositionEnd);
		                  // Safari < 10.2 & UIWebView doesn't fire compositionend when
		                  // switching focus before confirming composition choice
		                  // this also fixes the issue where some browsers e.g. iOS Chrome
		                  // fires "change" instead of "input" on autocomplete.
		                  el.addEventListener('change', onCompositionEnd);
		                  /* istanbul ignore if */
		                  if (isIE9) {
		                      el.vmodel = true;
		                  }
		              }
		          }
		      },
		      componentUpdated: function (el, binding, vnode) {
		          if (vnode.tag === 'select') {
		              setSelected(el, binding, vnode.context);
		              // in case the options rendered by v-for have changed,
		              // it's possible that the value is out-of-sync with the rendered options.
		              // detect such cases and filter out values that no longer has a matching
		              // option in the DOM.
		              var prevOptions_1 = el._vOptions;
		              var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));
		              if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {
		                  // trigger change event if
		                  // no matching option found for at least one value
		                  var needReset = el.multiple
		                      ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })
		                      : binding.value !== binding.oldValue &&
		                          hasNoMatchingOption(binding.value, curOptions_1);
		                  if (needReset) {
		                      trigger(el, 'change');
		                  }
		              }
		          }
		      }
		  };
		  function setSelected(el, binding, vm) {
		      actuallySetSelected(el, binding, vm);
		      /* istanbul ignore if */
		      if (isIE || isEdge) {
		          setTimeout(function () {
		              actuallySetSelected(el, binding, vm);
		          }, 0);
		      }
		  }
		  function actuallySetSelected(el, binding, vm) {
		      var value = binding.value;
		      var isMultiple = el.multiple;
		      if (isMultiple && !Array.isArray(value)) {
		          warn$2("<select multiple v-model=\"".concat(binding.expression, "\"> ") +
		                  "expects an Array value for its binding, but got ".concat(Object.prototype.toString
		                      .call(value)
		                      .slice(8, -1)), vm);
		          return;
		      }
		      var selected, option;
		      for (var i = 0, l = el.options.length; i < l; i++) {
		          option = el.options[i];
		          if (isMultiple) {
		              selected = looseIndexOf(value, getValue(option)) > -1;
		              if (option.selected !== selected) {
		                  option.selected = selected;
		              }
		          }
		          else {
		              if (looseEqual(getValue(option), value)) {
		                  if (el.selectedIndex !== i) {
		                      el.selectedIndex = i;
		                  }
		                  return;
		              }
		          }
		      }
		      if (!isMultiple) {
		          el.selectedIndex = -1;
		      }
		  }
		  function hasNoMatchingOption(value, options) {
		      return options.every(function (o) { return !looseEqual(o, value); });
		  }
		  function getValue(option) {
		      return '_value' in option ? option._value : option.value;
		  }
		  function onCompositionStart(e) {
		      e.target.composing = true;
		  }
		  function onCompositionEnd(e) {
		      // prevent triggering an input event for no reason
		      if (!e.target.composing)
		          return;
		      e.target.composing = false;
		      trigger(e.target, 'input');
		  }
		  function trigger(el, type) {
		      var e = document.createEvent('HTMLEvents');
		      e.initEvent(type, true, true);
		      el.dispatchEvent(e);
		  }

		  // recursively search for possible transition defined inside the component root
		  function locateNode(vnode) {
		      // @ts-expect-error
		      return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
		          ? locateNode(vnode.componentInstance._vnode)
		          : vnode;
		  }
		  var show = {
		      bind: function (el, _a, vnode) {
		          var value = _a.value;
		          vnode = locateNode(vnode);
		          var transition = vnode.data && vnode.data.transition;
		          var originalDisplay = (el.__vOriginalDisplay =
		              el.style.display === 'none' ? '' : el.style.display);
		          if (value && transition) {
		              vnode.data.show = true;
		              enter(vnode, function () {
		                  el.style.display = originalDisplay;
		              });
		          }
		          else {
		              el.style.display = value ? originalDisplay : 'none';
		          }
		      },
		      update: function (el, _a, vnode) {
		          var value = _a.value, oldValue = _a.oldValue;
		          /* istanbul ignore if */
		          if (!value === !oldValue)
		              return;
		          vnode = locateNode(vnode);
		          var transition = vnode.data && vnode.data.transition;
		          if (transition) {
		              vnode.data.show = true;
		              if (value) {
		                  enter(vnode, function () {
		                      el.style.display = el.__vOriginalDisplay;
		                  });
		              }
		              else {
		                  leave(vnode, function () {
		                      el.style.display = 'none';
		                  });
		              }
		          }
		          else {
		              el.style.display = value ? el.__vOriginalDisplay : 'none';
		          }
		      },
		      unbind: function (el, binding, vnode, oldVnode, isDestroy) {
		          if (!isDestroy) {
		              el.style.display = el.__vOriginalDisplay;
		          }
		      }
		  };

		  var platformDirectives = {
		      model: directive,
		      show: show
		  };

		  // Provides transition support for a single element/component.
		  var transitionProps = {
		      name: String,
		      appear: Boolean,
		      css: Boolean,
		      mode: String,
		      type: String,
		      enterClass: String,
		      leaveClass: String,
		      enterToClass: String,
		      leaveToClass: String,
		      enterActiveClass: String,
		      leaveActiveClass: String,
		      appearClass: String,
		      appearActiveClass: String,
		      appearToClass: String,
		      duration: [Number, String, Object]
		  };
		  // in case the child is also an abstract component, e.g. <keep-alive>
		  // we want to recursively retrieve the real component to be rendered
		  function getRealChild(vnode) {
		      var compOptions = vnode && vnode.componentOptions;
		      if (compOptions && compOptions.Ctor.options.abstract) {
		          return getRealChild(getFirstComponentChild(compOptions.children));
		      }
		      else {
		          return vnode;
		      }
		  }
		  function extractTransitionData(comp) {
		      var data = {};
		      var options = comp.$options;
		      // props
		      for (var key in options.propsData) {
		          data[key] = comp[key];
		      }
		      // events.
		      // extract listeners and pass them directly to the transition methods
		      var listeners = options._parentListeners;
		      for (var key in listeners) {
		          data[camelize(key)] = listeners[key];
		      }
		      return data;
		  }
		  function placeholder(h, rawChild) {
		      // @ts-expect-error
		      if (/\d-keep-alive$/.test(rawChild.tag)) {
		          return h('keep-alive', {
		              props: rawChild.componentOptions.propsData
		          });
		      }
		  }
		  function hasParentTransition(vnode) {
		      while ((vnode = vnode.parent)) {
		          if (vnode.data.transition) {
		              return true;
		          }
		      }
		  }
		  function isSameChild(child, oldChild) {
		      return oldChild.key === child.key && oldChild.tag === child.tag;
		  }
		  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };
		  var isVShowDirective = function (d) { return d.name === 'show'; };
		  var Transition = {
		      name: 'transition',
		      props: transitionProps,
		      abstract: true,
		      render: function (h) {
		          var _this = this;
		          var children = this.$slots.default;
		          if (!children) {
		              return;
		          }
		          // filter out text nodes (possible whitespaces)
		          children = children.filter(isNotTextNode);
		          /* istanbul ignore if */
		          if (!children.length) {
		              return;
		          }
		          // warn multiple elements
		          if (children.length > 1) {
		              warn$2('<transition> can only be used on a single element. Use ' +
		                  '<transition-group> for lists.', this.$parent);
		          }
		          var mode = this.mode;
		          // warn invalid mode
		          if (mode && mode !== 'in-out' && mode !== 'out-in') {
		              warn$2('invalid <transition> mode: ' + mode, this.$parent);
		          }
		          var rawChild = children[0];
		          // if this is a component root node and the component's
		          // parent container node also has transition, skip.
		          if (hasParentTransition(this.$vnode)) {
		              return rawChild;
		          }
		          // apply transition data to child
		          // use getRealChild() to ignore abstract components e.g. keep-alive
		          var child = getRealChild(rawChild);
		          /* istanbul ignore if */
		          if (!child) {
		              return rawChild;
		          }
		          if (this._leaving) {
		              return placeholder(h, rawChild);
		          }
		          // ensure a key that is unique to the vnode type and to this transition
		          // component instance. This key will be used to remove pending leaving nodes
		          // during entering.
		          var id = "__transition-".concat(this._uid, "-");
		          child.key =
		              child.key == null
		                  ? child.isComment
		                      ? id + 'comment'
		                      : id + child.tag
		                  : isPrimitive(child.key)
		                      ? String(child.key).indexOf(id) === 0
		                          ? child.key
		                          : id + child.key
		                      : child.key;
		          var data = ((child.data || (child.data = {})).transition =
		              extractTransitionData(this));
		          var oldRawChild = this._vnode;
		          var oldChild = getRealChild(oldRawChild);
		          // mark v-show
		          // so that the transition module can hand over the control to the directive
		          if (child.data.directives && child.data.directives.some(isVShowDirective)) {
		              child.data.show = true;
		          }
		          if (oldChild &&
		              oldChild.data &&
		              !isSameChild(child, oldChild) &&
		              !isAsyncPlaceholder(oldChild) &&
		              // #6687 component root is a comment node
		              !(oldChild.componentInstance &&
		                  oldChild.componentInstance._vnode.isComment)) {
		              // replace old child transition data with fresh one
		              // important for dynamic transitions!
		              var oldData = (oldChild.data.transition = extend({}, data));
		              // handle transition mode
		              if (mode === 'out-in') {
		                  // return placeholder node and queue update when leave finishes
		                  this._leaving = true;
		                  mergeVNodeHook(oldData, 'afterLeave', function () {
		                      _this._leaving = false;
		                      _this.$forceUpdate();
		                  });
		                  return placeholder(h, rawChild);
		              }
		              else if (mode === 'in-out') {
		                  if (isAsyncPlaceholder(child)) {
		                      return oldRawChild;
		                  }
		                  var delayedLeave_1;
		                  var performLeave = function () {
		                      delayedLeave_1();
		                  };
		                  mergeVNodeHook(data, 'afterEnter', performLeave);
		                  mergeVNodeHook(data, 'enterCancelled', performLeave);
		                  mergeVNodeHook(oldData, 'delayLeave', function (leave) {
		                      delayedLeave_1 = leave;
		                  });
		              }
		          }
		          return rawChild;
		      }
		  };

		  // Provides transition support for list items.
		  var props = extend({
		      tag: String,
		      moveClass: String
		  }, transitionProps);
		  delete props.mode;
		  var TransitionGroup = {
		      props: props,
		      beforeMount: function () {
		          var _this = this;
		          var update = this._update;
		          this._update = function (vnode, hydrating) {
		              var restoreActiveInstance = setActiveInstance(_this);
		              // force removing pass
		              _this.__patch__(_this._vnode, _this.kept, false, // hydrating
		              true // removeOnly (!important, avoids unnecessary moves)
		              );
		              _this._vnode = _this.kept;
		              restoreActiveInstance();
		              update.call(_this, vnode, hydrating);
		          };
		      },
		      render: function (h) {
		          var tag = this.tag || this.$vnode.data.tag || 'span';
		          var map = Object.create(null);
		          var prevChildren = (this.prevChildren = this.children);
		          var rawChildren = this.$slots.default || [];
		          var children = (this.children = []);
		          var transitionData = extractTransitionData(this);
		          for (var i = 0; i < rawChildren.length; i++) {
		              var c = rawChildren[i];
		              if (c.tag) {
		                  if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
		                      children.push(c);
		                      map[c.key] = c;
		                      (c.data || (c.data = {})).transition = transitionData;
		                  }
		                  else {
		                      var opts = c.componentOptions;
		                      var name_1 = opts
		                          ? getComponentName(opts.Ctor.options) || opts.tag || ''
		                          : c.tag;
		                      warn$2("<transition-group> children must be keyed: <".concat(name_1, ">"));
		                  }
		              }
		          }
		          if (prevChildren) {
		              var kept = [];
		              var removed = [];
		              for (var i = 0; i < prevChildren.length; i++) {
		                  var c = prevChildren[i];
		                  c.data.transition = transitionData;
		                  // @ts-expect-error .getBoundingClientRect is not typed in Node
		                  c.data.pos = c.elm.getBoundingClientRect();
		                  if (map[c.key]) {
		                      kept.push(c);
		                  }
		                  else {
		                      removed.push(c);
		                  }
		              }
		              this.kept = h(tag, null, kept);
		              this.removed = removed;
		          }
		          return h(tag, null, children);
		      },
		      updated: function () {
		          var children = this.prevChildren;
		          var moveClass = this.moveClass || (this.name || 'v') + '-move';
		          if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
		              return;
		          }
		          // we divide the work into three loops to avoid mixing DOM reads and writes
		          // in each iteration - which helps prevent layout thrashing.
		          children.forEach(callPendingCbs);
		          children.forEach(recordPosition);
		          children.forEach(applyTranslation);
		          // force reflow to put everything in position
		          // assign to this to avoid being removed in tree-shaking
		          // $flow-disable-line
		          this._reflow = document.body.offsetHeight;
		          children.forEach(function (c) {
		              if (c.data.moved) {
		                  var el_1 = c.elm;
		                  var s = el_1.style;
		                  addTransitionClass(el_1, moveClass);
		                  s.transform = s.WebkitTransform = s.transitionDuration = '';
		                  el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {
		                      if (e && e.target !== el_1) {
		                          return;
		                      }
		                      if (!e || /transform$/.test(e.propertyName)) {
		                          el_1.removeEventListener(transitionEndEvent, cb);
		                          el_1._moveCb = null;
		                          removeTransitionClass(el_1, moveClass);
		                      }
		                  }));
		              }
		          });
		      },
		      methods: {
		          hasMove: function (el, moveClass) {
		              /* istanbul ignore if */
		              if (!hasTransition) {
		                  return false;
		              }
		              /* istanbul ignore if */
		              if (this._hasMove) {
		                  return this._hasMove;
		              }
		              // Detect whether an element with the move class applied has
		              // CSS transitions. Since the element may be inside an entering
		              // transition at this very moment, we make a clone of it and remove
		              // all other transition classes applied to ensure only the move class
		              // is applied.
		              var clone = el.cloneNode();
		              if (el._transitionClasses) {
		                  el._transitionClasses.forEach(function (cls) {
		                      removeClass(clone, cls);
		                  });
		              }
		              addClass(clone, moveClass);
		              clone.style.display = 'none';
		              this.$el.appendChild(clone);
		              var info = getTransitionInfo(clone);
		              this.$el.removeChild(clone);
		              return (this._hasMove = info.hasTransform);
		          }
		      }
		  };
		  function callPendingCbs(c) {
		      /* istanbul ignore if */
		      if (c.elm._moveCb) {
		          c.elm._moveCb();
		      }
		      /* istanbul ignore if */
		      if (c.elm._enterCb) {
		          c.elm._enterCb();
		      }
		  }
		  function recordPosition(c) {
		      c.data.newPos = c.elm.getBoundingClientRect();
		  }
		  function applyTranslation(c) {
		      var oldPos = c.data.pos;
		      var newPos = c.data.newPos;
		      var dx = oldPos.left - newPos.left;
		      var dy = oldPos.top - newPos.top;
		      if (dx || dy) {
		          c.data.moved = true;
		          var s = c.elm.style;
		          s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
		          s.transitionDuration = '0s';
		      }
		  }

		  var platformComponents = {
		      Transition: Transition,
		      TransitionGroup: TransitionGroup
		  };

		  // install platform specific utils
		  Vue.config.mustUseProp = mustUseProp;
		  Vue.config.isReservedTag = isReservedTag;
		  Vue.config.isReservedAttr = isReservedAttr;
		  Vue.config.getTagNamespace = getTagNamespace;
		  Vue.config.isUnknownElement = isUnknownElement;
		  // install platform runtime directives & components
		  extend(Vue.options.directives, platformDirectives);
		  extend(Vue.options.components, platformComponents);
		  // install platform patch function
		  Vue.prototype.__patch__ = inBrowser ? patch : noop;
		  // public mount method
		  Vue.prototype.$mount = function (el, hydrating) {
		      el = el && inBrowser ? query(el) : undefined;
		      return mountComponent(this, el, hydrating);
		  };
		  // devtools global hook
		  /* istanbul ignore next */
		  if (inBrowser) {
		      setTimeout(function () {
		          if (config.devtools) {
		              if (devtools) {
		                  devtools.emit('init', Vue);
		              }
		              else {
		                  // @ts-expect-error
		                  console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
		                      'https://github.com/vuejs/vue-devtools');
		              }
		          }
		          if (config.productionTip !== false &&
		              typeof console !== 'undefined') {
		              // @ts-expect-error
		              console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" +
		                  "Make sure to turn on production mode when deploying for production.\n" +
		                  "See more tips at https://vuejs.org/guide/deployment.html");
		          }
		      }, 0);
		  }

		  var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
		  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
		  var buildRegex = cached(function (delimiters) {
		      var open = delimiters[0].replace(regexEscapeRE, '\\$&');
		      var close = delimiters[1].replace(regexEscapeRE, '\\$&');
		      return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
		  });
		  function parseText(text, delimiters) {
		      //@ts-expect-error
		      var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
		      if (!tagRE.test(text)) {
		          return;
		      }
		      var tokens = [];
		      var rawTokens = [];
		      var lastIndex = (tagRE.lastIndex = 0);
		      var match, index, tokenValue;
		      while ((match = tagRE.exec(text))) {
		          index = match.index;
		          // push text token
		          if (index > lastIndex) {
		              rawTokens.push((tokenValue = text.slice(lastIndex, index)));
		              tokens.push(JSON.stringify(tokenValue));
		          }
		          // tag token
		          var exp = parseFilters(match[1].trim());
		          tokens.push("_s(".concat(exp, ")"));
		          rawTokens.push({ '@binding': exp });
		          lastIndex = index + match[0].length;
		      }
		      if (lastIndex < text.length) {
		          rawTokens.push((tokenValue = text.slice(lastIndex)));
		          tokens.push(JSON.stringify(tokenValue));
		      }
		      return {
		          expression: tokens.join('+'),
		          tokens: rawTokens
		      };
		  }

		  function transformNode$1(el, options) {
		      var warn = options.warn || baseWarn;
		      var staticClass = getAndRemoveAttr(el, 'class');
		      if (staticClass) {
		          var res = parseText(staticClass, options.delimiters);
		          if (res) {
		              warn("class=\"".concat(staticClass, "\": ") +
		                  'Interpolation inside attributes has been removed. ' +
		                  'Use v-bind or the colon shorthand instead. For example, ' +
		                  'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
		          }
		      }
		      if (staticClass) {
		          el.staticClass = JSON.stringify(staticClass.replace(/\s+/g, ' ').trim());
		      }
		      var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
		      if (classBinding) {
		          el.classBinding = classBinding;
		      }
		  }
		  function genData$2(el) {
		      var data = '';
		      if (el.staticClass) {
		          data += "staticClass:".concat(el.staticClass, ",");
		      }
		      if (el.classBinding) {
		          data += "class:".concat(el.classBinding, ",");
		      }
		      return data;
		  }
		  var klass = {
		      staticKeys: ['staticClass'],
		      transformNode: transformNode$1,
		      genData: genData$2
		  };

		  function transformNode(el, options) {
		      var warn = options.warn || baseWarn;
		      var staticStyle = getAndRemoveAttr(el, 'style');
		      if (staticStyle) {
		          /* istanbul ignore if */
		          {
		              var res = parseText(staticStyle, options.delimiters);
		              if (res) {
		                  warn("style=\"".concat(staticStyle, "\": ") +
		                      'Interpolation inside attributes has been removed. ' +
		                      'Use v-bind or the colon shorthand instead. For example, ' +
		                      'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
		              }
		          }
		          el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
		      }
		      var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
		      if (styleBinding) {
		          el.styleBinding = styleBinding;
		      }
		  }
		  function genData$1(el) {
		      var data = '';
		      if (el.staticStyle) {
		          data += "staticStyle:".concat(el.staticStyle, ",");
		      }
		      if (el.styleBinding) {
		          data += "style:(".concat(el.styleBinding, "),");
		      }
		      return data;
		  }
		  var style = {
		      staticKeys: ['staticStyle'],
		      transformNode: transformNode,
		      genData: genData$1
		  };

		  var decoder;
		  var he = {
		      decode: function (html) {
		          decoder = decoder || document.createElement('div');
		          decoder.innerHTML = html;
		          return decoder.textContent;
		      }
		  };

		  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
		      'link,meta,param,source,track,wbr');
		  // Elements that you can, intentionally, leave open
		  // (and which close themselves)
		  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
		  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
		  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
		  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
		      'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
		      'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
		      'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
		      'title,tr,track');

		  /**
		   * Not type-checking this file because it's mostly vendor code.
		   */
		  // Regular Expressions for parsing tags and attributes
		  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
		  var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
		  var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(unicodeRegExp.source, "]*");
		  var qnameCapture = "((?:".concat(ncname, "\\:)?").concat(ncname, ")");
		  var startTagOpen = new RegExp("^<".concat(qnameCapture));
		  var startTagClose = /^\s*(\/?)>/;
		  var endTag = new RegExp("^<\\/".concat(qnameCapture, "[^>]*>"));
		  var doctype = /^<!DOCTYPE [^>]+>/i;
		  // #7298: escape - to avoid being passed as HTML comment when inlined in page
		  var comment = /^<!\--/;
		  var conditionalComment = /^<!\[/;
		  // Special Elements (can contain anything)
		  var isPlainTextElement = makeMap('script,style,textarea', true);
		  var reCache = {};
		  var decodingMap = {
		      '&lt;': '<',
		      '&gt;': '>',
		      '&quot;': '"',
		      '&amp;': '&',
		      '&#10;': '\n',
		      '&#9;': '\t',
		      '&#39;': "'"
		  };
		  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
		  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
		  // #5992
		  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
		  var shouldIgnoreFirstNewline = function (tag, html) {
		      return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
		  };
		  function decodeAttr(value, shouldDecodeNewlines) {
		      var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
		      return value.replace(re, function (match) { return decodingMap[match]; });
		  }
		  function parseHTML(html, options) {
		      var stack = [];
		      var expectHTML = options.expectHTML;
		      var isUnaryTag = options.isUnaryTag || no;
		      var canBeLeftOpenTag = options.canBeLeftOpenTag || no;
		      var index = 0;
		      var last, lastTag;
		      var _loop_1 = function () {
		          last = html;
		          // Make sure we're not in a plaintext content element like script/style
		          if (!lastTag || !isPlainTextElement(lastTag)) {
		              var textEnd = html.indexOf('<');
		              if (textEnd === 0) {
		                  // Comment:
		                  if (comment.test(html)) {
		                      var commentEnd = html.indexOf('-->');
		                      if (commentEnd >= 0) {
		                          if (options.shouldKeepComment && options.comment) {
		                              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
		                          }
		                          advance(commentEnd + 3);
		                          return "continue";
		                      }
		                  }
		                  // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
		                  if (conditionalComment.test(html)) {
		                      var conditionalEnd = html.indexOf(']>');
		                      if (conditionalEnd >= 0) {
		                          advance(conditionalEnd + 2);
		                          return "continue";
		                      }
		                  }
		                  // Doctype:
		                  var doctypeMatch = html.match(doctype);
		                  if (doctypeMatch) {
		                      advance(doctypeMatch[0].length);
		                      return "continue";
		                  }
		                  // End tag:
		                  var endTagMatch = html.match(endTag);
		                  if (endTagMatch) {
		                      var curIndex = index;
		                      advance(endTagMatch[0].length);
		                      parseEndTag(endTagMatch[1], curIndex, index);
		                      return "continue";
		                  }
		                  // Start tag:
		                  var startTagMatch = parseStartTag();
		                  if (startTagMatch) {
		                      handleStartTag(startTagMatch);
		                      if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
		                          advance(1);
		                      }
		                      return "continue";
		                  }
		              }
		              var text = void 0, rest = void 0, next = void 0;
		              if (textEnd >= 0) {
		                  rest = html.slice(textEnd);
		                  while (!endTag.test(rest) &&
		                      !startTagOpen.test(rest) &&
		                      !comment.test(rest) &&
		                      !conditionalComment.test(rest)) {
		                      // < in plain text, be forgiving and treat it as text
		                      next = rest.indexOf('<', 1);
		                      if (next < 0)
		                          break;
		                      textEnd += next;
		                      rest = html.slice(textEnd);
		                  }
		                  text = html.substring(0, textEnd);
		              }
		              if (textEnd < 0) {
		                  text = html;
		              }
		              if (text) {
		                  advance(text.length);
		              }
		              if (options.chars && text) {
		                  options.chars(text, index - text.length, index);
		              }
		          }
		          else {
		              var endTagLength_1 = 0;
		              var stackedTag_1 = lastTag.toLowerCase();
		              var reStackedTag = reCache[stackedTag_1] ||
		                  (reCache[stackedTag_1] = new RegExp('([\\s\\S]*?)(</' + stackedTag_1 + '[^>]*>)', 'i'));
		              var rest = html.replace(reStackedTag, function (all, text, endTag) {
		                  endTagLength_1 = endTag.length;
		                  if (!isPlainTextElement(stackedTag_1) && stackedTag_1 !== 'noscript') {
		                      text = text
		                          .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
		                          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
		                  }
		                  if (shouldIgnoreFirstNewline(stackedTag_1, text)) {
		                      text = text.slice(1);
		                  }
		                  if (options.chars) {
		                      options.chars(text);
		                  }
		                  return '';
		              });
		              index += html.length - rest.length;
		              html = rest;
		              parseEndTag(stackedTag_1, index - endTagLength_1, index);
		          }
		          if (html === last) {
		              options.chars && options.chars(html);
		              if (!stack.length && options.warn) {
		                  options.warn("Mal-formatted tag at end of template: \"".concat(html, "\""), {
		                      start: index + html.length
		                  });
		              }
		              return "break";
		          }
		      };
		      while (html) {
		          var state_1 = _loop_1();
		          if (state_1 === "break")
		              break;
		      }
		      // Clean up any remaining tags
		      parseEndTag();
		      function advance(n) {
		          index += n;
		          html = html.substring(n);
		      }
		      function parseStartTag() {
		          var start = html.match(startTagOpen);
		          if (start) {
		              var match = {
		                  tagName: start[1],
		                  attrs: [],
		                  start: index
		              };
		              advance(start[0].length);
		              var end = void 0, attr = void 0;
		              while (!(end = html.match(startTagClose)) &&
		                  (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
		                  attr.start = index;
		                  advance(attr[0].length);
		                  attr.end = index;
		                  match.attrs.push(attr);
		              }
		              if (end) {
		                  match.unarySlash = end[1];
		                  advance(end[0].length);
		                  match.end = index;
		                  return match;
		              }
		          }
		      }
		      function handleStartTag(match) {
		          var tagName = match.tagName;
		          var unarySlash = match.unarySlash;
		          if (expectHTML) {
		              if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
		                  parseEndTag(lastTag);
		              }
		              if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
		                  parseEndTag(tagName);
		              }
		          }
		          var unary = isUnaryTag(tagName) || !!unarySlash;
		          var l = match.attrs.length;
		          var attrs = new Array(l);
		          for (var i = 0; i < l; i++) {
		              var args = match.attrs[i];
		              var value = args[3] || args[4] || args[5] || '';
		              var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
		                  ? options.shouldDecodeNewlinesForHref
		                  : options.shouldDecodeNewlines;
		              attrs[i] = {
		                  name: args[1],
		                  value: decodeAttr(value, shouldDecodeNewlines)
		              };
		              if (options.outputSourceRange) {
		                  attrs[i].start = args.start + args[0].match(/^\s*/).length;
		                  attrs[i].end = args.end;
		              }
		          }
		          if (!unary) {
		              stack.push({
		                  tag: tagName,
		                  lowerCasedTag: tagName.toLowerCase(),
		                  attrs: attrs,
		                  start: match.start,
		                  end: match.end
		              });
		              lastTag = tagName;
		          }
		          if (options.start) {
		              options.start(tagName, attrs, unary, match.start, match.end);
		          }
		      }
		      function parseEndTag(tagName, start, end) {
		          var pos, lowerCasedTagName;
		          if (start == null)
		              start = index;
		          if (end == null)
		              end = index;
		          // Find the closest opened tag of the same type
		          if (tagName) {
		              lowerCasedTagName = tagName.toLowerCase();
		              for (pos = stack.length - 1; pos >= 0; pos--) {
		                  if (stack[pos].lowerCasedTag === lowerCasedTagName) {
		                      break;
		                  }
		              }
		          }
		          else {
		              // If no tag name is provided, clean shop
		              pos = 0;
		          }
		          if (pos >= 0) {
		              // Close all the open elements, up the stack
		              for (var i = stack.length - 1; i >= pos; i--) {
		                  if ((i > pos || !tagName) && options.warn) {
		                      options.warn("tag <".concat(stack[i].tag, "> has no matching end tag."), {
		                          start: stack[i].start,
		                          end: stack[i].end
		                      });
		                  }
		                  if (options.end) {
		                      options.end(stack[i].tag, start, end);
		                  }
		              }
		              // Remove the open elements from the stack
		              stack.length = pos;
		              lastTag = pos && stack[pos - 1].tag;
		          }
		          else if (lowerCasedTagName === 'br') {
		              if (options.start) {
		                  options.start(tagName, [], true, start, end);
		              }
		          }
		          else if (lowerCasedTagName === 'p') {
		              if (options.start) {
		                  options.start(tagName, [], false, start, end);
		              }
		              if (options.end) {
		                  options.end(tagName, start, end);
		              }
		          }
		      }
		  }

		  var onRE = /^@|^v-on:/;
		  var dirRE = /^v-|^@|^:|^#/;
		  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
		  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
		  var stripParensRE = /^\(|\)$/g;
		  var dynamicArgRE = /^\[.*\]$/;
		  var argRE = /:(.*)$/;
		  var bindRE = /^:|^\.|^v-bind:/;
		  var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
		  var slotRE = /^v-slot(:|$)|^#/;
		  var lineBreakRE = /[\r\n]/;
		  var whitespaceRE = /[ \f\t\r\n]+/g;
		  var invalidAttributeRE = /[\s"'<>\/=]/;
		  var decodeHTMLCached = cached(he.decode);
		  var emptySlotScopeToken = "_empty_";
		  // configurable state
		  var warn;
		  var delimiters;
		  var transforms;
		  var preTransforms;
		  var postTransforms;
		  var platformIsPreTag;
		  var platformMustUseProp;
		  var platformGetTagNamespace;
		  var maybeComponent;
		  function createASTElement(tag, attrs, parent) {
		      return {
		          type: 1,
		          tag: tag,
		          attrsList: attrs,
		          attrsMap: makeAttrsMap(attrs),
		          rawAttrsMap: {},
		          parent: parent,
		          children: []
		      };
		  }
		  /**
		   * Convert HTML string to AST.
		   */
		  function parse(template, options) {
		      warn = options.warn || baseWarn;
		      platformIsPreTag = options.isPreTag || no;
		      platformMustUseProp = options.mustUseProp || no;
		      platformGetTagNamespace = options.getTagNamespace || no;
		      var isReservedTag = options.isReservedTag || no;
		      maybeComponent = function (el) {
		          return !!(el.component ||
		              el.attrsMap[':is'] ||
		              el.attrsMap['v-bind:is'] ||
		              !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));
		      };
		      transforms = pluckModuleFunction(options.modules, 'transformNode');
		      preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
		      postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
		      delimiters = options.delimiters;
		      var stack = [];
		      var preserveWhitespace = options.preserveWhitespace !== false;
		      var whitespaceOption = options.whitespace;
		      var root;
		      var currentParent;
		      var inVPre = false;
		      var inPre = false;
		      var warned = false;
		      function warnOnce(msg, range) {
		          if (!warned) {
		              warned = true;
		              warn(msg, range);
		          }
		      }
		      function closeElement(element) {
		          trimEndingWhitespace(element);
		          if (!inVPre && !element.processed) {
		              element = processElement(element, options);
		          }
		          // tree management
		          if (!stack.length && element !== root) {
		              // allow root elements with v-if, v-else-if and v-else
		              if (root.if && (element.elseif || element.else)) {
		                  {
		                      checkRootConstraints(element);
		                  }
		                  addIfCondition(root, {
		                      exp: element.elseif,
		                      block: element
		                  });
		              }
		              else {
		                  warnOnce("Component template should contain exactly one root element. " +
		                      "If you are using v-if on multiple elements, " +
		                      "use v-else-if to chain them instead.", { start: element.start });
		              }
		          }
		          if (currentParent && !element.forbidden) {
		              if (element.elseif || element.else) {
		                  processIfConditions(element, currentParent);
		              }
		              else {
		                  if (element.slotScope) {
		                      // scoped slot
		                      // keep it in the children list so that v-else(-if) conditions can
		                      // find it as the prev node.
		                      var name_1 = element.slotTarget || '"default"';
		                      (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name_1] = element;
		                  }
		                  currentParent.children.push(element);
		                  element.parent = currentParent;
		              }
		          }
		          // final children cleanup
		          // filter out scoped slots
		          element.children = element.children.filter(function (c) { return !c.slotScope; });
		          // remove trailing whitespace node again
		          trimEndingWhitespace(element);
		          // check pre state
		          if (element.pre) {
		              inVPre = false;
		          }
		          if (platformIsPreTag(element.tag)) {
		              inPre = false;
		          }
		          // apply post-transforms
		          for (var i = 0; i < postTransforms.length; i++) {
		              postTransforms[i](element, options);
		          }
		      }
		      function trimEndingWhitespace(el) {
		          // remove trailing whitespace node
		          if (!inPre) {
		              var lastNode = void 0;
		              while ((lastNode = el.children[el.children.length - 1]) &&
		                  lastNode.type === 3 &&
		                  lastNode.text === ' ') {
		                  el.children.pop();
		              }
		          }
		      }
		      function checkRootConstraints(el) {
		          if (el.tag === 'slot' || el.tag === 'template') {
		              warnOnce("Cannot use <".concat(el.tag, "> as component root element because it may ") +
		                  'contain multiple nodes.', { start: el.start });
		          }
		          if (el.attrsMap.hasOwnProperty('v-for')) {
		              warnOnce('Cannot use v-for on stateful component root element because ' +
		                  'it renders multiple elements.', el.rawAttrsMap['v-for']);
		          }
		      }
		      parseHTML(template, {
		          warn: warn,
		          expectHTML: options.expectHTML,
		          isUnaryTag: options.isUnaryTag,
		          canBeLeftOpenTag: options.canBeLeftOpenTag,
		          shouldDecodeNewlines: options.shouldDecodeNewlines,
		          shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
		          shouldKeepComment: options.comments,
		          outputSourceRange: options.outputSourceRange,
		          start: function (tag, attrs, unary, start, end) {
		              // check namespace.
		              // inherit parent ns if there is one
		              var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
		              // handle IE svg bug
		              /* istanbul ignore if */
		              if (isIE && ns === 'svg') {
		                  attrs = guardIESVGBug(attrs);
		              }
		              var element = createASTElement(tag, attrs, currentParent);
		              if (ns) {
		                  element.ns = ns;
		              }
		              {
		                  if (options.outputSourceRange) {
		                      element.start = start;
		                      element.end = end;
		                      element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
		                          cumulated[attr.name] = attr;
		                          return cumulated;
		                      }, {});
		                  }
		                  attrs.forEach(function (attr) {
		                      if (invalidAttributeRE.test(attr.name)) {
		                          warn("Invalid dynamic argument expression: attribute names cannot contain " +
		                              "spaces, quotes, <, >, / or =.", options.outputSourceRange
		                              ? {
		                                  start: attr.start + attr.name.indexOf("["),
		                                  end: attr.start + attr.name.length
		                              }
		                              : undefined);
		                      }
		                  });
		              }
		              if (isForbiddenTag(element) && !isServerRendering()) {
		                  element.forbidden = true;
		                  warn('Templates should only be responsible for mapping the state to the ' +
		                          'UI. Avoid placing tags with side-effects in your templates, such as ' +
		                          "<".concat(tag, ">") +
		                          ', as they will not be parsed.', { start: element.start });
		              }
		              // apply pre-transforms
		              for (var i = 0; i < preTransforms.length; i++) {
		                  element = preTransforms[i](element, options) || element;
		              }
		              if (!inVPre) {
		                  processPre(element);
		                  if (element.pre) {
		                      inVPre = true;
		                  }
		              }
		              if (platformIsPreTag(element.tag)) {
		                  inPre = true;
		              }
		              if (inVPre) {
		                  processRawAttrs(element);
		              }
		              else if (!element.processed) {
		                  // structural directives
		                  processFor(element);
		                  processIf(element);
		                  processOnce(element);
		              }
		              if (!root) {
		                  root = element;
		                  {
		                      checkRootConstraints(root);
		                  }
		              }
		              if (!unary) {
		                  currentParent = element;
		                  stack.push(element);
		              }
		              else {
		                  closeElement(element);
		              }
		          },
		          end: function (tag, start, end) {
		              var element = stack[stack.length - 1];
		              // pop stack
		              stack.length -= 1;
		              currentParent = stack[stack.length - 1];
		              if (options.outputSourceRange) {
		                  element.end = end;
		              }
		              closeElement(element);
		          },
		          chars: function (text, start, end) {
		              if (!currentParent) {
		                  {
		                      if (text === template) {
		                          warnOnce('Component template requires a root element, rather than just text.', { start: start });
		                      }
		                      else if ((text = text.trim())) {
		                          warnOnce("text \"".concat(text, "\" outside root element will be ignored."), {
		                              start: start
		                          });
		                      }
		                  }
		                  return;
		              }
		              // IE textarea placeholder bug
		              /* istanbul ignore if */
		              if (isIE &&
		                  currentParent.tag === 'textarea' &&
		                  currentParent.attrsMap.placeholder === text) {
		                  return;
		              }
		              var children = currentParent.children;
		              if (inPre || text.trim()) {
		                  text = isTextTag(currentParent)
		                      ? text
		                      : decodeHTMLCached(text);
		              }
		              else if (!children.length) {
		                  // remove the whitespace-only node right after an opening tag
		                  text = '';
		              }
		              else if (whitespaceOption) {
		                  if (whitespaceOption === 'condense') {
		                      // in condense mode, remove the whitespace node if it contains
		                      // line break, otherwise condense to a single space
		                      text = lineBreakRE.test(text) ? '' : ' ';
		                  }
		                  else {
		                      text = ' ';
		                  }
		              }
		              else {
		                  text = preserveWhitespace ? ' ' : '';
		              }
		              if (text) {
		                  if (!inPre && whitespaceOption === 'condense') {
		                      // condense consecutive whitespaces into single space
		                      text = text.replace(whitespaceRE, ' ');
		                  }
		                  var res = void 0;
		                  var child = void 0;
		                  if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
		                      child = {
		                          type: 2,
		                          expression: res.expression,
		                          tokens: res.tokens,
		                          text: text
		                      };
		                  }
		                  else if (text !== ' ' ||
		                      !children.length ||
		                      children[children.length - 1].text !== ' ') {
		                      child = {
		                          type: 3,
		                          text: text
		                      };
		                  }
		                  if (child) {
		                      if (options.outputSourceRange) {
		                          child.start = start;
		                          child.end = end;
		                      }
		                      children.push(child);
		                  }
		              }
		          },
		          comment: function (text, start, end) {
		              // adding anything as a sibling to the root node is forbidden
		              // comments should still be allowed, but ignored
		              if (currentParent) {
		                  var child = {
		                      type: 3,
		                      text: text,
		                      isComment: true
		                  };
		                  if (options.outputSourceRange) {
		                      child.start = start;
		                      child.end = end;
		                  }
		                  currentParent.children.push(child);
		              }
		          }
		      });
		      return root;
		  }
		  function processPre(el) {
		      if (getAndRemoveAttr(el, 'v-pre') != null) {
		          el.pre = true;
		      }
		  }
		  function processRawAttrs(el) {
		      var list = el.attrsList;
		      var len = list.length;
		      if (len) {
		          var attrs = (el.attrs = new Array(len));
		          for (var i = 0; i < len; i++) {
		              attrs[i] = {
		                  name: list[i].name,
		                  value: JSON.stringify(list[i].value)
		              };
		              if (list[i].start != null) {
		                  attrs[i].start = list[i].start;
		                  attrs[i].end = list[i].end;
		              }
		          }
		      }
		      else if (!el.pre) {
		          // non root node in pre blocks with no attributes
		          el.plain = true;
		      }
		  }
		  function processElement(element, options) {
		      processKey(element);
		      // determine whether this is a plain element after
		      // removing structural attributes
		      element.plain =
		          !element.key && !element.scopedSlots && !element.attrsList.length;
		      processRef(element);
		      processSlotContent(element);
		      processSlotOutlet(element);
		      processComponent(element);
		      for (var i = 0; i < transforms.length; i++) {
		          element = transforms[i](element, options) || element;
		      }
		      processAttrs(element);
		      return element;
		  }
		  function processKey(el) {
		      var exp = getBindingAttr(el, 'key');
		      if (exp) {
		          {
		              if (el.tag === 'template') {
		                  warn("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
		              }
		              if (el.for) {
		                  var iterator = el.iterator2 || el.iterator1;
		                  var parent_1 = el.parent;
		                  if (iterator &&
		                      iterator === exp &&
		                      parent_1 &&
		                      parent_1.tag === 'transition-group') {
		                      warn("Do not use v-for index as key on <transition-group> children, " +
		                          "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true /* tip */);
		                  }
		              }
		          }
		          el.key = exp;
		      }
		  }
		  function processRef(el) {
		      var ref = getBindingAttr(el, 'ref');
		      if (ref) {
		          el.ref = ref;
		          el.refInFor = checkInFor(el);
		      }
		  }
		  function processFor(el) {
		      var exp;
		      if ((exp = getAndRemoveAttr(el, 'v-for'))) {
		          var res = parseFor(exp);
		          if (res) {
		              extend(el, res);
		          }
		          else {
		              warn("Invalid v-for expression: ".concat(exp), el.rawAttrsMap['v-for']);
		          }
		      }
		  }
		  function parseFor(exp) {
		      var inMatch = exp.match(forAliasRE);
		      if (!inMatch)
		          return;
		      var res = {};
		      res.for = inMatch[2].trim();
		      var alias = inMatch[1].trim().replace(stripParensRE, '');
		      var iteratorMatch = alias.match(forIteratorRE);
		      if (iteratorMatch) {
		          res.alias = alias.replace(forIteratorRE, '').trim();
		          res.iterator1 = iteratorMatch[1].trim();
		          if (iteratorMatch[2]) {
		              res.iterator2 = iteratorMatch[2].trim();
		          }
		      }
		      else {
		          res.alias = alias;
		      }
		      return res;
		  }
		  function processIf(el) {
		      var exp = getAndRemoveAttr(el, 'v-if');
		      if (exp) {
		          el.if = exp;
		          addIfCondition(el, {
		              exp: exp,
		              block: el
		          });
		      }
		      else {
		          if (getAndRemoveAttr(el, 'v-else') != null) {
		              el.else = true;
		          }
		          var elseif = getAndRemoveAttr(el, 'v-else-if');
		          if (elseif) {
		              el.elseif = elseif;
		          }
		      }
		  }
		  function processIfConditions(el, parent) {
		      var prev = findPrevElement(parent.children);
		      if (prev && prev.if) {
		          addIfCondition(prev, {
		              exp: el.elseif,
		              block: el
		          });
		      }
		      else {
		          warn("v-".concat(el.elseif ? 'else-if="' + el.elseif + '"' : 'else', " ") +
		              "used on element <".concat(el.tag, "> without corresponding v-if."), el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
		      }
		  }
		  function findPrevElement(children) {
		      var i = children.length;
		      while (i--) {
		          if (children[i].type === 1) {
		              return children[i];
		          }
		          else {
		              if (children[i].text !== ' ') {
		                  warn("text \"".concat(children[i].text.trim(), "\" between v-if and v-else(-if) ") +
		                      "will be ignored.", children[i]);
		              }
		              children.pop();
		          }
		      }
		  }
		  function addIfCondition(el, condition) {
		      if (!el.ifConditions) {
		          el.ifConditions = [];
		      }
		      el.ifConditions.push(condition);
		  }
		  function processOnce(el) {
		      var once = getAndRemoveAttr(el, 'v-once');
		      if (once != null) {
		          el.once = true;
		      }
		  }
		  // handle content being passed to a component as slot,
		  // e.g. <template slot="xxx">, <div slot-scope="xxx">
		  function processSlotContent(el) {
		      var slotScope;
		      if (el.tag === 'template') {
		          slotScope = getAndRemoveAttr(el, 'scope');
		          /* istanbul ignore if */
		          if (slotScope) {
		              warn("the \"scope\" attribute for scoped slots have been deprecated and " +
		                  "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
		                  "can also be used on plain elements in addition to <template> to " +
		                  "denote scoped slots.", el.rawAttrsMap['scope'], true);
		          }
		          el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
		      }
		      else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
		          /* istanbul ignore if */
		          if (el.attrsMap['v-for']) {
		              warn("Ambiguous combined usage of slot-scope and v-for on <".concat(el.tag, "> ") +
		                  "(v-for takes higher priority). Use a wrapper <template> for the " +
		                  "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
		          }
		          el.slotScope = slotScope;
		      }
		      // slot="xxx"
		      var slotTarget = getBindingAttr(el, 'slot');
		      if (slotTarget) {
		          el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
		          el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
		          // preserve slot as an attribute for native shadow DOM compat
		          // only for non-scoped slots.
		          if (el.tag !== 'template' && !el.slotScope) {
		              addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
		          }
		      }
		      // 2.6 v-slot syntax
		      {
		          if (el.tag === 'template') {
		              // v-slot on <template>
		              var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
		              if (slotBinding) {
		                  {
		                      if (el.slotTarget || el.slotScope) {
		                          warn("Unexpected mixed usage of different slot syntaxes.", el);
		                      }
		                      if (el.parent && !maybeComponent(el.parent)) {
		                          warn("<template v-slot> can only appear at the root level inside " +
		                              "the receiving component", el);
		                      }
		                  }
		                  var _a = getSlotName(slotBinding), name_2 = _a.name, dynamic = _a.dynamic;
		                  el.slotTarget = name_2;
		                  el.slotTargetDynamic = dynamic;
		                  el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
		              }
		          }
		          else {
		              // v-slot on component, denotes default slot
		              var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
		              if (slotBinding) {
		                  {
		                      if (!maybeComponent(el)) {
		                          warn("v-slot can only be used on components or <template>.", slotBinding);
		                      }
		                      if (el.slotScope || el.slotTarget) {
		                          warn("Unexpected mixed usage of different slot syntaxes.", el);
		                      }
		                      if (el.scopedSlots) {
		                          warn("To avoid scope ambiguity, the default slot should also use " +
		                              "<template> syntax when there are other named slots.", slotBinding);
		                      }
		                  }
		                  // add the component's children to its default slot
		                  var slots = el.scopedSlots || (el.scopedSlots = {});
		                  var _b = getSlotName(slotBinding), name_3 = _b.name, dynamic = _b.dynamic;
		                  var slotContainer_1 = (slots[name_3] = createASTElement('template', [], el));
		                  slotContainer_1.slotTarget = name_3;
		                  slotContainer_1.slotTargetDynamic = dynamic;
		                  slotContainer_1.children = el.children.filter(function (c) {
		                      if (!c.slotScope) {
		                          c.parent = slotContainer_1;
		                          return true;
		                      }
		                  });
		                  slotContainer_1.slotScope = slotBinding.value || emptySlotScopeToken;
		                  // remove children as they are returned from scopedSlots now
		                  el.children = [];
		                  // mark el non-plain so data gets generated
		                  el.plain = false;
		              }
		          }
		      }
		  }
		  function getSlotName(binding) {
		      var name = binding.name.replace(slotRE, '');
		      if (!name) {
		          if (binding.name[0] !== '#') {
		              name = 'default';
		          }
		          else {
		              warn("v-slot shorthand syntax requires a slot name.", binding);
		          }
		      }
		      return dynamicArgRE.test(name)
		          ? // dynamic [name]
		              { name: name.slice(1, -1), dynamic: true }
		          : // static name
		              { name: "\"".concat(name, "\""), dynamic: false };
		  }
		  // handle <slot/> outlets
		  function processSlotOutlet(el) {
		      if (el.tag === 'slot') {
		          el.slotName = getBindingAttr(el, 'name');
		          if (el.key) {
		              warn("`key` does not work on <slot> because slots are abstract outlets " +
		                  "and can possibly expand into multiple elements. " +
		                  "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
		          }
		      }
		  }
		  function processComponent(el) {
		      var binding;
		      if ((binding = getBindingAttr(el, 'is'))) {
		          el.component = binding;
		      }
		      if (getAndRemoveAttr(el, 'inline-template') != null) {
		          el.inlineTemplate = true;
		      }
		  }
		  function processAttrs(el) {
		      var list = el.attrsList;
		      var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
		      for (i = 0, l = list.length; i < l; i++) {
		          name = rawName = list[i].name;
		          value = list[i].value;
		          if (dirRE.test(name)) {
		              // mark element as dynamic
		              el.hasBindings = true;
		              // modifiers
		              modifiers = parseModifiers(name.replace(dirRE, ''));
		              // support .foo shorthand syntax for the .prop modifier
		              if (modifiers) {
		                  name = name.replace(modifierRE, '');
		              }
		              if (bindRE.test(name)) {
		                  // v-bind
		                  name = name.replace(bindRE, '');
		                  value = parseFilters(value);
		                  isDynamic = dynamicArgRE.test(name);
		                  if (isDynamic) {
		                      name = name.slice(1, -1);
		                  }
		                  if (value.trim().length === 0) {
		                      warn("The value for a v-bind expression cannot be empty. Found in \"v-bind:".concat(name, "\""));
		                  }
		                  if (modifiers) {
		                      if (modifiers.prop && !isDynamic) {
		                          name = camelize(name);
		                          if (name === 'innerHtml')
		                              name = 'innerHTML';
		                      }
		                      if (modifiers.camel && !isDynamic) {
		                          name = camelize(name);
		                      }
		                      if (modifiers.sync) {
		                          syncGen = genAssignmentCode(value, "$event");
		                          if (!isDynamic) {
		                              addHandler(el, "update:".concat(camelize(name)), syncGen, null, false, warn, list[i]);
		                              if (hyphenate(name) !== camelize(name)) {
		                                  addHandler(el, "update:".concat(hyphenate(name)), syncGen, null, false, warn, list[i]);
		                              }
		                          }
		                          else {
		                              // handler w/ dynamic event name
		                              addHandler(el, "\"update:\"+(".concat(name, ")"), syncGen, null, false, warn, list[i], true // dynamic
		                              );
		                          }
		                      }
		                  }
		                  if ((modifiers && modifiers.prop) ||
		                      (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {
		                      addProp(el, name, value, list[i], isDynamic);
		                  }
		                  else {
		                      addAttr(el, name, value, list[i], isDynamic);
		                  }
		              }
		              else if (onRE.test(name)) {
		                  // v-on
		                  name = name.replace(onRE, '');
		                  isDynamic = dynamicArgRE.test(name);
		                  if (isDynamic) {
		                      name = name.slice(1, -1);
		                  }
		                  addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);
		              }
		              else {
		                  // normal directives
		                  name = name.replace(dirRE, '');
		                  // parse arg
		                  var argMatch = name.match(argRE);
		                  var arg = argMatch && argMatch[1];
		                  isDynamic = false;
		                  if (arg) {
		                      name = name.slice(0, -(arg.length + 1));
		                      if (dynamicArgRE.test(arg)) {
		                          arg = arg.slice(1, -1);
		                          isDynamic = true;
		                      }
		                  }
		                  addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
		                  if (name === 'model') {
		                      checkForAliasModel(el, value);
		                  }
		              }
		          }
		          else {
		              // literal attribute
		              {
		                  var res = parseText(value, delimiters);
		                  if (res) {
		                      warn("".concat(name, "=\"").concat(value, "\": ") +
		                          'Interpolation inside attributes has been removed. ' +
		                          'Use v-bind or the colon shorthand instead. For example, ' +
		                          'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
		                  }
		              }
		              addAttr(el, name, JSON.stringify(value), list[i]);
		              // #6887 firefox doesn't update muted state if set via attribute
		              // even immediately after element creation
		              if (!el.component &&
		                  name === 'muted' &&
		                  platformMustUseProp(el.tag, el.attrsMap.type, name)) {
		                  addProp(el, name, 'true', list[i]);
		              }
		          }
		      }
		  }
		  function checkInFor(el) {
		      var parent = el;
		      while (parent) {
		          if (parent.for !== undefined) {
		              return true;
		          }
		          parent = parent.parent;
		      }
		      return false;
		  }
		  function parseModifiers(name) {
		      var match = name.match(modifierRE);
		      if (match) {
		          var ret_1 = {};
		          match.forEach(function (m) {
		              ret_1[m.slice(1)] = true;
		          });
		          return ret_1;
		      }
		  }
		  function makeAttrsMap(attrs) {
		      var map = {};
		      for (var i = 0, l = attrs.length; i < l; i++) {
		          if (map[attrs[i].name] && !isIE && !isEdge) {
		              warn('duplicate attribute: ' + attrs[i].name, attrs[i]);
		          }
		          map[attrs[i].name] = attrs[i].value;
		      }
		      return map;
		  }
		  // for script (e.g. type="x/template") or style, do not decode content
		  function isTextTag(el) {
		      return el.tag === 'script' || el.tag === 'style';
		  }
		  function isForbiddenTag(el) {
		      return (el.tag === 'style' ||
		          (el.tag === 'script' &&
		              (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));
		  }
		  var ieNSBug = /^xmlns:NS\d+/;
		  var ieNSPrefix = /^NS\d+:/;
		  /* istanbul ignore next */
		  function guardIESVGBug(attrs) {
		      var res = [];
		      for (var i = 0; i < attrs.length; i++) {
		          var attr = attrs[i];
		          if (!ieNSBug.test(attr.name)) {
		              attr.name = attr.name.replace(ieNSPrefix, '');
		              res.push(attr);
		          }
		      }
		      return res;
		  }
		  function checkForAliasModel(el, value) {
		      var _el = el;
		      while (_el) {
		          if (_el.for && _el.alias === value) {
		              warn("<".concat(el.tag, " v-model=\"").concat(value, "\">: ") +
		                  "You are binding v-model directly to a v-for iteration alias. " +
		                  "This will not be able to modify the v-for source array because " +
		                  "writing to the alias is like modifying a function local variable. " +
		                  "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
		          }
		          _el = _el.parent;
		      }
		  }

		  /**
		   * Expand input[v-model] with dynamic type bindings into v-if-else chains
		   * Turn this:
		   *   <input v-model="data[type]" :type="type">
		   * into this:
		   *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
		   *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
		   *   <input v-else :type="type" v-model="data[type]">
		   */
		  function preTransformNode(el, options) {
		      if (el.tag === 'input') {
		          var map = el.attrsMap;
		          if (!map['v-model']) {
		              return;
		          }
		          var typeBinding = void 0;
		          if (map[':type'] || map['v-bind:type']) {
		              typeBinding = getBindingAttr(el, 'type');
		          }
		          if (!map.type && !typeBinding && map['v-bind']) {
		              typeBinding = "(".concat(map['v-bind'], ").type");
		          }
		          if (typeBinding) {
		              var ifCondition = getAndRemoveAttr(el, 'v-if', true);
		              var ifConditionExtra = ifCondition ? "&&(".concat(ifCondition, ")") : "";
		              var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
		              var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
		              // 1. checkbox
		              var branch0 = cloneASTElement(el);
		              // process for on the main node
		              processFor(branch0);
		              addRawAttr(branch0, 'type', 'checkbox');
		              processElement(branch0, options);
		              branch0.processed = true; // prevent it from double-processed
		              branch0.if = "(".concat(typeBinding, ")==='checkbox'") + ifConditionExtra;
		              addIfCondition(branch0, {
		                  exp: branch0.if,
		                  block: branch0
		              });
		              // 2. add radio else-if condition
		              var branch1 = cloneASTElement(el);
		              getAndRemoveAttr(branch1, 'v-for', true);
		              addRawAttr(branch1, 'type', 'radio');
		              processElement(branch1, options);
		              addIfCondition(branch0, {
		                  exp: "(".concat(typeBinding, ")==='radio'") + ifConditionExtra,
		                  block: branch1
		              });
		              // 3. other
		              var branch2 = cloneASTElement(el);
		              getAndRemoveAttr(branch2, 'v-for', true);
		              addRawAttr(branch2, ':type', typeBinding);
		              processElement(branch2, options);
		              addIfCondition(branch0, {
		                  exp: ifCondition,
		                  block: branch2
		              });
		              if (hasElse) {
		                  branch0.else = true;
		              }
		              else if (elseIfCondition) {
		                  branch0.elseif = elseIfCondition;
		              }
		              return branch0;
		          }
		      }
		  }
		  function cloneASTElement(el) {
		      return createASTElement(el.tag, el.attrsList.slice(), el.parent);
		  }
		  var model = {
		      preTransformNode: preTransformNode
		  };

		  var modules = [klass, style, model];

		  function text(el, dir) {
		      if (dir.value) {
		          addProp(el, 'textContent', "_s(".concat(dir.value, ")"), dir);
		      }
		  }

		  function html(el, dir) {
		      if (dir.value) {
		          addProp(el, 'innerHTML', "_s(".concat(dir.value, ")"), dir);
		      }
		  }

		  var directives = {
		      model: model$1,
		      text: text,
		      html: html
		  };

		  var baseOptions = {
		      expectHTML: true,
		      modules: modules,
		      directives: directives,
		      isPreTag: isPreTag,
		      isUnaryTag: isUnaryTag,
		      mustUseProp: mustUseProp,
		      canBeLeftOpenTag: canBeLeftOpenTag,
		      isReservedTag: isReservedTag,
		      getTagNamespace: getTagNamespace,
		      staticKeys: genStaticKeys$1(modules)
		  };

		  var isStaticKey;
		  var isPlatformReservedTag;
		  var genStaticKeysCached = cached(genStaticKeys);
		  /**
		   * Goal of the optimizer: walk the generated template AST tree
		   * and detect sub-trees that are purely static, i.e. parts of
		   * the DOM that never needs to change.
		   *
		   * Once we detect these sub-trees, we can:
		   *
		   * 1. Hoist them into constants, so that we no longer need to
		   *    create fresh nodes for them on each re-render;
		   * 2. Completely skip them in the patching process.
		   */
		  function optimize(root, options) {
		      if (!root)
		          return;
		      isStaticKey = genStaticKeysCached(options.staticKeys || '');
		      isPlatformReservedTag = options.isReservedTag || no;
		      // first pass: mark all non-static nodes.
		      markStatic(root);
		      // second pass: mark static roots.
		      markStaticRoots(root, false);
		  }
		  function genStaticKeys(keys) {
		      return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
		          (keys ? ',' + keys : ''));
		  }
		  function markStatic(node) {
		      node.static = isStatic(node);
		      if (node.type === 1) {
		          // do not make component slot content static. this avoids
		          // 1. components not able to mutate slot nodes
		          // 2. static slot content fails for hot-reloading
		          if (!isPlatformReservedTag(node.tag) &&
		              node.tag !== 'slot' &&
		              node.attrsMap['inline-template'] == null) {
		              return;
		          }
		          for (var i = 0, l = node.children.length; i < l; i++) {
		              var child = node.children[i];
		              markStatic(child);
		              if (!child.static) {
		                  node.static = false;
		              }
		          }
		          if (node.ifConditions) {
		              for (var i = 1, l = node.ifConditions.length; i < l; i++) {
		                  var block = node.ifConditions[i].block;
		                  markStatic(block);
		                  if (!block.static) {
		                      node.static = false;
		                  }
		              }
		          }
		      }
		  }
		  function markStaticRoots(node, isInFor) {
		      if (node.type === 1) {
		          if (node.static || node.once) {
		              node.staticInFor = isInFor;
		          }
		          // For a node to qualify as a static root, it should have children that
		          // are not just static text. Otherwise the cost of hoisting out will
		          // outweigh the benefits and it's better off to just always render it fresh.
		          if (node.static &&
		              node.children.length &&
		              !(node.children.length === 1 && node.children[0].type === 3)) {
		              node.staticRoot = true;
		              return;
		          }
		          else {
		              node.staticRoot = false;
		          }
		          if (node.children) {
		              for (var i = 0, l = node.children.length; i < l; i++) {
		                  markStaticRoots(node.children[i], isInFor || !!node.for);
		              }
		          }
		          if (node.ifConditions) {
		              for (var i = 1, l = node.ifConditions.length; i < l; i++) {
		                  markStaticRoots(node.ifConditions[i].block, isInFor);
		              }
		          }
		      }
		  }
		  function isStatic(node) {
		      if (node.type === 2) {
		          // expression
		          return false;
		      }
		      if (node.type === 3) {
		          // text
		          return true;
		      }
		      return !!(node.pre ||
		          (!node.hasBindings && // no dynamic bindings
		              !node.if &&
		              !node.for && // not v-if or v-for or v-else
		              !isBuiltInTag(node.tag) && // not a built-in
		              isPlatformReservedTag(node.tag) && // not a component
		              !isDirectChildOfTemplateFor(node) &&
		              Object.keys(node).every(isStaticKey)));
		  }
		  function isDirectChildOfTemplateFor(node) {
		      while (node.parent) {
		          node = node.parent;
		          if (node.tag !== 'template') {
		              return false;
		          }
		          if (node.for) {
		              return true;
		          }
		      }
		      return false;
		  }

		  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
		  var fnInvokeRE = /\([^)]*?\);*$/;
		  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;
		  // KeyboardEvent.keyCode aliases
		  var keyCodes = {
		      esc: 27,
		      tab: 9,
		      enter: 13,
		      space: 32,
		      up: 38,
		      left: 37,
		      right: 39,
		      down: 40,
		      delete: [8, 46]
		  };
		  // KeyboardEvent.key aliases
		  var keyNames = {
		      // #7880: IE11 and Edge use `Esc` for Escape key name.
		      esc: ['Esc', 'Escape'],
		      tab: 'Tab',
		      enter: 'Enter',
		      // #9112: IE11 uses `Spacebar` for Space key name.
		      space: [' ', 'Spacebar'],
		      // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
		      up: ['Up', 'ArrowUp'],
		      left: ['Left', 'ArrowLeft'],
		      right: ['Right', 'ArrowRight'],
		      down: ['Down', 'ArrowDown'],
		      // #9112: IE11 uses `Del` for Delete key name.
		      delete: ['Backspace', 'Delete', 'Del']
		  };
		  // #4868: modifiers that prevent the execution of the listener
		  // need to explicitly return null so that we can determine whether to remove
		  // the listener for .once
		  var genGuard = function (condition) { return "if(".concat(condition, ")return null;"); };
		  var modifierCode = {
		      stop: '$event.stopPropagation();',
		      prevent: '$event.preventDefault();',
		      self: genGuard("$event.target !== $event.currentTarget"),
		      ctrl: genGuard("!$event.ctrlKey"),
		      shift: genGuard("!$event.shiftKey"),
		      alt: genGuard("!$event.altKey"),
		      meta: genGuard("!$event.metaKey"),
		      left: genGuard("'button' in $event && $event.button !== 0"),
		      middle: genGuard("'button' in $event && $event.button !== 1"),
		      right: genGuard("'button' in $event && $event.button !== 2")
		  };
		  function genHandlers(events, isNative) {
		      var prefix = isNative ? 'nativeOn:' : 'on:';
		      var staticHandlers = "";
		      var dynamicHandlers = "";
		      for (var name_1 in events) {
		          var handlerCode = genHandler(events[name_1]);
		          //@ts-expect-error
		          if (events[name_1] && events[name_1].dynamic) {
		              dynamicHandlers += "".concat(name_1, ",").concat(handlerCode, ",");
		          }
		          else {
		              staticHandlers += "\"".concat(name_1, "\":").concat(handlerCode, ",");
		          }
		      }
		      staticHandlers = "{".concat(staticHandlers.slice(0, -1), "}");
		      if (dynamicHandlers) {
		          return prefix + "_d(".concat(staticHandlers, ",[").concat(dynamicHandlers.slice(0, -1), "])");
		      }
		      else {
		          return prefix + staticHandlers;
		      }
		  }
		  function genHandler(handler) {
		      if (!handler) {
		          return 'function(){}';
		      }
		      if (Array.isArray(handler)) {
		          return "[".concat(handler.map(function (handler) { return genHandler(handler); }).join(','), "]");
		      }
		      var isMethodPath = simplePathRE.test(handler.value);
		      var isFunctionExpression = fnExpRE.test(handler.value);
		      var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));
		      if (!handler.modifiers) {
		          if (isMethodPath || isFunctionExpression) {
		              return handler.value;
		          }
		          return "function($event){".concat(isFunctionInvocation ? "return ".concat(handler.value) : handler.value, "}"); // inline statement
		      }
		      else {
		          var code = '';
		          var genModifierCode = '';
		          var keys = [];
		          var _loop_1 = function (key) {
		              if (modifierCode[key]) {
		                  genModifierCode += modifierCode[key];
		                  // left/right
		                  if (keyCodes[key]) {
		                      keys.push(key);
		                  }
		              }
		              else if (key === 'exact') {
		                  var modifiers_1 = handler.modifiers;
		                  genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']
		                      .filter(function (keyModifier) { return !modifiers_1[keyModifier]; })
		                      .map(function (keyModifier) { return "$event.".concat(keyModifier, "Key"); })
		                      .join('||'));
		              }
		              else {
		                  keys.push(key);
		              }
		          };
		          for (var key in handler.modifiers) {
		              _loop_1(key);
		          }
		          if (keys.length) {
		              code += genKeyFilter(keys);
		          }
		          // Make sure modifiers like prevent and stop get executed after key filtering
		          if (genModifierCode) {
		              code += genModifierCode;
		          }
		          var handlerCode = isMethodPath
		              ? "return ".concat(handler.value, ".apply(null, arguments)")
		              : isFunctionExpression
		                  ? "return (".concat(handler.value, ").apply(null, arguments)")
		                  : isFunctionInvocation
		                      ? "return ".concat(handler.value)
		                      : handler.value;
		          return "function($event){".concat(code).concat(handlerCode, "}");
		      }
		  }
		  function genKeyFilter(keys) {
		      return (
		      // make sure the key filters only apply to KeyboardEvents
		      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
		      // key events that do not have keyCode property...
		      "if(!$event.type.indexOf('key')&&" +
		          "".concat(keys.map(genFilterCode).join('&&'), ")return null;"));
		  }
		  function genFilterCode(key) {
		      var keyVal = parseInt(key, 10);
		      if (keyVal) {
		          return "$event.keyCode!==".concat(keyVal);
		      }
		      var keyCode = keyCodes[key];
		      var keyName = keyNames[key];
		      return ("_k($event.keyCode," +
		          "".concat(JSON.stringify(key), ",") +
		          "".concat(JSON.stringify(keyCode), ",") +
		          "$event.key," +
		          "".concat(JSON.stringify(keyName)) +
		          ")");
		  }

		  function on(el, dir) {
		      if (dir.modifiers) {
		          warn$2("v-on without argument does not support modifiers.");
		      }
		      el.wrapListeners = function (code) { return "_g(".concat(code, ",").concat(dir.value, ")"); };
		  }

		  function bind(el, dir) {
		      el.wrapData = function (code) {
		          return "_b(".concat(code, ",'").concat(el.tag, "',").concat(dir.value, ",").concat(dir.modifiers && dir.modifiers.prop ? 'true' : 'false').concat(dir.modifiers && dir.modifiers.sync ? ',true' : '', ")");
		      };
		  }

		  var baseDirectives = {
		      on: on,
		      bind: bind,
		      cloak: noop
		  };

		  var CodegenState = /** @class */ (function () {
		      function CodegenState(options) {
		          this.options = options;
		          this.warn = options.warn || baseWarn;
		          this.transforms = pluckModuleFunction(options.modules, 'transformCode');
		          this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
		          this.directives = extend(extend({}, baseDirectives), options.directives);
		          var isReservedTag = options.isReservedTag || no;
		          this.maybeComponent = function (el) {
		              return !!el.component || !isReservedTag(el.tag);
		          };
		          this.onceId = 0;
		          this.staticRenderFns = [];
		          this.pre = false;
		      }
		      return CodegenState;
		  }());
		  function generate(ast, options) {
		      var state = new CodegenState(options);
		      // fix #11483, Root level <script> tags should not be rendered.
		      var code = ast
		          ? ast.tag === 'script'
		              ? 'null'
		              : genElement(ast, state)
		          : '_c("div")';
		      return {
		          render: "with(this){return ".concat(code, "}"),
		          staticRenderFns: state.staticRenderFns
		      };
		  }
		  function genElement(el, state) {
		      if (el.parent) {
		          el.pre = el.pre || el.parent.pre;
		      }
		      if (el.staticRoot && !el.staticProcessed) {
		          return genStatic(el, state);
		      }
		      else if (el.once && !el.onceProcessed) {
		          return genOnce(el, state);
		      }
		      else if (el.for && !el.forProcessed) {
		          return genFor(el, state);
		      }
		      else if (el.if && !el.ifProcessed) {
		          return genIf(el, state);
		      }
		      else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
		          return genChildren(el, state) || 'void 0';
		      }
		      else if (el.tag === 'slot') {
		          return genSlot(el, state);
		      }
		      else {
		          // component or element
		          var code = void 0;
		          if (el.component) {
		              code = genComponent(el.component, el, state);
		          }
		          else {
		              var data = void 0;
		              var maybeComponent = state.maybeComponent(el);
		              if (!el.plain || (el.pre && maybeComponent)) {
		                  data = genData(el, state);
		              }
		              var tag 
		              // check if this is a component in <script setup>
		              = void 0;
		              // check if this is a component in <script setup>
		              var bindings = state.options.bindings;
		              if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {
		                  tag = checkBindingType(bindings, el.tag);
		              }
		              if (!tag)
		                  tag = "'".concat(el.tag, "'");
		              var children = el.inlineTemplate ? null : genChildren(el, state, true);
		              code = "_c(".concat(tag).concat(data ? ",".concat(data) : '' // data
		              ).concat(children ? ",".concat(children) : '' // children
		              , ")");
		          }
		          // module transforms
		          for (var i = 0; i < state.transforms.length; i++) {
		              code = state.transforms[i](el, code);
		          }
		          return code;
		      }
		  }
		  function checkBindingType(bindings, key) {
		      var camelName = camelize(key);
		      var PascalName = capitalize(camelName);
		      var checkType = function (type) {
		          if (bindings[key] === type) {
		              return key;
		          }
		          if (bindings[camelName] === type) {
		              return camelName;
		          }
		          if (bindings[PascalName] === type) {
		              return PascalName;
		          }
		      };
		      var fromConst = checkType("setup-const" /* BindingTypes.SETUP_CONST */) ||
		          checkType("setup-reactive-const" /* BindingTypes.SETUP_REACTIVE_CONST */);
		      if (fromConst) {
		          return fromConst;
		      }
		      var fromMaybeRef = checkType("setup-let" /* BindingTypes.SETUP_LET */) ||
		          checkType("setup-ref" /* BindingTypes.SETUP_REF */) ||
		          checkType("setup-maybe-ref" /* BindingTypes.SETUP_MAYBE_REF */);
		      if (fromMaybeRef) {
		          return fromMaybeRef;
		      }
		  }
		  // hoist static sub-trees out
		  function genStatic(el, state) {
		      el.staticProcessed = true;
		      // Some elements (templates) need to behave differently inside of a v-pre
		      // node.  All pre nodes are static roots, so we can use this as a location to
		      // wrap a state change and reset it upon exiting the pre node.
		      var originalPreState = state.pre;
		      if (el.pre) {
		          state.pre = el.pre;
		      }
		      state.staticRenderFns.push("with(this){return ".concat(genElement(el, state), "}"));
		      state.pre = originalPreState;
		      return "_m(".concat(state.staticRenderFns.length - 1).concat(el.staticInFor ? ',true' : '', ")");
		  }
		  // v-once
		  function genOnce(el, state) {
		      el.onceProcessed = true;
		      if (el.if && !el.ifProcessed) {
		          return genIf(el, state);
		      }
		      else if (el.staticInFor) {
		          var key = '';
		          var parent_1 = el.parent;
		          while (parent_1) {
		              if (parent_1.for) {
		                  key = parent_1.key;
		                  break;
		              }
		              parent_1 = parent_1.parent;
		          }
		          if (!key) {
		              state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
		              return genElement(el, state);
		          }
		          return "_o(".concat(genElement(el, state), ",").concat(state.onceId++, ",").concat(key, ")");
		      }
		      else {
		          return genStatic(el, state);
		      }
		  }
		  function genIf(el, state, altGen, altEmpty) {
		      el.ifProcessed = true; // avoid recursion
		      return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
		  }
		  function genIfConditions(conditions, state, altGen, altEmpty) {
		      if (!conditions.length) {
		          return altEmpty || '_e()';
		      }
		      var condition = conditions.shift();
		      if (condition.exp) {
		          return "(".concat(condition.exp, ")?").concat(genTernaryExp(condition.block), ":").concat(genIfConditions(conditions, state, altGen, altEmpty));
		      }
		      else {
		          return "".concat(genTernaryExp(condition.block));
		      }
		      // v-if with v-once should generate code like (a)?_m(0):_m(1)
		      function genTernaryExp(el) {
		          return altGen
		              ? altGen(el, state)
		              : el.once
		                  ? genOnce(el, state)
		                  : genElement(el, state);
		      }
		  }
		  function genFor(el, state, altGen, altHelper) {
		      var exp = el.for;
		      var alias = el.alias;
		      var iterator1 = el.iterator1 ? ",".concat(el.iterator1) : '';
		      var iterator2 = el.iterator2 ? ",".concat(el.iterator2) : '';
		      if (state.maybeComponent(el) &&
		          el.tag !== 'slot' &&
		          el.tag !== 'template' &&
		          !el.key) {
		          state.warn("<".concat(el.tag, " v-for=\"").concat(alias, " in ").concat(exp, "\">: component lists rendered with ") +
		              "v-for should have explicit keys. " +
		              "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true /* tip */);
		      }
		      el.forProcessed = true; // avoid recursion
		      return ("".concat(altHelper || '_l', "((").concat(exp, "),") +
		          "function(".concat(alias).concat(iterator1).concat(iterator2, "){") +
		          "return ".concat((altGen || genElement)(el, state)) +
		          '})');
		  }
		  function genData(el, state) {
		      var data = '{';
		      // directives first.
		      // directives may mutate the el's other properties before they are generated.
		      var dirs = genDirectives(el, state);
		      if (dirs)
		          data += dirs + ',';
		      // key
		      if (el.key) {
		          data += "key:".concat(el.key, ",");
		      }
		      // ref
		      if (el.ref) {
		          data += "ref:".concat(el.ref, ",");
		      }
		      if (el.refInFor) {
		          data += "refInFor:true,";
		      }
		      // pre
		      if (el.pre) {
		          data += "pre:true,";
		      }
		      // record original tag name for components using "is" attribute
		      if (el.component) {
		          data += "tag:\"".concat(el.tag, "\",");
		      }
		      // module data generation functions
		      for (var i = 0; i < state.dataGenFns.length; i++) {
		          data += state.dataGenFns[i](el);
		      }
		      // attributes
		      if (el.attrs) {
		          data += "attrs:".concat(genProps(el.attrs), ",");
		      }
		      // DOM props
		      if (el.props) {
		          data += "domProps:".concat(genProps(el.props), ",");
		      }
		      // event handlers
		      if (el.events) {
		          data += "".concat(genHandlers(el.events, false), ",");
		      }
		      if (el.nativeEvents) {
		          data += "".concat(genHandlers(el.nativeEvents, true), ",");
		      }
		      // slot target
		      // only for non-scoped slots
		      if (el.slotTarget && !el.slotScope) {
		          data += "slot:".concat(el.slotTarget, ",");
		      }
		      // scoped slots
		      if (el.scopedSlots) {
		          data += "".concat(genScopedSlots(el, el.scopedSlots, state), ",");
		      }
		      // component v-model
		      if (el.model) {
		          data += "model:{value:".concat(el.model.value, ",callback:").concat(el.model.callback, ",expression:").concat(el.model.expression, "},");
		      }
		      // inline-template
		      if (el.inlineTemplate) {
		          var inlineTemplate = genInlineTemplate(el, state);
		          if (inlineTemplate) {
		              data += "".concat(inlineTemplate, ",");
		          }
		      }
		      data = data.replace(/,$/, '') + '}';
		      // v-bind dynamic argument wrap
		      // v-bind with dynamic arguments must be applied using the same v-bind object
		      // merge helper so that class/style/mustUseProp attrs are handled correctly.
		      if (el.dynamicAttrs) {
		          data = "_b(".concat(data, ",\"").concat(el.tag, "\",").concat(genProps(el.dynamicAttrs), ")");
		      }
		      // v-bind data wrap
		      if (el.wrapData) {
		          data = el.wrapData(data);
		      }
		      // v-on data wrap
		      if (el.wrapListeners) {
		          data = el.wrapListeners(data);
		      }
		      return data;
		  }
		  function genDirectives(el, state) {
		      var dirs = el.directives;
		      if (!dirs)
		          return;
		      var res = 'directives:[';
		      var hasRuntime = false;
		      var i, l, dir, needRuntime;
		      for (i = 0, l = dirs.length; i < l; i++) {
		          dir = dirs[i];
		          needRuntime = true;
		          var gen = state.directives[dir.name];
		          if (gen) {
		              // compile-time directive that manipulates AST.
		              // returns true if it also needs a runtime counterpart.
		              needRuntime = !!gen(el, dir, state.warn);
		          }
		          if (needRuntime) {
		              hasRuntime = true;
		              res += "{name:\"".concat(dir.name, "\",rawName:\"").concat(dir.rawName, "\"").concat(dir.value
		                  ? ",value:(".concat(dir.value, "),expression:").concat(JSON.stringify(dir.value))
		                  : '').concat(dir.arg ? ",arg:".concat(dir.isDynamicArg ? dir.arg : "\"".concat(dir.arg, "\"")) : '').concat(dir.modifiers ? ",modifiers:".concat(JSON.stringify(dir.modifiers)) : '', "},");
		          }
		      }
		      if (hasRuntime) {
		          return res.slice(0, -1) + ']';
		      }
		  }
		  function genInlineTemplate(el, state) {
		      var ast = el.children[0];
		      if ((el.children.length !== 1 || ast.type !== 1)) {
		          state.warn('Inline-template components must have exactly one child element.', { start: el.start });
		      }
		      if (ast && ast.type === 1) {
		          var inlineRenderFns = generate(ast, state.options);
		          return "inlineTemplate:{render:function(){".concat(inlineRenderFns.render, "},staticRenderFns:[").concat(inlineRenderFns.staticRenderFns
		              .map(function (code) { return "function(){".concat(code, "}"); })
		              .join(','), "]}");
		      }
		  }
		  function genScopedSlots(el, slots, state) {
		      // by default scoped slots are considered "stable", this allows child
		      // components with only scoped slots to skip forced updates from parent.
		      // but in some cases we have to bail-out of this optimization
		      // for example if the slot contains dynamic names, has v-if or v-for on them...
		      var needsForceUpdate = el.for ||
		          Object.keys(slots).some(function (key) {
		              var slot = slots[key];
		              return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
		              );
		          });
		      // #9534: if a component with scoped slots is inside a conditional branch,
		      // it's possible for the same component to be reused but with different
		      // compiled slot content. To avoid that, we generate a unique key based on
		      // the generated code of all the slot contents.
		      var needsKey = !!el.if;
		      // OR when it is inside another scoped slot or v-for (the reactivity may be
		      // disconnected due to the intermediate scope variable)
		      // #9438, #9506
		      // TODO: this can be further optimized by properly analyzing in-scope bindings
		      // and skip force updating ones that do not actually use scope variables.
		      if (!needsForceUpdate) {
		          var parent_2 = el.parent;
		          while (parent_2) {
		              if ((parent_2.slotScope && parent_2.slotScope !== emptySlotScopeToken) ||
		                  parent_2.for) {
		                  needsForceUpdate = true;
		                  break;
		              }
		              if (parent_2.if) {
		                  needsKey = true;
		              }
		              parent_2 = parent_2.parent;
		          }
		      }
		      var generatedSlots = Object.keys(slots)
		          .map(function (key) { return genScopedSlot(slots[key], state); })
		          .join(',');
		      return "scopedSlots:_u([".concat(generatedSlots, "]").concat(needsForceUpdate ? ",null,true" : "").concat(!needsForceUpdate && needsKey ? ",null,false,".concat(hash(generatedSlots)) : "", ")");
		  }
		  function hash(str) {
		      var hash = 5381;
		      var i = str.length;
		      while (i) {
		          hash = (hash * 33) ^ str.charCodeAt(--i);
		      }
		      return hash >>> 0;
		  }
		  function containsSlotChild(el) {
		      if (el.type === 1) {
		          if (el.tag === 'slot') {
		              return true;
		          }
		          return el.children.some(containsSlotChild);
		      }
		      return false;
		  }
		  function genScopedSlot(el, state) {
		      var isLegacySyntax = el.attrsMap['slot-scope'];
		      if (el.if && !el.ifProcessed && !isLegacySyntax) {
		          return genIf(el, state, genScopedSlot, "null");
		      }
		      if (el.for && !el.forProcessed) {
		          return genFor(el, state, genScopedSlot);
		      }
		      var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
		      var fn = "function(".concat(slotScope, "){") +
		          "return ".concat(el.tag === 'template'
		              ? el.if && isLegacySyntax
		                  ? "(".concat(el.if, ")?").concat(genChildren(el, state) || 'undefined', ":undefined")
		                  : genChildren(el, state) || 'undefined'
		              : genElement(el, state), "}");
		      // reverse proxy v-slot without scope on this.$slots
		      var reverseProxy = slotScope ? "" : ",proxy:true";
		      return "{key:".concat(el.slotTarget || "\"default\"", ",fn:").concat(fn).concat(reverseProxy, "}");
		  }
		  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
		      var children = el.children;
		      if (children.length) {
		          var el_1 = children[0];
		          // optimize single v-for
		          if (children.length === 1 &&
		              el_1.for &&
		              el_1.tag !== 'template' &&
		              el_1.tag !== 'slot') {
		              var normalizationType_1 = checkSkip
		                  ? state.maybeComponent(el_1)
		                      ? ",1"
		                      : ",0"
		                  : "";
		              return "".concat((altGenElement || genElement)(el_1, state)).concat(normalizationType_1);
		          }
		          var normalizationType = checkSkip
		              ? getNormalizationType(children, state.maybeComponent)
		              : 0;
		          var gen_1 = altGenNode || genNode;
		          return "[".concat(children.map(function (c) { return gen_1(c, state); }).join(','), "]").concat(normalizationType ? ",".concat(normalizationType) : '');
		      }
		  }
		  // determine the normalization needed for the children array.
		  // 0: no normalization needed
		  // 1: simple normalization needed (possible 1-level deep nested array)
		  // 2: full normalization needed
		  function getNormalizationType(children, maybeComponent) {
		      var res = 0;
		      for (var i = 0; i < children.length; i++) {
		          var el = children[i];
		          if (el.type !== 1) {
		              continue;
		          }
		          if (needsNormalization(el) ||
		              (el.ifConditions &&
		                  el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
		              res = 2;
		              break;
		          }
		          if (maybeComponent(el) ||
		              (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
		              res = 1;
		          }
		      }
		      return res;
		  }
		  function needsNormalization(el) {
		      return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
		  }
		  function genNode(node, state) {
		      if (node.type === 1) {
		          return genElement(node, state);
		      }
		      else if (node.type === 3 && node.isComment) {
		          return genComment(node);
		      }
		      else {
		          return genText(node);
		      }
		  }
		  function genText(text) {
		      return "_v(".concat(text.type === 2
		          ? text.expression // no need for () because already wrapped in _s()
		          : transformSpecialNewlines(JSON.stringify(text.text)), ")");
		  }
		  function genComment(comment) {
		      return "_e(".concat(JSON.stringify(comment.text), ")");
		  }
		  function genSlot(el, state) {
		      var slotName = el.slotName || '"default"';
		      var children = genChildren(el, state);
		      var res = "_t(".concat(slotName).concat(children ? ",function(){return ".concat(children, "}") : '');
		      var attrs = el.attrs || el.dynamicAttrs
		          ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
		              // slot props are camelized
		              name: camelize(attr.name),
		              value: attr.value,
		              dynamic: attr.dynamic
		          }); }))
		          : null;
		      var bind = el.attrsMap['v-bind'];
		      if ((attrs || bind) && !children) {
		          res += ",null";
		      }
		      if (attrs) {
		          res += ",".concat(attrs);
		      }
		      if (bind) {
		          res += "".concat(attrs ? '' : ',null', ",").concat(bind);
		      }
		      return res + ')';
		  }
		  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
		  function genComponent(componentName, el, state) {
		      var children = el.inlineTemplate ? null : genChildren(el, state, true);
		      return "_c(".concat(componentName, ",").concat(genData(el, state)).concat(children ? ",".concat(children) : '', ")");
		  }
		  function genProps(props) {
		      var staticProps = "";
		      var dynamicProps = "";
		      for (var i = 0; i < props.length; i++) {
		          var prop = props[i];
		          var value = transformSpecialNewlines(prop.value);
		          if (prop.dynamic) {
		              dynamicProps += "".concat(prop.name, ",").concat(value, ",");
		          }
		          else {
		              staticProps += "\"".concat(prop.name, "\":").concat(value, ",");
		          }
		      }
		      staticProps = "{".concat(staticProps.slice(0, -1), "}");
		      if (dynamicProps) {
		          return "_d(".concat(staticProps, ",[").concat(dynamicProps.slice(0, -1), "])");
		      }
		      else {
		          return staticProps;
		      }
		  }
		  // #3895, #4268
		  function transformSpecialNewlines(text) {
		      return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
		  }

		  // these keywords should not appear inside expressions, but operators like
		  // typeof, instanceof and in are allowed
		  var prohibitedKeywordRE = new RegExp('\\b' +
		      ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
		          'super,throw,while,yield,delete,export,import,return,switch,default,' +
		          'extends,finally,continue,debugger,function,arguments')
		          .split(',')
		          .join('\\b|\\b') +
		      '\\b');
		  // these unary operators should not be used as property/method names
		  var unaryOperatorsRE = new RegExp('\\b' +
		      'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') +
		      '\\s*\\([^\\)]*\\)');
		  // strip strings in expressions
		  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
		  // detect problematic expressions in a template
		  function detectErrors(ast, warn) {
		      if (ast) {
		          checkNode(ast, warn);
		      }
		  }
		  function checkNode(node, warn) {
		      if (node.type === 1) {
		          for (var name_1 in node.attrsMap) {
		              if (dirRE.test(name_1)) {
		                  var value = node.attrsMap[name_1];
		                  if (value) {
		                      var range = node.rawAttrsMap[name_1];
		                      if (name_1 === 'v-for') {
		                          checkFor(node, "v-for=\"".concat(value, "\""), warn, range);
		                      }
		                      else if (name_1 === 'v-slot' || name_1[0] === '#') {
		                          checkFunctionParameterExpression(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
		                      }
		                      else if (onRE.test(name_1)) {
		                          checkEvent(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
		                      }
		                      else {
		                          checkExpression(value, "".concat(name_1, "=\"").concat(value, "\""), warn, range);
		                      }
		                  }
		              }
		          }
		          if (node.children) {
		              for (var i = 0; i < node.children.length; i++) {
		                  checkNode(node.children[i], warn);
		              }
		          }
		      }
		      else if (node.type === 2) {
		          checkExpression(node.expression, node.text, warn, node);
		      }
		  }
		  function checkEvent(exp, text, warn, range) {
		      var stripped = exp.replace(stripStringRE, '');
		      var keywordMatch = stripped.match(unaryOperatorsRE);
		      if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
		          warn("avoid using JavaScript unary operator as property name: " +
		              "\"".concat(keywordMatch[0], "\" in expression ").concat(text.trim()), range);
		      }
		      checkExpression(exp, text, warn, range);
		  }
		  function checkFor(node, text, warn, range) {
		      checkExpression(node.for || '', text, warn, range);
		      checkIdentifier(node.alias, 'v-for alias', text, warn, range);
		      checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
		      checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
		  }
		  function checkIdentifier(ident, type, text, warn, range) {
		      if (typeof ident === 'string') {
		          try {
		              new Function("var ".concat(ident, "=_"));
		          }
		          catch (e) {
		              warn("invalid ".concat(type, " \"").concat(ident, "\" in expression: ").concat(text.trim()), range);
		          }
		      }
		  }
		  function checkExpression(exp, text, warn, range) {
		      try {
		          new Function("return ".concat(exp));
		      }
		      catch (e) {
		          var keywordMatch = exp
		              .replace(stripStringRE, '')
		              .match(prohibitedKeywordRE);
		          if (keywordMatch) {
		              warn("avoid using JavaScript keyword as property name: " +
		                  "\"".concat(keywordMatch[0], "\"\n  Raw expression: ").concat(text.trim()), range);
		          }
		          else {
		              warn("invalid expression: ".concat(e.message, " in\n\n") +
		                  "    ".concat(exp, "\n\n") +
		                  "  Raw expression: ".concat(text.trim(), "\n"), range);
		          }
		      }
		  }
		  function checkFunctionParameterExpression(exp, text, warn, range) {
		      try {
		          new Function(exp, '');
		      }
		      catch (e) {
		          warn("invalid function parameter expression: ".concat(e.message, " in\n\n") +
		              "    ".concat(exp, "\n\n") +
		              "  Raw expression: ".concat(text.trim(), "\n"), range);
		      }
		  }

		  var range = 2;
		  function generateCodeFrame(source, start, end) {
		      if (start === void 0) { start = 0; }
		      if (end === void 0) { end = source.length; }
		      var lines = source.split(/\r?\n/);
		      var count = 0;
		      var res = [];
		      for (var i = 0; i < lines.length; i++) {
		          count += lines[i].length + 1;
		          if (count >= start) {
		              for (var j = i - range; j <= i + range || end > count; j++) {
		                  if (j < 0 || j >= lines.length)
		                      continue;
		                  res.push("".concat(j + 1).concat(repeat(" ", 3 - String(j + 1).length), "|  ").concat(lines[j]));
		                  var lineLength = lines[j].length;
		                  if (j === i) {
		                      // push underline
		                      var pad = start - (count - lineLength) + 1;
		                      var length_1 = end > count ? lineLength - pad : end - start;
		                      res.push("   |  " + repeat(" ", pad) + repeat("^", length_1));
		                  }
		                  else if (j > i) {
		                      if (end > count) {
		                          var length_2 = Math.min(end - count, lineLength);
		                          res.push("   |  " + repeat("^", length_2));
		                      }
		                      count += lineLength + 1;
		                  }
		              }
		              break;
		          }
		      }
		      return res.join('\n');
		  }
		  function repeat(str, n) {
		      var result = '';
		      if (n > 0) {
		          // eslint-disable-next-line no-constant-condition
		          while (true) {
		              // eslint-disable-line
		              if (n & 1)
		                  result += str;
		              n >>>= 1;
		              if (n <= 0)
		                  break;
		              str += str;
		          }
		      }
		      return result;
		  }

		  function createFunction(code, errors) {
		      try {
		          return new Function(code);
		      }
		      catch (err) {
		          errors.push({ err: err, code: code });
		          return noop;
		      }
		  }
		  function createCompileToFunctionFn(compile) {
		      var cache = Object.create(null);
		      return function compileToFunctions(template, options, vm) {
		          options = extend({}, options);
		          var warn = options.warn || warn$2;
		          delete options.warn;
		          /* istanbul ignore if */
		          {
		              // detect possible CSP restriction
		              try {
		                  new Function('return 1');
		              }
		              catch (e) {
		                  if (e.toString().match(/unsafe-eval|CSP/)) {
		                      warn('It seems you are using the standalone build of Vue.js in an ' +
		                          'environment with Content Security Policy that prohibits unsafe-eval. ' +
		                          'The template compiler cannot work in this environment. Consider ' +
		                          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
		                          'templates into render functions.');
		                  }
		              }
		          }
		          // check cache
		          var key = options.delimiters
		              ? String(options.delimiters) + template
		              : template;
		          if (cache[key]) {
		              return cache[key];
		          }
		          // compile
		          var compiled = compile(template, options);
		          // check compilation errors/tips
		          {
		              if (compiled.errors && compiled.errors.length) {
		                  if (options.outputSourceRange) {
		                      compiled.errors.forEach(function (e) {
		                          warn("Error compiling template:\n\n".concat(e.msg, "\n\n") +
		                              generateCodeFrame(template, e.start, e.end), vm);
		                      });
		                  }
		                  else {
		                      warn("Error compiling template:\n\n".concat(template, "\n\n") +
		                          compiled.errors.map(function (e) { return "- ".concat(e); }).join('\n') +
		                          '\n', vm);
		                  }
		              }
		              if (compiled.tips && compiled.tips.length) {
		                  if (options.outputSourceRange) {
		                      compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
		                  }
		                  else {
		                      compiled.tips.forEach(function (msg) { return tip(msg, vm); });
		                  }
		              }
		          }
		          // turn code into functions
		          var res = {};
		          var fnGenErrors = [];
		          res.render = createFunction(compiled.render, fnGenErrors);
		          res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
		              return createFunction(code, fnGenErrors);
		          });
		          // check function generation errors.
		          // this should only happen if there is a bug in the compiler itself.
		          // mostly for codegen development use
		          /* istanbul ignore if */
		          {
		              if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
		                  warn("Failed to generate render function:\n\n" +
		                      fnGenErrors
		                          .map(function (_a) {
		                          var err = _a.err, code = _a.code;
		                          return "".concat(err.toString(), " in\n\n").concat(code, "\n");
		                      })
		                          .join('\n'), vm);
		              }
		          }
		          return (cache[key] = res);
		      };
		  }

		  function createCompilerCreator(baseCompile) {
		      return function createCompiler(baseOptions) {
		          function compile(template, options) {
		              var finalOptions = Object.create(baseOptions);
		              var errors = [];
		              var tips = [];
		              var warn = function (msg, range, tip) {
		                  (tip ? tips : errors).push(msg);
		              };
		              if (options) {
		                  if (options.outputSourceRange) {
		                      // $flow-disable-line
		                      var leadingSpaceLength_1 = template.match(/^\s*/)[0].length;
		                      warn = function (msg, range, tip) {
		                          var data = typeof msg === 'string' ? { msg: msg } : msg;
		                          if (range) {
		                              if (range.start != null) {
		                                  data.start = range.start + leadingSpaceLength_1;
		                              }
		                              if (range.end != null) {
		                                  data.end = range.end + leadingSpaceLength_1;
		                              }
		                          }
		                          (tip ? tips : errors).push(data);
		                      };
		                  }
		                  // merge custom modules
		                  if (options.modules) {
		                      finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
		                  }
		                  // merge custom directives
		                  if (options.directives) {
		                      finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
		                  }
		                  // copy other options
		                  for (var key in options) {
		                      if (key !== 'modules' && key !== 'directives') {
		                          finalOptions[key] = options[key];
		                      }
		                  }
		              }
		              finalOptions.warn = warn;
		              var compiled = baseCompile(template.trim(), finalOptions);
		              {
		                  detectErrors(compiled.ast, warn);
		              }
		              compiled.errors = errors;
		              compiled.tips = tips;
		              return compiled;
		          }
		          return {
		              compile: compile,
		              compileToFunctions: createCompileToFunctionFn(compile)
		          };
		      };
		  }

		  // `createCompilerCreator` allows creating compilers that use alternative
		  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
		  // Here we just export a default compiler using the default parts.
		  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
		      var ast = parse(template.trim(), options);
		      if (options.optimize !== false) {
		          optimize(ast, options);
		      }
		      var code = generate(ast, options);
		      return {
		          ast: ast,
		          render: code.render,
		          staticRenderFns: code.staticRenderFns
		      };
		  });

		  var _a = createCompiler(baseOptions), compileToFunctions = _a.compileToFunctions;

		  // check whether current browser encodes a char inside attribute values
		  var div;
		  function getShouldDecode(href) {
		      div = div || document.createElement('div');
		      div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
		      return div.innerHTML.indexOf('&#10;') > 0;
		  }
		  // #3663: IE encodes newlines inside attribute values while other browsers don't
		  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
		  // #6828: chrome encodes content in a[href]
		  var shouldDecodeNewlinesForHref = inBrowser
		      ? getShouldDecode(true)
		      : false;

		  var idToTemplate = cached(function (id) {
		      var el = query(id);
		      return el && el.innerHTML;
		  });
		  var mount = Vue.prototype.$mount;
		  Vue.prototype.$mount = function (el, hydrating) {
		      el = el && query(el);
		      /* istanbul ignore if */
		      if (el === document.body || el === document.documentElement) {
		          warn$2("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
		          return this;
		      }
		      var options = this.$options;
		      // resolve template/el and convert to render function
		      if (!options.render) {
		          var template = options.template;
		          if (template) {
		              if (typeof template === 'string') {
		                  if (template.charAt(0) === '#') {
		                      template = idToTemplate(template);
		                      /* istanbul ignore if */
		                      if (!template) {
		                          warn$2("Template element not found or is empty: ".concat(options.template), this);
		                      }
		                  }
		              }
		              else if (template.nodeType) {
		                  template = template.innerHTML;
		              }
		              else {
		                  {
		                      warn$2('invalid template option:' + template, this);
		                  }
		                  return this;
		              }
		          }
		          else if (el) {
		              // @ts-expect-error
		              template = getOuterHTML(el);
		          }
		          if (template) {
		              /* istanbul ignore if */
		              if (config.performance && mark) {
		                  mark('compile');
		              }
		              var _a = compileToFunctions(template, {
		                  outputSourceRange: true,
		                  shouldDecodeNewlines: shouldDecodeNewlines,
		                  shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
		                  delimiters: options.delimiters,
		                  comments: options.comments
		              }, this), render = _a.render, staticRenderFns = _a.staticRenderFns;
		              options.render = render;
		              options.staticRenderFns = staticRenderFns;
		              /* istanbul ignore if */
		              if (config.performance && mark) {
		                  mark('compile end');
		                  measure("vue ".concat(this._name, " compile"), 'compile', 'compile end');
		              }
		          }
		      }
		      return mount.call(this, el, hydrating);
		  };
		  /**
		   * Get outerHTML of elements, taking care
		   * of SVG elements in IE as well.
		   */
		  function getOuterHTML(el) {
		      if (el.outerHTML) {
		          return el.outerHTML;
		      }
		      else {
		          var container = document.createElement('div');
		          container.appendChild(el.cloneNode(true));
		          return container.innerHTML;
		      }
		  }
		  Vue.compile = compileToFunctions;

		  // export type EffectScheduler = (...args: any[]) => any
		  /**
		   * @internal since we are not exposing this in Vue 2, it's used only for
		   * internal testing.
		   */
		  function effect(fn, scheduler) {
		      var watcher = new Watcher(currentInstance, fn, noop, {
		          sync: true
		      });
		      if (scheduler) {
		          watcher.update = function () {
		              scheduler(function () { return watcher.run(); });
		          };
		      }
		  }

		  extend(Vue, vca);
		  Vue.effect = effect;

		  return Vue;

		}));
	} (vue));

	var Vue$1 = /*@__PURE__*/getDefaultExportFromCjs(vue.exports);

	var axios$2 = {exports: {}};

	var axios$1 = {exports: {}};

	var bind$3 = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

	var bind$2 = bind$3;

	// utils is a library of generic helper functions non-specific to axios

	var toString$2 = Object.prototype.toString;

	// eslint-disable-next-line func-names
	var kindOf = (function(cache) {
	  // eslint-disable-next-line func-names
	  return function(thing) {
	    var str = toString$2.call(thing);
	    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	  };
	})(Object.create(null));

	function kindOfTest(type) {
	  type = type.toLowerCase();
	  return function isKindOf(thing) {
	    return kindOf(thing) === type;
	  };
	}

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray$2(val) {
	  return Array.isArray(val);
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer$1(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	var isArrayBuffer = kindOfTest('ArrayBuffer');


	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject$1(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {Object} val The value to test
	 * @return {boolean} True if value is a plain Object, otherwise false
	 */
	function isPlainObject$1(val) {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }

	  var prototype = Object.getPrototypeOf(val);
	  return prototype === null || prototype === Object.prototype;
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	var isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	var isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	var isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	var isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction$1(val) {
	  return toString$2.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject$1(val) && isFunction$1(val.pipe);
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} thing The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(thing) {
	  var pattern = '[object FormData]';
	  return thing && (
	    (typeof FormData === 'function' && thing instanceof FormData) ||
	    toString$2.call(thing) === pattern ||
	    (isFunction$1(thing.toString) && thing.toString() === pattern)
	  );
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 * @function
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	var isURLSearchParams = kindOfTest('URLSearchParams');

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
	                                           navigator.product === 'NativeScript' ||
	                                           navigator.product === 'NS')) {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray$2(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
	      result[key] = merge(result[key], val);
	    } else if (isPlainObject$1(val)) {
	      result[key] = merge({}, val);
	    } else if (isArray$2(val)) {
	      result[key] = val.slice();
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend$1(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind$2(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 * @return {string} content value without BOM
	 */
	function stripBOM(content) {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	}

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 */

	function inherits(constructor, superConstructor, props, descriptors) {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  props && Object.assign(constructor.prototype, props);
	}

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function} [filter]
	 * @returns {Object}
	 */

	function toFlatObject(sourceObj, destObj, filter) {
	  var props;
	  var i;
	  var prop;
	  var merged = {};

	  destObj = destObj || {};

	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if (!merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = Object.getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

	  return destObj;
	}

	/*
	 * determines whether a string ends with the characters of a specified string
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 * @returns {boolean}
	 */
	function endsWith(str, searchString, position) {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  var lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	}


	/**
	 * Returns new array from array like object
	 * @param {*} [thing]
	 * @returns {Array}
	 */
	function toArray$1(thing) {
	  if (!thing) return null;
	  var i = thing.length;
	  if (isUndefined(i)) return null;
	  var arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	}

	// eslint-disable-next-line func-names
	var isTypedArray = (function(TypedArray) {
	  // eslint-disable-next-line func-names
	  return function(thing) {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

	var utils$9 = {
	  isArray: isArray$2,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer$1,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject$1,
	  isPlainObject: isPlainObject$1,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction$1,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend$1,
	  trim: trim,
	  stripBOM: stripBOM,
	  inherits: inherits,
	  toFlatObject: toFlatObject,
	  kindOf: kindOf,
	  kindOfTest: kindOfTest,
	  endsWith: endsWith,
	  toArray: toArray$1,
	  isTypedArray: isTypedArray,
	  isFileList: isFileList
	};

	var utils$8 = utils$9;

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	var buildURL$1 = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils$8.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils$8.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils$8.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }

	      utils$8.forEach(val, function parseValue(v) {
	        if (utils$8.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils$8.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    var hashmarkIndex = url.indexOf('#');
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }

	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};

	var utils$7 = utils$9;

	function InterceptorManager$1() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected,
	    synchronous: options ? options.synchronous : false,
	    runWhen: options ? options.runWhen : null
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager$1.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager$1.prototype.forEach = function forEach(fn) {
	  utils$7.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	var InterceptorManager_1 = InterceptorManager$1;

	var global$1 = (typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue$1 = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue$1 = currentQueue.concat(queue$1);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue$1.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue$1.length;
	    while(len) {
	        currentQueue = queue$1;
	        queue$1 = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue$1.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick$1(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue$1.push(new Item(fun, args));
	    if (queue$1.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version$1 = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config$1 = {};

	function noop$1() {}

	var on$1 = noop$1;
	var addListener = noop$1;
	var once$1 = noop$1;
	var off = noop$1;
	var removeListener = noop$1;
	var removeAllListeners = noop$1;
	var emit = noop$1;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance$1 = global$1.performance || {};
	var performanceNow =
	  performance$1.now        ||
	  performance$1.mozNow     ||
	  performance$1.msNow      ||
	  performance$1.oNow       ||
	  performance$1.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance$1)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process = {
	  nextTick: nextTick$1,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version$1,
	  versions: versions,
	  on: on$1,
	  addListener: addListener,
	  once: once$1,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config$1,
	  uptime: uptime
	};

	var utils$6 = utils$9;

	var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
	  utils$6.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

	var AxiosError_1;
	var hasRequiredAxiosError;

	function requireAxiosError () {
		if (hasRequiredAxiosError) return AxiosError_1;
		hasRequiredAxiosError = 1;

		var utils = utils$9;

		/**
		 * Create an Error with the specified message, config, error code, request and response.
		 *
		 * @param {string} message The error message.
		 * @param {string} [code] The error code (for example, 'ECONNABORTED').
		 * @param {Object} [config] The config.
		 * @param {Object} [request] The request.
		 * @param {Object} [response] The response.
		 * @returns {Error} The created error.
		 */
		function AxiosError(message, code, config, request, response) {
		  Error.call(this);
		  this.message = message;
		  this.name = 'AxiosError';
		  code && (this.code = code);
		  config && (this.config = config);
		  request && (this.request = request);
		  response && (this.response = response);
		}

		utils.inherits(AxiosError, Error, {
		  toJSON: function toJSON() {
		    return {
		      // Standard
		      message: this.message,
		      name: this.name,
		      // Microsoft
		      description: this.description,
		      number: this.number,
		      // Mozilla
		      fileName: this.fileName,
		      lineNumber: this.lineNumber,
		      columnNumber: this.columnNumber,
		      stack: this.stack,
		      // Axios
		      config: this.config,
		      code: this.code,
		      status: this.response && this.response.status ? this.response.status : null
		    };
		  }
		});

		var prototype = AxiosError.prototype;
		var descriptors = {};

		[
		  'ERR_BAD_OPTION_VALUE',
		  'ERR_BAD_OPTION',
		  'ECONNABORTED',
		  'ETIMEDOUT',
		  'ERR_NETWORK',
		  'ERR_FR_TOO_MANY_REDIRECTS',
		  'ERR_DEPRECATED',
		  'ERR_BAD_RESPONSE',
		  'ERR_BAD_REQUEST',
		  'ERR_CANCELED'
		// eslint-disable-next-line func-names
		].forEach(function(code) {
		  descriptors[code] = {value: code};
		});

		Object.defineProperties(AxiosError, descriptors);
		Object.defineProperty(prototype, 'isAxiosError', {value: true});

		// eslint-disable-next-line func-names
		AxiosError.from = function(error, code, config, request, response, customProps) {
		  var axiosError = Object.create(prototype);

		  utils.toFlatObject(error, axiosError, function filter(obj) {
		    return obj !== Error.prototype;
		  });

		  AxiosError.call(axiosError, error.message, code, config, request, response);

		  axiosError.name = error.name;

		  customProps && Object.assign(axiosError, customProps);

		  return axiosError;
		};

		AxiosError_1 = AxiosError;
		return AxiosError_1;
	}

	var transitional = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$1 = {}.toString;

	var isArray$1 = Array.isArray || function (arr) {
	  return toString$1.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	kMaxLength();

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) ;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer.isBuffer = isBuffer;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer.concat = function concat (list, length) {
	  if (!isArray$1(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	};

	Buffer.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var toFormData_1;
	var hasRequiredToFormData;

	function requireToFormData () {
		if (hasRequiredToFormData) return toFormData_1;
		hasRequiredToFormData = 1;

		var utils = utils$9;

		/**
		 * Convert a data object to FormData
		 * @param {Object} obj
		 * @param {?Object} [formData]
		 * @returns {Object}
		 **/

		function toFormData(obj, formData) {
		  // eslint-disable-next-line no-param-reassign
		  formData = formData || new FormData();

		  var stack = [];

		  function convertValue(value) {
		    if (value === null) return '';

		    if (utils.isDate(value)) {
		      return value.toISOString();
		    }

		    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
		      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
		    }

		    return value;
		  }

		  function build(data, parentKey) {
		    if (utils.isPlainObject(data) || utils.isArray(data)) {
		      if (stack.indexOf(data) !== -1) {
		        throw Error('Circular reference detected in ' + parentKey);
		      }

		      stack.push(data);

		      utils.forEach(data, function each(value, key) {
		        if (utils.isUndefined(value)) return;
		        var fullKey = parentKey ? parentKey + '.' + key : key;
		        var arr;

		        if (value && !parentKey && typeof value === 'object') {
		          if (utils.endsWith(key, '{}')) {
		            // eslint-disable-next-line no-param-reassign
		            value = JSON.stringify(value);
		          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
		            // eslint-disable-next-line func-names
		            arr.forEach(function(el) {
		              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
		            });
		            return;
		          }
		        }

		        build(value, fullKey);
		      });

		      stack.pop();
		    } else {
		      formData.append(parentKey, convertValue(data));
		    }
		  }

		  build(obj);

		  return formData;
		}

		toFormData_1 = toFormData;
		return toFormData_1;
	}

	var settle;
	var hasRequiredSettle;

	function requireSettle () {
		if (hasRequiredSettle) return settle;
		hasRequiredSettle = 1;

		var AxiosError = requireAxiosError();

		/**
		 * Resolve or reject a Promise based on response status.
		 *
		 * @param {Function} resolve A function that resolves the promise.
		 * @param {Function} reject A function that rejects the promise.
		 * @param {object} response The response.
		 */
		settle = function settle(resolve, reject, response) {
		  var validateStatus = response.config.validateStatus;
		  if (!response.status || !validateStatus || validateStatus(response.status)) {
		    resolve(response);
		  } else {
		    reject(new AxiosError(
		      'Request failed with status code ' + response.status,
		      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
		      response.config,
		      response.request,
		      response
		    ));
		  }
		};
		return settle;
	}

	var cookies;
	var hasRequiredCookies;

	function requireCookies () {
		if (hasRequiredCookies) return cookies;
		hasRequiredCookies = 1;

		var utils = utils$9;

		cookies = (
		  utils.isStandardBrowserEnv() ?

		  // Standard browser envs support document.cookie
		    (function standardBrowserEnv() {
		      return {
		        write: function write(name, value, expires, path, domain, secure) {
		          var cookie = [];
		          cookie.push(name + '=' + encodeURIComponent(value));

		          if (utils.isNumber(expires)) {
		            cookie.push('expires=' + new Date(expires).toGMTString());
		          }

		          if (utils.isString(path)) {
		            cookie.push('path=' + path);
		          }

		          if (utils.isString(domain)) {
		            cookie.push('domain=' + domain);
		          }

		          if (secure === true) {
		            cookie.push('secure');
		          }

		          document.cookie = cookie.join('; ');
		        },

		        read: function read(name) {
		          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
		          return (match ? decodeURIComponent(match[3]) : null);
		        },

		        remove: function remove(name) {
		          this.write(name, '', Date.now() - 86400000);
		        }
		      };
		    })() :

		  // Non standard browser env (web workers, react-native) lack needed support.
		    (function nonStandardBrowserEnv() {
		      return {
		        write: function write() {},
		        read: function read() { return null; },
		        remove: function remove() {}
		      };
		    })()
		);
		return cookies;
	}

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	var isAbsoluteURL$1 = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	};

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};

	var isAbsoluteURL = isAbsoluteURL$1;
	var combineURLs = combineURLs$1;

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 * @returns {string} The combined full path
	 */
	var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	};

	var parseHeaders;
	var hasRequiredParseHeaders;

	function requireParseHeaders () {
		if (hasRequiredParseHeaders) return parseHeaders;
		hasRequiredParseHeaders = 1;

		var utils = utils$9;

		// Headers whose duplicates are ignored by node
		// c.f. https://nodejs.org/api/http.html#http_message_headers
		var ignoreDuplicateOf = [
		  'age', 'authorization', 'content-length', 'content-type', 'etag',
		  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
		  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
		  'referer', 'retry-after', 'user-agent'
		];

		/**
		 * Parse headers into an object
		 *
		 * ```
		 * Date: Wed, 27 Aug 2014 08:58:49 GMT
		 * Content-Type: application/json
		 * Connection: keep-alive
		 * Transfer-Encoding: chunked
		 * ```
		 *
		 * @param {String} headers Headers needing to be parsed
		 * @returns {Object} Headers parsed into an object
		 */
		parseHeaders = function parseHeaders(headers) {
		  var parsed = {};
		  var key;
		  var val;
		  var i;

		  if (!headers) { return parsed; }

		  utils.forEach(headers.split('\n'), function parser(line) {
		    i = line.indexOf(':');
		    key = utils.trim(line.substr(0, i)).toLowerCase();
		    val = utils.trim(line.substr(i + 1));

		    if (key) {
		      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
		        return;
		      }
		      if (key === 'set-cookie') {
		        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
		      } else {
		        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
		      }
		    }
		  });

		  return parsed;
		};
		return parseHeaders;
	}

	var isURLSameOrigin;
	var hasRequiredIsURLSameOrigin;

	function requireIsURLSameOrigin () {
		if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
		hasRequiredIsURLSameOrigin = 1;

		var utils = utils$9;

		isURLSameOrigin = (
		  utils.isStandardBrowserEnv() ?

		  // Standard browser envs have full support of the APIs needed to test
		  // whether the request URL is of the same origin as current location.
		    (function standardBrowserEnv() {
		      var msie = /(msie|trident)/i.test(navigator.userAgent);
		      var urlParsingNode = document.createElement('a');
		      var originURL;

		      /**
		    * Parse a URL to discover it's components
		    *
		    * @param {String} url The URL to be parsed
		    * @returns {Object}
		    */
		      function resolveURL(url) {
		        var href = url;

		        if (msie) {
		        // IE needs attribute set twice to normalize properties
		          urlParsingNode.setAttribute('href', href);
		          href = urlParsingNode.href;
		        }

		        urlParsingNode.setAttribute('href', href);

		        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
		        return {
		          href: urlParsingNode.href,
		          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
		          host: urlParsingNode.host,
		          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
		          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
		          hostname: urlParsingNode.hostname,
		          port: urlParsingNode.port,
		          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
		            urlParsingNode.pathname :
		            '/' + urlParsingNode.pathname
		        };
		      }

		      originURL = resolveURL(window.location.href);

		      /**
		    * Determine if a URL shares the same origin as the current location
		    *
		    * @param {String} requestURL The URL to test
		    * @returns {boolean} True if URL shares the same origin, otherwise false
		    */
		      return function isURLSameOrigin(requestURL) {
		        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
		        return (parsed.protocol === originURL.protocol &&
		            parsed.host === originURL.host);
		      };
		    })() :

		  // Non standard browser envs (web workers, react-native) lack needed support.
		    (function nonStandardBrowserEnv() {
		      return function isURLSameOrigin() {
		        return true;
		      };
		    })()
		);
		return isURLSameOrigin;
	}

	var CanceledError_1;
	var hasRequiredCanceledError;

	function requireCanceledError () {
		if (hasRequiredCanceledError) return CanceledError_1;
		hasRequiredCanceledError = 1;

		var AxiosError = requireAxiosError();
		var utils = utils$9;

		/**
		 * A `CanceledError` is an object that is thrown when an operation is canceled.
		 *
		 * @class
		 * @param {string=} message The message.
		 */
		function CanceledError(message) {
		  // eslint-disable-next-line no-eq-null,eqeqeq
		  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
		  this.name = 'CanceledError';
		}

		utils.inherits(CanceledError, AxiosError, {
		  __CANCEL__: true
		});

		CanceledError_1 = CanceledError;
		return CanceledError_1;
	}

	var parseProtocol;
	var hasRequiredParseProtocol;

	function requireParseProtocol () {
		if (hasRequiredParseProtocol) return parseProtocol;
		hasRequiredParseProtocol = 1;

		parseProtocol = function parseProtocol(url) {
		  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
		  return match && match[1] || '';
		};
		return parseProtocol;
	}

	var xhr;
	var hasRequiredXhr;

	function requireXhr () {
		if (hasRequiredXhr) return xhr;
		hasRequiredXhr = 1;

		var utils = utils$9;
		var settle = requireSettle();
		var cookies = requireCookies();
		var buildURL = buildURL$1;
		var buildFullPath = buildFullPath$1;
		var parseHeaders = requireParseHeaders();
		var isURLSameOrigin = requireIsURLSameOrigin();
		var transitionalDefaults = transitional;
		var AxiosError = requireAxiosError();
		var CanceledError = requireCanceledError();
		var parseProtocol = requireParseProtocol();

		xhr = function xhrAdapter(config) {
		  return new Promise(function dispatchXhrRequest(resolve, reject) {
		    var requestData = config.data;
		    var requestHeaders = config.headers;
		    var responseType = config.responseType;
		    var onCanceled;
		    function done() {
		      if (config.cancelToken) {
		        config.cancelToken.unsubscribe(onCanceled);
		      }

		      if (config.signal) {
		        config.signal.removeEventListener('abort', onCanceled);
		      }
		    }

		    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
		      delete requestHeaders['Content-Type']; // Let the browser set it
		    }

		    var request = new XMLHttpRequest();

		    // HTTP basic authentication
		    if (config.auth) {
		      var username = config.auth.username || '';
		      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
		      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
		    }

		    var fullPath = buildFullPath(config.baseURL, config.url);

		    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

		    // Set the request timeout in MS
		    request.timeout = config.timeout;

		    function onloadend() {
		      if (!request) {
		        return;
		      }
		      // Prepare the response
		      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
		      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
		        request.responseText : request.response;
		      var response = {
		        data: responseData,
		        status: request.status,
		        statusText: request.statusText,
		        headers: responseHeaders,
		        config: config,
		        request: request
		      };

		      settle(function _resolve(value) {
		        resolve(value);
		        done();
		      }, function _reject(err) {
		        reject(err);
		        done();
		      }, response);

		      // Clean up request
		      request = null;
		    }

		    if ('onloadend' in request) {
		      // Use onloadend if available
		      request.onloadend = onloadend;
		    } else {
		      // Listen for ready state to emulate onloadend
		      request.onreadystatechange = function handleLoad() {
		        if (!request || request.readyState !== 4) {
		          return;
		        }

		        // The request errored out and we didn't get a response, this will be
		        // handled by onerror instead
		        // With one exception: request that using file: protocol, most browsers
		        // will return status as 0 even though it's a successful request
		        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
		          return;
		        }
		        // readystate handler is calling before onerror or ontimeout handlers,
		        // so we should call onloadend on the next 'tick'
		        setTimeout(onloadend);
		      };
		    }

		    // Handle browser request cancellation (as opposed to a manual cancellation)
		    request.onabort = function handleAbort() {
		      if (!request) {
		        return;
		      }

		      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

		      // Clean up request
		      request = null;
		    };

		    // Handle low level network errors
		    request.onerror = function handleError() {
		      // Real errors are hidden from us by the browser
		      // onerror should only fire if it's a network error
		      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

		      // Clean up request
		      request = null;
		    };

		    // Handle timeout
		    request.ontimeout = function handleTimeout() {
		      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
		      var transitional = config.transitional || transitionalDefaults;
		      if (config.timeoutErrorMessage) {
		        timeoutErrorMessage = config.timeoutErrorMessage;
		      }
		      reject(new AxiosError(
		        timeoutErrorMessage,
		        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
		        config,
		        request));

		      // Clean up request
		      request = null;
		    };

		    // Add xsrf header
		    // This is only done if running in a standard browser environment.
		    // Specifically not if we're in a web worker, or react-native.
		    if (utils.isStandardBrowserEnv()) {
		      // Add xsrf header
		      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
		        cookies.read(config.xsrfCookieName) :
		        undefined;

		      if (xsrfValue) {
		        requestHeaders[config.xsrfHeaderName] = xsrfValue;
		      }
		    }

		    // Add headers to the request
		    if ('setRequestHeader' in request) {
		      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
		        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
		          // Remove Content-Type if data is undefined
		          delete requestHeaders[key];
		        } else {
		          // Otherwise add header to the request
		          request.setRequestHeader(key, val);
		        }
		      });
		    }

		    // Add withCredentials to request if needed
		    if (!utils.isUndefined(config.withCredentials)) {
		      request.withCredentials = !!config.withCredentials;
		    }

		    // Add responseType to request if needed
		    if (responseType && responseType !== 'json') {
		      request.responseType = config.responseType;
		    }

		    // Handle progress if needed
		    if (typeof config.onDownloadProgress === 'function') {
		      request.addEventListener('progress', config.onDownloadProgress);
		    }

		    // Not all browsers support upload events
		    if (typeof config.onUploadProgress === 'function' && request.upload) {
		      request.upload.addEventListener('progress', config.onUploadProgress);
		    }

		    if (config.cancelToken || config.signal) {
		      // Handle cancellation
		      // eslint-disable-next-line func-names
		      onCanceled = function(cancel) {
		        if (!request) {
		          return;
		        }
		        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
		        request.abort();
		        request = null;
		      };

		      config.cancelToken && config.cancelToken.subscribe(onCanceled);
		      if (config.signal) {
		        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
		      }
		    }

		    if (!requestData) {
		      requestData = null;
		    }

		    var protocol = parseProtocol(fullPath);

		    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
		      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
		      return;
		    }


		    // Send the request
		    request.send(requestData);
		  });
		};
		return xhr;
	}

	var _null;
	var hasRequired_null;

	function require_null () {
		if (hasRequired_null) return _null;
		hasRequired_null = 1;
		// eslint-disable-next-line strict
		_null = null;
		return _null;
	}

	var utils$5 = utils$9;
	var normalizeHeaderName = normalizeHeaderName$1;
	var AxiosError$1 = requireAxiosError();
	var transitionalDefaults = transitional;
	var toFormData = requireToFormData();

	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = requireXhr();
	  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
	    // For node use HTTP adapter
	    adapter = requireXhr();
	  }
	  return adapter;
	}

	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$5.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$5.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	var defaults$3 = {

	  transitional: transitionalDefaults,

	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Accept');
	    normalizeHeaderName(headers, 'Content-Type');

	    if (utils$5.isFormData(data) ||
	      utils$5.isArrayBuffer(data) ||
	      utils$5.isBuffer(data) ||
	      utils$5.isStream(data) ||
	      utils$5.isFile(data) ||
	      utils$5.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils$5.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$5.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }

	    var isObjectPayload = utils$5.isObject(data);
	    var contentType = headers && headers['Content-Type'];

	    var isFileList;

	    if ((isFileList = utils$5.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
	      var _FormData = this.env && this.env.FormData;
	      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
	    } else if (isObjectPayload || contentType === 'application/json') {
	      setContentTypeIfUnset(headers, 'application/json');
	      return stringifySafely(data);
	    }

	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    var transitional = this.transitional || defaults$3.transitional;
	    var silentJSONParsing = transitional && transitional.silentJSONParsing;
	    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

	    if (strictJSONParsing || (forcedJSONParsing && utils$5.isString(data) && data.length)) {
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  env: {
	    FormData: require_null()
	  },

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },

	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*'
	    }
	  }
	};

	utils$5.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults$3.headers[method] = {};
	});

	utils$5.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
	});

	var defaults_1 = defaults$3;

	var utils$4 = utils$9;
	var defaults$2 = defaults_1;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	var transformData$1 = function transformData(data, headers, fns) {
	  var context = this || defaults$2;
	  /*eslint no-param-reassign:0*/
	  utils$4.forEach(fns, function transform(fn) {
	    data = fn.call(context, data, headers);
	  });

	  return data;
	};

	var isCancel$1;
	var hasRequiredIsCancel;

	function requireIsCancel () {
		if (hasRequiredIsCancel) return isCancel$1;
		hasRequiredIsCancel = 1;

		isCancel$1 = function isCancel(value) {
		  return !!(value && value.__CANCEL__);
		};
		return isCancel$1;
	}

	var utils$3 = utils$9;
	var transformData = transformData$1;
	var isCancel = requireIsCancel();
	var defaults$1 = defaults_1;
	var CanceledError = requireCanceledError();

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }

	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	var dispatchRequest$1 = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData.call(
	    config,
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils$3.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers
	  );

	  utils$3.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults$1.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(
	      config,
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};

	var utils$2 = utils$9;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	var mergeConfig$2 = function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  var config = {};

	  function getMergedValue(target, source) {
	    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
	      return utils$2.merge(target, source);
	    } else if (utils$2.isPlainObject(source)) {
	      return utils$2.merge({}, source);
	    } else if (utils$2.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(prop) {
	    if (!utils$2.isUndefined(config2[prop])) {
	      return getMergedValue(config1[prop], config2[prop]);
	    } else if (!utils$2.isUndefined(config1[prop])) {
	      return getMergedValue(undefined, config1[prop]);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(prop) {
	    if (!utils$2.isUndefined(config2[prop])) {
	      return getMergedValue(undefined, config2[prop]);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(prop) {
	    if (!utils$2.isUndefined(config2[prop])) {
	      return getMergedValue(undefined, config2[prop]);
	    } else if (!utils$2.isUndefined(config1[prop])) {
	      return getMergedValue(undefined, config1[prop]);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(prop) {
	    if (prop in config2) {
	      return getMergedValue(config1[prop], config2[prop]);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, config1[prop]);
	    }
	  }

	  var mergeMap = {
	    'url': valueFromConfig2,
	    'method': valueFromConfig2,
	    'data': valueFromConfig2,
	    'baseURL': defaultToConfig2,
	    'transformRequest': defaultToConfig2,
	    'transformResponse': defaultToConfig2,
	    'paramsSerializer': defaultToConfig2,
	    'timeout': defaultToConfig2,
	    'timeoutMessage': defaultToConfig2,
	    'withCredentials': defaultToConfig2,
	    'adapter': defaultToConfig2,
	    'responseType': defaultToConfig2,
	    'xsrfCookieName': defaultToConfig2,
	    'xsrfHeaderName': defaultToConfig2,
	    'onUploadProgress': defaultToConfig2,
	    'onDownloadProgress': defaultToConfig2,
	    'decompress': defaultToConfig2,
	    'maxContentLength': defaultToConfig2,
	    'maxBodyLength': defaultToConfig2,
	    'beforeRedirect': defaultToConfig2,
	    'transport': defaultToConfig2,
	    'httpAgent': defaultToConfig2,
	    'httpsAgent': defaultToConfig2,
	    'cancelToken': defaultToConfig2,
	    'socketPath': defaultToConfig2,
	    'responseEncoding': defaultToConfig2,
	    'validateStatus': mergeDirectKeys
	  };

	  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
	    var merge = mergeMap[prop] || mergeDeepProperties;
	    var configValue = merge(prop);
	    (utils$2.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
	  });

	  return config;
	};

	var data;
	var hasRequiredData;

	function requireData () {
		if (hasRequiredData) return data;
		hasRequiredData = 1;
		data = {
		  "version": "0.27.2"
		};
		return data;
	}

	var VERSION = requireData().version;
	var AxiosError = requireAxiosError();

	var validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	var deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return function(value, opt, opts) {
	    if (validator === false) {
	      throw new AxiosError(
	        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
	        AxiosError.ERR_DEPRECATED
	      );
	    }

	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	/**
	 * Assert object's properties type
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
	  }
	  var keys = Object.keys(options);
	  var i = keys.length;
	  while (i-- > 0) {
	    var opt = keys[i];
	    var validator = schema[opt];
	    if (validator) {
	      var value = options[opt];
	      var result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
	    }
	  }
	}

	var validator$1 = {
	  assertOptions: assertOptions,
	  validators: validators$1
	};

	var utils$1 = utils$9;
	var buildURL = buildURL$1;
	var InterceptorManager = InterceptorManager_1;
	var dispatchRequest = dispatchRequest$1;
	var mergeConfig$1 = mergeConfig$2;
	var buildFullPath = buildFullPath$1;
	var validator = validator$1;

	var validators = validator.validators;
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios$1(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios$1.prototype.request = function request(configOrUrl, config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof configOrUrl === 'string') {
	    config = config || {};
	    config.url = configOrUrl;
	  } else {
	    config = configOrUrl || {};
	  }

	  config = mergeConfig$1(this.defaults, config);

	  // Set config.method
	  if (config.method) {
	    config.method = config.method.toLowerCase();
	  } else if (this.defaults.method) {
	    config.method = this.defaults.method.toLowerCase();
	  } else {
	    config.method = 'get';
	  }

	  var transitional = config.transitional;

	  if (transitional !== undefined) {
	    validator.assertOptions(transitional, {
	      silentJSONParsing: validators.transitional(validators.boolean),
	      forcedJSONParsing: validators.transitional(validators.boolean),
	      clarifyTimeoutError: validators.transitional(validators.boolean)
	    }, false);
	  }

	  // filter out skipped interceptors
	  var requestInterceptorChain = [];
	  var synchronousRequestInterceptors = true;
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	      return;
	    }

	    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  var responseInterceptorChain = [];
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  var promise;

	  if (!synchronousRequestInterceptors) {
	    var chain = [dispatchRequest, undefined];

	    Array.prototype.unshift.apply(chain, requestInterceptorChain);
	    chain = chain.concat(responseInterceptorChain);

	    promise = Promise.resolve(config);
	    while (chain.length) {
	      promise = promise.then(chain.shift(), chain.shift());
	    }

	    return promise;
	  }


	  var newConfig = config;
	  while (requestInterceptorChain.length) {
	    var onFulfilled = requestInterceptorChain.shift();
	    var onRejected = requestInterceptorChain.shift();
	    try {
	      newConfig = onFulfilled(newConfig);
	    } catch (error) {
	      onRejected(error);
	      break;
	    }
	  }

	  try {
	    promise = dispatchRequest(newConfig);
	  } catch (error) {
	    return Promise.reject(error);
	  }

	  while (responseInterceptorChain.length) {
	    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
	  }

	  return promise;
	};

	Axios$1.prototype.getUri = function getUri(config) {
	  config = mergeConfig$1(this.defaults, config);
	  var fullPath = buildFullPath(config.baseURL, config.url);
	  return buildURL(fullPath, config.params, config.paramsSerializer);
	};

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function(url, config) {
	    return this.request(mergeConfig$1(config || {}, {
	      method: method,
	      url: url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig$1(config || {}, {
	        method: method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url: url,
	        data: data
	      }));
	    };
	  }

	  Axios$1.prototype[method] = generateHTTPMethod();

	  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	var Axios_1 = Axios$1;

	var CancelToken_1;
	var hasRequiredCancelToken;

	function requireCancelToken () {
		if (hasRequiredCancelToken) return CancelToken_1;
		hasRequiredCancelToken = 1;

		var CanceledError = requireCanceledError();

		/**
		 * A `CancelToken` is an object that can be used to request cancellation of an operation.
		 *
		 * @class
		 * @param {Function} executor The executor function.
		 */
		function CancelToken(executor) {
		  if (typeof executor !== 'function') {
		    throw new TypeError('executor must be a function.');
		  }

		  var resolvePromise;

		  this.promise = new Promise(function promiseExecutor(resolve) {
		    resolvePromise = resolve;
		  });

		  var token = this;

		  // eslint-disable-next-line func-names
		  this.promise.then(function(cancel) {
		    if (!token._listeners) return;

		    var i;
		    var l = token._listeners.length;

		    for (i = 0; i < l; i++) {
		      token._listeners[i](cancel);
		    }
		    token._listeners = null;
		  });

		  // eslint-disable-next-line func-names
		  this.promise.then = function(onfulfilled) {
		    var _resolve;
		    // eslint-disable-next-line func-names
		    var promise = new Promise(function(resolve) {
		      token.subscribe(resolve);
		      _resolve = resolve;
		    }).then(onfulfilled);

		    promise.cancel = function reject() {
		      token.unsubscribe(_resolve);
		    };

		    return promise;
		  };

		  executor(function cancel(message) {
		    if (token.reason) {
		      // Cancellation has already been requested
		      return;
		    }

		    token.reason = new CanceledError(message);
		    resolvePromise(token.reason);
		  });
		}

		/**
		 * Throws a `CanceledError` if cancellation has been requested.
		 */
		CancelToken.prototype.throwIfRequested = function throwIfRequested() {
		  if (this.reason) {
		    throw this.reason;
		  }
		};

		/**
		 * Subscribe to the cancel signal
		 */

		CancelToken.prototype.subscribe = function subscribe(listener) {
		  if (this.reason) {
		    listener(this.reason);
		    return;
		  }

		  if (this._listeners) {
		    this._listeners.push(listener);
		  } else {
		    this._listeners = [listener];
		  }
		};

		/**
		 * Unsubscribe from the cancel signal
		 */

		CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
		  if (!this._listeners) {
		    return;
		  }
		  var index = this._listeners.indexOf(listener);
		  if (index !== -1) {
		    this._listeners.splice(index, 1);
		  }
		};

		/**
		 * Returns an object that contains a new `CancelToken` and a function that, when called,
		 * cancels the `CancelToken`.
		 */
		CancelToken.source = function source() {
		  var cancel;
		  var token = new CancelToken(function executor(c) {
		    cancel = c;
		  });
		  return {
		    token: token,
		    cancel: cancel
		  };
		};

		CancelToken_1 = CancelToken;
		return CancelToken_1;
	}

	var spread;
	var hasRequiredSpread;

	function requireSpread () {
		if (hasRequiredSpread) return spread;
		hasRequiredSpread = 1;

		/**
		 * Syntactic sugar for invoking a function and expanding an array for arguments.
		 *
		 * Common use case would be to use `Function.prototype.apply`.
		 *
		 *  ```js
		 *  function f(x, y, z) {}
		 *  var args = [1, 2, 3];
		 *  f.apply(null, args);
		 *  ```
		 *
		 * With `spread` this example can be re-written.
		 *
		 *  ```js
		 *  spread(function(x, y, z) {})([1, 2, 3]);
		 *  ```
		 *
		 * @param {Function} callback
		 * @returns {Function}
		 */
		spread = function spread(callback) {
		  return function wrap(arr) {
		    return callback.apply(null, arr);
		  };
		};
		return spread;
	}

	var isAxiosError;
	var hasRequiredIsAxiosError;

	function requireIsAxiosError () {
		if (hasRequiredIsAxiosError) return isAxiosError;
		hasRequiredIsAxiosError = 1;

		var utils = utils$9;

		/**
		 * Determines whether the payload is an error thrown by Axios
		 *
		 * @param {*} payload The value to test
		 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
		 */
		isAxiosError = function isAxiosError(payload) {
		  return utils.isObject(payload) && (payload.isAxiosError === true);
		};
		return isAxiosError;
	}

	var utils = utils$9;
	var bind$1 = bind$3;
	var Axios = Axios_1;
	var mergeConfig = mergeConfig$2;
	var defaults = defaults_1;

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind$1(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	  };

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Expose Cancel & CancelToken
	axios.CanceledError = requireCanceledError();
	axios.CancelToken = requireCancelToken();
	axios.isCancel = requireIsCancel();
	axios.VERSION = requireData().version;
	axios.toFormData = requireToFormData();

	// Expose AxiosError class
	axios.AxiosError = requireAxiosError();

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = requireSpread();

	// Expose isAxiosError
	axios.isAxiosError = requireIsAxiosError();

	axios$1.exports = axios;

	// Allow use of default import syntax in TypeScript
	axios$1.exports.default = axios;

	(function (module) {
		module.exports = axios$1.exports;
	} (axios$2));

	var e = /*@__PURE__*/getDefaultExportFromCjs(axios$2.exports);

	/*!
	 * Vue.js v2.7.8
	 * (c) 2014-2022 Evan You
	 * Released under the MIT License.
	 */
	var emptyObject = Object.freeze({});
	var isArray = Array.isArray;
	// These helpers produce better VM code in JS engines due to their
	// explicitness and function inlining.
	function isUndef(v) {
	    return v === undefined || v === null;
	}
	function isDef(v) {
	    return v !== undefined && v !== null;
	}
	function isTrue(v) {
	    return v === true;
	}
	function isFalse(v) {
	    return v === false;
	}
	/**
	 * Check if value is primitive.
	 */
	function isPrimitive(value) {
	    return (typeof value === 'string' ||
	        typeof value === 'number' ||
	        // $flow-disable-line
	        typeof value === 'symbol' ||
	        typeof value === 'boolean');
	}
	function isFunction(value) {
	    return typeof value === 'function';
	}
	/**
	 * Quick object check - this is primarily used to tell
	 * objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	/**
	 * Get the raw type string of a value, e.g., [object Object].
	 */
	var _toString = Object.prototype.toString;
	function toRawType(value) {
	    return _toString.call(value).slice(8, -1);
	}
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	    return _toString.call(obj) === '[object Object]';
	}
	function isRegExp(v) {
	    return _toString.call(v) === '[object RegExp]';
	}
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	    var n = parseFloat(String(val));
	    return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	function isPromise(val) {
	    return (isDef(val) &&
	        typeof val.then === 'function' &&
	        typeof val.catch === 'function');
	}
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	    return val == null
	        ? ''
	        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
	            ? JSON.stringify(val, null, 2)
	            : String(val);
	}
	/**
	 * Convert an input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	    var n = parseFloat(val);
	    return isNaN(n) ? val : n;
	}
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	    var map = Object.create(null);
	    var list = str.split(',');
	    for (var i = 0; i < list.length; i++) {
	        map[list[i]] = true;
	    }
	    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
	}
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	/**
	 * Check if an attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
	/**
	 * Remove an item from an array.
	 */
	function remove$2(arr, item) {
	    if (arr.length) {
	        var index = arr.indexOf(item);
	        if (index > -1) {
	            return arr.splice(index, 1);
	        }
	    }
	}
	/**
	 * Check whether an object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	    return hasOwnProperty.call(obj, key);
	}
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	    var cache = Object.create(null);
	    return function cachedFn(str) {
	        var hit = cache[str];
	        return hit || (cache[str] = fn(str));
	    };
	}
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
	});
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	});
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /\B([A-Z])/g;
	var hyphenate = cached(function (str) {
	    return str.replace(hyphenateRE, '-$1').toLowerCase();
	});
	/**
	 * Simple bind polyfill for environments that do not support it,
	 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
	 * since native bind is now performant enough in most browsers.
	 * But removing it would mean breaking code that was able to run in
	 * PhantomJS 1.x, so this must be kept for backward compatibility.
	 */
	/* istanbul ignore next */
	function polyfillBind(fn, ctx) {
	    function boundFn(a) {
	        var l = arguments.length;
	        return l
	            ? l > 1
	                ? fn.apply(ctx, arguments)
	                : fn.call(ctx, a)
	            : fn.call(ctx);
	    }
	    boundFn._length = fn.length;
	    return boundFn;
	}
	function nativeBind(fn, ctx) {
	    return fn.bind(ctx);
	}
	// @ts-expect-error bind cannot be `undefined`
	var bind = Function.prototype.bind ? nativeBind : polyfillBind;
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	    start = start || 0;
	    var i = list.length - start;
	    var ret = new Array(i);
	    while (i--) {
	        ret[i] = list[i + start];
	    }
	    return ret;
	}
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	    for (var key in _from) {
	        to[key] = _from[key];
	    }
	    return to;
	}
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	    var res = {};
	    for (var i = 0; i < arr.length; i++) {
	        if (arr[i]) {
	            extend(res, arr[i]);
	        }
	    }
	    return res;
	}
	/* eslint-disable no-unused-vars */
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
	 */
	function noop(a, b, c) { }
	/**
	 * Always return false.
	 */
	var no$1 = function (a, b, c) { return false; };
	/* eslint-enable no-unused-vars */
	/**
	 * Return the same value.
	 */
	var identity = function (_) { return _; };
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	    if (a === b)
	        return true;
	    var isObjectA = isObject(a);
	    var isObjectB = isObject(b);
	    if (isObjectA && isObjectB) {
	        try {
	            var isArrayA = Array.isArray(a);
	            var isArrayB = Array.isArray(b);
	            if (isArrayA && isArrayB) {
	                return (a.length === b.length &&
	                    a.every(function (e, i) {
	                        return looseEqual(e, b[i]);
	                    }));
	            }
	            else if (a instanceof Date && b instanceof Date) {
	                return a.getTime() === b.getTime();
	            }
	            else if (!isArrayA && !isArrayB) {
	                var keysA = Object.keys(a);
	                var keysB = Object.keys(b);
	                return (keysA.length === keysB.length &&
	                    keysA.every(function (key) {
	                        return looseEqual(a[key], b[key]);
	                    }));
	            }
	            else {
	                /* istanbul ignore next */
	                return false;
	            }
	        }
	        catch (e) {
	            /* istanbul ignore next */
	            return false;
	        }
	    }
	    else if (!isObjectA && !isObjectB) {
	        return String(a) === String(b);
	    }
	    else {
	        return false;
	    }
	}
	/**
	 * Return the first index at which a loosely equal value can be
	 * found in the array (if value is a plain object, the array must
	 * contain an object of the same shape), or -1 if it is not present.
	 */
	function looseIndexOf(arr, val) {
	    for (var i = 0; i < arr.length; i++) {
	        if (looseEqual(arr[i], val))
	            return i;
	    }
	    return -1;
	}
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	    var called = false;
	    return function () {
	        if (!called) {
	            called = true;
	            fn.apply(this, arguments);
	        }
	    };
	}
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
	function hasChanged(x, y) {
	    if (x === y) {
	        return x === 0 && 1 / x !== 1 / y;
	    }
	    else {
	        return x === x || y === y;
	    }
	}

	var SSR_ATTR = 'data-server-rendered';
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	var LIFECYCLE_HOOKS = [
	    'beforeCreate',
	    'created',
	    'beforeMount',
	    'mounted',
	    'beforeUpdate',
	    'updated',
	    'beforeDestroy',
	    'destroyed',
	    'activated',
	    'deactivated',
	    'errorCaptured',
	    'serverPrefetch',
	    'renderTracked',
	    'renderTriggered'
	];

	var config = {
	    /**
	     * Option merge strategies (used in core/util/options)
	     */
	    // $flow-disable-line
	    optionMergeStrategies: Object.create(null),
	    /**
	     * Whether to suppress warnings.
	     */
	    silent: false,
	    /**
	     * Show production mode tip message on boot?
	     */
	    productionTip: process.env.NODE_ENV !== 'production',
	    /**
	     * Whether to enable devtools
	     */
	    devtools: process.env.NODE_ENV !== 'production',
	    /**
	     * Whether to record perf
	     */
	    performance: false,
	    /**
	     * Error handler for watcher errors
	     */
	    errorHandler: null,
	    /**
	     * Warn handler for watcher warns
	     */
	    warnHandler: null,
	    /**
	     * Ignore certain custom elements
	     */
	    ignoredElements: [],
	    /**
	     * Custom user key aliases for v-on
	     */
	    // $flow-disable-line
	    keyCodes: Object.create(null),
	    /**
	     * Check if a tag is reserved so that it cannot be registered as a
	     * component. This is platform-dependent and may be overwritten.
	     */
	    isReservedTag: no$1,
	    /**
	     * Check if an attribute is reserved so that it cannot be used as a component
	     * prop. This is platform-dependent and may be overwritten.
	     */
	    isReservedAttr: no$1,
	    /**
	     * Check if a tag is an unknown element.
	     * Platform-dependent.
	     */
	    isUnknownElement: no$1,
	    /**
	     * Get the namespace of an element
	     */
	    getTagNamespace: noop,
	    /**
	     * Parse the real tag name for the specific platform.
	     */
	    parsePlatformTagName: identity,
	    /**
	     * Check if an attribute must be bound using property, e.g. value
	     * Platform-dependent.
	     */
	    mustUseProp: no$1,
	    /**
	     * Perform updates asynchronously. Intended to be used by Vue Test Utils
	     * This will significantly reduce performance if set to false.
	     */
	    async: true,
	    /**
	     * Exposed for legacy reasons
	     */
	    _lifecycleHooks: LIFECYCLE_HOOKS
	};

	/**
	 * unicode letters used for parsing html tags, component names and property paths.
	 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
	 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
	 */
	var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	    var c = (str + '').charCodeAt(0);
	    return c === 0x24 || c === 0x5f;
	}
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	    Object.defineProperty(obj, key, {
	        value: val,
	        enumerable: !!enumerable,
	        writable: true,
	        configurable: true
	    });
	}
	/**
	 * Parse simple path.
	 */
	var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
	function parsePath(path) {
	    if (bailRE.test(path)) {
	        return;
	    }
	    var segments = path.split('.');
	    return function (obj) {
	        for (var i = 0; i < segments.length; i++) {
	            if (!obj)
	                return;
	            obj = obj[segments[i]];
	        }
	        return obj;
	    };
	}

	// can we use __proto__?
	var hasProto = '__proto__' in {};
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA$1 = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA$1 && /msie|trident/.test(UA$1);
	var isIE9 = UA$1 && UA$1.indexOf('msie 9.0') > 0;
	var isEdge = UA$1 && UA$1.indexOf('edge/') > 0;
	UA$1 && UA$1.indexOf('android') > 0;
	var isIOS = UA$1 && /iphone|ipad|ipod|ios/.test(UA$1);
	UA$1 && /chrome\/\d+/.test(UA$1) && !isEdge;
	UA$1 && /phantomjs/.test(UA$1);
	var isFF = UA$1 && UA$1.match(/firefox\/(\d+)/);
	// Firefox has a "watch" function on Object.prototype...
	// @ts-expect-error firebox support
	var nativeWatch = {}.watch;
	var supportsPassive = false;
	if (inBrowser) {
	    try {
	        var opts = {};
	        Object.defineProperty(opts, 'passive', {
	            get: function () {
	                /* istanbul ignore next */
	                supportsPassive = true;
	            }
	        }); // https://github.com/facebook/flow/issues/285
	        window.addEventListener('test-passive', null, opts);
	    }
	    catch (e) { }
	}
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function () {
	    if (_isServer === undefined) {
	        /* istanbul ignore if */
	        if (!inBrowser && typeof global$1 !== 'undefined') {
	            // detect presence of vue-server-renderer and avoid
	            // Webpack shimming the process
	            _isServer =
	                global$1['process'] && global$1['process'].env.VUE_ENV === 'server';
	        }
	        else {
	            _isServer = false;
	        }
	    }
	    return _isServer;
	};
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	/* istanbul ignore next */
	function isNative(Ctor) {
	    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	var hasSymbol = typeof Symbol !== 'undefined' &&
	    isNative(Symbol) &&
	    typeof Reflect !== 'undefined' &&
	    isNative(Reflect.ownKeys);
	var _Set; // $flow-disable-line
	/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
	    // use native Set when available.
	    _Set = Set;
	}
	else {
	    // a non-standard Set polyfill that only works with primitive keys.
	    _Set = /** @class */ (function () {
	        function Set() {
	            this.set = Object.create(null);
	        }
	        Set.prototype.has = function (key) {
	            return this.set[key] === true;
	        };
	        Set.prototype.add = function (key) {
	            this.set[key] = true;
	        };
	        Set.prototype.clear = function () {
	            this.set = Object.create(null);
	        };
	        return Set;
	    }());
	}

	var currentInstance = null;
	/**
	 * @internal
	 */
	function setCurrentInstance(vm) {
	    if (vm === void 0) { vm = null; }
	    if (!vm)
	        currentInstance && currentInstance._scope.off();
	    currentInstance = vm;
	    vm && vm._scope.on();
	}

	/**
	 * @internal
	 */
	var VNode = /** @class */ (function () {
	    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	        this.tag = tag;
	        this.data = data;
	        this.children = children;
	        this.text = text;
	        this.elm = elm;
	        this.ns = undefined;
	        this.context = context;
	        this.fnContext = undefined;
	        this.fnOptions = undefined;
	        this.fnScopeId = undefined;
	        this.key = data && data.key;
	        this.componentOptions = componentOptions;
	        this.componentInstance = undefined;
	        this.parent = undefined;
	        this.raw = false;
	        this.isStatic = false;
	        this.isRootInsert = true;
	        this.isComment = false;
	        this.isCloned = false;
	        this.isOnce = false;
	        this.asyncFactory = asyncFactory;
	        this.asyncMeta = undefined;
	        this.isAsyncPlaceholder = false;
	    }
	    Object.defineProperty(VNode.prototype, "child", {
	        // DEPRECATED: alias for componentInstance for backwards compat.
	        /* istanbul ignore next */
	        get: function () {
	            return this.componentInstance;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return VNode;
	}());
	var createEmptyVNode = function (text) {
	    if (text === void 0) { text = ''; }
	    var node = new VNode();
	    node.text = text;
	    node.isComment = true;
	    return node;
	};
	function createTextVNode(val) {
	    return new VNode(undefined, undefined, undefined, String(val));
	}
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	    var cloned = new VNode(vnode.tag, vnode.data, 
	    // #7975
	    // clone children array to avoid mutating original in case of cloning
	    // a child.
	    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	    cloned.ns = vnode.ns;
	    cloned.isStatic = vnode.isStatic;
	    cloned.key = vnode.key;
	    cloned.isComment = vnode.isComment;
	    cloned.fnContext = vnode.fnContext;
	    cloned.fnOptions = vnode.fnOptions;
	    cloned.fnScopeId = vnode.fnScopeId;
	    cloned.asyncMeta = vnode.asyncMeta;
	    cloned.isCloned = true;
	    return cloned;
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	var uid$2 = 0;
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 * @internal
	 */
	var Dep = /** @class */ (function () {
	    function Dep() {
	        this.id = uid$2++;
	        this.subs = [];
	    }
	    Dep.prototype.addSub = function (sub) {
	        this.subs.push(sub);
	    };
	    Dep.prototype.removeSub = function (sub) {
	        remove$2(this.subs, sub);
	    };
	    Dep.prototype.depend = function (info) {
	        if (Dep.target) {
	            Dep.target.addDep(this);
	            if (process.env.NODE_ENV !== 'production' && info && Dep.target.onTrack) {
	                Dep.target.onTrack(__assign({ effect: Dep.target }, info));
	            }
	        }
	    };
	    Dep.prototype.notify = function (info) {
	        // stabilize the subscriber list first
	        var subs = this.subs.slice();
	        if (process.env.NODE_ENV !== 'production' && !config.async) {
	            // subs aren't sorted in scheduler if not running async
	            // we need to sort them now to make sure they fire in correct
	            // order
	            subs.sort(function (a, b) { return a.id - b.id; });
	        }
	        for (var i = 0, l = subs.length; i < l; i++) {
	            if (process.env.NODE_ENV !== 'production' && info) {
	                var sub = subs[i];
	                sub.onTrigger &&
	                    sub.onTrigger(__assign({ effect: subs[i] }, info));
	            }
	            subs[i].update();
	        }
	    };
	    return Dep;
	}());
	// The current target watcher being evaluated.
	// This is globally unique because only one watcher
	// can be evaluated at a time.
	Dep.target = null;
	var targetStack = [];
	function pushTarget(target) {
	    targetStack.push(target);
	    Dep.target = target;
	}
	function popTarget() {
	    targetStack.pop();
	    Dep.target = targetStack[targetStack.length - 1];
	}

	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);
	var methodsToPatch = [
	    'push',
	    'pop',
	    'shift',
	    'unshift',
	    'splice',
	    'sort',
	    'reverse'
	];
	/**
	 * Intercept mutating methods and emit events
	 */
	methodsToPatch.forEach(function (method) {
	    // cache original method
	    var original = arrayProto[method];
	    def(arrayMethods, method, function mutator() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var result = original.apply(this, args);
	        var ob = this.__ob__;
	        var inserted;
	        switch (method) {
	            case 'push':
	            case 'unshift':
	                inserted = args;
	                break;
	            case 'splice':
	                inserted = args.slice(2);
	                break;
	        }
	        if (inserted)
	            ob.observeArray(inserted);
	        // notify change
	        if (process.env.NODE_ENV !== 'production') {
	            ob.dep.notify({
	                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
	                target: this,
	                key: method
	            });
	        }
	        else {
	            ob.dep.notify();
	        }
	        return result;
	    });
	});

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	var NO_INIITIAL_VALUE = {};
	/**
	 * In some cases we may want to disable observation inside a component's
	 * update computation.
	 */
	var shouldObserve = true;
	function toggleObserving(value) {
	    shouldObserve = value;
	}
	// ssr mock dep
	var mockDep = {
	    notify: noop,
	    depend: noop,
	    addSub: noop,
	    removeSub: noop
	};
	/**
	 * Observer class that is attached to each observed
	 * object. Once attached, the observer converts the target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatch updates.
	 */
	var Observer = /** @class */ (function () {
	    function Observer(value, shallow, mock) {
	        if (shallow === void 0) { shallow = false; }
	        if (mock === void 0) { mock = false; }
	        this.value = value;
	        this.shallow = shallow;
	        this.mock = mock;
	        // this.value = value
	        this.dep = mock ? mockDep : new Dep();
	        this.vmCount = 0;
	        def(value, '__ob__', this);
	        if (isArray(value)) {
	            if (!mock) {
	                if (hasProto) {
	                    value.__proto__ = arrayMethods;
	                    /* eslint-enable no-proto */
	                }
	                else {
	                    for (var i = 0, l = arrayKeys.length; i < l; i++) {
	                        var key = arrayKeys[i];
	                        def(value, key, arrayMethods[key]);
	                    }
	                }
	            }
	            if (!shallow) {
	                this.observeArray(value);
	            }
	        }
	        else {
	            /**
	             * Walk through all properties and convert them into
	             * getter/setters. This method should only be called when
	             * value type is Object.
	             */
	            var keys = Object.keys(value);
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);
	            }
	        }
	    }
	    /**
	     * Observe a list of Array items.
	     */
	    Observer.prototype.observeArray = function (value) {
	        for (var i = 0, l = value.length; i < l; i++) {
	            observe(value[i], false, this.mock);
	        }
	    };
	    return Observer;
	}());
	// helpers
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, shallow, ssrMockReactivity) {
	    if (!isObject(value) || isRef(value) || value instanceof VNode) {
	        return;
	    }
	    var ob;
	    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	        ob = value.__ob__;
	    }
	    else if (shouldObserve &&
	        (ssrMockReactivity || !isServerRendering()) &&
	        (isArray(value) || isPlainObject(value)) &&
	        Object.isExtensible(value) &&
	        !value.__v_skip /* ReactiveFlags.SKIP */) {
	        ob = new Observer(value, shallow, ssrMockReactivity);
	    }
	    return ob;
	}
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive(obj, key, val, customSetter, shallow, mock) {
	    var dep = new Dep();
	    var property = Object.getOwnPropertyDescriptor(obj, key);
	    if (property && property.configurable === false) {
	        return;
	    }
	    // cater for pre-defined getter/setters
	    var getter = property && property.get;
	    var setter = property && property.set;
	    if ((!getter || setter) &&
	        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
	        val = obj[key];
	    }
	    var childOb = !shallow && observe(val, false, mock);
	    Object.defineProperty(obj, key, {
	        enumerable: true,
	        configurable: true,
	        get: function reactiveGetter() {
	            var value = getter ? getter.call(obj) : val;
	            if (Dep.target) {
	                if (process.env.NODE_ENV !== 'production') {
	                    dep.depend({
	                        target: obj,
	                        type: "get" /* TrackOpTypes.GET */,
	                        key: key
	                    });
	                }
	                else {
	                    dep.depend();
	                }
	                if (childOb) {
	                    childOb.dep.depend();
	                    if (isArray(value)) {
	                        dependArray(value);
	                    }
	                }
	            }
	            return isRef(value) && !shallow ? value.value : value;
	        },
	        set: function reactiveSetter(newVal) {
	            var value = getter ? getter.call(obj) : val;
	            if (!hasChanged(value, newVal)) {
	                return;
	            }
	            if (process.env.NODE_ENV !== 'production' && customSetter) {
	                customSetter();
	            }
	            if (setter) {
	                setter.call(obj, newVal);
	            }
	            else if (getter) {
	                // #7981: for accessor properties without setter
	                return;
	            }
	            else if (!shallow && isRef(value) && !isRef(newVal)) {
	                value.value = newVal;
	                return;
	            }
	            else {
	                val = newVal;
	            }
	            childOb = !shallow && observe(newVal, false, mock);
	            if (process.env.NODE_ENV !== 'production') {
	                dep.notify({
	                    type: "set" /* TriggerOpTypes.SET */,
	                    target: obj,
	                    key: key,
	                    newValue: newVal,
	                    oldValue: value
	                });
	            }
	            else {
	                dep.notify();
	            }
	        }
	    });
	    return dep;
	}
	function set(target, key, val) {
	    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
	        warn("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
	    }
	    if (isReadonly(target)) {
	        process.env.NODE_ENV !== 'production' && warn("Set operation on key \"".concat(key, "\" failed: target is readonly."));
	        return;
	    }
	    var ob = target.__ob__;
	    if (isArray(target) && isValidArrayIndex(key)) {
	        target.length = Math.max(target.length, key);
	        target.splice(key, 1, val);
	        // when mocking for SSR, array methods are not hijacked
	        if (ob && !ob.shallow && ob.mock) {
	            observe(val, false, true);
	        }
	        return val;
	    }
	    if (key in target && !(key in Object.prototype)) {
	        target[key] = val;
	        return val;
	    }
	    if (target._isVue || (ob && ob.vmCount)) {
	        process.env.NODE_ENV !== 'production' &&
	            warn('Avoid adding reactive properties to a Vue instance or its root $data ' +
	                'at runtime - declare it upfront in the data option.');
	        return val;
	    }
	    if (!ob) {
	        target[key] = val;
	        return val;
	    }
	    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
	    if (process.env.NODE_ENV !== 'production') {
	        ob.dep.notify({
	            type: "add" /* TriggerOpTypes.ADD */,
	            target: target,
	            key: key,
	            newValue: val,
	            oldValue: undefined
	        });
	    }
	    else {
	        ob.dep.notify();
	    }
	    return val;
	}
	function del(target, key) {
	    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
	        warn("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target));
	    }
	    if (isArray(target) && isValidArrayIndex(key)) {
	        target.splice(key, 1);
	        return;
	    }
	    var ob = target.__ob__;
	    if (target._isVue || (ob && ob.vmCount)) {
	        process.env.NODE_ENV !== 'production' &&
	            warn('Avoid deleting properties on a Vue instance or its root $data ' +
	                '- just set it to null.');
	        return;
	    }
	    if (isReadonly(target)) {
	        process.env.NODE_ENV !== 'production' &&
	            warn("Delete operation on key \"".concat(key, "\" failed: target is readonly."));
	        return;
	    }
	    if (!hasOwn(target, key)) {
	        return;
	    }
	    delete target[key];
	    if (!ob) {
	        return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	        ob.dep.notify({
	            type: "delete" /* TriggerOpTypes.DELETE */,
	            target: target,
	            key: key
	        });
	    }
	    else {
	        ob.dep.notify();
	    }
	}
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	        e = value[i];
	        if (e && e.__ob__) {
	            e.__ob__.dep.depend();
	        }
	        if (isArray(e)) {
	            dependArray(e);
	        }
	    }
	}
	/**
	 * Return a shallowly-reactive copy of the original object, where only the root
	 * level properties are reactive. It also does not auto-unwrap refs (even at the
	 * root level).
	 */
	function shallowReactive(target) {
	    makeReactive(target, true);
	    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
	    return target;
	}
	function makeReactive(target, shallow) {
	    // if trying to observe a readonly proxy, return the readonly version.
	    if (!isReadonly(target)) {
	        if (process.env.NODE_ENV !== 'production') {
	            if (isArray(target)) {
	                warn("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
	            }
	            var existingOb = target && target.__ob__;
	            if (existingOb && existingOb.shallow !== shallow) {
	                warn("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
	            }
	        }
	        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
	        if (process.env.NODE_ENV !== 'production' && !ob) {
	            if (target == null || isPrimitive(target)) {
	                warn("value cannot be made reactive: ".concat(String(target)));
	            }
	            if (isCollectionType(target)) {
	                warn("Vue 2 does not support reactive collection types such as Map or Set.");
	            }
	        }
	    }
	}
	function isReadonly(value) {
	    return !!(value && value.__v_isReadonly);
	}
	/**
	 * @internal
	 */
	function isCollectionType(value) {
	    var type = toRawType(value);
	    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
	}
	function isRef(r) {
	    return !!(r && r.__v_isRef === true);
	}
	function proxyWithRefUnwrap(target, source, key) {
	    Object.defineProperty(target, key, {
	        enumerable: true,
	        configurable: true,
	        get: function () {
	            var val = source[key];
	            if (isRef(val)) {
	                return val.value;
	            }
	            else {
	                var ob = val && val.__ob__;
	                if (ob)
	                    ob.dep.depend();
	                return val;
	            }
	        },
	        set: function (value) {
	            var oldValue = source[key];
	            if (isRef(oldValue) && !isRef(value)) {
	                oldValue.value = value;
	            }
	            else {
	                source[key] = value;
	            }
	        }
	    });
	}

	var activeEffectScope;
	var EffectScope = /** @class */ (function () {
	    function EffectScope(detached) {
	        if (detached === void 0) { detached = false; }
	        /**
	         * @internal
	         */
	        this.active = true;
	        /**
	         * @internal
	         */
	        this.effects = [];
	        /**
	         * @internal
	         */
	        this.cleanups = [];
	        if (!detached && activeEffectScope) {
	            this.parent = activeEffectScope;
	            this.index =
	                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
	        }
	    }
	    EffectScope.prototype.run = function (fn) {
	        if (this.active) {
	            var currentEffectScope = activeEffectScope;
	            try {
	                activeEffectScope = this;
	                return fn();
	            }
	            finally {
	                activeEffectScope = currentEffectScope;
	            }
	        }
	        else if (process.env.NODE_ENV !== 'production') {
	            warn("cannot run an inactive effect scope.");
	        }
	    };
	    /**
	     * This should only be called on non-detached scopes
	     * @internal
	     */
	    EffectScope.prototype.on = function () {
	        activeEffectScope = this;
	    };
	    /**
	     * This should only be called on non-detached scopes
	     * @internal
	     */
	    EffectScope.prototype.off = function () {
	        activeEffectScope = this.parent;
	    };
	    EffectScope.prototype.stop = function (fromParent) {
	        if (this.active) {
	            var i = void 0, l = void 0;
	            for (i = 0, l = this.effects.length; i < l; i++) {
	                this.effects[i].teardown();
	            }
	            for (i = 0, l = this.cleanups.length; i < l; i++) {
	                this.cleanups[i]();
	            }
	            if (this.scopes) {
	                for (i = 0, l = this.scopes.length; i < l; i++) {
	                    this.scopes[i].stop(true);
	                }
	            }
	            // nested scope, dereference from parent to avoid memory leaks
	            if (this.parent && !fromParent) {
	                // optimized O(1) removal
	                var last = this.parent.scopes.pop();
	                if (last && last !== this) {
	                    this.parent.scopes[this.index] = last;
	                    last.index = this.index;
	                }
	            }
	            this.active = false;
	        }
	    };
	    return EffectScope;
	}());
	/**
	 * @internal
	 */
	function recordEffectScope(effect, scope) {
	    if (scope === void 0) { scope = activeEffectScope; }
	    if (scope && scope.active) {
	        scope.effects.push(effect);
	    }
	}
	function resolveProvided(vm) {
	    // by default an instance inherits its parent's provides object
	    // but when it needs to provide values of its own, it creates its
	    // own provides object using parent provides object as prototype.
	    // this way in `inject` we can simply look up injections from direct
	    // parent and let the prototype chain do the work.
	    var existing = vm._provided;
	    var parentProvides = vm.$parent && vm.$parent._provided;
	    if (parentProvides === existing) {
	        return (vm._provided = Object.create(parentProvides));
	    }
	    else {
	        return existing;
	    }
	}

	var normalizeEvent = cached(function (name) {
	    var passive = name.charAt(0) === '&';
	    name = passive ? name.slice(1) : name;
	    var once = name.charAt(0) === '~'; // Prefixed last, checked first
	    name = once ? name.slice(1) : name;
	    var capture = name.charAt(0) === '!';
	    name = capture ? name.slice(1) : name;
	    return {
	        name: name,
	        once: once,
	        capture: capture,
	        passive: passive
	    };
	});
	function createFnInvoker(fns, vm) {
	    function invoker() {
	        var fns = invoker.fns;
	        if (isArray(fns)) {
	            var cloned = fns.slice();
	            for (var i = 0; i < cloned.length; i++) {
	                invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
	            }
	        }
	        else {
	            // return handler return value for single handlers
	            return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
	        }
	    }
	    invoker.fns = fns;
	    return invoker;
	}
	function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
	    var name, cur, old, event;
	    for (name in on) {
	        cur = on[name];
	        old = oldOn[name];
	        event = normalizeEvent(name);
	        if (isUndef(cur)) {
	            process.env.NODE_ENV !== 'production' &&
	                warn("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
	        }
	        else if (isUndef(old)) {
	            if (isUndef(cur.fns)) {
	                cur = on[name] = createFnInvoker(cur, vm);
	            }
	            if (isTrue(event.once)) {
	                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
	            }
	            add(event.name, cur, event.capture, event.passive, event.params);
	        }
	        else if (cur !== old) {
	            old.fns = cur;
	            on[name] = old;
	        }
	    }
	    for (name in oldOn) {
	        if (isUndef(on[name])) {
	            event = normalizeEvent(name);
	            remove(event.name, oldOn[name], event.capture);
	        }
	    }
	}

	function mergeVNodeHook(def, hookKey, hook) {
	    if (def instanceof VNode) {
	        def = def.data.hook || (def.data.hook = {});
	    }
	    var invoker;
	    var oldHook = def[hookKey];
	    function wrappedHook() {
	        hook.apply(this, arguments);
	        // important: remove merged hook to ensure it's called only once
	        // and prevent memory leak
	        remove$2(invoker.fns, wrappedHook);
	    }
	    if (isUndef(oldHook)) {
	        // no existing hook
	        invoker = createFnInvoker([wrappedHook]);
	    }
	    else {
	        /* istanbul ignore if */
	        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	            // already a merged invoker
	            invoker = oldHook;
	            invoker.fns.push(wrappedHook);
	        }
	        else {
	            // existing plain hook
	            invoker = createFnInvoker([oldHook, wrappedHook]);
	        }
	    }
	    invoker.merged = true;
	    def[hookKey] = invoker;
	}

	function extractPropsFromVNodeData(data, Ctor, tag) {
	    // we are only extracting raw values here.
	    // validation and default values are handled in the child
	    // component itself.
	    var propOptions = Ctor.options.props;
	    if (isUndef(propOptions)) {
	        return;
	    }
	    var res = {};
	    var attrs = data.attrs, props = data.props;
	    if (isDef(attrs) || isDef(props)) {
	        for (var key in propOptions) {
	            var altKey = hyphenate(key);
	            if (process.env.NODE_ENV !== 'production') {
	                var keyInLowerCase = key.toLowerCase();
	                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	                    tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
	                        "".concat(formatComponentName(
	                        // @ts-expect-error tag is string
	                        tag || Ctor), ", but the declared prop name is") +
	                        " \"".concat(key, "\". ") +
	                        "Note that HTML attributes are case-insensitive and camelCased " +
	                        "props need to use their kebab-case equivalents when using in-DOM " +
	                        "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
	                }
	            }
	            checkProp(res, props, key, altKey, true) ||
	                checkProp(res, attrs, key, altKey, false);
	        }
	    }
	    return res;
	}
	function checkProp(res, hash, key, altKey, preserve) {
	    if (isDef(hash)) {
	        if (hasOwn(hash, key)) {
	            res[key] = hash[key];
	            if (!preserve) {
	                delete hash[key];
	            }
	            return true;
	        }
	        else if (hasOwn(hash, altKey)) {
	            res[key] = hash[altKey];
	            if (!preserve) {
	                delete hash[altKey];
	            }
	            return true;
	        }
	    }
	    return false;
	}

	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	    for (var i = 0; i < children.length; i++) {
	        if (isArray(children[i])) {
	            return Array.prototype.concat.apply([], children);
	        }
	    }
	    return children;
	}
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	    return isPrimitive(children)
	        ? [createTextVNode(children)]
	        : isArray(children)
	            ? normalizeArrayChildren(children)
	            : undefined;
	}
	function isTextNode(node) {
	    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	function normalizeArrayChildren(children, nestedIndex) {
	    var res = [];
	    var i, c, lastIndex, last;
	    for (i = 0; i < children.length; i++) {
	        c = children[i];
	        if (isUndef(c) || typeof c === 'boolean')
	            continue;
	        lastIndex = res.length - 1;
	        last = res[lastIndex];
	        //  nested
	        if (isArray(c)) {
	            if (c.length > 0) {
	                c = normalizeArrayChildren(c, "".concat(nestedIndex || '', "_").concat(i));
	                // merge adjacent text nodes
	                if (isTextNode(c[0]) && isTextNode(last)) {
	                    res[lastIndex] = createTextVNode(last.text + c[0].text);
	                    c.shift();
	                }
	                res.push.apply(res, c);
	            }
	        }
	        else if (isPrimitive(c)) {
	            if (isTextNode(last)) {
	                // merge adjacent text nodes
	                // this is necessary for SSR hydration because text nodes are
	                // essentially merged when rendered to HTML strings
	                res[lastIndex] = createTextVNode(last.text + c);
	            }
	            else if (c !== '') {
	                // convert primitive to vnode
	                res.push(createTextVNode(c));
	            }
	        }
	        else {
	            if (isTextNode(c) && isTextNode(last)) {
	                // merge adjacent text nodes
	                res[lastIndex] = createTextVNode(last.text + c.text);
	            }
	            else {
	                // default key for nested array children (likely generated by v-for)
	                if (isTrue(children._isVList) &&
	                    isDef(c.tag) &&
	                    isUndef(c.key) &&
	                    isDef(nestedIndex)) {
	                    c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
	                }
	                res.push(c);
	            }
	        }
	    }
	    return res;
	}

	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	    var ret = null, i, l, keys, key;
	    if (isArray(val) || typeof val === 'string') {
	        ret = new Array(val.length);
	        for (i = 0, l = val.length; i < l; i++) {
	            ret[i] = render(val[i], i);
	        }
	    }
	    else if (typeof val === 'number') {
	        ret = new Array(val);
	        for (i = 0; i < val; i++) {
	            ret[i] = render(i + 1, i);
	        }
	    }
	    else if (isObject(val)) {
	        if (hasSymbol && val[Symbol.iterator]) {
	            ret = [];
	            var iterator = val[Symbol.iterator]();
	            var result = iterator.next();
	            while (!result.done) {
	                ret.push(render(result.value, ret.length));
	                result = iterator.next();
	            }
	        }
	        else {
	            keys = Object.keys(val);
	            ret = new Array(keys.length);
	            for (i = 0, l = keys.length; i < l; i++) {
	                key = keys[i];
	                ret[i] = render(val[key], key, i);
	            }
	        }
	    }
	    if (!isDef(ret)) {
	        ret = [];
	    }
	    ret._isVList = true;
	    return ret;
	}

	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallbackRender, props, bindObject) {
	    var scopedSlotFn = this.$scopedSlots[name];
	    var nodes;
	    if (scopedSlotFn) {
	        // scoped slot
	        props = props || {};
	        if (bindObject) {
	            if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
	                warn('slot v-bind without argument expects an Object', this);
	            }
	            props = extend(extend({}, bindObject), props);
	        }
	        nodes =
	            scopedSlotFn(props) ||
	                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
	    }
	    else {
	        nodes =
	            this.$slots[name] ||
	                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
	    }
	    var target = props && props.slot;
	    if (target) {
	        return this.$createElement('template', { slot: target }, nodes);
	    }
	    else {
	        return nodes;
	    }
	}

	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	    return resolveAsset(this.$options, 'filters', id, true) || identity;
	}

	function isKeyNotMatch(expect, actual) {
	    if (isArray(expect)) {
	        return expect.indexOf(actual) === -1;
	    }
	    else {
	        return expect !== actual;
	    }
	}
	/**
	 * Runtime helper for checking keyCodes from config.
	 * exposed as Vue.prototype._k
	 * passing in eventKeyName as last argument separately for backwards compat
	 */
	function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
	    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
	    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
	        return isKeyNotMatch(builtInKeyName, eventKeyName);
	    }
	    else if (mappedKeyCode) {
	        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
	    }
	    else if (eventKeyName) {
	        return hyphenate(eventKeyName) !== key;
	    }
	    return eventKeyCode === undefined;
	}

	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp, isSync) {
	    if (value) {
	        if (!isObject(value)) {
	            process.env.NODE_ENV !== 'production' &&
	                warn('v-bind without argument expects an Object or Array value', this);
	        }
	        else {
	            if (isArray(value)) {
	                value = toObject(value);
	            }
	            var hash = void 0;
	            var _loop_1 = function (key) {
	                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
	                    hash = data;
	                }
	                else {
	                    var type = data.attrs && data.attrs.type;
	                    hash =
	                        asProp || config.mustUseProp(tag, type, key)
	                            ? data.domProps || (data.domProps = {})
	                            : data.attrs || (data.attrs = {});
	                }
	                var camelizedKey = camelize(key);
	                var hyphenatedKey = hyphenate(key);
	                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
	                    hash[key] = value[key];
	                    if (isSync) {
	                        var on = data.on || (data.on = {});
	                        on["update:".concat(key)] = function ($event) {
	                            value[key] = $event;
	                        };
	                    }
	                }
	            };
	            for (var key in value) {
	                _loop_1(key);
	            }
	        }
	    }
	    return data;
	}

	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	    var cached = this._staticTrees || (this._staticTrees = []);
	    var tree = cached[index];
	    // if has already-rendered static tree and not inside v-for,
	    // we can reuse the same tree.
	    if (tree && !isInFor) {
	        return tree;
	    }
	    // otherwise, render a fresh tree.
	    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
	    );
	    markStatic(tree, "__static__".concat(index), false);
	    return tree;
	}
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	    markStatic(tree, "__once__".concat(index).concat(key ? "_".concat(key) : ""), true);
	    return tree;
	}
	function markStatic(tree, key, isOnce) {
	    if (isArray(tree)) {
	        for (var i = 0; i < tree.length; i++) {
	            if (tree[i] && typeof tree[i] !== 'string') {
	                markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
	            }
	        }
	    }
	    else {
	        markStaticNode(tree, key, isOnce);
	    }
	}
	function markStaticNode(node, key, isOnce) {
	    node.isStatic = true;
	    node.key = key;
	    node.isOnce = isOnce;
	}

	function bindObjectListeners(data, value) {
	    if (value) {
	        if (!isPlainObject(value)) {
	            process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
	        }
	        else {
	            var on = (data.on = data.on ? extend({}, data.on) : {});
	            for (var key in value) {
	                var existing = on[key];
	                var ours = value[key];
	                on[key] = existing ? [].concat(existing, ours) : ours;
	            }
	        }
	    }
	    return data;
	}

	function resolveScopedSlots(fns, res, 
	// the following are added in 2.6
	hasDynamicKeys, contentHashKey) {
	    res = res || { $stable: !hasDynamicKeys };
	    for (var i = 0; i < fns.length; i++) {
	        var slot = fns[i];
	        if (isArray(slot)) {
	            resolveScopedSlots(slot, res, hasDynamicKeys);
	        }
	        else if (slot) {
	            // marker for reverse proxying v-slot without scope on this.$slots
	            // @ts-expect-error
	            if (slot.proxy) {
	                // @ts-expect-error
	                slot.fn.proxy = true;
	            }
	            res[slot.key] = slot.fn;
	        }
	    }
	    if (contentHashKey) {
	        res.$key = contentHashKey;
	    }
	    return res;
	}

	// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
	function bindDynamicKeys(baseObj, values) {
	    for (var i = 0; i < values.length; i += 2) {
	        var key = values[i];
	        if (typeof key === 'string' && key) {
	            baseObj[values[i]] = values[i + 1];
	        }
	        else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {
	            // null is a special value for explicitly removing a binding
	            warn("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
	        }
	    }
	    return baseObj;
	}
	// helper to dynamically append modifier runtime markers to event names.
	// ensure only append when value is already string, otherwise it will be cast
	// to string and cause the type check to miss.
	function prependModifier(value, symbol) {
	    return typeof value === 'string' ? symbol + value : value;
	}

	function installRenderHelpers(target) {
	    target._o = markOnce;
	    target._n = toNumber;
	    target._s = toString;
	    target._l = renderList;
	    target._t = renderSlot;
	    target._q = looseEqual;
	    target._i = looseIndexOf;
	    target._m = renderStatic;
	    target._f = resolveFilter;
	    target._k = checkKeyCodes;
	    target._b = bindObjectProps;
	    target._v = createTextVNode;
	    target._e = createEmptyVNode;
	    target._u = resolveScopedSlots;
	    target._g = bindObjectListeners;
	    target._d = bindDynamicKeys;
	    target._p = prependModifier;
	}

	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	    if (!children || !children.length) {
	        return {};
	    }
	    var slots = {};
	    for (var i = 0, l = children.length; i < l; i++) {
	        var child = children[i];
	        var data = child.data;
	        // remove slot attribute if the node is resolved as a Vue slot node
	        if (data && data.attrs && data.attrs.slot) {
	            delete data.attrs.slot;
	        }
	        // named slots should only be respected if the vnode was rendered in the
	        // same context.
	        if ((child.context === context || child.fnContext === context) &&
	            data &&
	            data.slot != null) {
	            var name_1 = data.slot;
	            var slot = slots[name_1] || (slots[name_1] = []);
	            if (child.tag === 'template') {
	                slot.push.apply(slot, child.children || []);
	            }
	            else {
	                slot.push(child);
	            }
	        }
	        else {
	            (slots.default || (slots.default = [])).push(child);
	        }
	    }
	    // ignore slots that contains only whitespace
	    for (var name_2 in slots) {
	        if (slots[name_2].every(isWhitespace)) {
	            delete slots[name_2];
	        }
	    }
	    return slots;
	}
	function isWhitespace(node) {
	    return (node.isComment && !node.asyncFactory) || node.text === ' ';
	}

	function isAsyncPlaceholder(node) {
	    // @ts-expect-error not really boolean type
	    return node.isComment && node.asyncFactory;
	}

	function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
	    var res;
	    var hasNormalSlots = Object.keys(normalSlots).length > 0;
	    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
	    var key = scopedSlots && scopedSlots.$key;
	    if (!scopedSlots) {
	        res = {};
	    }
	    else if (scopedSlots._normalized) {
	        // fast path 1: child component re-render only, parent did not change
	        return scopedSlots._normalized;
	    }
	    else if (isStable &&
	        prevScopedSlots &&
	        prevScopedSlots !== emptyObject &&
	        key === prevScopedSlots.$key &&
	        !hasNormalSlots &&
	        !prevScopedSlots.$hasNormal) {
	        // fast path 2: stable scoped slots w/ no normal slots to proxy,
	        // only need to normalize once
	        return prevScopedSlots;
	    }
	    else {
	        res = {};
	        for (var key_1 in scopedSlots) {
	            if (scopedSlots[key_1] && key_1[0] !== '$') {
	                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
	            }
	        }
	    }
	    // expose normal slots on scopedSlots
	    for (var key_2 in normalSlots) {
	        if (!(key_2 in res)) {
	            res[key_2] = proxyNormalSlot(normalSlots, key_2);
	        }
	    }
	    // avoriaz seems to mock a non-extensible $scopedSlots object
	    // and when that is passed down this would cause an error
	    if (scopedSlots && Object.isExtensible(scopedSlots)) {
	        scopedSlots._normalized = res;
	    }
	    def(res, '$stable', isStable);
	    def(res, '$key', key);
	    def(res, '$hasNormal', hasNormalSlots);
	    return res;
	}
	function normalizeScopedSlot(vm, normalSlots, key, fn) {
	    var normalized = function () {
	        var cur = currentInstance;
	        setCurrentInstance(vm);
	        var res = arguments.length ? fn.apply(null, arguments) : fn({});
	        res =
	            res && typeof res === 'object' && !isArray(res)
	                ? [res] // single vnode
	                : normalizeChildren(res);
	        var vnode = res && res[0];
	        setCurrentInstance(cur);
	        return res &&
	            (!vnode ||
	                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
	            ? undefined
	            : res;
	    };
	    // this is a slot using the new v-slot syntax without scope. although it is
	    // compiled as a scoped slot, render fn users would expect it to be present
	    // on this.$slots because the usage is semantically a normal slot.
	    if (fn.proxy) {
	        Object.defineProperty(normalSlots, key, {
	            get: normalized,
	            enumerable: true,
	            configurable: true
	        });
	    }
	    return normalized;
	}
	function proxyNormalSlot(slots, key) {
	    return function () { return slots[key]; };
	}

	function initSetup(vm) {
	    var options = vm.$options;
	    var setup = options.setup;
	    if (setup) {
	        var ctx = (vm._setupContext = createSetupContext(vm));
	        setCurrentInstance(vm);
	        pushTarget();
	        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
	        popTarget();
	        setCurrentInstance();
	        if (isFunction(setupResult)) {
	            // render function
	            // @ts-ignore
	            options.render = setupResult;
	        }
	        else if (isObject(setupResult)) {
	            // bindings
	            if (process.env.NODE_ENV !== 'production' && setupResult instanceof VNode) {
	                warn("setup() should not return VNodes directly - " +
	                    "return a render function instead.");
	            }
	            vm._setupState = setupResult;
	            // __sfc indicates compiled bindings from <script setup>
	            if (!setupResult.__sfc) {
	                for (var key in setupResult) {
	                    if (!isReserved(key)) {
	                        proxyWithRefUnwrap(vm, setupResult, key);
	                    }
	                    else if (process.env.NODE_ENV !== 'production') {
	                        warn("Avoid using variables that start with _ or $ in setup().");
	                    }
	                }
	            }
	            else {
	                // exposed for compiled render fn
	                var proxy = (vm._setupProxy = {});
	                for (var key in setupResult) {
	                    if (key !== '__sfc') {
	                        proxyWithRefUnwrap(proxy, setupResult, key);
	                    }
	                }
	            }
	        }
	        else if (process.env.NODE_ENV !== 'production' && setupResult !== undefined) {
	            warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : typeof setupResult));
	        }
	    }
	}
	function createSetupContext(vm) {
	    var exposeCalled = false;
	    return {
	        get attrs() {
	            if (!vm._attrsProxy) {
	                var proxy = (vm._attrsProxy = {});
	                def(proxy, '_v_attr_proxy', true);
	                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
	            }
	            return vm._attrsProxy;
	        },
	        get listeners() {
	            if (!vm._listenersProxy) {
	                var proxy = (vm._listenersProxy = {});
	                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
	            }
	            return vm._listenersProxy;
	        },
	        get slots() {
	            return initSlotsProxy(vm);
	        },
	        emit: bind(vm.$emit, vm),
	        expose: function (exposed) {
	            if (process.env.NODE_ENV !== 'production') {
	                if (exposeCalled) {
	                    warn("expose() should be called only once per setup().", vm);
	                }
	                exposeCalled = true;
	            }
	            if (exposed) {
	                Object.keys(exposed).forEach(function (key) {
	                    return proxyWithRefUnwrap(vm, exposed, key);
	                });
	            }
	        }
	    };
	}
	function syncSetupProxy(to, from, prev, instance, type) {
	    var changed = false;
	    for (var key in from) {
	        if (!(key in to)) {
	            changed = true;
	            defineProxyAttr(to, key, instance, type);
	        }
	        else if (from[key] !== prev[key]) {
	            changed = true;
	        }
	    }
	    for (var key in to) {
	        if (!(key in from)) {
	            changed = true;
	            delete to[key];
	        }
	    }
	    return changed;
	}
	function defineProxyAttr(proxy, key, instance, type) {
	    Object.defineProperty(proxy, key, {
	        enumerable: true,
	        configurable: true,
	        get: function () {
	            return instance[type][key];
	        }
	    });
	}
	function initSlotsProxy(vm) {
	    if (!vm._slotsProxy) {
	        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
	    }
	    return vm._slotsProxy;
	}
	function syncSetupSlots(to, from) {
	    for (var key in from) {
	        to[key] = from[key];
	    }
	    for (var key in to) {
	        if (!(key in from)) {
	            delete to[key];
	        }
	    }
	}

	function initRender(vm) {
	    vm._vnode = null; // the root of the child tree
	    vm._staticTrees = null; // v-once cached trees
	    var options = vm.$options;
	    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
	    var renderContext = parentVnode && parentVnode.context;
	    vm.$slots = resolveSlots(options._renderChildren, renderContext);
	    vm.$scopedSlots = parentVnode
	        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
	        : emptyObject;
	    // bind the createElement fn to this instance
	    // so that we get proper render context inside it.
	    // args order: tag, data, children, normalizationType, alwaysNormalize
	    // internal version is used by render functions compiled from templates
	    // @ts-expect-error
	    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };
	    // normalization is always applied for the public version, used in
	    // user-written render functions.
	    // @ts-expect-error
	    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };
	    // $attrs & $listeners are exposed for easier HOC creation.
	    // they need to be reactive so that HOCs using them are always updated
	    var parentData = parentVnode && parentVnode.data;
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {
	            !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
	        }, true);
	        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
	            !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
	        }, true);
	    }
	    else {
	        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, null, true);
	        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
	    }
	}
	var currentRenderingInstance = null;
	function renderMixin(Vue) {
	    // install runtime convenience helpers
	    installRenderHelpers(Vue.prototype);
	    Vue.prototype.$nextTick = function (fn) {
	        return nextTick(fn, this);
	    };
	    Vue.prototype._render = function () {
	        var vm = this;
	        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
	        if (_parentVnode && vm._isMounted) {
	            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
	            if (vm._slotsProxy) {
	                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
	            }
	        }
	        // set parent vnode. this allows render functions to have access
	        // to the data on the placeholder node.
	        vm.$vnode = _parentVnode;
	        // render self
	        var vnode;
	        try {
	            // There's no need to maintain a stack because all render fns are called
	            // separately from one another. Nested component's render fns are called
	            // when parent component is patched.
	            setCurrentInstance(vm);
	            currentRenderingInstance = vm;
	            vnode = render.call(vm._renderProxy, vm.$createElement);
	        }
	        catch (e) {
	            handleError(e, vm, "render");
	            // return error render result,
	            // or previous vnode to prevent render error causing blank component
	            /* istanbul ignore else */
	            if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
	                try {
	                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
	                }
	                catch (e) {
	                    handleError(e, vm, "renderError");
	                    vnode = vm._vnode;
	                }
	            }
	            else {
	                vnode = vm._vnode;
	            }
	        }
	        finally {
	            currentRenderingInstance = null;
	            setCurrentInstance();
	        }
	        // if the returned array contains only a single node, allow it
	        if (isArray(vnode) && vnode.length === 1) {
	            vnode = vnode[0];
	        }
	        // return empty vnode in case the render function errored out
	        if (!(vnode instanceof VNode)) {
	            if (process.env.NODE_ENV !== 'production' && isArray(vnode)) {
	                warn('Multiple root nodes returned from render function. Render function ' +
	                    'should return a single root node.', vm);
	            }
	            vnode = createEmptyVNode();
	        }
	        // set parent
	        vnode.parent = _parentVnode;
	        return vnode;
	    };
	}

	function ensureCtor(comp, base) {
	    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
	        comp = comp.default;
	    }
	    return isObject(comp) ? base.extend(comp) : comp;
	}
	function createAsyncPlaceholder(factory, data, context, children, tag) {
	    var node = createEmptyVNode();
	    node.asyncFactory = factory;
	    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
	    return node;
	}
	function resolveAsyncComponent(factory, baseCtor) {
	    if (isTrue(factory.error) && isDef(factory.errorComp)) {
	        return factory.errorComp;
	    }
	    if (isDef(factory.resolved)) {
	        return factory.resolved;
	    }
	    var owner = currentRenderingInstance;
	    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
	        // already pending
	        factory.owners.push(owner);
	    }
	    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	        return factory.loadingComp;
	    }
	    if (owner && !isDef(factory.owners)) {
	        var owners_1 = (factory.owners = [owner]);
	        var sync_1 = true;
	        var timerLoading_1 = null;
	        var timerTimeout_1 = null;
	        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });
	        var forceRender_1 = function (renderCompleted) {
	            for (var i = 0, l = owners_1.length; i < l; i++) {
	                owners_1[i].$forceUpdate();
	            }
	            if (renderCompleted) {
	                owners_1.length = 0;
	                if (timerLoading_1 !== null) {
	                    clearTimeout(timerLoading_1);
	                    timerLoading_1 = null;
	                }
	                if (timerTimeout_1 !== null) {
	                    clearTimeout(timerTimeout_1);
	                    timerTimeout_1 = null;
	                }
	            }
	        };
	        var resolve = once(function (res) {
	            // cache resolved
	            factory.resolved = ensureCtor(res, baseCtor);
	            // invoke callbacks only if this is not a synchronous resolve
	            // (async resolves are shimmed as synchronous during SSR)
	            if (!sync_1) {
	                forceRender_1(true);
	            }
	            else {
	                owners_1.length = 0;
	            }
	        });
	        var reject_1 = once(function (reason) {
	            process.env.NODE_ENV !== 'production' &&
	                warn("Failed to resolve async component: ".concat(String(factory)) +
	                    (reason ? "\nReason: ".concat(reason) : ''));
	            if (isDef(factory.errorComp)) {
	                factory.error = true;
	                forceRender_1(true);
	            }
	        });
	        var res_1 = factory(resolve, reject_1);
	        if (isObject(res_1)) {
	            if (isPromise(res_1)) {
	                // () => Promise
	                if (isUndef(factory.resolved)) {
	                    res_1.then(resolve, reject_1);
	                }
	            }
	            else if (isPromise(res_1.component)) {
	                res_1.component.then(resolve, reject_1);
	                if (isDef(res_1.error)) {
	                    factory.errorComp = ensureCtor(res_1.error, baseCtor);
	                }
	                if (isDef(res_1.loading)) {
	                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
	                    if (res_1.delay === 0) {
	                        factory.loading = true;
	                    }
	                    else {
	                        // @ts-expect-error NodeJS timeout type
	                        timerLoading_1 = setTimeout(function () {
	                            timerLoading_1 = null;
	                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                                factory.loading = true;
	                                forceRender_1(false);
	                            }
	                        }, res_1.delay || 200);
	                    }
	                }
	                if (isDef(res_1.timeout)) {
	                    // @ts-expect-error NodeJS timeout type
	                    timerTimeout_1 = setTimeout(function () {
	                        timerTimeout_1 = null;
	                        if (isUndef(factory.resolved)) {
	                            reject_1(process.env.NODE_ENV !== 'production' ? "timeout (".concat(res_1.timeout, "ms)") : null);
	                        }
	                    }, res_1.timeout);
	                }
	            }
	        }
	        sync_1 = false;
	        // return in case resolved synchronously
	        return factory.loading ? factory.loadingComp : factory.resolved;
	    }
	}

	function getFirstComponentChild(children) {
	    if (isArray(children)) {
	        for (var i = 0; i < children.length; i++) {
	            var c = children[i];
	            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
	                return c;
	            }
	        }
	    }
	}

	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
	    if (isArray(data) || isPrimitive(data)) {
	        normalizationType = children;
	        children = data;
	        data = undefined;
	    }
	    if (isTrue(alwaysNormalize)) {
	        normalizationType = ALWAYS_NORMALIZE;
	    }
	    return _createElement(context, tag, data, children, normalizationType);
	}
	function _createElement(context, tag, data, children, normalizationType) {
	    if (isDef(data) && isDef(data.__ob__)) {
	        process.env.NODE_ENV !== 'production' &&
	            warn("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + 'Always create fresh vnode data objects in each render!', context);
	        return createEmptyVNode();
	    }
	    // object syntax in v-bind
	    if (isDef(data) && isDef(data.is)) {
	        tag = data.is;
	    }
	    if (!tag) {
	        // in case of component :is set to falsy value
	        return createEmptyVNode();
	    }
	    // warn against non-primitive key
	    if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
	        warn('Avoid using non-primitive value as key, ' +
	            'use string/number value instead.', context);
	    }
	    // support single function children as default scoped slot
	    if (isArray(children) && isFunction(children[0])) {
	        data = data || {};
	        data.scopedSlots = { default: children[0] };
	        children.length = 0;
	    }
	    if (normalizationType === ALWAYS_NORMALIZE) {
	        children = normalizeChildren(children);
	    }
	    else if (normalizationType === SIMPLE_NORMALIZE) {
	        children = simpleNormalizeChildren(children);
	    }
	    var vnode, ns;
	    if (typeof tag === 'string') {
	        var Ctor = void 0;
	        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
	        if (config.isReservedTag(tag)) {
	            // platform built-in elements
	            if (process.env.NODE_ENV !== 'production' &&
	                isDef(data) &&
	                isDef(data.nativeOn) &&
	                data.tag !== 'component') {
	                warn("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
	            }
	            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	        }
	        else if ((!data || !data.pre) &&
	            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
	            // component
	            vnode = createComponent(Ctor, data, context, children, tag);
	        }
	        else {
	            // unknown or unlisted namespaced elements
	            // check at runtime because it may get assigned a namespace when its
	            // parent normalizes children
	            vnode = new VNode(tag, data, children, undefined, undefined, context);
	        }
	    }
	    else {
	        // direct component options / constructor
	        vnode = createComponent(tag, data, context, children);
	    }
	    if (isArray(vnode)) {
	        return vnode;
	    }
	    else if (isDef(vnode)) {
	        if (isDef(ns))
	            applyNS(vnode, ns);
	        if (isDef(data))
	            registerDeepBindings(data);
	        return vnode;
	    }
	    else {
	        return createEmptyVNode();
	    }
	}
	function applyNS(vnode, ns, force) {
	    vnode.ns = ns;
	    if (vnode.tag === 'foreignObject') {
	        // use default namespace inside foreignObject
	        ns = undefined;
	        force = true;
	    }
	    if (isDef(vnode.children)) {
	        for (var i = 0, l = vnode.children.length; i < l; i++) {
	            var child = vnode.children[i];
	            if (isDef(child.tag) &&
	                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
	                applyNS(child, ns, force);
	            }
	        }
	    }
	}
	// ref #5318
	// necessary to ensure parent re-render when deep bindings like :style and
	// :class are used on slot nodes
	function registerDeepBindings(data) {
	    if (isObject(data.style)) {
	        traverse(data.style);
	    }
	    if (isObject(data.class)) {
	        traverse(data.class);
	    }
	}

	function handleError(err, vm, info) {
	    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
	    // See: https://github.com/vuejs/vuex/issues/1505
	    pushTarget();
	    try {
	        if (vm) {
	            var cur = vm;
	            while ((cur = cur.$parent)) {
	                var hooks = cur.$options.errorCaptured;
	                if (hooks) {
	                    for (var i = 0; i < hooks.length; i++) {
	                        try {
	                            var capture = hooks[i].call(cur, err, vm, info) === false;
	                            if (capture)
	                                return;
	                        }
	                        catch (e) {
	                            globalHandleError(e, cur, 'errorCaptured hook');
	                        }
	                    }
	                }
	            }
	        }
	        globalHandleError(err, vm, info);
	    }
	    finally {
	        popTarget();
	    }
	}
	function invokeWithErrorHandling(handler, context, args, vm, info) {
	    var res;
	    try {
	        res = args ? handler.apply(context, args) : handler.call(context);
	        if (res && !res._isVue && isPromise(res) && !res._handled) {
	            res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
	            res._handled = true;
	        }
	    }
	    catch (e) {
	        handleError(e, vm, info);
	    }
	    return res;
	}
	function globalHandleError(err, vm, info) {
	    if (config.errorHandler) {
	        try {
	            return config.errorHandler.call(null, err, vm, info);
	        }
	        catch (e) {
	            // if the user intentionally throws the original error in the handler,
	            // do not log it twice
	            if (e !== err) {
	                logError(e, null, 'config.errorHandler');
	            }
	        }
	    }
	    logError(err, vm, info);
	}
	function logError(err, vm, info) {
	    if (process.env.NODE_ENV !== 'production') {
	        warn("Error in ".concat(info, ": \"").concat(err.toString(), "\""), vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	        console.error(err);
	    }
	    else {
	        throw err;
	    }
	}

	/* globals MutationObserver */
	var isUsingMicroTask = false;
	var callbacks = [];
	var pending = false;
	function flushCallbacks() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	        copies[i]();
	    }
	}
	// Here we have async deferring wrappers using microtasks.
	// In 2.5 we used (macro) tasks (in combination with microtasks).
	// However, it has subtle problems when state is changed right before repaint
	// (e.g. #6813, out-in transitions).
	// Also, using (macro) tasks in event handler would cause some weird behaviors
	// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
	// So we now use microtasks everywhere, again.
	// A major drawback of this tradeoff is that there are some scenarios
	// where microtasks have too high a priority and fire in between supposedly
	// sequential events (e.g. #4521, #6690, which have workarounds)
	// or even between bubbling of the same event (#6566).
	var timerFunc;
	// The nextTick behavior leverages the microtask queue, which can be accessed
	// via either native Promise.then or MutationObserver.
	// MutationObserver has wider support, however it is seriously bugged in
	// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	// completely stops working after triggering a few times... so, if native
	// Promise is available, we will use it:
	/* istanbul ignore next, $flow-disable-line */
	if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p_1 = Promise.resolve();
	    timerFunc = function () {
	        p_1.then(flushCallbacks);
	        // In problematic UIWebViews, Promise.then doesn't completely break, but
	        // it can get stuck in a weird state where callbacks are pushed into the
	        // microtask queue but the queue isn't being flushed, until the browser
	        // needs to do some other work, e.g. handle a timer. Therefore we can
	        // "force" the microtask queue to be flushed by adding an empty timer.
	        if (isIOS)
	            setTimeout(noop);
	    };
	    isUsingMicroTask = true;
	}
	else if (!isIE &&
	    typeof MutationObserver !== 'undefined' &&
	    (isNative(MutationObserver) ||
	        // PhantomJS and iOS 7.x
	        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // Use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS, iOS7, Android 4.4
	    // (#6466 MutationObserver is unreliable in IE11)
	    var counter_1 = 1;
	    var observer = new MutationObserver(flushCallbacks);
	    var textNode_1 = document.createTextNode(String(counter_1));
	    observer.observe(textNode_1, {
	        characterData: true
	    });
	    timerFunc = function () {
	        counter_1 = (counter_1 + 1) % 2;
	        textNode_1.data = String(counter_1);
	    };
	    isUsingMicroTask = true;
	}
	else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
	    // Fallback to setImmediate.
	    // Technically it leverages the (macro) task queue,
	    // but it is still a better choice than setTimeout.
	    timerFunc = function () {
	        setImmediate(flushCallbacks);
	    };
	}
	else {
	    // Fallback to setTimeout.
	    timerFunc = function () {
	        setTimeout(flushCallbacks, 0);
	    };
	}
	/**
	 * @internal
	 */
	function nextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	        if (cb) {
	            try {
	                cb.call(ctx);
	            }
	            catch (e) {
	                handleError(e, ctx, 'nextTick');
	            }
	        }
	        else if (_resolve) {
	            _resolve(ctx);
	        }
	    });
	    if (!pending) {
	        pending = true;
	        timerFunc();
	    }
	    // $flow-disable-line
	    if (!cb && typeof Promise !== 'undefined') {
	        return new Promise(function (resolve) {
	            _resolve = resolve;
	        });
	    }
	}

	/**
	 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
	 */
	var version = '2.7.8';

	var seenObjects = new _Set();
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	function traverse(val) {
	    _traverse(val, seenObjects);
	    seenObjects.clear();
	    return val;
	}
	function _traverse(val, seen) {
	    var i, keys;
	    var isA = isArray(val);
	    if ((!isA && !isObject(val)) ||
	        Object.isFrozen(val) ||
	        val instanceof VNode) {
	        return;
	    }
	    if (val.__ob__) {
	        var depId = val.__ob__.dep.id;
	        if (seen.has(depId)) {
	            return;
	        }
	        seen.add(depId);
	    }
	    if (isA) {
	        i = val.length;
	        while (i--)
	            _traverse(val[i], seen);
	    }
	    else if (isRef(val)) {
	        _traverse(val.value, seen);
	    }
	    else {
	        keys = Object.keys(val);
	        i = keys.length;
	        while (i--)
	            _traverse(val[keys[i]], seen);
	    }
	}

	var uid$1 = 0;
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 * @internal
	 */
	var Watcher = /** @class */ (function () {
	    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
	        recordEffectScope(this, activeEffectScope || (vm ? vm._scope : undefined));
	        if ((this.vm = vm)) {
	            if (isRenderWatcher) {
	                vm._watcher = this;
	            }
	        }
	        // options
	        if (options) {
	            this.deep = !!options.deep;
	            this.user = !!options.user;
	            this.lazy = !!options.lazy;
	            this.sync = !!options.sync;
	            this.before = options.before;
	            if (process.env.NODE_ENV !== 'production') {
	                this.onTrack = options.onTrack;
	                this.onTrigger = options.onTrigger;
	            }
	        }
	        else {
	            this.deep = this.user = this.lazy = this.sync = false;
	        }
	        this.cb = cb;
	        this.id = ++uid$1; // uid for batching
	        this.active = true;
	        this.post = false;
	        this.dirty = this.lazy; // for lazy watchers
	        this.deps = [];
	        this.newDeps = [];
	        this.depIds = new _Set();
	        this.newDepIds = new _Set();
	        this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	        // parse expression for getter
	        if (isFunction(expOrFn)) {
	            this.getter = expOrFn;
	        }
	        else {
	            this.getter = parsePath(expOrFn);
	            if (!this.getter) {
	                this.getter = noop;
	                process.env.NODE_ENV !== 'production' &&
	                    warn("Failed watching path: \"".concat(expOrFn, "\" ") +
	                        'Watcher only accepts simple dot-delimited paths. ' +
	                        'For full control, use a function instead.', vm);
	            }
	        }
	        this.value = this.lazy ? undefined : this.get();
	    }
	    /**
	     * Evaluate the getter, and re-collect dependencies.
	     */
	    Watcher.prototype.get = function () {
	        pushTarget(this);
	        var value;
	        var vm = this.vm;
	        try {
	            value = this.getter.call(vm, vm);
	        }
	        catch (e) {
	            if (this.user) {
	                handleError(e, vm, "getter for watcher \"".concat(this.expression, "\""));
	            }
	            else {
	                throw e;
	            }
	        }
	        finally {
	            // "touch" every property so they are all tracked as
	            // dependencies for deep watching
	            if (this.deep) {
	                traverse(value);
	            }
	            popTarget();
	            this.cleanupDeps();
	        }
	        return value;
	    };
	    /**
	     * Add a dependency to this directive.
	     */
	    Watcher.prototype.addDep = function (dep) {
	        var id = dep.id;
	        if (!this.newDepIds.has(id)) {
	            this.newDepIds.add(id);
	            this.newDeps.push(dep);
	            if (!this.depIds.has(id)) {
	                dep.addSub(this);
	            }
	        }
	    };
	    /**
	     * Clean up for dependency collection.
	     */
	    Watcher.prototype.cleanupDeps = function () {
	        var i = this.deps.length;
	        while (i--) {
	            var dep = this.deps[i];
	            if (!this.newDepIds.has(dep.id)) {
	                dep.removeSub(this);
	            }
	        }
	        var tmp = this.depIds;
	        this.depIds = this.newDepIds;
	        this.newDepIds = tmp;
	        this.newDepIds.clear();
	        tmp = this.deps;
	        this.deps = this.newDeps;
	        this.newDeps = tmp;
	        this.newDeps.length = 0;
	    };
	    /**
	     * Subscriber interface.
	     * Will be called when a dependency changes.
	     */
	    Watcher.prototype.update = function () {
	        /* istanbul ignore else */
	        if (this.lazy) {
	            this.dirty = true;
	        }
	        else if (this.sync) {
	            this.run();
	        }
	        else {
	            queueWatcher(this);
	        }
	    };
	    /**
	     * Scheduler job interface.
	     * Will be called by the scheduler.
	     */
	    Watcher.prototype.run = function () {
	        if (this.active) {
	            var value = this.get();
	            if (value !== this.value ||
	                // Deep watchers and watchers on Object/Arrays should fire even
	                // when the value is the same, because the value may
	                // have mutated.
	                isObject(value) ||
	                this.deep) {
	                // set new value
	                var oldValue = this.value;
	                this.value = value;
	                if (this.user) {
	                    var info = "callback for watcher \"".concat(this.expression, "\"");
	                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
	                }
	                else {
	                    this.cb.call(this.vm, value, oldValue);
	                }
	            }
	        }
	    };
	    /**
	     * Evaluate the value of the watcher.
	     * This only gets called for lazy watchers.
	     */
	    Watcher.prototype.evaluate = function () {
	        this.value = this.get();
	        this.dirty = false;
	    };
	    /**
	     * Depend on all deps collected by this watcher.
	     */
	    Watcher.prototype.depend = function () {
	        var i = this.deps.length;
	        while (i--) {
	            this.deps[i].depend();
	        }
	    };
	    /**
	     * Remove self from all dependencies' subscriber list.
	     */
	    Watcher.prototype.teardown = function () {
	        if (this.vm && !this.vm._isBeingDestroyed) {
	            remove$2(this.vm._scope.effects, this);
	        }
	        if (this.active) {
	            var i = this.deps.length;
	            while (i--) {
	                this.deps[i].removeSub(this);
	            }
	            this.active = false;
	            if (this.onStop) {
	                this.onStop();
	            }
	        }
	    };
	    return Watcher;
	}());

	var mark;
	var measure;
	if (process.env.NODE_ENV !== 'production') {
	    var perf_1 = inBrowser && window.performance;
	    /* istanbul ignore if */
	    if (perf_1 &&
	        // @ts-ignore
	        perf_1.mark &&
	        // @ts-ignore
	        perf_1.measure &&
	        // @ts-ignore
	        perf_1.clearMarks &&
	        // @ts-ignore
	        perf_1.clearMeasures) {
	        mark = function (tag) { return perf_1.mark(tag); };
	        measure = function (name, startTag, endTag) {
	            perf_1.measure(name, startTag, endTag);
	            perf_1.clearMarks(startTag);
	            perf_1.clearMarks(endTag);
	            // perf.clearMeasures(name)
	        };
	    }
	}

	function initEvents(vm) {
	    vm._events = Object.create(null);
	    vm._hasHookEvent = false;
	    // init parent attached events
	    var listeners = vm.$options._parentListeners;
	    if (listeners) {
	        updateComponentListeners(vm, listeners);
	    }
	}
	var target$1;
	function add$1(event, fn) {
	    target$1.$on(event, fn);
	}
	function remove$1(event, fn) {
	    target$1.$off(event, fn);
	}
	function createOnceHandler$1(event, fn) {
	    var _target = target$1;
	    return function onceHandler() {
	        var res = fn.apply(null, arguments);
	        if (res !== null) {
	            _target.$off(event, onceHandler);
	        }
	    };
	}
	function updateComponentListeners(vm, listeners, oldListeners) {
	    target$1 = vm;
	    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
	    target$1 = undefined;
	}
	function eventsMixin(Vue) {
	    var hookRE = /^hook:/;
	    Vue.prototype.$on = function (event, fn) {
	        var vm = this;
	        if (isArray(event)) {
	            for (var i = 0, l = event.length; i < l; i++) {
	                vm.$on(event[i], fn);
	            }
	        }
	        else {
	            (vm._events[event] || (vm._events[event] = [])).push(fn);
	            // optimize hook:event cost by using a boolean flag marked at registration
	            // instead of a hash lookup
	            if (hookRE.test(event)) {
	                vm._hasHookEvent = true;
	            }
	        }
	        return vm;
	    };
	    Vue.prototype.$once = function (event, fn) {
	        var vm = this;
	        function on() {
	            vm.$off(event, on);
	            fn.apply(vm, arguments);
	        }
	        on.fn = fn;
	        vm.$on(event, on);
	        return vm;
	    };
	    Vue.prototype.$off = function (event, fn) {
	        var vm = this;
	        // all
	        if (!arguments.length) {
	            vm._events = Object.create(null);
	            return vm;
	        }
	        // array of events
	        if (isArray(event)) {
	            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
	                vm.$off(event[i_1], fn);
	            }
	            return vm;
	        }
	        // specific event
	        var cbs = vm._events[event];
	        if (!cbs) {
	            return vm;
	        }
	        if (!fn) {
	            vm._events[event] = null;
	            return vm;
	        }
	        // specific handler
	        var cb;
	        var i = cbs.length;
	        while (i--) {
	            cb = cbs[i];
	            if (cb === fn || cb.fn === fn) {
	                cbs.splice(i, 1);
	                break;
	            }
	        }
	        return vm;
	    };
	    Vue.prototype.$emit = function (event) {
	        var vm = this;
	        if (process.env.NODE_ENV !== 'production') {
	            var lowerCaseEvent = event.toLowerCase();
	            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	                tip("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") +
	                    "".concat(formatComponentName(vm), " but the handler is registered for \"").concat(event, "\". ") +
	                    "Note that HTML attributes are case-insensitive and you cannot use " +
	                    "v-on to listen to camelCase events when using in-DOM templates. " +
	                    "You should probably use \"".concat(hyphenate(event), "\" instead of \"").concat(event, "\"."));
	            }
	        }
	        var cbs = vm._events[event];
	        if (cbs) {
	            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	            var args = toArray(arguments, 1);
	            var info = "event handler for \"".concat(event, "\"");
	            for (var i = 0, l = cbs.length; i < l; i++) {
	                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
	            }
	        }
	        return vm;
	    };
	}

	var activeInstance = null;
	var isUpdatingChildComponent = false;
	function setActiveInstance(vm) {
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    return function () {
	        activeInstance = prevActiveInstance;
	    };
	}
	function initLifecycle(vm) {
	    var options = vm.$options;
	    // locate first non-abstract parent
	    var parent = options.parent;
	    if (parent && !options.abstract) {
	        while (parent.$options.abstract && parent.$parent) {
	            parent = parent.$parent;
	        }
	        parent.$children.push(vm);
	    }
	    vm.$parent = parent;
	    vm.$root = parent ? parent.$root : vm;
	    vm.$children = [];
	    vm.$refs = {};
	    vm._provided = parent ? parent._provided : Object.create(null);
	    vm._watcher = null;
	    vm._inactive = null;
	    vm._directInactive = false;
	    vm._isMounted = false;
	    vm._isDestroyed = false;
	    vm._isBeingDestroyed = false;
	}
	function lifecycleMixin(Vue) {
	    Vue.prototype._update = function (vnode, hydrating) {
	        var vm = this;
	        var prevEl = vm.$el;
	        var prevVnode = vm._vnode;
	        var restoreActiveInstance = setActiveInstance(vm);
	        vm._vnode = vnode;
	        // Vue.prototype.__patch__ is injected in entry points
	        // based on the rendering backend used.
	        if (!prevVnode) {
	            // initial render
	            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
	        }
	        else {
	            // updates
	            vm.$el = vm.__patch__(prevVnode, vnode);
	        }
	        restoreActiveInstance();
	        // update __vue__ reference
	        if (prevEl) {
	            prevEl.__vue__ = null;
	        }
	        if (vm.$el) {
	            vm.$el.__vue__ = vm;
	        }
	        // if parent is an HOC, update its $el as well
	        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	            vm.$parent.$el = vm.$el;
	        }
	        // updated hook is called by the scheduler to ensure that children are
	        // updated in a parent's updated hook.
	    };
	    Vue.prototype.$forceUpdate = function () {
	        var vm = this;
	        if (vm._watcher) {
	            vm._watcher.update();
	        }
	    };
	    Vue.prototype.$destroy = function () {
	        var vm = this;
	        if (vm._isBeingDestroyed) {
	            return;
	        }
	        callHook$1(vm, 'beforeDestroy');
	        vm._isBeingDestroyed = true;
	        // remove self from parent
	        var parent = vm.$parent;
	        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	            remove$2(parent.$children, vm);
	        }
	        // teardown scope. this includes both the render watcher and other
	        // watchers created
	        vm._scope.stop();
	        // remove reference from data ob
	        // frozen object may not have observer.
	        if (vm._data.__ob__) {
	            vm._data.__ob__.vmCount--;
	        }
	        // call the last hook...
	        vm._isDestroyed = true;
	        // invoke destroy hooks on current rendered tree
	        vm.__patch__(vm._vnode, null);
	        // fire destroyed hook
	        callHook$1(vm, 'destroyed');
	        // turn off all instance listeners.
	        vm.$off();
	        // remove __vue__ reference
	        if (vm.$el) {
	            vm.$el.__vue__ = null;
	        }
	        // release circular reference (#6759)
	        if (vm.$vnode) {
	            vm.$vnode.parent = null;
	        }
	    };
	}
	function mountComponent(vm, el, hydrating) {
	    vm.$el = el;
	    if (!vm.$options.render) {
	        // @ts-expect-error invalid type
	        vm.$options.render = createEmptyVNode;
	        if (process.env.NODE_ENV !== 'production') {
	            /* istanbul ignore if */
	            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
	                vm.$options.el ||
	                el) {
	                warn('You are using the runtime-only build of Vue where the template ' +
	                    'compiler is not available. Either pre-compile the templates into ' +
	                    'render functions, or use the compiler-included build.', vm);
	            }
	            else {
	                warn('Failed to mount component: template or render function not defined.', vm);
	            }
	        }
	    }
	    callHook$1(vm, 'beforeMount');
	    var updateComponent;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	        updateComponent = function () {
	            var name = vm._name;
	            var id = vm._uid;
	            var startTag = "vue-perf-start:".concat(id);
	            var endTag = "vue-perf-end:".concat(id);
	            mark(startTag);
	            var vnode = vm._render();
	            mark(endTag);
	            measure("vue ".concat(name, " render"), startTag, endTag);
	            mark(startTag);
	            vm._update(vnode, hydrating);
	            mark(endTag);
	            measure("vue ".concat(name, " patch"), startTag, endTag);
	        };
	    }
	    else {
	        updateComponent = function () {
	            vm._update(vm._render(), hydrating);
	        };
	    }
	    var watcherOptions = {
	        before: function () {
	            if (vm._isMounted && !vm._isDestroyed) {
	                callHook$1(vm, 'beforeUpdate');
	            }
	        }
	    };
	    if (process.env.NODE_ENV !== 'production') {
	        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };
	        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };
	    }
	    // we set this to vm._watcher inside the watcher's constructor
	    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
	    // component's mounted hook), which relies on vm._watcher being already defined
	    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
	    hydrating = false;
	    // flush buffer for flush: "pre" watchers queued in setup()
	    var preWatchers = vm._preWatchers;
	    if (preWatchers) {
	        for (var i = 0; i < preWatchers.length; i++) {
	            preWatchers[i].run();
	        }
	    }
	    // manually mounted instance, call mounted on self
	    // mounted is called for render-created child components in its inserted hook
	    if (vm.$vnode == null) {
	        vm._isMounted = true;
	        callHook$1(vm, 'mounted');
	    }
	    return vm;
	}
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	    if (process.env.NODE_ENV !== 'production') {
	        isUpdatingChildComponent = true;
	    }
	    // determine whether component has slot children
	    // we need to do this before overwriting $options._renderChildren.
	    // check if there are dynamic scopedSlots (hand-written or compiled but with
	    // dynamic slot names). Static scoped slots compiled from template has the
	    // "$stable" marker.
	    var newScopedSlots = parentVnode.data.scopedSlots;
	    var oldScopedSlots = vm.$scopedSlots;
	    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
	        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
	        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
	        (!newScopedSlots && vm.$scopedSlots.$key));
	    // Any static slot children from the parent may have changed during parent's
	    // update. Dynamic scoped slots may also have changed. In such cases, a forced
	    // update is necessary to ensure correctness.
	    var needsForceUpdate = !!(renderChildren || // has new static slots
	        vm.$options._renderChildren || // has old static slots
	        hasDynamicScopedSlot);
	    var prevVNode = vm.$vnode;
	    vm.$options._parentVnode = parentVnode;
	    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	    if (vm._vnode) {
	        // update child tree's parent
	        vm._vnode.parent = parentVnode;
	    }
	    vm.$options._renderChildren = renderChildren;
	    // update $attrs and $listeners hash
	    // these are also reactive so they may trigger child update if the child
	    // used them during render
	    var attrs = parentVnode.data.attrs || emptyObject;
	    if (vm._attrsProxy) {
	        // force update if attrs are accessed and has changed since it may be
	        // passed to a child component.
	        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
	            needsForceUpdate = true;
	        }
	    }
	    vm.$attrs = attrs;
	    // update listeners
	    listeners = listeners || emptyObject;
	    var prevListeners = vm.$options._parentListeners;
	    if (vm._listenersProxy) {
	        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
	    }
	    vm.$listeners = vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, prevListeners);
	    // update props
	    if (propsData && vm.$options.props) {
	        toggleObserving(false);
	        var props = vm._props;
	        var propKeys = vm.$options._propKeys || [];
	        for (var i = 0; i < propKeys.length; i++) {
	            var key = propKeys[i];
	            var propOptions = vm.$options.props; // wtf flow?
	            props[key] = validateProp(key, propOptions, propsData, vm);
	        }
	        toggleObserving(true);
	        // keep a copy of raw propsData
	        vm.$options.propsData = propsData;
	    }
	    // resolve slots + force update if has children
	    if (needsForceUpdate) {
	        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	        vm.$forceUpdate();
	    }
	    if (process.env.NODE_ENV !== 'production') {
	        isUpdatingChildComponent = false;
	    }
	}
	function isInInactiveTree(vm) {
	    while (vm && (vm = vm.$parent)) {
	        if (vm._inactive)
	            return true;
	    }
	    return false;
	}
	function activateChildComponent(vm, direct) {
	    if (direct) {
	        vm._directInactive = false;
	        if (isInInactiveTree(vm)) {
	            return;
	        }
	    }
	    else if (vm._directInactive) {
	        return;
	    }
	    if (vm._inactive || vm._inactive === null) {
	        vm._inactive = false;
	        for (var i = 0; i < vm.$children.length; i++) {
	            activateChildComponent(vm.$children[i]);
	        }
	        callHook$1(vm, 'activated');
	    }
	}
	function deactivateChildComponent(vm, direct) {
	    if (direct) {
	        vm._directInactive = true;
	        if (isInInactiveTree(vm)) {
	            return;
	        }
	    }
	    if (!vm._inactive) {
	        vm._inactive = true;
	        for (var i = 0; i < vm.$children.length; i++) {
	            deactivateChildComponent(vm.$children[i]);
	        }
	        callHook$1(vm, 'deactivated');
	    }
	}
	function callHook$1(vm, hook, args, setContext) {
	    if (setContext === void 0) { setContext = true; }
	    // #7573 disable dep collection when invoking lifecycle hooks
	    pushTarget();
	    var prev = currentInstance;
	    setContext && setCurrentInstance(vm);
	    var handlers = vm.$options[hook];
	    var info = "".concat(hook, " hook");
	    if (handlers) {
	        for (var i = 0, j = handlers.length; i < j; i++) {
	            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
	        }
	    }
	    if (vm._hasHookEvent) {
	        vm.$emit('hook:' + hook);
	    }
	    setContext && setCurrentInstance(prev);
	    popTarget();
	}

	var MAX_UPDATE_COUNT = 100;
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	    index = queue.length = activatedChildren.length = 0;
	    has = {};
	    if (process.env.NODE_ENV !== 'production') {
	        circular = {};
	    }
	    waiting = flushing = false;
	}
	// Async edge case #6566 requires saving the timestamp when event listeners are
	// attached. However, calling performance.now() has a perf overhead especially
	// if the page has thousands of event listeners. Instead, we take a timestamp
	// every time the scheduler flushes and use that for all event listeners
	// attached during that flush.
	var currentFlushTimestamp = 0;
	// Async edge case fix requires storing an event listener's attach timestamp.
	var getNow = Date.now;
	// Determine what event timestamp the browser is using. Annoyingly, the
	// timestamp can either be hi-res (relative to page load) or low-res
	// (relative to UNIX epoch), so in order to compare time we have to use the
	// same timestamp type when saving the flush timestamp.
	// All IE versions use low-res event timestamps, and have problematic clock
	// implementations (#9632)
	if (inBrowser && !isIE) {
	    var performance_1 = window.performance;
	    if (performance_1 &&
	        typeof performance_1.now === 'function' &&
	        getNow() > document.createEvent('Event').timeStamp) {
	        // if the event timestamp, although evaluated AFTER the Date.now(), is
	        // smaller than it, it means the event is using a hi-res timestamp,
	        // and we need to use the hi-res version for event listener timestamps as
	        // well.
	        getNow = function () { return performance_1.now(); };
	    }
	}
	var sortCompareFn = function (a, b) {
	    if (a.post) {
	        if (!b.post)
	            return 1;
	    }
	    else if (b.post) {
	        return -1;
	    }
	    return a.id - b.id;
	};
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	    currentFlushTimestamp = getNow();
	    flushing = true;
	    var watcher, id;
	    // Sort queue before flush.
	    // This ensures that:
	    // 1. Components are updated from parent to child. (because parent is always
	    //    created before the child)
	    // 2. A component's user watchers are run before its render watcher (because
	    //    user watchers are created before the render watcher)
	    // 3. If a component is destroyed during a parent component's watcher run,
	    //    its watchers can be skipped.
	    queue.sort(sortCompareFn);
	    // do not cache length because more watchers might be pushed
	    // as we run existing watchers
	    for (index = 0; index < queue.length; index++) {
	        watcher = queue[index];
	        if (watcher.before) {
	            watcher.before();
	        }
	        id = watcher.id;
	        has[id] = null;
	        watcher.run();
	        // in dev build, check and stop circular updates.
	        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	            circular[id] = (circular[id] || 0) + 1;
	            if (circular[id] > MAX_UPDATE_COUNT) {
	                warn('You may have an infinite update loop ' +
	                    (watcher.user
	                        ? "in watcher with expression \"".concat(watcher.expression, "\"")
	                        : "in a component render function."), watcher.vm);
	                break;
	            }
	        }
	    }
	    // keep copies of post queues before resetting state
	    var activatedQueue = activatedChildren.slice();
	    var updatedQueue = queue.slice();
	    resetSchedulerState();
	    // call component updated and activated hooks
	    callActivatedHooks(activatedQueue);
	    callUpdatedHooks(updatedQueue);
	    // devtool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	        devtools.emit('flush');
	    }
	}
	function callUpdatedHooks(queue) {
	    var i = queue.length;
	    while (i--) {
	        var watcher = queue[i];
	        var vm = watcher.vm;
	        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
	            callHook$1(vm, 'updated');
	        }
	    }
	}
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	    // setting _inactive to false here so that a render function can
	    // rely on checking whether it's in an inactive tree (e.g. router-view)
	    vm._inactive = false;
	    activatedChildren.push(vm);
	}
	function callActivatedHooks(queue) {
	    for (var i = 0; i < queue.length; i++) {
	        queue[i]._inactive = true;
	        activateChildComponent(queue[i], true /* true */);
	    }
	}
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	    var id = watcher.id;
	    if (has[id] != null) {
	        return;
	    }
	    if (watcher === Dep.target && watcher.noRecurse) {
	        return;
	    }
	    has[id] = true;
	    if (!flushing) {
	        queue.push(watcher);
	    }
	    else {
	        // if already flushing, splice the watcher based on its id
	        // if already past its id, it will be run next immediately.
	        var i = queue.length - 1;
	        while (i > index && queue[i].id > watcher.id) {
	            i--;
	        }
	        queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	        waiting = true;
	        if (process.env.NODE_ENV !== 'production' && !config.async) {
	            flushSchedulerQueue();
	            return;
	        }
	        nextTick(flushSchedulerQueue);
	    }
	}

	function initProvide(vm) {
	    var provideOption = vm.$options.provide;
	    if (provideOption) {
	        var provided = isFunction(provideOption)
	            ? provideOption.call(vm)
	            : provideOption;
	        if (!isObject(provided)) {
	            return;
	        }
	        var source = resolveProvided(vm);
	        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
	        // iterate the keys ourselves.
	        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
	        }
	    }
	}
	function initInjections(vm) {
	    var result = resolveInject(vm.$options.inject, vm);
	    if (result) {
	        toggleObserving(false);
	        Object.keys(result).forEach(function (key) {
	            /* istanbul ignore else */
	            if (process.env.NODE_ENV !== 'production') {
	                defineReactive(vm, key, result[key], function () {
	                    warn("Avoid mutating an injected value directly since the changes will be " +
	                        "overwritten whenever the provided component re-renders. " +
	                        "injection being mutated: \"".concat(key, "\""), vm);
	                });
	            }
	            else {
	                defineReactive(vm, key, result[key]);
	            }
	        });
	        toggleObserving(true);
	    }
	}
	function resolveInject(inject, vm) {
	    if (inject) {
	        // inject is :any because flow is not smart enough to figure out cached
	        var result = Object.create(null);
	        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            // #6574 in case the inject object is observed...
	            if (key === '__ob__')
	                continue;
	            var provideKey = inject[key].from;
	            if (provideKey in vm._provided) {
	                result[key] = vm._provided[provideKey];
	            }
	            else if ('default' in inject[key]) {
	                var provideDefault = inject[key].default;
	                result[key] = isFunction(provideDefault)
	                    ? provideDefault.call(vm)
	                    : provideDefault;
	            }
	            else if (process.env.NODE_ENV !== 'production') {
	                warn("Injection \"".concat(key, "\" not found"), vm);
	            }
	        }
	        return result;
	    }
	}

	function FunctionalRenderContext(data, props, children, parent, Ctor) {
	    var _this = this;
	    var options = Ctor.options;
	    // ensure the createElement function in functional components
	    // gets a unique context - this is necessary for correct named slot check
	    var contextVm;
	    if (hasOwn(parent, '_uid')) {
	        contextVm = Object.create(parent);
	        contextVm._original = parent;
	    }
	    else {
	        // the context vm passed in is a functional context as well.
	        // in this case we want to make sure we are able to get a hold to the
	        // real context instance.
	        contextVm = parent;
	        // @ts-ignore
	        parent = parent._original;
	    }
	    var isCompiled = isTrue(options._compiled);
	    var needNormalization = !isCompiled;
	    this.data = data;
	    this.props = props;
	    this.children = children;
	    this.parent = parent;
	    this.listeners = data.on || emptyObject;
	    this.injections = resolveInject(options.inject, parent);
	    this.slots = function () {
	        if (!_this.$slots) {
	            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));
	        }
	        return _this.$slots;
	    };
	    Object.defineProperty(this, 'scopedSlots', {
	        enumerable: true,
	        get: function () {
	            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
	        }
	    });
	    // support for compiled functional template
	    if (isCompiled) {
	        // exposing $options for renderStatic()
	        this.$options = options;
	        // pre-resolve slots for renderSlot()
	        this.$slots = this.slots();
	        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
	    }
	    if (options._scopeId) {
	        this._c = function (a, b, c, d) {
	            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
	            if (vnode && !isArray(vnode)) {
	                vnode.fnScopeId = options._scopeId;
	                vnode.fnContext = parent;
	            }
	            return vnode;
	        };
	    }
	    else {
	        this._c = function (a, b, c, d) {
	            return createElement$1(contextVm, a, b, c, d, needNormalization);
	        };
	    }
	}
	installRenderHelpers(FunctionalRenderContext.prototype);
	function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
	    var options = Ctor.options;
	    var props = {};
	    var propOptions = options.props;
	    if (isDef(propOptions)) {
	        for (var key in propOptions) {
	            props[key] = validateProp(key, propOptions, propsData || emptyObject);
	        }
	    }
	    else {
	        if (isDef(data.attrs))
	            mergeProps(props, data.attrs);
	        if (isDef(data.props))
	            mergeProps(props, data.props);
	    }
	    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
	    var vnode = options.render.call(null, renderContext._c, renderContext);
	    if (vnode instanceof VNode) {
	        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
	    }
	    else if (isArray(vnode)) {
	        var vnodes = normalizeChildren(vnode) || [];
	        var res = new Array(vnodes.length);
	        for (var i = 0; i < vnodes.length; i++) {
	            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
	        }
	        return res;
	    }
	}
	function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
	    // #7817 clone node before setting fnContext, otherwise if the node is reused
	    // (e.g. it was from a cached normal slot) the fnContext causes named slots
	    // that should not be matched to match.
	    var clone = cloneVNode(vnode);
	    clone.fnContext = contextVm;
	    clone.fnOptions = options;
	    if (process.env.NODE_ENV !== 'production') {
	        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
	            renderContext;
	    }
	    if (data.slot) {
	        (clone.data || (clone.data = {})).slot = data.slot;
	    }
	    return clone;
	}
	function mergeProps(to, from) {
	    for (var key in from) {
	        to[camelize(key)] = from[key];
	    }
	}

	function getComponentName(options) {
	    return options.name || options.__name || options._componentTag;
	}
	// inline hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	    init: function (vnode, hydrating) {
	        if (vnode.componentInstance &&
	            !vnode.componentInstance._isDestroyed &&
	            vnode.data.keepAlive) {
	            // kept-alive components, treat as a patch
	            var mountedNode = vnode; // work around flow
	            componentVNodeHooks.prepatch(mountedNode, mountedNode);
	        }
	        else {
	            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
	            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	        }
	    },
	    prepatch: function (oldVnode, vnode) {
	        var options = vnode.componentOptions;
	        var child = (vnode.componentInstance = oldVnode.componentInstance);
	        updateChildComponent(child, options.propsData, // updated props
	        options.listeners, // updated listeners
	        vnode, // new parent vnode
	        options.children // new children
	        );
	    },
	    insert: function (vnode) {
	        var context = vnode.context, componentInstance = vnode.componentInstance;
	        if (!componentInstance._isMounted) {
	            componentInstance._isMounted = true;
	            callHook$1(componentInstance, 'mounted');
	        }
	        if (vnode.data.keepAlive) {
	            if (context._isMounted) {
	                // vue-router#1212
	                // During updates, a kept-alive component's child components may
	                // change, so directly walking the tree here may call activated hooks
	                // on incorrect children. Instead we push them into a queue which will
	                // be processed after the whole patch process ended.
	                queueActivatedComponent(componentInstance);
	            }
	            else {
	                activateChildComponent(componentInstance, true /* direct */);
	            }
	        }
	    },
	    destroy: function (vnode) {
	        var componentInstance = vnode.componentInstance;
	        if (!componentInstance._isDestroyed) {
	            if (!vnode.data.keepAlive) {
	                componentInstance.$destroy();
	            }
	            else {
	                deactivateChildComponent(componentInstance, true /* direct */);
	            }
	        }
	    }
	};
	var hooksToMerge = Object.keys(componentVNodeHooks);
	function createComponent(Ctor, data, context, children, tag) {
	    if (isUndef(Ctor)) {
	        return;
	    }
	    var baseCtor = context.$options._base;
	    // plain options object: turn it into a constructor
	    if (isObject(Ctor)) {
	        Ctor = baseCtor.extend(Ctor);
	    }
	    // if at this stage it's not a constructor or an async component factory,
	    // reject.
	    if (typeof Ctor !== 'function') {
	        if (process.env.NODE_ENV !== 'production') {
	            warn("Invalid Component definition: ".concat(String(Ctor)), context);
	        }
	        return;
	    }
	    // async component
	    var asyncFactory;
	    // @ts-expect-error
	    if (isUndef(Ctor.cid)) {
	        asyncFactory = Ctor;
	        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
	        if (Ctor === undefined) {
	            // return a placeholder node for async component, which is rendered
	            // as a comment node but preserves all the raw information for the node.
	            // the information will be used for async server-rendering and hydration.
	            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
	        }
	    }
	    data = data || {};
	    // resolve constructor options in case global mixins are applied after
	    // component constructor creation
	    resolveConstructorOptions(Ctor);
	    // transform component v-model data into props & events
	    if (isDef(data.model)) {
	        // @ts-expect-error
	        transformModel(Ctor.options, data);
	    }
	    // extract props
	    // @ts-expect-error
	    var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	    // functional component
	    // @ts-expect-error
	    if (isTrue(Ctor.options.functional)) {
	        return createFunctionalComponent(Ctor, propsData, data, context, children);
	    }
	    // extract listeners, since these needs to be treated as
	    // child component listeners instead of DOM listeners
	    var listeners = data.on;
	    // replace with listeners with .native modifier
	    // so it gets processed during parent component patch.
	    data.on = data.nativeOn;
	    // @ts-expect-error
	    if (isTrue(Ctor.options.abstract)) {
	        // abstract components do not keep anything
	        // other than props & listeners & slot
	        // work around flow
	        var slot = data.slot;
	        data = {};
	        if (slot) {
	            data.slot = slot;
	        }
	    }
	    // install component management hooks onto the placeholder node
	    installComponentHooks(data);
	    // return a placeholder vnode
	    // @ts-expect-error
	    var name = getComponentName(Ctor.options) || tag;
	    var vnode = new VNode(
	    // @ts-expect-error
	    "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ''), data, undefined, undefined, undefined, context, 
	    // @ts-expect-error
	    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
	    return vnode;
	}
	function createComponentInstanceForVnode(
	// we know it's MountedComponentVNode but flow doesn't
	vnode, 
	// activeInstance in lifecycle state
	parent) {
	    var options = {
	        _isComponent: true,
	        _parentVnode: vnode,
	        parent: parent
	    };
	    // check inline-template render functions
	    var inlineTemplate = vnode.data.inlineTemplate;
	    if (isDef(inlineTemplate)) {
	        options.render = inlineTemplate.render;
	        options.staticRenderFns = inlineTemplate.staticRenderFns;
	    }
	    return new vnode.componentOptions.Ctor(options);
	}
	function installComponentHooks(data) {
	    var hooks = data.hook || (data.hook = {});
	    for (var i = 0; i < hooksToMerge.length; i++) {
	        var key = hooksToMerge[i];
	        var existing = hooks[key];
	        var toMerge = componentVNodeHooks[key];
	        // @ts-expect-error
	        if (existing !== toMerge && !(existing && existing._merged)) {
	            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
	        }
	    }
	}
	function mergeHook(f1, f2) {
	    var merged = function (a, b) {
	        // flow complains about extra args which is why we use any
	        f1(a, b);
	        f2(a, b);
	    };
	    merged._merged = true;
	    return merged;
	}
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	    var prop = (options.model && options.model.prop) || 'value';
	    var event = (options.model && options.model.event) || 'input';
	    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
	    var on = data.on || (data.on = {});
	    var existing = on[event];
	    var callback = data.model.callback;
	    if (isDef(existing)) {
	        if (isArray(existing)
	            ? existing.indexOf(callback) === -1
	            : existing !== callback) {
	            on[event] = [callback].concat(existing);
	        }
	    }
	    else {
	        on[event] = callback;
	    }
	}

	var warn = noop;
	var tip = noop;
	var generateComponentTrace; // work around flow check
	var formatComponentName;
	if (process.env.NODE_ENV !== 'production') {
	    var hasConsole_1 = typeof console !== 'undefined';
	    var classifyRE_1 = /(?:^|[-_])(\w)/g;
	    var classify_1 = function (str) {
	        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');
	    };
	    warn = function (msg, vm) {
	        if (vm === void 0) { vm = currentInstance; }
	        var trace = vm ? generateComponentTrace(vm) : '';
	        if (config.warnHandler) {
	            config.warnHandler.call(null, msg, vm, trace);
	        }
	        else if (hasConsole_1 && !config.silent) {
	            console.error("[Vue warn]: ".concat(msg).concat(trace));
	        }
	    };
	    tip = function (msg, vm) {
	        if (hasConsole_1 && !config.silent) {
	            console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ''));
	        }
	    };
	    formatComponentName = function (vm, includeFile) {
	        if (vm.$root === vm) {
	            return '<Root>';
	        }
	        var options = isFunction(vm) && vm.cid != null
	            ? vm.options
	            : vm._isVue
	                ? vm.$options || vm.constructor.options
	                : vm;
	        var name = getComponentName(options);
	        var file = options.__file;
	        if (!name && file) {
	            var match = file.match(/([^/\\]+)\.vue$/);
	            name = match && match[1];
	        }
	        return ((name ? "<".concat(classify_1(name), ">") : "<Anonymous>") +
	            (file && includeFile !== false ? " at ".concat(file) : ''));
	    };
	    var repeat_1 = function (str, n) {
	        var res = '';
	        while (n) {
	            if (n % 2 === 1)
	                res += str;
	            if (n > 1)
	                str += str;
	            n >>= 1;
	        }
	        return res;
	    };
	    generateComponentTrace = function (vm) {
	        if (vm._isVue && vm.$parent) {
	            var tree = [];
	            var currentRecursiveSequence = 0;
	            while (vm) {
	                if (tree.length > 0) {
	                    var last = tree[tree.length - 1];
	                    if (last.constructor === vm.constructor) {
	                        currentRecursiveSequence++;
	                        vm = vm.$parent;
	                        continue;
	                    }
	                    else if (currentRecursiveSequence > 0) {
	                        tree[tree.length - 1] = [last, currentRecursiveSequence];
	                        currentRecursiveSequence = 0;
	                    }
	                }
	                tree.push(vm);
	                vm = vm.$parent;
	            }
	            return ('\n\nfound in\n\n' +
	                tree
	                    .map(function (vm, i) {
	                    return "".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)
	                        ? "".concat(formatComponentName(vm[0]), "... (").concat(vm[1], " recursive calls)")
	                        : formatComponentName(vm));
	                })
	                    .join('\n'));
	        }
	        else {
	            return "\n\n(found in ".concat(formatComponentName(vm), ")");
	        }
	    };
	}

	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	    strats.el = strats.propsData = function (parent, child, vm, key) {
	        if (!vm) {
	            warn("option \"".concat(key, "\" can only be used during instance ") +
	                'creation with the `new` keyword.');
	        }
	        return defaultStrat(parent, child);
	    };
	}
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	    if (!from)
	        return to;
	    var key, toVal, fromVal;
	    var keys = hasSymbol
	        ? Reflect.ownKeys(from)
	        : Object.keys(from);
	    for (var i = 0; i < keys.length; i++) {
	        key = keys[i];
	        // in case the object is already observed...
	        if (key === '__ob__')
	            continue;
	        toVal = to[key];
	        fromVal = from[key];
	        if (!hasOwn(to, key)) {
	            set(to, key, fromVal);
	        }
	        else if (toVal !== fromVal &&
	            isPlainObject(toVal) &&
	            isPlainObject(fromVal)) {
	            mergeData(toVal, fromVal);
	        }
	    }
	    return to;
	}
	/**
	 * Data
	 */
	function mergeDataOrFn(parentVal, childVal, vm) {
	    if (!vm) {
	        // in a Vue.extend merge, both should be functions
	        if (!childVal) {
	            return parentVal;
	        }
	        if (!parentVal) {
	            return childVal;
	        }
	        // when parentVal & childVal are both present,
	        // we need to return a function that returns the
	        // merged result of both functions... no need to
	        // check if parentVal is a function here because
	        // it has to be a function to pass previous merges.
	        return function mergedDataFn() {
	            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
	        };
	    }
	    else {
	        return function mergedInstanceDataFn() {
	            // instance merge
	            var instanceData = isFunction(childVal)
	                ? childVal.call(vm, vm)
	                : childVal;
	            var defaultData = isFunction(parentVal)
	                ? parentVal.call(vm, vm)
	                : parentVal;
	            if (instanceData) {
	                return mergeData(instanceData, defaultData);
	            }
	            else {
	                return defaultData;
	            }
	        };
	    }
	}
	strats.data = function (parentVal, childVal, vm) {
	    if (!vm) {
	        if (childVal && typeof childVal !== 'function') {
	            process.env.NODE_ENV !== 'production' &&
	                warn('The "data" option should be a function ' +
	                    'that returns a per-instance value in component ' +
	                    'definitions.', vm);
	            return parentVal;
	        }
	        return mergeDataOrFn(parentVal, childVal);
	    }
	    return mergeDataOrFn(parentVal, childVal, vm);
	};
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeLifecycleHook(parentVal, childVal) {
	    var res = childVal
	        ? parentVal
	            ? parentVal.concat(childVal)
	            : isArray(childVal)
	                ? childVal
	                : [childVal]
	        : parentVal;
	    return res ? dedupeHooks(res) : res;
	}
	function dedupeHooks(hooks) {
	    var res = [];
	    for (var i = 0; i < hooks.length; i++) {
	        if (res.indexOf(hooks[i]) === -1) {
	            res.push(hooks[i]);
	        }
	    }
	    return res;
	}
	LIFECYCLE_HOOKS.forEach(function (hook) {
	    strats[hook] = mergeLifecycleHook;
	});
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal, vm, key) {
	    var res = Object.create(parentVal || null);
	    if (childVal) {
	        process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
	        return extend(res, childVal);
	    }
	    else {
	        return res;
	    }
	}
	ASSET_TYPES.forEach(function (type) {
	    strats[type + 's'] = mergeAssets;
	});
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal, vm, key) {
	    // work around Firefox's Object.prototype.watch...
	    //@ts-expect-error work around
	    if (parentVal === nativeWatch)
	        parentVal = undefined;
	    //@ts-expect-error work around
	    if (childVal === nativeWatch)
	        childVal = undefined;
	    /* istanbul ignore if */
	    if (!childVal)
	        return Object.create(parentVal || null);
	    if (process.env.NODE_ENV !== 'production') {
	        assertObjectType(key, childVal, vm);
	    }
	    if (!parentVal)
	        return childVal;
	    var ret = {};
	    extend(ret, parentVal);
	    for (var key_1 in childVal) {
	        var parent_1 = ret[key_1];
	        var child = childVal[key_1];
	        if (parent_1 && !isArray(parent_1)) {
	            parent_1 = [parent_1];
	        }
	        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
	    }
	    return ret;
	};
	/**
	 * Other object hashes.
	 */
	strats.props =
	    strats.methods =
	        strats.inject =
	            strats.computed =
	                function (parentVal, childVal, vm, key) {
	                    if (childVal && process.env.NODE_ENV !== 'production') {
	                        assertObjectType(key, childVal, vm);
	                    }
	                    if (!parentVal)
	                        return childVal;
	                    var ret = Object.create(null);
	                    extend(ret, parentVal);
	                    if (childVal)
	                        extend(ret, childVal);
	                    return ret;
	                };
	strats.provide = mergeDataOrFn;
	/**
	 * Default strategy.
	 */
	var defaultStrat = function (parentVal, childVal) {
	    return childVal === undefined ? parentVal : childVal;
	};
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	    for (var key in options.components) {
	        validateComponentName(key);
	    }
	}
	function validateComponentName(name) {
	    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
	        warn('Invalid component name: "' +
	            name +
	            '". Component names ' +
	            'should conform to valid custom element name in html5 specification.');
	    }
	    if (isBuiltInTag(name) || config.isReservedTag(name)) {
	        warn('Do not use built-in or reserved HTML elements as component ' +
	            'id: ' +
	            name);
	    }
	}
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options, vm) {
	    var props = options.props;
	    if (!props)
	        return;
	    var res = {};
	    var i, val, name;
	    if (isArray(props)) {
	        i = props.length;
	        while (i--) {
	            val = props[i];
	            if (typeof val === 'string') {
	                name = camelize(val);
	                res[name] = { type: null };
	            }
	            else if (process.env.NODE_ENV !== 'production') {
	                warn('props must be strings when using array syntax.');
	            }
	        }
	    }
	    else if (isPlainObject(props)) {
	        for (var key in props) {
	            val = props[key];
	            name = camelize(key);
	            res[name] = isPlainObject(val) ? val : { type: val };
	        }
	    }
	    else if (process.env.NODE_ENV !== 'production') {
	        warn("Invalid value for option \"props\": expected an Array or an Object, " +
	            "but got ".concat(toRawType(props), "."), vm);
	    }
	    options.props = res;
	}
	/**
	 * Normalize all injections into Object-based format
	 */
	function normalizeInject(options, vm) {
	    var inject = options.inject;
	    if (!inject)
	        return;
	    var normalized = (options.inject = {});
	    if (isArray(inject)) {
	        for (var i = 0; i < inject.length; i++) {
	            normalized[inject[i]] = { from: inject[i] };
	        }
	    }
	    else if (isPlainObject(inject)) {
	        for (var key in inject) {
	            var val = inject[key];
	            normalized[key] = isPlainObject(val)
	                ? extend({ from: key }, val)
	                : { from: val };
	        }
	    }
	    else if (process.env.NODE_ENV !== 'production') {
	        warn("Invalid value for option \"inject\": expected an Array or an Object, " +
	            "but got ".concat(toRawType(inject), "."), vm);
	    }
	}
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives$1(options) {
	    var dirs = options.directives;
	    if (dirs) {
	        for (var key in dirs) {
	            var def = dirs[key];
	            if (isFunction(def)) {
	                dirs[key] = { bind: def, update: def };
	            }
	        }
	    }
	}
	function assertObjectType(name, value, vm) {
	    if (!isPlainObject(value)) {
	        warn("Invalid value for option \"".concat(name, "\": expected an Object, ") +
	            "but got ".concat(toRawType(value), "."), vm);
	    }
	}
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	    if (process.env.NODE_ENV !== 'production') {
	        checkComponents(child);
	    }
	    if (isFunction(child)) {
	        // @ts-expect-error
	        child = child.options;
	    }
	    normalizeProps(child, vm);
	    normalizeInject(child, vm);
	    normalizeDirectives$1(child);
	    // Apply extends and mixins on the child options,
	    // but only if it is a raw options object that isn't
	    // the result of another mergeOptions call.
	    // Only merged options has the _base property.
	    if (!child._base) {
	        if (child.extends) {
	            parent = mergeOptions(parent, child.extends, vm);
	        }
	        if (child.mixins) {
	            for (var i = 0, l = child.mixins.length; i < l; i++) {
	                parent = mergeOptions(parent, child.mixins[i], vm);
	            }
	        }
	    }
	    var options = {};
	    var key;
	    for (key in parent) {
	        mergeField(key);
	    }
	    for (key in child) {
	        if (!hasOwn(parent, key)) {
	            mergeField(key);
	        }
	    }
	    function mergeField(key) {
	        var strat = strats[key] || defaultStrat;
	        options[key] = strat(parent[key], child[key], vm, key);
	    }
	    return options;
	}
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	    /* istanbul ignore if */
	    if (typeof id !== 'string') {
	        return;
	    }
	    var assets = options[type];
	    // check local registration variations first
	    if (hasOwn(assets, id))
	        return assets[id];
	    var camelizedId = camelize(id);
	    if (hasOwn(assets, camelizedId))
	        return assets[camelizedId];
	    var PascalCaseId = capitalize(camelizedId);
	    if (hasOwn(assets, PascalCaseId))
	        return assets[PascalCaseId];
	    // fallback to prototype chain
	    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	    if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
	    }
	    return res;
	}

	function validateProp(key, propOptions, propsData, vm) {
	    var prop = propOptions[key];
	    var absent = !hasOwn(propsData, key);
	    var value = propsData[key];
	    // boolean casting
	    var booleanIndex = getTypeIndex(Boolean, prop.type);
	    if (booleanIndex > -1) {
	        if (absent && !hasOwn(prop, 'default')) {
	            value = false;
	        }
	        else if (value === '' || value === hyphenate(key)) {
	            // only cast empty string / same name to boolean if
	            // boolean has higher priority
	            var stringIndex = getTypeIndex(String, prop.type);
	            if (stringIndex < 0 || booleanIndex < stringIndex) {
	                value = true;
	            }
	        }
	    }
	    // check default value
	    if (value === undefined) {
	        value = getPropDefaultValue(vm, prop, key);
	        // since the default value is a fresh copy,
	        // make sure to observe it.
	        var prevShouldObserve = shouldObserve;
	        toggleObserving(true);
	        observe(value);
	        toggleObserving(prevShouldObserve);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	        assertProp(prop, key, value, vm, absent);
	    }
	    return value;
	}
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	    // no default, return undefined
	    if (!hasOwn(prop, 'default')) {
	        return undefined;
	    }
	    var def = prop.default;
	    // warn against non-factory defaults for Object & Array
	    if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	        warn('Invalid default value for prop "' +
	            key +
	            '": ' +
	            'Props with type Object/Array must use a factory function ' +
	            'to return the default value.', vm);
	    }
	    // the raw prop value was also undefined from previous render,
	    // return previous default value to avoid unnecessary watcher trigger
	    if (vm &&
	        vm.$options.propsData &&
	        vm.$options.propsData[key] === undefined &&
	        vm._props[key] !== undefined) {
	        return vm._props[key];
	    }
	    // call factory function for non-Function types
	    // a value is Function if its prototype is function even across different execution context
	    return isFunction(def) && getType(prop.type) !== 'Function'
	        ? def.call(vm)
	        : def;
	}
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	    if (prop.required && absent) {
	        warn('Missing required prop: "' + name + '"', vm);
	        return;
	    }
	    if (value == null && !prop.required) {
	        return;
	    }
	    var type = prop.type;
	    var valid = !type || type === true;
	    var expectedTypes = [];
	    if (type) {
	        if (!isArray(type)) {
	            type = [type];
	        }
	        for (var i = 0; i < type.length && !valid; i++) {
	            var assertedType = assertType(value, type[i], vm);
	            expectedTypes.push(assertedType.expectedType || '');
	            valid = assertedType.valid;
	        }
	    }
	    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
	    if (!valid && haveExpectedTypes) {
	        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
	        return;
	    }
	    var validator = prop.validator;
	    if (validator) {
	        if (!validator(value)) {
	            warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	        }
	    }
	}
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
	function assertType(value, type, vm) {
	    var valid;
	    var expectedType = getType(type);
	    if (simpleCheckRE.test(expectedType)) {
	        var t = typeof value;
	        valid = t === expectedType.toLowerCase();
	        // for primitive wrapper objects
	        if (!valid && t === 'object') {
	            valid = value instanceof type;
	        }
	    }
	    else if (expectedType === 'Object') {
	        valid = isPlainObject(value);
	    }
	    else if (expectedType === 'Array') {
	        valid = isArray(value);
	    }
	    else {
	        try {
	            valid = value instanceof type;
	        }
	        catch (e) {
	            warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
	            valid = false;
	        }
	    }
	    return {
	        valid: valid,
	        expectedType: expectedType
	    };
	}
	var functionTypeCheckRE = /^\s*function (\w+)/;
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	    var match = fn && fn.toString().match(functionTypeCheckRE);
	    return match ? match[1] : '';
	}
	function isSameType(a, b) {
	    return getType(a) === getType(b);
	}
	function getTypeIndex(type, expectedTypes) {
	    if (!isArray(expectedTypes)) {
	        return isSameType(expectedTypes, type) ? 0 : -1;
	    }
	    for (var i = 0, len = expectedTypes.length; i < len; i++) {
	        if (isSameType(expectedTypes[i], type)) {
	            return i;
	        }
	    }
	    return -1;
	}
	function getInvalidTypeMessage(name, value, expectedTypes) {
	    var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") +
	        " Expected ".concat(expectedTypes.map(capitalize).join(', '));
	    var expectedType = expectedTypes[0];
	    var receivedType = toRawType(value);
	    // check if we need to specify expected value
	    if (expectedTypes.length === 1 &&
	        isExplicable(expectedType) &&
	        isExplicable(typeof value) &&
	        !isBoolean(expectedType, receivedType)) {
	        message += " with value ".concat(styleValue(value, expectedType));
	    }
	    message += ", got ".concat(receivedType, " ");
	    // check if we need to specify received value
	    if (isExplicable(receivedType)) {
	        message += "with value ".concat(styleValue(value, receivedType), ".");
	    }
	    return message;
	}
	function styleValue(value, type) {
	    if (type === 'String') {
	        return "\"".concat(value, "\"");
	    }
	    else if (type === 'Number') {
	        return "".concat(Number(value));
	    }
	    else {
	        return "".concat(value);
	    }
	}
	var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
	function isExplicable(value) {
	    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });
	}
	function isBoolean() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });
	}

	/* not type checking this file because flow doesn't play well with Proxy */
	var initProxy;
	if (process.env.NODE_ENV !== 'production') {
	    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
	        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
	        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
	        'require' // for Webpack/Browserify
	    );
	    var warnNonPresent_1 = function (target, key) {
	        warn("Property or method \"".concat(key, "\" is not defined on the instance but ") +
	            'referenced during render. Make sure that this property is reactive, ' +
	            'either in the data option, or for class-based components, by ' +
	            'initializing the property. ' +
	            'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
	    };
	    var warnReservedPrefix_1 = function (target, key) {
	        warn("Property \"".concat(key, "\" must be accessed with \"$data.").concat(key, "\" because ") +
	            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
	            'prevent conflicts with Vue internals. ' +
	            'See: https://vuejs.org/v2/api/#data', target);
	    };
	    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
	    if (hasProxy_1) {
	        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
	        config.keyCodes = new Proxy(config.keyCodes, {
	            set: function (target, key, value) {
	                if (isBuiltInModifier_1(key)) {
	                    warn("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
	                    return false;
	                }
	                else {
	                    target[key] = value;
	                    return true;
	                }
	            }
	        });
	    }
	    var hasHandler_1 = {
	        has: function (target, key) {
	            var has = key in target;
	            var isAllowed = allowedGlobals_1(key) ||
	                (typeof key === 'string' &&
	                    key.charAt(0) === '_' &&
	                    !(key in target.$data));
	            if (!has && !isAllowed) {
	                if (key in target.$data)
	                    warnReservedPrefix_1(target, key);
	                else
	                    warnNonPresent_1(target, key);
	            }
	            return has || !isAllowed;
	        }
	    };
	    var getHandler_1 = {
	        get: function (target, key) {
	            if (typeof key === 'string' && !(key in target)) {
	                if (key in target.$data)
	                    warnReservedPrefix_1(target, key);
	                else
	                    warnNonPresent_1(target, key);
	            }
	            return target[key];
	        }
	    };
	    initProxy = function initProxy(vm) {
	        if (hasProxy_1) {
	            // determine which proxy handler to use
	            var options = vm.$options;
	            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
	            vm._renderProxy = new Proxy(vm, handlers);
	        }
	        else {
	            vm._renderProxy = vm;
	        }
	    };
	}

	var sharedPropertyDefinition = {
	    enumerable: true,
	    configurable: true,
	    get: noop,
	    set: noop
	};
	function proxy(target, sourceKey, key) {
	    sharedPropertyDefinition.get = function proxyGetter() {
	        return this[sourceKey][key];
	    };
	    sharedPropertyDefinition.set = function proxySetter(val) {
	        this[sourceKey][key] = val;
	    };
	    Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	function initState(vm) {
	    var opts = vm.$options;
	    if (opts.props)
	        initProps$1(vm, opts.props);
	    // Composition API
	    initSetup(vm);
	    if (opts.methods)
	        initMethods(vm, opts.methods);
	    if (opts.data) {
	        initData(vm);
	    }
	    else {
	        var ob = observe((vm._data = {}));
	        ob && ob.vmCount++;
	    }
	    if (opts.computed)
	        initComputed$1(vm, opts.computed);
	    if (opts.watch && opts.watch !== nativeWatch) {
	        initWatch(vm, opts.watch);
	    }
	}
	function initProps$1(vm, propsOptions) {
	    var propsData = vm.$options.propsData || {};
	    var props = (vm._props = shallowReactive({}));
	    // cache prop keys so that future props updates can iterate using Array
	    // instead of dynamic object key enumeration.
	    var keys = (vm.$options._propKeys = []);
	    var isRoot = !vm.$parent;
	    // root instance props should be converted
	    if (!isRoot) {
	        toggleObserving(false);
	    }
	    var _loop_1 = function (key) {
	        keys.push(key);
	        var value = validateProp(key, propsOptions, propsData, vm);
	        /* istanbul ignore else */
	        if (process.env.NODE_ENV !== 'production') {
	            var hyphenatedKey = hyphenate(key);
	            if (isReservedAttribute(hyphenatedKey) ||
	                config.isReservedAttr(hyphenatedKey)) {
	                warn("\"".concat(hyphenatedKey, "\" is a reserved attribute and cannot be used as component prop."), vm);
	            }
	            defineReactive(props, key, value, function () {
	                if (!isRoot && !isUpdatingChildComponent) {
	                    warn("Avoid mutating a prop directly since the value will be " +
	                        "overwritten whenever the parent component re-renders. " +
	                        "Instead, use a data or computed property based on the prop's " +
	                        "value. Prop being mutated: \"".concat(key, "\""), vm);
	                }
	            });
	        }
	        else {
	            defineReactive(props, key, value);
	        }
	        // static props are already proxied on the component's prototype
	        // during Vue.extend(). We only need to proxy props defined at
	        // instantiation here.
	        if (!(key in vm)) {
	            proxy(vm, "_props", key);
	        }
	    };
	    for (var key in propsOptions) {
	        _loop_1(key);
	    }
	    toggleObserving(true);
	}
	function initData(vm) {
	    var data = vm.$options.data;
	    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
	    if (!isPlainObject(data)) {
	        data = {};
	        process.env.NODE_ENV !== 'production' &&
	            warn('data functions should return an object:\n' +
	                'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	    }
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var props = vm.$options.props;
	    var methods = vm.$options.methods;
	    var i = keys.length;
	    while (i--) {
	        var key = keys[i];
	        if (process.env.NODE_ENV !== 'production') {
	            if (methods && hasOwn(methods, key)) {
	                warn("Method \"".concat(key, "\" has already been defined as a data property."), vm);
	            }
	        }
	        if (props && hasOwn(props, key)) {
	            process.env.NODE_ENV !== 'production' &&
	                warn("The data property \"".concat(key, "\" is already declared as a prop. ") +
	                    "Use prop default value instead.", vm);
	        }
	        else if (!isReserved(key)) {
	            proxy(vm, "_data", key);
	        }
	    }
	    // observe data
	    var ob = observe(data);
	    ob && ob.vmCount++;
	}
	function getData(data, vm) {
	    // #7573 disable dep collection when invoking data getters
	    pushTarget();
	    try {
	        return data.call(vm, vm);
	    }
	    catch (e) {
	        handleError(e, vm, "data()");
	        return {};
	    }
	    finally {
	        popTarget();
	    }
	}
	var computedWatcherOptions = { lazy: true };
	function initComputed$1(vm, computed) {
	    // $flow-disable-line
	    var watchers = (vm._computedWatchers = Object.create(null));
	    // computed properties are just getters during SSR
	    var isSSR = isServerRendering();
	    for (var key in computed) {
	        var userDef = computed[key];
	        var getter = isFunction(userDef) ? userDef : userDef.get;
	        if (process.env.NODE_ENV !== 'production' && getter == null) {
	            warn("Getter is missing for computed property \"".concat(key, "\"."), vm);
	        }
	        if (!isSSR) {
	            // create internal watcher for the computed property.
	            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
	        }
	        // component-defined computed properties are already defined on the
	        // component prototype. We only need to define computed properties defined
	        // at instantiation here.
	        if (!(key in vm)) {
	            defineComputed(vm, key, userDef);
	        }
	        else if (process.env.NODE_ENV !== 'production') {
	            if (key in vm.$data) {
	                warn("The computed property \"".concat(key, "\" is already defined in data."), vm);
	            }
	            else if (vm.$options.props && key in vm.$options.props) {
	                warn("The computed property \"".concat(key, "\" is already defined as a prop."), vm);
	            }
	            else if (vm.$options.methods && key in vm.$options.methods) {
	                warn("The computed property \"".concat(key, "\" is already defined as a method."), vm);
	            }
	        }
	    }
	}
	function defineComputed(target, key, userDef) {
	    var shouldCache = !isServerRendering();
	    if (isFunction(userDef)) {
	        sharedPropertyDefinition.get = shouldCache
	            ? createComputedGetter(key)
	            : createGetterInvoker(userDef);
	        sharedPropertyDefinition.set = noop;
	    }
	    else {
	        sharedPropertyDefinition.get = userDef.get
	            ? shouldCache && userDef.cache !== false
	                ? createComputedGetter(key)
	                : createGetterInvoker(userDef.get)
	            : noop;
	        sharedPropertyDefinition.set = userDef.set || noop;
	    }
	    if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
	        sharedPropertyDefinition.set = function () {
	            warn("Computed property \"".concat(key, "\" was assigned to but it has no setter."), this);
	        };
	    }
	    Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	function createComputedGetter(key) {
	    return function computedGetter() {
	        var watcher = this._computedWatchers && this._computedWatchers[key];
	        if (watcher) {
	            if (watcher.dirty) {
	                watcher.evaluate();
	            }
	            if (Dep.target) {
	                if (process.env.NODE_ENV !== 'production' && Dep.target.onTrack) {
	                    Dep.target.onTrack({
	                        effect: Dep.target,
	                        target: this,
	                        type: "get" /* TrackOpTypes.GET */,
	                        key: key
	                    });
	                }
	                watcher.depend();
	            }
	            return watcher.value;
	        }
	    };
	}
	function createGetterInvoker(fn) {
	    return function computedGetter() {
	        return fn.call(this, this);
	    };
	}
	function initMethods(vm, methods) {
	    var props = vm.$options.props;
	    for (var key in methods) {
	        if (process.env.NODE_ENV !== 'production') {
	            if (typeof methods[key] !== 'function') {
	                warn("Method \"".concat(key, "\" has type \"").concat(typeof methods[key], "\" in the component definition. ") +
	                    "Did you reference the function correctly?", vm);
	            }
	            if (props && hasOwn(props, key)) {
	                warn("Method \"".concat(key, "\" has already been defined as a prop."), vm);
	            }
	            if (key in vm && isReserved(key)) {
	                warn("Method \"".concat(key, "\" conflicts with an existing Vue instance method. ") +
	                    "Avoid defining component methods that start with _ or $.");
	            }
	        }
	        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
	    }
	}
	function initWatch(vm, watch) {
	    for (var key in watch) {
	        var handler = watch[key];
	        if (isArray(handler)) {
	            for (var i = 0; i < handler.length; i++) {
	                createWatcher(vm, key, handler[i]);
	            }
	        }
	        else {
	            createWatcher(vm, key, handler);
	        }
	    }
	}
	function createWatcher(vm, expOrFn, handler, options) {
	    if (isPlainObject(handler)) {
	        options = handler;
	        handler = handler.handler;
	    }
	    if (typeof handler === 'string') {
	        handler = vm[handler];
	    }
	    return vm.$watch(expOrFn, handler, options);
	}
	function stateMixin(Vue) {
	    // flow somehow has problems with directly declared definition object
	    // when using Object.defineProperty, so we have to procedurally build up
	    // the object here.
	    var dataDef = {};
	    dataDef.get = function () {
	        return this._data;
	    };
	    var propsDef = {};
	    propsDef.get = function () {
	        return this._props;
	    };
	    if (process.env.NODE_ENV !== 'production') {
	        dataDef.set = function () {
	            warn('Avoid replacing instance root $data. ' +
	                'Use nested data properties instead.', this);
	        };
	        propsDef.set = function () {
	            warn("$props is readonly.", this);
	        };
	    }
	    Object.defineProperty(Vue.prototype, '$data', dataDef);
	    Object.defineProperty(Vue.prototype, '$props', propsDef);
	    Vue.prototype.$set = set;
	    Vue.prototype.$delete = del;
	    Vue.prototype.$watch = function (expOrFn, cb, options) {
	        var vm = this;
	        if (isPlainObject(cb)) {
	            return createWatcher(vm, expOrFn, cb, options);
	        }
	        options = options || {};
	        options.user = true;
	        var watcher = new Watcher(vm, expOrFn, cb, options);
	        if (options.immediate) {
	            var info = "callback for immediate watcher \"".concat(watcher.expression, "\"");
	            pushTarget();
	            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
	            popTarget();
	        }
	        return function unwatchFn() {
	            watcher.teardown();
	        };
	    };
	}

	var uid = 0;
	function initMixin$1(Vue) {
	    Vue.prototype._init = function (options) {
	        var vm = this;
	        // a uid
	        vm._uid = uid++;
	        var startTag, endTag;
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	            startTag = "vue-perf-start:".concat(vm._uid);
	            endTag = "vue-perf-end:".concat(vm._uid);
	            mark(startTag);
	        }
	        // a flag to mark this as a Vue instance without having to do instanceof
	        // check
	        vm._isVue = true;
	        // avoid instances from being observed
	        vm.__v_skip = true;
	        // effect scope
	        vm._scope = new EffectScope(true /* detached */);
	        // merge options
	        if (options && options._isComponent) {
	            // optimize internal component instantiation
	            // since dynamic options merging is pretty slow, and none of the
	            // internal component options needs special treatment.
	            initInternalComponent(vm, options);
	        }
	        else {
	            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	        }
	        /* istanbul ignore else */
	        if (process.env.NODE_ENV !== 'production') {
	            initProxy(vm);
	        }
	        else {
	            vm._renderProxy = vm;
	        }
	        // expose real self
	        vm._self = vm;
	        initLifecycle(vm);
	        initEvents(vm);
	        initRender(vm);
	        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
	        initInjections(vm); // resolve injections before data/props
	        initState(vm);
	        initProvide(vm); // resolve provide after data/props
	        callHook$1(vm, 'created');
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	            vm._name = formatComponentName(vm, false);
	            mark(endTag);
	            measure("vue ".concat(vm._name, " init"), startTag, endTag);
	        }
	        if (vm.$options.el) {
	            vm.$mount(vm.$options.el);
	        }
	    };
	}
	function initInternalComponent(vm, options) {
	    var opts = (vm.$options = Object.create(vm.constructor.options));
	    // doing this because it's faster than dynamic enumeration.
	    var parentVnode = options._parentVnode;
	    opts.parent = options.parent;
	    opts._parentVnode = parentVnode;
	    var vnodeComponentOptions = parentVnode.componentOptions;
	    opts.propsData = vnodeComponentOptions.propsData;
	    opts._parentListeners = vnodeComponentOptions.listeners;
	    opts._renderChildren = vnodeComponentOptions.children;
	    opts._componentTag = vnodeComponentOptions.tag;
	    if (options.render) {
	        opts.render = options.render;
	        opts.staticRenderFns = options.staticRenderFns;
	    }
	}
	function resolveConstructorOptions(Ctor) {
	    var options = Ctor.options;
	    if (Ctor.super) {
	        var superOptions = resolveConstructorOptions(Ctor.super);
	        var cachedSuperOptions = Ctor.superOptions;
	        if (superOptions !== cachedSuperOptions) {
	            // super option changed,
	            // need to resolve new options.
	            Ctor.superOptions = superOptions;
	            // check if there are any late-modified/attached options (#4976)
	            var modifiedOptions = resolveModifiedOptions(Ctor);
	            // update base extend options
	            if (modifiedOptions) {
	                extend(Ctor.extendOptions, modifiedOptions);
	            }
	            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	            if (options.name) {
	                options.components[options.name] = Ctor;
	            }
	        }
	    }
	    return options;
	}
	function resolveModifiedOptions(Ctor) {
	    var modified;
	    var latest = Ctor.options;
	    var sealed = Ctor.sealedOptions;
	    for (var key in latest) {
	        if (latest[key] !== sealed[key]) {
	            if (!modified)
	                modified = {};
	            modified[key] = latest[key];
	        }
	    }
	    return modified;
	}

	function Vue(options) {
	    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {
	        warn('Vue is a constructor and should be called with the `new` keyword');
	    }
	    this._init(options);
	}
	//@ts-expect-error Vue has function type
	initMixin$1(Vue);
	//@ts-expect-error Vue has function type
	stateMixin(Vue);
	//@ts-expect-error Vue has function type
	eventsMixin(Vue);
	//@ts-expect-error Vue has function type
	lifecycleMixin(Vue);
	//@ts-expect-error Vue has function type
	renderMixin(Vue);

	function initUse(Vue) {
	    Vue.use = function (plugin) {
	        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
	        if (installedPlugins.indexOf(plugin) > -1) {
	            return this;
	        }
	        // additional parameters
	        var args = toArray(arguments, 1);
	        args.unshift(this);
	        if (isFunction(plugin.install)) {
	            plugin.install.apply(plugin, args);
	        }
	        else if (isFunction(plugin)) {
	            plugin.apply(null, args);
	        }
	        installedPlugins.push(plugin);
	        return this;
	    };
	}

	function initMixin(Vue) {
	    Vue.mixin = function (mixin) {
	        this.options = mergeOptions(this.options, mixin);
	        return this;
	    };
	}

	function initExtend(Vue) {
	    /**
	     * Each instance constructor, including Vue, has a unique
	     * cid. This enables us to create wrapped "child
	     * constructors" for prototypal inheritance and cache them.
	     */
	    Vue.cid = 0;
	    var cid = 1;
	    /**
	     * Class inheritance
	     */
	    Vue.extend = function (extendOptions) {
	        extendOptions = extendOptions || {};
	        var Super = this;
	        var SuperId = Super.cid;
	        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	        if (cachedCtors[SuperId]) {
	            return cachedCtors[SuperId];
	        }
	        var name = getComponentName(extendOptions) || getComponentName(Super.options);
	        if (process.env.NODE_ENV !== 'production' && name) {
	            validateComponentName(name);
	        }
	        var Sub = function VueComponent(options) {
	            this._init(options);
	        };
	        Sub.prototype = Object.create(Super.prototype);
	        Sub.prototype.constructor = Sub;
	        Sub.cid = cid++;
	        Sub.options = mergeOptions(Super.options, extendOptions);
	        Sub['super'] = Super;
	        // For props and computed properties, we define the proxy getters on
	        // the Vue instances at extension time, on the extended prototype. This
	        // avoids Object.defineProperty calls for each instance created.
	        if (Sub.options.props) {
	            initProps(Sub);
	        }
	        if (Sub.options.computed) {
	            initComputed(Sub);
	        }
	        // allow further extension/mixin/plugin usage
	        Sub.extend = Super.extend;
	        Sub.mixin = Super.mixin;
	        Sub.use = Super.use;
	        // create asset registers, so extended classes
	        // can have their private assets too.
	        ASSET_TYPES.forEach(function (type) {
	            Sub[type] = Super[type];
	        });
	        // enable recursive self-lookup
	        if (name) {
	            Sub.options.components[name] = Sub;
	        }
	        // keep a reference to the super options at extension time.
	        // later at instantiation we can check if Super's options have
	        // been updated.
	        Sub.superOptions = Super.options;
	        Sub.extendOptions = extendOptions;
	        Sub.sealedOptions = extend({}, Sub.options);
	        // cache constructor
	        cachedCtors[SuperId] = Sub;
	        return Sub;
	    };
	}
	function initProps(Comp) {
	    var props = Comp.options.props;
	    for (var key in props) {
	        proxy(Comp.prototype, "_props", key);
	    }
	}
	function initComputed(Comp) {
	    var computed = Comp.options.computed;
	    for (var key in computed) {
	        defineComputed(Comp.prototype, key, computed[key]);
	    }
	}

	function initAssetRegisters(Vue) {
	    /**
	     * Create asset registration methods.
	     */
	    ASSET_TYPES.forEach(function (type) {
	        // @ts-expect-error function is not exact same type
	        Vue[type] = function (id, definition) {
	            if (!definition) {
	                return this.options[type + 's'][id];
	            }
	            else {
	                /* istanbul ignore if */
	                if (process.env.NODE_ENV !== 'production' && type === 'component') {
	                    validateComponentName(id);
	                }
	                if (type === 'component' && isPlainObject(definition)) {
	                    // @ts-expect-error
	                    definition.name = definition.name || id;
	                    definition = this.options._base.extend(definition);
	                }
	                if (type === 'directive' && isFunction(definition)) {
	                    definition = { bind: definition, update: definition };
	                }
	                this.options[type + 's'][id] = definition;
	                return definition;
	            }
	        };
	    });
	}

	function _getComponentName(opts) {
	    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
	}
	function matches(pattern, name) {
	    if (isArray(pattern)) {
	        return pattern.indexOf(name) > -1;
	    }
	    else if (typeof pattern === 'string') {
	        return pattern.split(',').indexOf(name) > -1;
	    }
	    else if (isRegExp(pattern)) {
	        return pattern.test(name);
	    }
	    /* istanbul ignore next */
	    return false;
	}
	function pruneCache(keepAliveInstance, filter) {
	    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
	    for (var key in cache) {
	        var entry = cache[key];
	        if (entry) {
	            var name_1 = entry.name;
	            if (name_1 && !filter(name_1)) {
	                pruneCacheEntry(cache, key, keys, _vnode);
	            }
	        }
	    }
	}
	function pruneCacheEntry(cache, key, keys, current) {
	    var entry = cache[key];
	    if (entry && (!current || entry.tag !== current.tag)) {
	        // @ts-expect-error can be undefined
	        entry.componentInstance.$destroy();
	    }
	    cache[key] = null;
	    remove$2(keys, key);
	}
	var patternTypes = [String, RegExp, Array];
	// TODO defineComponent
	var KeepAlive = {
	    name: 'keep-alive',
	    abstract: true,
	    props: {
	        include: patternTypes,
	        exclude: patternTypes,
	        max: [String, Number]
	    },
	    methods: {
	        cacheVNode: function () {
	            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
	            if (vnodeToCache) {
	                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
	                cache[keyToCache] = {
	                    name: _getComponentName(componentOptions),
	                    tag: tag,
	                    componentInstance: componentInstance
	                };
	                keys.push(keyToCache);
	                // prune oldest entry
	                if (this.max && keys.length > parseInt(this.max)) {
	                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
	                }
	                this.vnodeToCache = null;
	            }
	        }
	    },
	    created: function () {
	        this.cache = Object.create(null);
	        this.keys = [];
	    },
	    destroyed: function () {
	        for (var key in this.cache) {
	            pruneCacheEntry(this.cache, key, this.keys);
	        }
	    },
	    mounted: function () {
	        var _this = this;
	        this.cacheVNode();
	        this.$watch('include', function (val) {
	            pruneCache(_this, function (name) { return matches(val, name); });
	        });
	        this.$watch('exclude', function (val) {
	            pruneCache(_this, function (name) { return !matches(val, name); });
	        });
	    },
	    updated: function () {
	        this.cacheVNode();
	    },
	    render: function () {
	        var slot = this.$slots.default;
	        var vnode = getFirstComponentChild(slot);
	        var componentOptions = vnode && vnode.componentOptions;
	        if (componentOptions) {
	            // check pattern
	            var name_2 = _getComponentName(componentOptions);
	            var _a = this, include = _a.include, exclude = _a.exclude;
	            if (
	            // not included
	            (include && (!name_2 || !matches(include, name_2))) ||
	                // excluded
	                (exclude && name_2 && matches(exclude, name_2))) {
	                return vnode;
	            }
	            var _b = this, cache = _b.cache, keys = _b.keys;
	            var key = vnode.key == null
	                ? // same constructor may get registered as different local components
	                    // so cid alone is not enough (#3269)
	                    componentOptions.Ctor.cid +
	                        (componentOptions.tag ? "::".concat(componentOptions.tag) : '')
	                : vnode.key;
	            if (cache[key]) {
	                vnode.componentInstance = cache[key].componentInstance;
	                // make current key freshest
	                remove$2(keys, key);
	                keys.push(key);
	            }
	            else {
	                // delay setting the cache until update
	                this.vnodeToCache = vnode;
	                this.keyToCache = key;
	            }
	            // @ts-expect-error can vnode.data can be undefined
	            vnode.data.keepAlive = true;
	        }
	        return vnode || (slot && slot[0]);
	    }
	};

	var builtInComponents = {
	    KeepAlive: KeepAlive
	};

	function initGlobalAPI(Vue) {
	    // config
	    var configDef = {};
	    configDef.get = function () { return config; };
	    if (process.env.NODE_ENV !== 'production') {
	        configDef.set = function () {
	            warn('Do not replace the Vue.config object, set individual fields instead.');
	        };
	    }
	    Object.defineProperty(Vue, 'config', configDef);
	    // exposed util methods.
	    // NOTE: these are not considered part of the public API - avoid relying on
	    // them unless you are aware of the risk.
	    Vue.util = {
	        warn: warn,
	        extend: extend,
	        mergeOptions: mergeOptions,
	        defineReactive: defineReactive
	    };
	    Vue.set = set;
	    Vue.delete = del;
	    Vue.nextTick = nextTick;
	    // 2.6 explicit observable API
	    Vue.observable = function (obj) {
	        observe(obj);
	        return obj;
	    };
	    Vue.options = Object.create(null);
	    ASSET_TYPES.forEach(function (type) {
	        Vue.options[type + 's'] = Object.create(null);
	    });
	    // this is used to identify the "base" constructor to extend all plain-object
	    // components with in Weex's multi-instance scenarios.
	    Vue.options._base = Vue;
	    extend(Vue.options.components, builtInComponents);
	    initUse(Vue);
	    initMixin(Vue);
	    initExtend(Vue);
	    initAssetRegisters(Vue);
	}

	initGlobalAPI(Vue);
	Object.defineProperty(Vue.prototype, '$isServer', {
	    get: isServerRendering
	});
	Object.defineProperty(Vue.prototype, '$ssrContext', {
	    get: function () {
	        /* istanbul ignore next */
	        return this.$vnode && this.$vnode.ssrContext;
	    }
	});
	// expose FunctionalRenderContext for ssr runtime helper installation
	Object.defineProperty(Vue, 'FunctionalRenderContext', {
	    value: FunctionalRenderContext
	});
	Vue.version = version;

	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select,progress');
	var mustUseProp = function (tag, type, attr) {
	    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
	        (attr === 'selected' && tag === 'option') ||
	        (attr === 'checked' && tag === 'input') ||
	        (attr === 'muted' && tag === 'video'));
	};
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
	var convertEnumeratedValue = function (key, value) {
	    return isFalsyAttrValue(value) || value === 'false'
	        ? 'false'
	        : // allow arbitrary string value for contenteditable
	            key === 'contenteditable' && isValidContentEditableValue(value)
	                ? value
	                : 'true';
	};
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
	    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
	    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
	    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
	    'required,reversed,scoped,seamless,selected,sortable,' +
	    'truespeed,typemustmatch,visible');
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var isXlink = function (name) {
	    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	var getXlinkProp = function (name) {
	    return isXlink(name) ? name.slice(6, name.length) : '';
	};
	var isFalsyAttrValue = function (val) {
	    return val == null || val === false;
	};

	function genClassForVnode(vnode) {
	    var data = vnode.data;
	    var parentNode = vnode;
	    var childNode = vnode;
	    while (isDef(childNode.componentInstance)) {
	        childNode = childNode.componentInstance._vnode;
	        if (childNode && childNode.data) {
	            data = mergeClassData(childNode.data, data);
	        }
	    }
	    // @ts-expect-error parentNode.parent not VNodeWithData
	    while (isDef((parentNode = parentNode.parent))) {
	        if (parentNode && parentNode.data) {
	            data = mergeClassData(data, parentNode.data);
	        }
	    }
	    return renderClass(data.staticClass, data.class);
	}
	function mergeClassData(child, parent) {
	    return {
	        staticClass: concat(child.staticClass, parent.staticClass),
	        class: isDef(child.class) ? [child.class, parent.class] : parent.class
	    };
	}
	function renderClass(staticClass, dynamicClass) {
	    if (isDef(staticClass) || isDef(dynamicClass)) {
	        return concat(staticClass, stringifyClass(dynamicClass));
	    }
	    /* istanbul ignore next */
	    return '';
	}
	function concat(a, b) {
	    return a ? (b ? a + ' ' + b : a) : b || '';
	}
	function stringifyClass(value) {
	    if (Array.isArray(value)) {
	        return stringifyArray(value);
	    }
	    if (isObject(value)) {
	        return stringifyObject(value);
	    }
	    if (typeof value === 'string') {
	        return value;
	    }
	    /* istanbul ignore next */
	    return '';
	}
	function stringifyArray(value) {
	    var res = '';
	    var stringified;
	    for (var i = 0, l = value.length; i < l; i++) {
	        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
	            if (res)
	                res += ' ';
	            res += stringified;
	        }
	    }
	    return res;
	}
	function stringifyObject(value) {
	    var res = '';
	    for (var key in value) {
	        if (value[key]) {
	            if (res)
	                res += ' ';
	            res += key;
	        }
	    }
	    return res;
	}

	var namespaceMap = {
	    svg: 'http://www.w3.org/2000/svg',
	    math: 'http://www.w3.org/1998/Math/MathML'
	};
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
	    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
	    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
	    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
	    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
	    'embed,object,param,source,canvas,script,noscript,del,ins,' +
	    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
	    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
	    'output,progress,select,textarea,' +
	    'details,dialog,menu,menuitem,summary,' +
	    'content,element,shadow,template,blockquote,iframe,tfoot');
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
	    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
	    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	var isReservedTag = function (tag) {
	    return isHTMLTag(tag) || isSVG(tag);
	};
	function getTagNamespace(tag) {
	    if (isSVG(tag)) {
	        return 'svg';
	    }
	    // basic support for MathML
	    // note it doesn't support other MathML elements being component roots
	    if (tag === 'math') {
	        return 'math';
	    }
	}
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	    /* istanbul ignore if */
	    if (!inBrowser) {
	        return true;
	    }
	    if (isReservedTag(tag)) {
	        return false;
	    }
	    tag = tag.toLowerCase();
	    /* istanbul ignore if */
	    if (unknownElementCache[tag] != null) {
	        return unknownElementCache[tag];
	    }
	    var el = document.createElement(tag);
	    if (tag.indexOf('-') > -1) {
	        // http://stackoverflow.com/a/28210364/1070244
	        return (unknownElementCache[tag] =
	            el.constructor === window.HTMLUnknownElement ||
	                el.constructor === window.HTMLElement);
	    }
	    else {
	        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
	    }
	}
	var isTextInputType = makeMap('text,number,password,search,email,tel,url');

	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	    if (typeof el === 'string') {
	        var selected = document.querySelector(el);
	        if (!selected) {
	            process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	            return document.createElement('div');
	        }
	        return selected;
	    }
	    else {
	        return el;
	    }
	}

	function createElement(tagName, vnode) {
	    var elm = document.createElement(tagName);
	    if (tagName !== 'select') {
	        return elm;
	    }
	    // false or null will remove the attribute but undefined will not
	    if (vnode.data &&
	        vnode.data.attrs &&
	        vnode.data.attrs.multiple !== undefined) {
	        elm.setAttribute('multiple', 'multiple');
	    }
	    return elm;
	}
	function createElementNS(namespace, tagName) {
	    return document.createElementNS(namespaceMap[namespace], tagName);
	}
	function createTextNode(text) {
	    return document.createTextNode(text);
	}
	function createComment(text) {
	    return document.createComment(text);
	}
	function insertBefore(parentNode, newNode, referenceNode) {
	    parentNode.insertBefore(newNode, referenceNode);
	}
	function removeChild(node, child) {
	    node.removeChild(child);
	}
	function appendChild(node, child) {
	    node.appendChild(child);
	}
	function parentNode(node) {
	    return node.parentNode;
	}
	function nextSibling(node) {
	    return node.nextSibling;
	}
	function tagName(node) {
	    return node.tagName;
	}
	function setTextContent(node, text) {
	    node.textContent = text;
	}
	function setStyleScope(node, scopeId) {
	    node.setAttribute(scopeId, '');
	}

	var nodeOps = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  createElement: createElement,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setStyleScope: setStyleScope
	});

	var ref = {
	    create: function (_, vnode) {
	        registerRef(vnode);
	    },
	    update: function (oldVnode, vnode) {
	        if (oldVnode.data.ref !== vnode.data.ref) {
	            registerRef(oldVnode, true);
	            registerRef(vnode);
	        }
	    },
	    destroy: function (vnode) {
	        registerRef(vnode, true);
	    }
	};
	function registerRef(vnode, isRemoval) {
	    var ref = vnode.data.ref;
	    if (!isDef(ref))
	        return;
	    var vm = vnode.context;
	    var refValue = vnode.componentInstance || vnode.elm;
	    var value = isRemoval ? null : refValue;
	    var $refsValue = isRemoval ? undefined : refValue;
	    if (isFunction(ref)) {
	        invokeWithErrorHandling(ref, vm, [value], vm, "template ref function");
	        return;
	    }
	    var isFor = vnode.data.refInFor;
	    var _isString = typeof ref === 'string' || typeof ref === 'number';
	    var _isRef = isRef(ref);
	    var refs = vm.$refs;
	    if (_isString || _isRef) {
	        if (isFor) {
	            var existing = _isString ? refs[ref] : ref.value;
	            if (isRemoval) {
	                isArray(existing) && remove$2(existing, refValue);
	            }
	            else {
	                if (!isArray(existing)) {
	                    if (_isString) {
	                        refs[ref] = [refValue];
	                        setSetupRef(vm, ref, refs[ref]);
	                    }
	                    else {
	                        ref.value = [refValue];
	                    }
	                }
	                else if (!existing.includes(refValue)) {
	                    existing.push(refValue);
	                }
	            }
	        }
	        else if (_isString) {
	            if (isRemoval && refs[ref] !== refValue) {
	                return;
	            }
	            refs[ref] = $refsValue;
	            setSetupRef(vm, ref, value);
	        }
	        else if (_isRef) {
	            if (isRemoval && ref.value !== refValue) {
	                return;
	            }
	            ref.value = value;
	        }
	        else if (process.env.NODE_ENV !== 'production') {
	            warn("Invalid template ref type: ".concat(typeof ref));
	        }
	    }
	}
	function setSetupRef(_a, key, val) {
	    var _setupState = _a._setupState;
	    if (_setupState && hasOwn(_setupState, key)) {
	        if (isRef(_setupState[key])) {
	            _setupState[key].value = val;
	        }
	        else {
	            _setupState[key] = val;
	        }
	    }
	}

	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	var emptyNode = new VNode('', {}, []);
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	function sameVnode(a, b) {
	    return (a.key === b.key &&
	        a.asyncFactory === b.asyncFactory &&
	        ((a.tag === b.tag &&
	            a.isComment === b.isComment &&
	            isDef(a.data) === isDef(b.data) &&
	            sameInputType(a, b)) ||
	            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
	}
	function sameInputType(a, b) {
	    if (a.tag !== 'input')
	        return true;
	    var i;
	    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
	    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
	    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
	}
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	    var i, key;
	    var map = {};
	    for (i = beginIdx; i <= endIdx; ++i) {
	        key = children[i].key;
	        if (isDef(key))
	            map[key] = i;
	    }
	    return map;
	}
	function createPatchFunction(backend) {
	    var i, j;
	    var cbs = {};
	    var modules = backend.modules, nodeOps = backend.nodeOps;
	    for (i = 0; i < hooks.length; ++i) {
	        cbs[hooks[i]] = [];
	        for (j = 0; j < modules.length; ++j) {
	            if (isDef(modules[j][hooks[i]])) {
	                cbs[hooks[i]].push(modules[j][hooks[i]]);
	            }
	        }
	    }
	    function emptyNodeAt(elm) {
	        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	    }
	    function createRmCb(childElm, listeners) {
	        function remove() {
	            if (--remove.listeners === 0) {
	                removeNode(childElm);
	            }
	        }
	        remove.listeners = listeners;
	        return remove;
	    }
	    function removeNode(el) {
	        var parent = nodeOps.parentNode(el);
	        // element may have already been removed due to v-html / v-text
	        if (isDef(parent)) {
	            nodeOps.removeChild(parent, el);
	        }
	    }
	    function isUnknownElement(vnode, inVPre) {
	        return (!inVPre &&
	            !vnode.ns &&
	            !(config.ignoredElements.length &&
	                config.ignoredElements.some(function (ignore) {
	                    return isRegExp(ignore)
	                        ? ignore.test(vnode.tag)
	                        : ignore === vnode.tag;
	                })) &&
	            config.isUnknownElement(vnode.tag));
	    }
	    var creatingElmInVPre = 0;
	    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
	        if (isDef(vnode.elm) && isDef(ownerArray)) {
	            // This vnode was used in a previous render!
	            // now it's used as a new node, overwriting its elm would cause
	            // potential patch errors down the road when it's used as an insertion
	            // reference node. Instead, we clone the node on-demand before creating
	            // associated DOM element for it.
	            vnode = ownerArray[index] = cloneVNode(vnode);
	        }
	        vnode.isRootInsert = !nested; // for transition enter check
	        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	            return;
	        }
	        var data = vnode.data;
	        var children = vnode.children;
	        var tag = vnode.tag;
	        if (isDef(tag)) {
	            if (process.env.NODE_ENV !== 'production') {
	                if (data && data.pre) {
	                    creatingElmInVPre++;
	                }
	                if (isUnknownElement(vnode, creatingElmInVPre)) {
	                    warn('Unknown custom element: <' +
	                        tag +
	                        '> - did you ' +
	                        'register the component correctly? For recursive components, ' +
	                        'make sure to provide the "name" option.', vnode.context);
	                }
	            }
	            vnode.elm = vnode.ns
	                ? nodeOps.createElementNS(vnode.ns, tag)
	                : nodeOps.createElement(tag, vnode);
	            setScope(vnode);
	            createChildren(vnode, children, insertedVnodeQueue);
	            if (isDef(data)) {
	                invokeCreateHooks(vnode, insertedVnodeQueue);
	            }
	            insert(parentElm, vnode.elm, refElm);
	            if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	                creatingElmInVPre--;
	            }
	        }
	        else if (isTrue(vnode.isComment)) {
	            vnode.elm = nodeOps.createComment(vnode.text);
	            insert(parentElm, vnode.elm, refElm);
	        }
	        else {
	            vnode.elm = nodeOps.createTextNode(vnode.text);
	            insert(parentElm, vnode.elm, refElm);
	        }
	    }
	    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	        var i = vnode.data;
	        if (isDef(i)) {
	            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	            if (isDef((i = i.hook)) && isDef((i = i.init))) {
	                i(vnode, false /* hydrating */);
	            }
	            // after calling the init hook, if the vnode is a child component
	            // it should've created a child instance and mounted it. the child
	            // component also has set the placeholder vnode's elm.
	            // in that case we can just return the element and be done.
	            if (isDef(vnode.componentInstance)) {
	                initComponent(vnode, insertedVnodeQueue);
	                insert(parentElm, vnode.elm, refElm);
	                if (isTrue(isReactivated)) {
	                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	                }
	                return true;
	            }
	        }
	    }
	    function initComponent(vnode, insertedVnodeQueue) {
	        if (isDef(vnode.data.pendingInsert)) {
	            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	            vnode.data.pendingInsert = null;
	        }
	        vnode.elm = vnode.componentInstance.$el;
	        if (isPatchable(vnode)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            setScope(vnode);
	        }
	        else {
	            // empty component root.
	            // skip all element-related modules except for ref (#3455)
	            registerRef(vnode);
	            // make sure to invoke the insert hook
	            insertedVnodeQueue.push(vnode);
	        }
	    }
	    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	        var i;
	        // hack for #4339: a reactivated component with inner transition
	        // does not trigger because the inner node's created hooks are not called
	        // again. It's not ideal to involve module-specific logic in here but
	        // there doesn't seem to be a better way to do it.
	        var innerNode = vnode;
	        while (innerNode.componentInstance) {
	            innerNode = innerNode.componentInstance._vnode;
	            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
	                for (i = 0; i < cbs.activate.length; ++i) {
	                    cbs.activate[i](emptyNode, innerNode);
	                }
	                insertedVnodeQueue.push(innerNode);
	                break;
	            }
	        }
	        // unlike a newly created component,
	        // a reactivated keep-alive component doesn't insert itself
	        insert(parentElm, vnode.elm, refElm);
	    }
	    function insert(parent, elm, ref) {
	        if (isDef(parent)) {
	            if (isDef(ref)) {
	                if (nodeOps.parentNode(ref) === parent) {
	                    nodeOps.insertBefore(parent, elm, ref);
	                }
	            }
	            else {
	                nodeOps.appendChild(parent, elm);
	            }
	        }
	    }
	    function createChildren(vnode, children, insertedVnodeQueue) {
	        if (isArray(children)) {
	            if (process.env.NODE_ENV !== 'production') {
	                checkDuplicateKeys(children);
	            }
	            for (var i_1 = 0; i_1 < children.length; ++i_1) {
	                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
	            }
	        }
	        else if (isPrimitive(vnode.text)) {
	            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
	        }
	    }
	    function isPatchable(vnode) {
	        while (vnode.componentInstance) {
	            vnode = vnode.componentInstance._vnode;
	        }
	        return isDef(vnode.tag);
	    }
	    function invokeCreateHooks(vnode, insertedVnodeQueue) {
	        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
	            cbs.create[i_2](emptyNode, vnode);
	        }
	        i = vnode.data.hook; // Reuse variable
	        if (isDef(i)) {
	            if (isDef(i.create))
	                i.create(emptyNode, vnode);
	            if (isDef(i.insert))
	                insertedVnodeQueue.push(vnode);
	        }
	    }
	    // set scope id attribute for scoped CSS.
	    // this is implemented as a special case to avoid the overhead
	    // of going through the normal attribute patching process.
	    function setScope(vnode) {
	        var i;
	        if (isDef((i = vnode.fnScopeId))) {
	            nodeOps.setStyleScope(vnode.elm, i);
	        }
	        else {
	            var ancestor = vnode;
	            while (ancestor) {
	                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
	                    nodeOps.setStyleScope(vnode.elm, i);
	                }
	                ancestor = ancestor.parent;
	            }
	        }
	        // for slot content they should also get the scopeId from the host instance.
	        if (isDef((i = activeInstance)) &&
	            i !== vnode.context &&
	            i !== vnode.fnContext &&
	            isDef((i = i.$options._scopeId))) {
	            nodeOps.setStyleScope(vnode.elm, i);
	        }
	    }
	    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	        for (; startIdx <= endIdx; ++startIdx) {
	            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
	        }
	    }
	    function invokeDestroyHook(vnode) {
	        var i, j;
	        var data = vnode.data;
	        if (isDef(data)) {
	            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
	                i(vnode);
	            for (i = 0; i < cbs.destroy.length; ++i)
	                cbs.destroy[i](vnode);
	        }
	        if (isDef((i = vnode.children))) {
	            for (j = 0; j < vnode.children.length; ++j) {
	                invokeDestroyHook(vnode.children[j]);
	            }
	        }
	    }
	    function removeVnodes(vnodes, startIdx, endIdx) {
	        for (; startIdx <= endIdx; ++startIdx) {
	            var ch = vnodes[startIdx];
	            if (isDef(ch)) {
	                if (isDef(ch.tag)) {
	                    removeAndInvokeRemoveHook(ch);
	                    invokeDestroyHook(ch);
	                }
	                else {
	                    // Text node
	                    removeNode(ch.elm);
	                }
	            }
	        }
	    }
	    function removeAndInvokeRemoveHook(vnode, rm) {
	        if (isDef(rm) || isDef(vnode.data)) {
	            var i_3;
	            var listeners = cbs.remove.length + 1;
	            if (isDef(rm)) {
	                // we have a recursively passed down rm callback
	                // increase the listeners count
	                rm.listeners += listeners;
	            }
	            else {
	                // directly removing
	                rm = createRmCb(vnode.elm, listeners);
	            }
	            // recursively invoke hooks on child component root node
	            if (isDef((i_3 = vnode.componentInstance)) &&
	                isDef((i_3 = i_3._vnode)) &&
	                isDef(i_3.data)) {
	                removeAndInvokeRemoveHook(i_3, rm);
	            }
	            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
	                cbs.remove[i_3](vnode, rm);
	            }
	            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
	                i_3(vnode, rm);
	            }
	            else {
	                rm();
	            }
	        }
	        else {
	            removeNode(vnode.elm);
	        }
	    }
	    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	        var oldStartIdx = 0;
	        var newStartIdx = 0;
	        var oldEndIdx = oldCh.length - 1;
	        var oldStartVnode = oldCh[0];
	        var oldEndVnode = oldCh[oldEndIdx];
	        var newEndIdx = newCh.length - 1;
	        var newStartVnode = newCh[0];
	        var newEndVnode = newCh[newEndIdx];
	        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
	        // removeOnly is a special flag used only by <transition-group>
	        // to ensure removed elements stay in correct relative positions
	        // during leaving transitions
	        var canMove = !removeOnly;
	        if (process.env.NODE_ENV !== 'production') {
	            checkDuplicateKeys(newCh);
	        }
	        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	            if (isUndef(oldStartVnode)) {
	                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	            }
	            else if (isUndef(oldEndVnode)) {
	                oldEndVnode = oldCh[--oldEndIdx];
	            }
	            else if (sameVnode(oldStartVnode, newStartVnode)) {
	                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
	                oldStartVnode = oldCh[++oldStartIdx];
	                newStartVnode = newCh[++newStartIdx];
	            }
	            else if (sameVnode(oldEndVnode, newEndVnode)) {
	                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
	                oldEndVnode = oldCh[--oldEndIdx];
	                newEndVnode = newCh[--newEndIdx];
	            }
	            else if (sameVnode(oldStartVnode, newEndVnode)) {
	                // Vnode moved right
	                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
	                canMove &&
	                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	                oldStartVnode = oldCh[++oldStartIdx];
	                newEndVnode = newCh[--newEndIdx];
	            }
	            else if (sameVnode(oldEndVnode, newStartVnode)) {
	                // Vnode moved left
	                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
	                canMove &&
	                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	                oldEndVnode = oldCh[--oldEndIdx];
	                newStartVnode = newCh[++newStartIdx];
	            }
	            else {
	                if (isUndef(oldKeyToIdx))
	                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	                idxInOld = isDef(newStartVnode.key)
	                    ? oldKeyToIdx[newStartVnode.key]
	                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
	                if (isUndef(idxInOld)) {
	                    // New element
	                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
	                }
	                else {
	                    vnodeToMove = oldCh[idxInOld];
	                    if (sameVnode(vnodeToMove, newStartVnode)) {
	                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
	                        oldCh[idxInOld] = undefined;
	                        canMove &&
	                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
	                    }
	                    else {
	                        // same key but different element. treat as new element
	                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
	                    }
	                }
	                newStartVnode = newCh[++newStartIdx];
	            }
	        }
	        if (oldStartIdx > oldEndIdx) {
	            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	        }
	        else if (newStartIdx > newEndIdx) {
	            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
	        }
	    }
	    function checkDuplicateKeys(children) {
	        var seenKeys = {};
	        for (var i_4 = 0; i_4 < children.length; i_4++) {
	            var vnode = children[i_4];
	            var key = vnode.key;
	            if (isDef(key)) {
	                if (seenKeys[key]) {
	                    warn("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
	                }
	                else {
	                    seenKeys[key] = true;
	                }
	            }
	        }
	    }
	    function findIdxInOld(node, oldCh, start, end) {
	        for (var i_5 = start; i_5 < end; i_5++) {
	            var c = oldCh[i_5];
	            if (isDef(c) && sameVnode(node, c))
	                return i_5;
	        }
	    }
	    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
	        if (oldVnode === vnode) {
	            return;
	        }
	        if (isDef(vnode.elm) && isDef(ownerArray)) {
	            // clone reused vnode
	            vnode = ownerArray[index] = cloneVNode(vnode);
	        }
	        var elm = (vnode.elm = oldVnode.elm);
	        if (isTrue(oldVnode.isAsyncPlaceholder)) {
	            if (isDef(vnode.asyncFactory.resolved)) {
	                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
	            }
	            else {
	                vnode.isAsyncPlaceholder = true;
	            }
	            return;
	        }
	        // reuse element for static trees.
	        // note we only do this if the vnode is cloned -
	        // if the new node is not cloned it means the render functions have been
	        // reset by the hot-reload-api and we need to do a proper re-render.
	        if (isTrue(vnode.isStatic) &&
	            isTrue(oldVnode.isStatic) &&
	            vnode.key === oldVnode.key &&
	            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	            vnode.componentInstance = oldVnode.componentInstance;
	            return;
	        }
	        var i;
	        var data = vnode.data;
	        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
	            i(oldVnode, vnode);
	        }
	        var oldCh = oldVnode.children;
	        var ch = vnode.children;
	        if (isDef(data) && isPatchable(vnode)) {
	            for (i = 0; i < cbs.update.length; ++i)
	                cbs.update[i](oldVnode, vnode);
	            if (isDef((i = data.hook)) && isDef((i = i.update)))
	                i(oldVnode, vnode);
	        }
	        if (isUndef(vnode.text)) {
	            if (isDef(oldCh) && isDef(ch)) {
	                if (oldCh !== ch)
	                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	            }
	            else if (isDef(ch)) {
	                if (process.env.NODE_ENV !== 'production') {
	                    checkDuplicateKeys(ch);
	                }
	                if (isDef(oldVnode.text))
	                    nodeOps.setTextContent(elm, '');
	                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	            }
	            else if (isDef(oldCh)) {
	                removeVnodes(oldCh, 0, oldCh.length - 1);
	            }
	            else if (isDef(oldVnode.text)) {
	                nodeOps.setTextContent(elm, '');
	            }
	        }
	        else if (oldVnode.text !== vnode.text) {
	            nodeOps.setTextContent(elm, vnode.text);
	        }
	        if (isDef(data)) {
	            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
	                i(oldVnode, vnode);
	        }
	    }
	    function invokeInsertHook(vnode, queue, initial) {
	        // delay insert hooks for component root nodes, invoke them after the
	        // element is really inserted
	        if (isTrue(initial) && isDef(vnode.parent)) {
	            vnode.parent.data.pendingInsert = queue;
	        }
	        else {
	            for (var i_6 = 0; i_6 < queue.length; ++i_6) {
	                queue[i_6].data.hook.insert(queue[i_6]);
	            }
	        }
	    }
	    var hydrationBailed = false;
	    // list of modules that can skip create hook during hydration because they
	    // are already rendered on the client or has no need for initialization
	    // Note: style is excluded because it relies on initial clone for future
	    // deep updates (#7063).
	    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
	    // Note: this is a browser-only function so we can assume elms are DOM nodes.
	    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
	        var i;
	        var tag = vnode.tag, data = vnode.data, children = vnode.children;
	        inVPre = inVPre || (data && data.pre);
	        vnode.elm = elm;
	        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
	            vnode.isAsyncPlaceholder = true;
	            return true;
	        }
	        // assert node match
	        if (process.env.NODE_ENV !== 'production') {
	            if (!assertNodeMatch(elm, vnode, inVPre)) {
	                return false;
	            }
	        }
	        if (isDef(data)) {
	            if (isDef((i = data.hook)) && isDef((i = i.init)))
	                i(vnode, true /* hydrating */);
	            if (isDef((i = vnode.componentInstance))) {
	                // child component. it should have hydrated its own tree.
	                initComponent(vnode, insertedVnodeQueue);
	                return true;
	            }
	        }
	        if (isDef(tag)) {
	            if (isDef(children)) {
	                // empty element, allow client to pick up and populate children
	                if (!elm.hasChildNodes()) {
	                    createChildren(vnode, children, insertedVnodeQueue);
	                }
	                else {
	                    // v-html and domProps: innerHTML
	                    if (isDef((i = data)) &&
	                        isDef((i = i.domProps)) &&
	                        isDef((i = i.innerHTML))) {
	                        if (i !== elm.innerHTML) {
	                            /* istanbul ignore if */
	                            if (process.env.NODE_ENV !== 'production' &&
	                                typeof console !== 'undefined' &&
	                                !hydrationBailed) {
	                                hydrationBailed = true;
	                                console.warn('Parent: ', elm);
	                                console.warn('server innerHTML: ', i);
	                                console.warn('client innerHTML: ', elm.innerHTML);
	                            }
	                            return false;
	                        }
	                    }
	                    else {
	                        // iterate and compare children lists
	                        var childrenMatch = true;
	                        var childNode = elm.firstChild;
	                        for (var i_7 = 0; i_7 < children.length; i_7++) {
	                            if (!childNode ||
	                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
	                                childrenMatch = false;
	                                break;
	                            }
	                            childNode = childNode.nextSibling;
	                        }
	                        // if childNode is not null, it means the actual childNodes list is
	                        // longer than the virtual children list.
	                        if (!childrenMatch || childNode) {
	                            /* istanbul ignore if */
	                            if (process.env.NODE_ENV !== 'production' &&
	                                typeof console !== 'undefined' &&
	                                !hydrationBailed) {
	                                hydrationBailed = true;
	                                console.warn('Parent: ', elm);
	                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	                            }
	                            return false;
	                        }
	                    }
	                }
	            }
	            if (isDef(data)) {
	                var fullInvoke = false;
	                for (var key in data) {
	                    if (!isRenderedModule(key)) {
	                        fullInvoke = true;
	                        invokeCreateHooks(vnode, insertedVnodeQueue);
	                        break;
	                    }
	                }
	                if (!fullInvoke && data['class']) {
	                    // ensure collecting deps for deep class bindings for future updates
	                    traverse(data['class']);
	                }
	            }
	        }
	        else if (elm.data !== vnode.text) {
	            elm.data = vnode.text;
	        }
	        return true;
	    }
	    function assertNodeMatch(node, vnode, inVPre) {
	        if (isDef(vnode.tag)) {
	            return (vnode.tag.indexOf('vue-component') === 0 ||
	                (!isUnknownElement(vnode, inVPre) &&
	                    vnode.tag.toLowerCase() ===
	                        (node.tagName && node.tagName.toLowerCase())));
	        }
	        else {
	            return node.nodeType === (vnode.isComment ? 8 : 3);
	        }
	    }
	    return function patch(oldVnode, vnode, hydrating, removeOnly) {
	        if (isUndef(vnode)) {
	            if (isDef(oldVnode))
	                invokeDestroyHook(oldVnode);
	            return;
	        }
	        var isInitialPatch = false;
	        var insertedVnodeQueue = [];
	        if (isUndef(oldVnode)) {
	            // empty mount (likely as component), create new root element
	            isInitialPatch = true;
	            createElm(vnode, insertedVnodeQueue);
	        }
	        else {
	            var isRealElement = isDef(oldVnode.nodeType);
	            if (!isRealElement && sameVnode(oldVnode, vnode)) {
	                // patch existing root node
	                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
	            }
	            else {
	                if (isRealElement) {
	                    // mounting to a real element
	                    // check if this is server-rendered content and if we can perform
	                    // a successful hydration.
	                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	                        oldVnode.removeAttribute(SSR_ATTR);
	                        hydrating = true;
	                    }
	                    if (isTrue(hydrating)) {
	                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	                            invokeInsertHook(vnode, insertedVnodeQueue, true);
	                            return oldVnode;
	                        }
	                        else if (process.env.NODE_ENV !== 'production') {
	                            warn('The client-side rendered virtual DOM tree is not matching ' +
	                                'server-rendered content. This is likely caused by incorrect ' +
	                                'HTML markup, for example nesting block-level elements inside ' +
	                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
	                                'full client-side render.');
	                        }
	                    }
	                    // either not server-rendered, or hydration failed.
	                    // create an empty node and replace it
	                    oldVnode = emptyNodeAt(oldVnode);
	                }
	                // replacing existing element
	                var oldElm = oldVnode.elm;
	                var parentElm = nodeOps.parentNode(oldElm);
	                // create new node
	                createElm(vnode, insertedVnodeQueue, 
	                // extremely rare edge case: do not insert if old element is in a
	                // leaving transition. Only happens when combining transition +
	                // keep-alive + HOCs. (#4590)
	                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
	                // update parent placeholder node element, recursively
	                if (isDef(vnode.parent)) {
	                    var ancestor = vnode.parent;
	                    var patchable = isPatchable(vnode);
	                    while (ancestor) {
	                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
	                            cbs.destroy[i_8](ancestor);
	                        }
	                        ancestor.elm = vnode.elm;
	                        if (patchable) {
	                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
	                                cbs.create[i_9](emptyNode, ancestor);
	                            }
	                            // #6513
	                            // invoke insert hooks that may have been merged by create hooks.
	                            // e.g. for directives that uses the "inserted" hook.
	                            var insert_1 = ancestor.data.hook.insert;
	                            if (insert_1.merged) {
	                                // start at index 1 to avoid re-invoking component mounted hook
	                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
	                                    insert_1.fns[i_10]();
	                                }
	                            }
	                        }
	                        else {
	                            registerRef(ancestor);
	                        }
	                        ancestor = ancestor.parent;
	                    }
	                }
	                // destroy old node
	                if (isDef(parentElm)) {
	                    removeVnodes([oldVnode], 0, 0);
	                }
	                else if (isDef(oldVnode.tag)) {
	                    invokeDestroyHook(oldVnode);
	                }
	            }
	        }
	        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	        return vnode.elm;
	    };
	}

	var directives = {
	    create: updateDirectives,
	    update: updateDirectives,
	    destroy: function unbindDirectives(vnode) {
	        // @ts-expect-error emptyNode is not VNodeWithData
	        updateDirectives(vnode, emptyNode);
	    }
	};
	function updateDirectives(oldVnode, vnode) {
	    if (oldVnode.data.directives || vnode.data.directives) {
	        _update(oldVnode, vnode);
	    }
	}
	function _update(oldVnode, vnode) {
	    var isCreate = oldVnode === emptyNode;
	    var isDestroy = vnode === emptyNode;
	    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
	    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
	    var dirsWithInsert = [];
	    var dirsWithPostpatch = [];
	    var key, oldDir, dir;
	    for (key in newDirs) {
	        oldDir = oldDirs[key];
	        dir = newDirs[key];
	        if (!oldDir) {
	            // new directive, bind
	            callHook(dir, 'bind', vnode, oldVnode);
	            if (dir.def && dir.def.inserted) {
	                dirsWithInsert.push(dir);
	            }
	        }
	        else {
	            // existing directive, update
	            dir.oldValue = oldDir.value;
	            dir.oldArg = oldDir.arg;
	            callHook(dir, 'update', vnode, oldVnode);
	            if (dir.def && dir.def.componentUpdated) {
	                dirsWithPostpatch.push(dir);
	            }
	        }
	    }
	    if (dirsWithInsert.length) {
	        var callInsert = function () {
	            for (var i = 0; i < dirsWithInsert.length; i++) {
	                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	            }
	        };
	        if (isCreate) {
	            mergeVNodeHook(vnode, 'insert', callInsert);
	        }
	        else {
	            callInsert();
	        }
	    }
	    if (dirsWithPostpatch.length) {
	        mergeVNodeHook(vnode, 'postpatch', function () {
	            for (var i = 0; i < dirsWithPostpatch.length; i++) {
	                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	            }
	        });
	    }
	    if (!isCreate) {
	        for (key in oldDirs) {
	            if (!newDirs[key]) {
	                // no longer present, unbind
	                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	            }
	        }
	    }
	}
	var emptyModifiers = Object.create(null);
	function normalizeDirectives(dirs, vm) {
	    var res = Object.create(null);
	    if (!dirs) {
	        // $flow-disable-line
	        return res;
	    }
	    var i, dir;
	    for (i = 0; i < dirs.length; i++) {
	        dir = dirs[i];
	        if (!dir.modifiers) {
	            // $flow-disable-line
	            dir.modifiers = emptyModifiers;
	        }
	        res[getRawDirName(dir)] = dir;
	        if (vm._setupState && vm._setupState.__sfc) {
	            dir.def = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
	        }
	        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
	    }
	    // $flow-disable-line
	    return res;
	}
	function getRawDirName(dir) {
	    return (dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join('.')));
	}
	function callHook(dir, hook, vnode, oldVnode, isDestroy) {
	    var fn = dir.def && dir.def[hook];
	    if (fn) {
	        try {
	            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	        }
	        catch (e) {
	            handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
	        }
	    }
	}

	var baseModules = [ref, directives];

	function updateAttrs(oldVnode, vnode) {
	    var opts = vnode.componentOptions;
	    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
	        return;
	    }
	    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	        return;
	    }
	    var key, cur, old;
	    var elm = vnode.elm;
	    var oldAttrs = oldVnode.data.attrs || {};
	    var attrs = vnode.data.attrs || {};
	    // clone observed objects, as the user probably wants to mutate it
	    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
	        attrs = vnode.data.attrs = extend({}, attrs);
	    }
	    for (key in attrs) {
	        cur = attrs[key];
	        old = oldAttrs[key];
	        if (old !== cur) {
	            setAttr(elm, key, cur, vnode.data.pre);
	        }
	    }
	    // #4391: in IE9, setting type can reset value for input[type=radio]
	    // #6666: IE/Edge forces progress value down to 1 before setting a max
	    /* istanbul ignore if */
	    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
	        setAttr(elm, 'value', attrs.value);
	    }
	    for (key in oldAttrs) {
	        if (isUndef(attrs[key])) {
	            if (isXlink(key)) {
	                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	            }
	            else if (!isEnumeratedAttr(key)) {
	                elm.removeAttribute(key);
	            }
	        }
	    }
	}
	function setAttr(el, key, value, isInPre) {
	    if (isInPre || el.tagName.indexOf('-') > -1) {
	        baseSetAttr(el, key, value);
	    }
	    else if (isBooleanAttr(key)) {
	        // set attribute for blank value
	        // e.g. <option disabled>Select one</option>
	        if (isFalsyAttrValue(value)) {
	            el.removeAttribute(key);
	        }
	        else {
	            // technically allowfullscreen is a boolean attribute for <iframe>,
	            // but Flash expects a value of "true" when used on <embed> tag
	            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
	            el.setAttribute(key, value);
	        }
	    }
	    else if (isEnumeratedAttr(key)) {
	        el.setAttribute(key, convertEnumeratedValue(key, value));
	    }
	    else if (isXlink(key)) {
	        if (isFalsyAttrValue(value)) {
	            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	        }
	        else {
	            el.setAttributeNS(xlinkNS, key, value);
	        }
	    }
	    else {
	        baseSetAttr(el, key, value);
	    }
	}
	function baseSetAttr(el, key, value) {
	    if (isFalsyAttrValue(value)) {
	        el.removeAttribute(key);
	    }
	    else {
	        // #7138: IE10 & 11 fires input event when setting placeholder on
	        // <textarea>... block the first input event and remove the blocker
	        // immediately.
	        /* istanbul ignore if */
	        if (isIE &&
	            !isIE9 &&
	            el.tagName === 'TEXTAREA' &&
	            key === 'placeholder' &&
	            value !== '' &&
	            !el.__ieph) {
	            var blocker_1 = function (e) {
	                e.stopImmediatePropagation();
	                el.removeEventListener('input', blocker_1);
	            };
	            el.addEventListener('input', blocker_1);
	            // $flow-disable-line
	            el.__ieph = true; /* IE placeholder patched */
	        }
	        el.setAttribute(key, value);
	    }
	}
	var attrs = {
	    create: updateAttrs,
	    update: updateAttrs
	};

	function updateClass(oldVnode, vnode) {
	    var el = vnode.elm;
	    var data = vnode.data;
	    var oldData = oldVnode.data;
	    if (isUndef(data.staticClass) &&
	        isUndef(data.class) &&
	        (isUndef(oldData) ||
	            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
	        return;
	    }
	    var cls = genClassForVnode(vnode);
	    // handle transition classes
	    var transitionClass = el._transitionClasses;
	    if (isDef(transitionClass)) {
	        cls = concat(cls, stringifyClass(transitionClass));
	    }
	    // set the class
	    if (cls !== el._prevClass) {
	        el.setAttribute('class', cls);
	        el._prevClass = cls;
	    }
	}
	var klass = {
	    create: updateClass,
	    update: updateClass
	};

	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';

	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	    /* istanbul ignore if */
	    if (isDef(on[RANGE_TOKEN])) {
	        // IE input[type=range] only supports `change` event
	        var event_1 = isIE ? 'change' : 'input';
	        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
	        delete on[RANGE_TOKEN];
	    }
	    // This was originally intended to fix #4521 but no longer necessary
	    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
	    /* istanbul ignore if */
	    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
	        delete on[CHECKBOX_RADIO_TOKEN];
	    }
	}
	var target;
	function createOnceHandler(event, handler, capture) {
	    var _target = target; // save current target element in closure
	    return function onceHandler() {
	        var res = handler.apply(null, arguments);
	        if (res !== null) {
	            remove(event, onceHandler, capture, _target);
	        }
	    };
	}
	// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
	// implementation and does not fire microtasks in between event propagation, so
	// safe to exclude.
	var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
	function add(name, handler, capture, passive) {
	    // async edge case #6566: inner click event triggers patch, event handler
	    // attached to outer element during patch, and triggered again. This
	    // happens because browsers fire microtask ticks between event propagation.
	    // the solution is simple: we save the timestamp when a handler is attached,
	    // and the handler would only fire if the event passed to it was fired
	    // AFTER it was attached.
	    if (useMicrotaskFix) {
	        var attachedTimestamp_1 = currentFlushTimestamp;
	        var original_1 = handler;
	        //@ts-expect-error
	        handler = original_1._wrapper = function (e) {
	            if (
	            // no bubbling, should always fire.
	            // this is just a safety net in case event.timeStamp is unreliable in
	            // certain weird environments...
	            e.target === e.currentTarget ||
	                // event is fired after handler attachment
	                e.timeStamp >= attachedTimestamp_1 ||
	                // bail for environments that have buggy event.timeStamp implementations
	                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
	                // #9681 QtWebEngine event.timeStamp is negative value
	                e.timeStamp <= 0 ||
	                // #9448 bail if event is fired in another document in a multi-page
	                // electron/nw.js app, since event.timeStamp will be using a different
	                // starting reference
	                e.target.ownerDocument !== document) {
	                return original_1.apply(this, arguments);
	            }
	        };
	    }
	    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	function remove(name, handler, capture, _target) {
	    (_target || target).removeEventListener(name, 
	    //@ts-expect-error
	    handler._wrapper || handler, capture);
	}
	function updateDOMListeners(oldVnode, vnode) {
	    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	        return;
	    }
	    var on = vnode.data.on || {};
	    var oldOn = oldVnode.data.on || {};
	    // vnode is empty when removing all listeners,
	    // and use old vnode dom element
	    target = vnode.elm || oldVnode.elm;
	    normalizeEvents(on);
	    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
	    target = undefined;
	}
	var events = {
	    create: updateDOMListeners,
	    update: updateDOMListeners,
	    // @ts-expect-error emptyNode has actually data
	    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }
	};

	var svgContainer;
	function updateDOMProps(oldVnode, vnode) {
	    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	        return;
	    }
	    var key, cur;
	    var elm = vnode.elm;
	    var oldProps = oldVnode.data.domProps || {};
	    var props = vnode.data.domProps || {};
	    // clone observed objects, as the user probably wants to mutate it
	    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
	        props = vnode.data.domProps = extend({}, props);
	    }
	    for (key in oldProps) {
	        if (!(key in props)) {
	            elm[key] = '';
	        }
	    }
	    for (key in props) {
	        cur = props[key];
	        // ignore children if the node has textContent or innerHTML,
	        // as these will throw away existing DOM nodes and cause removal errors
	        // on subsequent patches (#3360)
	        if (key === 'textContent' || key === 'innerHTML') {
	            if (vnode.children)
	                vnode.children.length = 0;
	            if (cur === oldProps[key])
	                continue;
	            // #6601 work around Chrome version <= 55 bug where single textNode
	            // replaced by innerHTML/textContent retains its parentNode property
	            if (elm.childNodes.length === 1) {
	                elm.removeChild(elm.childNodes[0]);
	            }
	        }
	        if (key === 'value' && elm.tagName !== 'PROGRESS') {
	            // store value as _value as well since
	            // non-string values will be stringified
	            elm._value = cur;
	            // avoid resetting cursor position when value is the same
	            var strCur = isUndef(cur) ? '' : String(cur);
	            if (shouldUpdateValue(elm, strCur)) {
	                elm.value = strCur;
	            }
	        }
	        else if (key === 'innerHTML' &&
	            isSVG(elm.tagName) &&
	            isUndef(elm.innerHTML)) {
	            // IE doesn't support innerHTML for SVG elements
	            svgContainer = svgContainer || document.createElement('div');
	            svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
	            var svg = svgContainer.firstChild;
	            while (elm.firstChild) {
	                elm.removeChild(elm.firstChild);
	            }
	            while (svg.firstChild) {
	                elm.appendChild(svg.firstChild);
	            }
	        }
	        else if (
	        // skip the update if old and new VDOM state is the same.
	        // `value` is handled separately because the DOM value may be temporarily
	        // out of sync with VDOM state due to focus, composition and modifiers.
	        // This  #4521 by skipping the unnecessary `checked` update.
	        cur !== oldProps[key]) {
	            // some property updates can throw
	            // e.g. `value` on <progress> w/ non-finite value
	            try {
	                elm[key] = cur;
	            }
	            catch (e) { }
	        }
	    }
	}
	function shouldUpdateValue(elm, checkVal) {
	    return (
	    //@ts-expect-error
	    !elm.composing &&
	        (elm.tagName === 'OPTION' ||
	            isNotInFocusAndDirty(elm, checkVal) ||
	            isDirtyWithModifiers(elm, checkVal)));
	}
	function isNotInFocusAndDirty(elm, checkVal) {
	    // return true when textbox (.number and .trim) loses focus and its value is
	    // not equal to the updated value
	    var notInFocus = true;
	    // #6157
	    // work around IE bug when accessing document.activeElement in an iframe
	    try {
	        notInFocus = document.activeElement !== elm;
	    }
	    catch (e) { }
	    return notInFocus && elm.value !== checkVal;
	}
	function isDirtyWithModifiers(elm, newVal) {
	    var value = elm.value;
	    var modifiers = elm._vModifiers; // injected by v-model runtime
	    if (isDef(modifiers)) {
	        if (modifiers.number) {
	            return toNumber(value) !== toNumber(newVal);
	        }
	        if (modifiers.trim) {
	            return value.trim() !== newVal.trim();
	        }
	    }
	    return value !== newVal;
	}
	var domProps = {
	    create: updateDOMProps,
	    update: updateDOMProps
	};

	var parseStyleText = cached(function (cssText) {
	    var res = {};
	    var listDelimiter = /;(?![^(]*\))/g;
	    var propertyDelimiter = /:(.+)/;
	    cssText.split(listDelimiter).forEach(function (item) {
	        if (item) {
	            var tmp = item.split(propertyDelimiter);
	            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	        }
	    });
	    return res;
	});
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	    var style = normalizeStyleBinding(data.style);
	    // static style is pre-processed into an object during compilation
	    // and is always a fresh object, so it's safe to merge into it
	    return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	    if (Array.isArray(bindingStyle)) {
	        return toObject(bindingStyle);
	    }
	    if (typeof bindingStyle === 'string') {
	        return parseStyleText(bindingStyle);
	    }
	    return bindingStyle;
	}
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	    var res = {};
	    var styleData;
	    if (checkChild) {
	        var childNode = vnode;
	        while (childNode.componentInstance) {
	            childNode = childNode.componentInstance._vnode;
	            if (childNode &&
	                childNode.data &&
	                (styleData = normalizeStyleData(childNode.data))) {
	                extend(res, styleData);
	            }
	        }
	    }
	    if ((styleData = normalizeStyleData(vnode.data))) {
	        extend(res, styleData);
	    }
	    var parentNode = vnode;
	    // @ts-expect-error parentNode.parent not VNodeWithData
	    while ((parentNode = parentNode.parent)) {
	        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	            extend(res, styleData);
	        }
	    }
	    return res;
	}

	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function (el, name, val) {
	    /* istanbul ignore if */
	    if (cssVarRE.test(name)) {
	        el.style.setProperty(name, val);
	    }
	    else if (importantRE.test(val)) {
	        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
	    }
	    else {
	        var normalizedName = normalize(name);
	        if (Array.isArray(val)) {
	            // Support values array created by autoprefixer, e.g.
	            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	            // Set them one by one, and the browser will only set those it can recognize
	            for (var i = 0, len = val.length; i < len; i++) {
	                el.style[normalizedName] = val[i];
	            }
	        }
	        else {
	            el.style[normalizedName] = val;
	        }
	    }
	};
	var vendorNames = ['Webkit', 'Moz', 'ms'];
	var emptyStyle;
	var normalize = cached(function (prop) {
	    emptyStyle = emptyStyle || document.createElement('div').style;
	    prop = camelize(prop);
	    if (prop !== 'filter' && prop in emptyStyle) {
	        return prop;
	    }
	    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
	    for (var i = 0; i < vendorNames.length; i++) {
	        var name_1 = vendorNames[i] + capName;
	        if (name_1 in emptyStyle) {
	            return name_1;
	        }
	    }
	});
	function updateStyle(oldVnode, vnode) {
	    var data = vnode.data;
	    var oldData = oldVnode.data;
	    if (isUndef(data.staticStyle) &&
	        isUndef(data.style) &&
	        isUndef(oldData.staticStyle) &&
	        isUndef(oldData.style)) {
	        return;
	    }
	    var cur, name;
	    var el = vnode.elm;
	    var oldStaticStyle = oldData.staticStyle;
	    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	    var oldStyle = oldStaticStyle || oldStyleBinding;
	    var style = normalizeStyleBinding(vnode.data.style) || {};
	    // store normalized style under a different key for next diff
	    // make sure to clone it if it's reactive, since the user likely wants
	    // to mutate it.
	    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	    var newStyle = getStyle(vnode, true);
	    for (name in oldStyle) {
	        if (isUndef(newStyle[name])) {
	            setProp(el, name, '');
	        }
	    }
	    for (name in newStyle) {
	        cur = newStyle[name];
	        if (cur !== oldStyle[name]) {
	            // ie9 setting to null has no effect, must use empty string
	            setProp(el, name, cur == null ? '' : cur);
	        }
	    }
	}
	var style = {
	    create: updateStyle,
	    update: updateStyle
	};

	var whitespaceRE = /\s+/;
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	    /* istanbul ignore if */
	    if (!cls || !(cls = cls.trim())) {
	        return;
	    }
	    /* istanbul ignore else */
	    if (el.classList) {
	        if (cls.indexOf(' ') > -1) {
	            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
	        }
	        else {
	            el.classList.add(cls);
	        }
	    }
	    else {
	        var cur = " ".concat(el.getAttribute('class') || '', " ");
	        if (cur.indexOf(' ' + cls + ' ') < 0) {
	            el.setAttribute('class', (cur + cls).trim());
	        }
	    }
	}
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	    /* istanbul ignore if */
	    if (!cls || !(cls = cls.trim())) {
	        return;
	    }
	    /* istanbul ignore else */
	    if (el.classList) {
	        if (cls.indexOf(' ') > -1) {
	            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
	        }
	        else {
	            el.classList.remove(cls);
	        }
	        if (!el.classList.length) {
	            el.removeAttribute('class');
	        }
	    }
	    else {
	        var cur = " ".concat(el.getAttribute('class') || '', " ");
	        var tar = ' ' + cls + ' ';
	        while (cur.indexOf(tar) >= 0) {
	            cur = cur.replace(tar, ' ');
	        }
	        cur = cur.trim();
	        if (cur) {
	            el.setAttribute('class', cur);
	        }
	        else {
	            el.removeAttribute('class');
	        }
	    }
	}

	function resolveTransition(def) {
	    if (!def) {
	        return;
	    }
	    /* istanbul ignore else */
	    if (typeof def === 'object') {
	        var res = {};
	        if (def.css !== false) {
	            extend(res, autoCssTransition(def.name || 'v'));
	        }
	        extend(res, def);
	        return res;
	    }
	    else if (typeof def === 'string') {
	        return autoCssTransition(def);
	    }
	}
	var autoCssTransition = cached(function (name) {
	    return {
	        enterClass: "".concat(name, "-enter"),
	        enterToClass: "".concat(name, "-enter-to"),
	        enterActiveClass: "".concat(name, "-enter-active"),
	        leaveClass: "".concat(name, "-leave"),
	        leaveToClass: "".concat(name, "-leave-to"),
	        leaveActiveClass: "".concat(name, "-leave-active")
	    };
	});
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	    /* istanbul ignore if */
	    if (window.ontransitionend === undefined &&
	        window.onwebkittransitionend !== undefined) {
	        transitionProp = 'WebkitTransition';
	        transitionEndEvent = 'webkitTransitionEnd';
	    }
	    if (window.onanimationend === undefined &&
	        window.onwebkitanimationend !== undefined) {
	        animationProp = 'WebkitAnimation';
	        animationEndEvent = 'webkitAnimationEnd';
	    }
	}
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser
	    ? window.requestAnimationFrame
	        ? window.requestAnimationFrame.bind(window)
	        : setTimeout
	    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };
	function nextFrame(fn) {
	    raf(function () {
	        // @ts-expect-error
	        raf(fn);
	    });
	}
	function addTransitionClass(el, cls) {
	    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
	    if (transitionClasses.indexOf(cls) < 0) {
	        transitionClasses.push(cls);
	        addClass(el, cls);
	    }
	}
	function removeTransitionClass(el, cls) {
	    if (el._transitionClasses) {
	        remove$2(el._transitionClasses, cls);
	    }
	    removeClass(el, cls);
	}
	function whenTransitionEnds(el, expectedType, cb) {
	    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
	    if (!type)
	        return cb();
	    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	    var ended = 0;
	    var end = function () {
	        el.removeEventListener(event, onEnd);
	        cb();
	    };
	    var onEnd = function (e) {
	        if (e.target === el) {
	            if (++ended >= propCount) {
	                end();
	            }
	        }
	    };
	    setTimeout(function () {
	        if (ended < propCount) {
	            end();
	        }
	    }, timeout + 1);
	    el.addEventListener(event, onEnd);
	}
	var transformRE = /\b(transform|all)(,|$)/;
	function getTransitionInfo(el, expectedType) {
	    var styles = window.getComputedStyle(el);
	    // JSDOM may return undefined for transition properties
	    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
	    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
	    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
	    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
	    var animationTimeout = getTimeout(animationDelays, animationDurations);
	    var type;
	    var timeout = 0;
	    var propCount = 0;
	    /* istanbul ignore if */
	    if (expectedType === TRANSITION) {
	        if (transitionTimeout > 0) {
	            type = TRANSITION;
	            timeout = transitionTimeout;
	            propCount = transitionDurations.length;
	        }
	    }
	    else if (expectedType === ANIMATION) {
	        if (animationTimeout > 0) {
	            type = ANIMATION;
	            timeout = animationTimeout;
	            propCount = animationDurations.length;
	        }
	    }
	    else {
	        timeout = Math.max(transitionTimeout, animationTimeout);
	        type =
	            timeout > 0
	                ? transitionTimeout > animationTimeout
	                    ? TRANSITION
	                    : ANIMATION
	                : null;
	        propCount = type
	            ? type === TRANSITION
	                ? transitionDurations.length
	                : animationDurations.length
	            : 0;
	    }
	    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	    return {
	        type: type,
	        timeout: timeout,
	        propCount: propCount,
	        hasTransform: hasTransform
	    };
	}
	function getTimeout(delays, durations) {
	    /* istanbul ignore next */
	    while (delays.length < durations.length) {
	        delays = delays.concat(delays);
	    }
	    return Math.max.apply(null, durations.map(function (d, i) {
	        return toMs(d) + toMs(delays[i]);
	    }));
	}
	// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
	// in a locale-dependent way, using a comma instead of a dot.
	// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
	// as a floor function) causing unexpected behaviors
	function toMs(s) {
	    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
	}

	function enter(vnode, toggleDisplay) {
	    var el = vnode.elm;
	    // call leave callback now
	    if (isDef(el._leaveCb)) {
	        el._leaveCb.cancelled = true;
	        el._leaveCb();
	    }
	    var data = resolveTransition(vnode.data.transition);
	    if (isUndef(data)) {
	        return;
	    }
	    /* istanbul ignore if */
	    if (isDef(el._enterCb) || el.nodeType !== 1) {
	        return;
	    }
	    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
	    // activeInstance will always be the <transition> component managing this
	    // transition. One edge case to check is when the <transition> is placed
	    // as the root node of a child component. In that case we need to check
	    // <transition>'s parent for appear check.
	    var context = activeInstance;
	    var transitionNode = activeInstance.$vnode;
	    while (transitionNode && transitionNode.parent) {
	        context = transitionNode.context;
	        transitionNode = transitionNode.parent;
	    }
	    var isAppear = !context._isMounted || !vnode.isRootInsert;
	    if (isAppear && !appear && appear !== '') {
	        return;
	    }
	    var startClass = isAppear && appearClass ? appearClass : enterClass;
	    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
	    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	    var enterCancelledHook = isAppear
	        ? appearCancelled || enterCancelled
	        : enterCancelled;
	    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	    if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	        checkDuration(explicitEnterDuration, 'enter', vnode);
	    }
	    var expectsCSS = css !== false && !isIE9;
	    var userWantsControl = getHookArgumentsLength(enterHook);
	    var cb = (el._enterCb = once(function () {
	        if (expectsCSS) {
	            removeTransitionClass(el, toClass);
	            removeTransitionClass(el, activeClass);
	        }
	        // @ts-expect-error
	        if (cb.cancelled) {
	            if (expectsCSS) {
	                removeTransitionClass(el, startClass);
	            }
	            enterCancelledHook && enterCancelledHook(el);
	        }
	        else {
	            afterEnterHook && afterEnterHook(el);
	        }
	        el._enterCb = null;
	    }));
	    if (!vnode.data.show) {
	        // remove pending leave element on enter by injecting an insert hook
	        mergeVNodeHook(vnode, 'insert', function () {
	            var parent = el.parentNode;
	            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	            if (pendingNode &&
	                pendingNode.tag === vnode.tag &&
	                pendingNode.elm._leaveCb) {
	                pendingNode.elm._leaveCb();
	            }
	            enterHook && enterHook(el, cb);
	        });
	    }
	    // start enter transition
	    beforeEnterHook && beforeEnterHook(el);
	    if (expectsCSS) {
	        addTransitionClass(el, startClass);
	        addTransitionClass(el, activeClass);
	        nextFrame(function () {
	            removeTransitionClass(el, startClass);
	            // @ts-expect-error
	            if (!cb.cancelled) {
	                addTransitionClass(el, toClass);
	                if (!userWantsControl) {
	                    if (isValidDuration(explicitEnterDuration)) {
	                        setTimeout(cb, explicitEnterDuration);
	                    }
	                    else {
	                        whenTransitionEnds(el, type, cb);
	                    }
	                }
	            }
	        });
	    }
	    if (vnode.data.show) {
	        toggleDisplay && toggleDisplay();
	        enterHook && enterHook(el, cb);
	    }
	    if (!expectsCSS && !userWantsControl) {
	        cb();
	    }
	}
	function leave(vnode, rm) {
	    var el = vnode.elm;
	    // call enter callback now
	    if (isDef(el._enterCb)) {
	        el._enterCb.cancelled = true;
	        el._enterCb();
	    }
	    var data = resolveTransition(vnode.data.transition);
	    if (isUndef(data) || el.nodeType !== 1) {
	        return rm();
	    }
	    /* istanbul ignore if */
	    if (isDef(el._leaveCb)) {
	        return;
	    }
	    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
	    var expectsCSS = css !== false && !isIE9;
	    var userWantsControl = getHookArgumentsLength(leave);
	    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	    if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	        checkDuration(explicitLeaveDuration, 'leave', vnode);
	    }
	    var cb = (el._leaveCb = once(function () {
	        if (el.parentNode && el.parentNode._pending) {
	            el.parentNode._pending[vnode.key] = null;
	        }
	        if (expectsCSS) {
	            removeTransitionClass(el, leaveToClass);
	            removeTransitionClass(el, leaveActiveClass);
	        }
	        // @ts-expect-error
	        if (cb.cancelled) {
	            if (expectsCSS) {
	                removeTransitionClass(el, leaveClass);
	            }
	            leaveCancelled && leaveCancelled(el);
	        }
	        else {
	            rm();
	            afterLeave && afterLeave(el);
	        }
	        el._leaveCb = null;
	    }));
	    if (delayLeave) {
	        delayLeave(performLeave);
	    }
	    else {
	        performLeave();
	    }
	    function performLeave() {
	        // the delayed leave may have already been cancelled
	        // @ts-expect-error
	        if (cb.cancelled) {
	            return;
	        }
	        // record leaving element
	        if (!vnode.data.show && el.parentNode) {
	            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
	                vnode;
	        }
	        beforeLeave && beforeLeave(el);
	        if (expectsCSS) {
	            addTransitionClass(el, leaveClass);
	            addTransitionClass(el, leaveActiveClass);
	            nextFrame(function () {
	                removeTransitionClass(el, leaveClass);
	                // @ts-expect-error
	                if (!cb.cancelled) {
	                    addTransitionClass(el, leaveToClass);
	                    if (!userWantsControl) {
	                        if (isValidDuration(explicitLeaveDuration)) {
	                            setTimeout(cb, explicitLeaveDuration);
	                        }
	                        else {
	                            whenTransitionEnds(el, type, cb);
	                        }
	                    }
	                }
	            });
	        }
	        leave && leave(el, cb);
	        if (!expectsCSS && !userWantsControl) {
	            cb();
	        }
	    }
	}
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	    if (typeof val !== 'number') {
	        warn("<transition> explicit ".concat(name, " duration is not a valid number - ") +
	            "got ".concat(JSON.stringify(val), "."), vnode.context);
	    }
	    else if (isNaN(val)) {
	        warn("<transition> explicit ".concat(name, " duration is NaN - ") +
	            'the duration expression might be incorrect.', vnode.context);
	    }
	}
	function isValidDuration(val) {
	    return typeof val === 'number' && !isNaN(val);
	}
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	    if (isUndef(fn)) {
	        return false;
	    }
	    // @ts-expect-error
	    var invokerFns = fn.fns;
	    if (isDef(invokerFns)) {
	        // invoker
	        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	    }
	    else {
	        // @ts-expect-error
	        return (fn._length || fn.length) > 1;
	    }
	}
	function _enter(_, vnode) {
	    if (vnode.data.show !== true) {
	        enter(vnode);
	    }
	}
	var transition = inBrowser
	    ? {
	        create: _enter,
	        activate: _enter,
	        remove: function (vnode, rm) {
	            /* istanbul ignore else */
	            if (vnode.data.show !== true) {
	                // @ts-expect-error
	                leave(vnode, rm);
	            }
	            else {
	                rm();
	            }
	        }
	    }
	    : {};

	var platformModules = [attrs, klass, events, domProps, style, transition];

	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	/* istanbul ignore if */
	if (isIE9) {
	    // http://www.matts411.com/post/internet-explorer-9-oninput/
	    document.addEventListener('selectionchange', function () {
	        var el = document.activeElement;
	        // @ts-expect-error
	        if (el && el.vmodel) {
	            trigger(el, 'input');
	        }
	    });
	}
	var directive = {
	    inserted: function (el, binding, vnode, oldVnode) {
	        if (vnode.tag === 'select') {
	            // #6903
	            if (oldVnode.elm && !oldVnode.elm._vOptions) {
	                mergeVNodeHook(vnode, 'postpatch', function () {
	                    directive.componentUpdated(el, binding, vnode);
	                });
	            }
	            else {
	                setSelected(el, binding, vnode.context);
	            }
	            el._vOptions = [].map.call(el.options, getValue);
	        }
	        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
	            el._vModifiers = binding.modifiers;
	            if (!binding.modifiers.lazy) {
	                el.addEventListener('compositionstart', onCompositionStart);
	                el.addEventListener('compositionend', onCompositionEnd);
	                // Safari < 10.2 & UIWebView doesn't fire compositionend when
	                // switching focus before confirming composition choice
	                // this also fixes the issue where some browsers e.g. iOS Chrome
	                // fires "change" instead of "input" on autocomplete.
	                el.addEventListener('change', onCompositionEnd);
	                /* istanbul ignore if */
	                if (isIE9) {
	                    el.vmodel = true;
	                }
	            }
	        }
	    },
	    componentUpdated: function (el, binding, vnode) {
	        if (vnode.tag === 'select') {
	            setSelected(el, binding, vnode.context);
	            // in case the options rendered by v-for have changed,
	            // it's possible that the value is out-of-sync with the rendered options.
	            // detect such cases and filter out values that no longer has a matching
	            // option in the DOM.
	            var prevOptions_1 = el._vOptions;
	            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));
	            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {
	                // trigger change event if
	                // no matching option found for at least one value
	                var needReset = el.multiple
	                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })
	                    : binding.value !== binding.oldValue &&
	                        hasNoMatchingOption(binding.value, curOptions_1);
	                if (needReset) {
	                    trigger(el, 'change');
	                }
	            }
	        }
	    }
	};
	function setSelected(el, binding, vm) {
	    actuallySetSelected(el, binding, vm);
	    /* istanbul ignore if */
	    if (isIE || isEdge) {
	        setTimeout(function () {
	            actuallySetSelected(el, binding, vm);
	        }, 0);
	    }
	}
	function actuallySetSelected(el, binding, vm) {
	    var value = binding.value;
	    var isMultiple = el.multiple;
	    if (isMultiple && !Array.isArray(value)) {
	        process.env.NODE_ENV !== 'production' &&
	            warn("<select multiple v-model=\"".concat(binding.expression, "\"> ") +
	                "expects an Array value for its binding, but got ".concat(Object.prototype.toString
	                    .call(value)
	                    .slice(8, -1)), vm);
	        return;
	    }
	    var selected, option;
	    for (var i = 0, l = el.options.length; i < l; i++) {
	        option = el.options[i];
	        if (isMultiple) {
	            selected = looseIndexOf(value, getValue(option)) > -1;
	            if (option.selected !== selected) {
	                option.selected = selected;
	            }
	        }
	        else {
	            if (looseEqual(getValue(option), value)) {
	                if (el.selectedIndex !== i) {
	                    el.selectedIndex = i;
	                }
	                return;
	            }
	        }
	    }
	    if (!isMultiple) {
	        el.selectedIndex = -1;
	    }
	}
	function hasNoMatchingOption(value, options) {
	    return options.every(function (o) { return !looseEqual(o, value); });
	}
	function getValue(option) {
	    return '_value' in option ? option._value : option.value;
	}
	function onCompositionStart(e) {
	    e.target.composing = true;
	}
	function onCompositionEnd(e) {
	    // prevent triggering an input event for no reason
	    if (!e.target.composing)
	        return;
	    e.target.composing = false;
	    trigger(e.target, 'input');
	}
	function trigger(el, type) {
	    var e = document.createEvent('HTMLEvents');
	    e.initEvent(type, true, true);
	    el.dispatchEvent(e);
	}

	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	    // @ts-expect-error
	    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
	        ? locateNode(vnode.componentInstance._vnode)
	        : vnode;
	}
	var show = {
	    bind: function (el, _a, vnode) {
	        var value = _a.value;
	        vnode = locateNode(vnode);
	        var transition = vnode.data && vnode.data.transition;
	        var originalDisplay = (el.__vOriginalDisplay =
	            el.style.display === 'none' ? '' : el.style.display);
	        if (value && transition) {
	            vnode.data.show = true;
	            enter(vnode, function () {
	                el.style.display = originalDisplay;
	            });
	        }
	        else {
	            el.style.display = value ? originalDisplay : 'none';
	        }
	    },
	    update: function (el, _a, vnode) {
	        var value = _a.value, oldValue = _a.oldValue;
	        /* istanbul ignore if */
	        if (!value === !oldValue)
	            return;
	        vnode = locateNode(vnode);
	        var transition = vnode.data && vnode.data.transition;
	        if (transition) {
	            vnode.data.show = true;
	            if (value) {
	                enter(vnode, function () {
	                    el.style.display = el.__vOriginalDisplay;
	                });
	            }
	            else {
	                leave(vnode, function () {
	                    el.style.display = 'none';
	                });
	            }
	        }
	        else {
	            el.style.display = value ? el.__vOriginalDisplay : 'none';
	        }
	    },
	    unbind: function (el, binding, vnode, oldVnode, isDestroy) {
	        if (!isDestroy) {
	            el.style.display = el.__vOriginalDisplay;
	        }
	    }
	};

	var platformDirectives = {
	    model: directive,
	    show: show
	};

	// Provides transition support for a single element/component.
	var transitionProps = {
	    name: String,
	    appear: Boolean,
	    css: Boolean,
	    mode: String,
	    type: String,
	    enterClass: String,
	    leaveClass: String,
	    enterToClass: String,
	    leaveToClass: String,
	    enterActiveClass: String,
	    leaveActiveClass: String,
	    appearClass: String,
	    appearActiveClass: String,
	    appearToClass: String,
	    duration: [Number, String, Object]
	};
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	    var compOptions = vnode && vnode.componentOptions;
	    if (compOptions && compOptions.Ctor.options.abstract) {
	        return getRealChild(getFirstComponentChild(compOptions.children));
	    }
	    else {
	        return vnode;
	    }
	}
	function extractTransitionData(comp) {
	    var data = {};
	    var options = comp.$options;
	    // props
	    for (var key in options.propsData) {
	        data[key] = comp[key];
	    }
	    // events.
	    // extract listeners and pass them directly to the transition methods
	    var listeners = options._parentListeners;
	    for (var key in listeners) {
	        data[camelize(key)] = listeners[key];
	    }
	    return data;
	}
	function placeholder(h, rawChild) {
	    // @ts-expect-error
	    if (/\d-keep-alive$/.test(rawChild.tag)) {
	        return h('keep-alive', {
	            props: rawChild.componentOptions.propsData
	        });
	    }
	}
	function hasParentTransition(vnode) {
	    while ((vnode = vnode.parent)) {
	        if (vnode.data.transition) {
	            return true;
	        }
	    }
	}
	function isSameChild(child, oldChild) {
	    return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };
	var isVShowDirective = function (d) { return d.name === 'show'; };
	var Transition = {
	    name: 'transition',
	    props: transitionProps,
	    abstract: true,
	    render: function (h) {
	        var _this = this;
	        var children = this.$slots.default;
	        if (!children) {
	            return;
	        }
	        // filter out text nodes (possible whitespaces)
	        children = children.filter(isNotTextNode);
	        /* istanbul ignore if */
	        if (!children.length) {
	            return;
	        }
	        // warn multiple elements
	        if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	            warn('<transition> can only be used on a single element. Use ' +
	                '<transition-group> for lists.', this.$parent);
	        }
	        var mode = this.mode;
	        // warn invalid mode
	        if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	            warn('invalid <transition> mode: ' + mode, this.$parent);
	        }
	        var rawChild = children[0];
	        // if this is a component root node and the component's
	        // parent container node also has transition, skip.
	        if (hasParentTransition(this.$vnode)) {
	            return rawChild;
	        }
	        // apply transition data to child
	        // use getRealChild() to ignore abstract components e.g. keep-alive
	        var child = getRealChild(rawChild);
	        /* istanbul ignore if */
	        if (!child) {
	            return rawChild;
	        }
	        if (this._leaving) {
	            return placeholder(h, rawChild);
	        }
	        // ensure a key that is unique to the vnode type and to this transition
	        // component instance. This key will be used to remove pending leaving nodes
	        // during entering.
	        var id = "__transition-".concat(this._uid, "-");
	        child.key =
	            child.key == null
	                ? child.isComment
	                    ? id + 'comment'
	                    : id + child.tag
	                : isPrimitive(child.key)
	                    ? String(child.key).indexOf(id) === 0
	                        ? child.key
	                        : id + child.key
	                    : child.key;
	        var data = ((child.data || (child.data = {})).transition =
	            extractTransitionData(this));
	        var oldRawChild = this._vnode;
	        var oldChild = getRealChild(oldRawChild);
	        // mark v-show
	        // so that the transition module can hand over the control to the directive
	        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
	            child.data.show = true;
	        }
	        if (oldChild &&
	            oldChild.data &&
	            !isSameChild(child, oldChild) &&
	            !isAsyncPlaceholder(oldChild) &&
	            // #6687 component root is a comment node
	            !(oldChild.componentInstance &&
	                oldChild.componentInstance._vnode.isComment)) {
	            // replace old child transition data with fresh one
	            // important for dynamic transitions!
	            var oldData = (oldChild.data.transition = extend({}, data));
	            // handle transition mode
	            if (mode === 'out-in') {
	                // return placeholder node and queue update when leave finishes
	                this._leaving = true;
	                mergeVNodeHook(oldData, 'afterLeave', function () {
	                    _this._leaving = false;
	                    _this.$forceUpdate();
	                });
	                return placeholder(h, rawChild);
	            }
	            else if (mode === 'in-out') {
	                if (isAsyncPlaceholder(child)) {
	                    return oldRawChild;
	                }
	                var delayedLeave_1;
	                var performLeave = function () {
	                    delayedLeave_1();
	                };
	                mergeVNodeHook(data, 'afterEnter', performLeave);
	                mergeVNodeHook(data, 'enterCancelled', performLeave);
	                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	                    delayedLeave_1 = leave;
	                });
	            }
	        }
	        return rawChild;
	    }
	};

	// Provides transition support for list items.
	var props = extend({
	    tag: String,
	    moveClass: String
	}, transitionProps);
	delete props.mode;
	var TransitionGroup = {
	    props: props,
	    beforeMount: function () {
	        var _this = this;
	        var update = this._update;
	        this._update = function (vnode, hydrating) {
	            var restoreActiveInstance = setActiveInstance(_this);
	            // force removing pass
	            _this.__patch__(_this._vnode, _this.kept, false, // hydrating
	            true // removeOnly (!important, avoids unnecessary moves)
	            );
	            _this._vnode = _this.kept;
	            restoreActiveInstance();
	            update.call(_this, vnode, hydrating);
	        };
	    },
	    render: function (h) {
	        var tag = this.tag || this.$vnode.data.tag || 'span';
	        var map = Object.create(null);
	        var prevChildren = (this.prevChildren = this.children);
	        var rawChildren = this.$slots.default || [];
	        var children = (this.children = []);
	        var transitionData = extractTransitionData(this);
	        for (var i = 0; i < rawChildren.length; i++) {
	            var c = rawChildren[i];
	            if (c.tag) {
	                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	                    children.push(c);
	                    map[c.key] = c;
	                    (c.data || (c.data = {})).transition = transitionData;
	                }
	                else if (process.env.NODE_ENV !== 'production') {
	                    var opts = c.componentOptions;
	                    var name_1 = opts
	                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
	                        : c.tag;
	                    warn("<transition-group> children must be keyed: <".concat(name_1, ">"));
	                }
	            }
	        }
	        if (prevChildren) {
	            var kept = [];
	            var removed = [];
	            for (var i = 0; i < prevChildren.length; i++) {
	                var c = prevChildren[i];
	                c.data.transition = transitionData;
	                // @ts-expect-error .getBoundingClientRect is not typed in Node
	                c.data.pos = c.elm.getBoundingClientRect();
	                if (map[c.key]) {
	                    kept.push(c);
	                }
	                else {
	                    removed.push(c);
	                }
	            }
	            this.kept = h(tag, null, kept);
	            this.removed = removed;
	        }
	        return h(tag, null, children);
	    },
	    updated: function () {
	        var children = this.prevChildren;
	        var moveClass = this.moveClass || (this.name || 'v') + '-move';
	        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	            return;
	        }
	        // we divide the work into three loops to avoid mixing DOM reads and writes
	        // in each iteration - which helps prevent layout thrashing.
	        children.forEach(callPendingCbs);
	        children.forEach(recordPosition);
	        children.forEach(applyTranslation);
	        // force reflow to put everything in position
	        // assign to this to avoid being removed in tree-shaking
	        // $flow-disable-line
	        this._reflow = document.body.offsetHeight;
	        children.forEach(function (c) {
	            if (c.data.moved) {
	                var el_1 = c.elm;
	                var s = el_1.style;
	                addTransitionClass(el_1, moveClass);
	                s.transform = s.WebkitTransform = s.transitionDuration = '';
	                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {
	                    if (e && e.target !== el_1) {
	                        return;
	                    }
	                    if (!e || /transform$/.test(e.propertyName)) {
	                        el_1.removeEventListener(transitionEndEvent, cb);
	                        el_1._moveCb = null;
	                        removeTransitionClass(el_1, moveClass);
	                    }
	                }));
	            }
	        });
	    },
	    methods: {
	        hasMove: function (el, moveClass) {
	            /* istanbul ignore if */
	            if (!hasTransition) {
	                return false;
	            }
	            /* istanbul ignore if */
	            if (this._hasMove) {
	                return this._hasMove;
	            }
	            // Detect whether an element with the move class applied has
	            // CSS transitions. Since the element may be inside an entering
	            // transition at this very moment, we make a clone of it and remove
	            // all other transition classes applied to ensure only the move class
	            // is applied.
	            var clone = el.cloneNode();
	            if (el._transitionClasses) {
	                el._transitionClasses.forEach(function (cls) {
	                    removeClass(clone, cls);
	                });
	            }
	            addClass(clone, moveClass);
	            clone.style.display = 'none';
	            this.$el.appendChild(clone);
	            var info = getTransitionInfo(clone);
	            this.$el.removeChild(clone);
	            return (this._hasMove = info.hasTransform);
	        }
	    }
	};
	function callPendingCbs(c) {
	    /* istanbul ignore if */
	    if (c.elm._moveCb) {
	        c.elm._moveCb();
	    }
	    /* istanbul ignore if */
	    if (c.elm._enterCb) {
	        c.elm._enterCb();
	    }
	}
	function recordPosition(c) {
	    c.data.newPos = c.elm.getBoundingClientRect();
	}
	function applyTranslation(c) {
	    var oldPos = c.data.pos;
	    var newPos = c.data.newPos;
	    var dx = oldPos.left - newPos.left;
	    var dy = oldPos.top - newPos.top;
	    if (dx || dy) {
	        c.data.moved = true;
	        var s = c.elm.style;
	        s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
	        s.transitionDuration = '0s';
	    }
	}

	var platformComponents = {
	    Transition: Transition,
	    TransitionGroup: TransitionGroup
	};

	// install platform specific utils
	Vue.config.mustUseProp = mustUseProp;
	Vue.config.isReservedTag = isReservedTag;
	Vue.config.isReservedAttr = isReservedAttr;
	Vue.config.getTagNamespace = getTagNamespace;
	Vue.config.isUnknownElement = isUnknownElement;
	// install platform runtime directives & components
	extend(Vue.options.directives, platformDirectives);
	extend(Vue.options.components, platformComponents);
	// install platform patch function
	Vue.prototype.__patch__ = inBrowser ? patch : noop;
	// public mount method
	Vue.prototype.$mount = function (el, hydrating) {
	    el = el && inBrowser ? query(el) : undefined;
	    return mountComponent(this, el, hydrating);
	};
	// devtools global hook
	/* istanbul ignore next */
	if (inBrowser) {
	    setTimeout(function () {
	        if (config.devtools) {
	            if (devtools) {
	                devtools.emit('init', Vue);
	            }
	            else if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
	                // @ts-expect-error
	                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
	                    'https://github.com/vuejs/vue-devtools');
	            }
	        }
	        if (process.env.NODE_ENV !== 'production' &&
	            process.env.NODE_ENV !== 'test' &&
	            config.productionTip !== false &&
	            typeof console !== 'undefined') {
	            // @ts-expect-error
	            console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" +
	                "Make sure to turn on production mode when deploying for production.\n" +
	                "See more tips at https://vuejs.org/guide/deployment.html");
	        }
	    }, 0);
	}

	var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global$1?global$1:"undefined"!=typeof self?self:{},n=function(e){return e&&e.Math==Math&&e},r=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof t&&t)||function(){return this}()||Function("return this")(),i={},o=function(e){try{return !!e()}catch(e){return !0}},s=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),a=!o((function(){var e=function(){}.bind();return "function"!=typeof e||e.hasOwnProperty("prototype")})),l=a,c=Function.prototype.call,u=l?c.bind(c):function(){return c.apply(c,arguments)},d={},h={}.propertyIsEnumerable,p=Object.getOwnPropertyDescriptor,f=p&&!h.call({1:2},1);d.f=f?function(e){var t=p(this,e);return !!t&&t.enumerable}:h;var m,g,v=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},y=a,b=Function.prototype,w=b.bind,k=b.call,C=y&&w.bind(k,k),E=y?function(e){return e&&C(e)}:function(e){return e&&function(){return k.apply(e,arguments)}},x=E,S=x({}.toString),D=x("".slice),M=function(e){return D(S(e),8,-1)},O=o,A=M,N=Object,_=E("".split),T=O((function(){return !N("z").propertyIsEnumerable(0)}))?function(e){return "String"==A(e)?_(e,""):N(e)}:N,L=TypeError,R=function(e){if(null==e)throw L("Can't call method on "+e);return e},F=T,B=R,I=function(e){return F(B(e))},P=function(e){return "function"==typeof e},z=P,$=function(e){return "object"==typeof e?null!==e:z(e)},j=r,H=P,V=function(e){return H(e)?e:void 0},K=function(e,t){return arguments.length<2?V(j[e]):j[e]&&j[e][t]},q=E({}.isPrototypeOf),U=K("navigator","userAgent")||"",W=r,G=U,J=W.process,Z=W.Deno,X=J&&J.versions||Z&&Z.version,Q=X&&X.v8;Q&&(g=(m=Q.split("."))[0]>0&&m[0]<4?1:+(m[0]+m[1])),!g&&G&&(!(m=G.match(/Edge\/(\d+)/))||m[1]>=74)&&(m=G.match(/Chrome\/(\d+)/))&&(g=+m[1]);var Y=g,ee=Y,te=o,ne=!!Object.getOwnPropertySymbols&&!te((function(){var e=Symbol();return !String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&ee&&ee<41})),re=ne&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,ie=K,oe=P,se=q,ae=Object,le=re?function(e){return "symbol"==typeof e}:function(e){var t=ie("Symbol");return oe(t)&&se(t.prototype,ae(e))},ce=String,ue=function(e){try{return ce(e)}catch(e){return "Object"}},de=P,he=ue,pe=TypeError,fe=function(e){if(de(e))return e;throw pe(he(e)+" is not a function")},me=fe,ge=function(e,t){var n=e[t];return null==n?void 0:me(n)},ve=u,ye=P,be=$,we=TypeError,ke={exports:{}},Ce=r,Ee=Object.defineProperty,xe=function(e,t){try{Ee(Ce,e,{value:t,configurable:!0,writable:!0});}catch(n){Ce[e]=t;}return t},Se=xe,De=r["__core-js_shared__"]||Se("__core-js_shared__",{}),Me=De;(ke.exports=function(e,t){return Me[e]||(Me[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.23.5",mode:"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.5/LICENSE",source:"https://github.com/zloirock/core-js"});var Oe=R,Ae=Object,Ne=function(e){return Ae(Oe(e))},_e=Ne,Te=E({}.hasOwnProperty),Le=Object.hasOwn||function(e,t){return Te(_e(e),t)},Re=E,Fe=0,Be=Math.random(),Ie=Re(1..toString),Pe=function(e){return "Symbol("+(void 0===e?"":e)+")_"+Ie(++Fe+Be,36)},ze=r,$e=ke.exports,je=Le,He=Pe,Ve=ne,Ke=re,qe=$e("wks"),Ue=ze.Symbol,We=Ue&&Ue.for,Ge=Ke?Ue:Ue&&Ue.withoutSetter||He,Je=function(e){if(!je(qe,e)||!Ve&&"string"!=typeof qe[e]){var t="Symbol."+e;Ve&&je(Ue,e)?qe[e]=Ue[e]:qe[e]=Ke&&We?We(t):Ge(t);}return qe[e]},Ze=u,Xe=$,Qe=le,Ye=ge,et=function(e,t){var n,r;if("string"===t&&ye(n=e.toString)&&!be(r=ve(n,e)))return r;if(ye(n=e.valueOf)&&!be(r=ve(n,e)))return r;if("string"!==t&&ye(n=e.toString)&&!be(r=ve(n,e)))return r;throw we("Can't convert object to primitive value")},tt=TypeError,nt=Je("toPrimitive"),rt=function(e,t){if(!Xe(e)||Qe(e))return e;var n,r=Ye(e,nt);if(r){if(void 0===t&&(t="default"),n=Ze(r,e,t),!Xe(n)||Qe(n))return n;throw tt("Can't convert object to primitive value")}return void 0===t&&(t="number"),et(e,t)},it=rt,ot=le,st=function(e){var t=it(e,"string");return ot(t)?t:t+""},at=$,lt=r.document,ct=at(lt)&&at(lt.createElement),ut=function(e){return ct?lt.createElement(e):{}},dt=ut,ht=!s&&!o((function(){return 7!=Object.defineProperty(dt("div"),"a",{get:function(){return 7}}).a})),pt=s,ft=u,mt=d,gt=v,vt=I,yt=st,bt=Le,wt=ht,kt=Object.getOwnPropertyDescriptor;i.f=pt?kt:function(e,t){if(e=vt(e),t=yt(t),wt)try{return kt(e,t)}catch(e){}if(bt(e,t))return gt(!ft(mt.f,e,t),e[t])};var Ct={},Et=s&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),xt=$,St=String,Dt=TypeError,Mt=function(e){if(xt(e))return e;throw Dt(St(e)+" is not an object")},Ot=s,At=ht,Nt=Et,_t=Mt,Tt=st,Lt=TypeError,Rt=Object.defineProperty,Ft=Object.getOwnPropertyDescriptor;Ct.f=Ot?Nt?function(e,t,n){if(_t(e),t=Tt(t),_t(n),"function"==typeof e&&"prototype"===t&&"value"in n&&"writable"in n&&!n.writable){var r=Ft(e,t);r&&r.writable&&(e[t]=n.value,n={configurable:"configurable"in n?n.configurable:r.configurable,enumerable:"enumerable"in n?n.enumerable:r.enumerable,writable:!1});}return Rt(e,t,n)}:Rt:function(e,t,n){if(_t(e),t=Tt(t),_t(n),At)try{return Rt(e,t,n)}catch(e){}if("get"in n||"set"in n)throw Lt("Accessors not supported");return "value"in n&&(e[t]=n.value),e};var Bt=Ct,It=v,Pt=s?function(e,t,n){return Bt.f(e,t,It(1,n))}:function(e,t,n){return e[t]=n,e},zt={exports:{}},$t=s,jt=Le,Ht=Function.prototype,Vt=$t&&Object.getOwnPropertyDescriptor,Kt=jt(Ht,"name"),qt={EXISTS:Kt,PROPER:Kt&&"something"===function(){}.name,CONFIGURABLE:Kt&&(!$t||$t&&Vt(Ht,"name").configurable)},Ut=P,Wt=De,Gt=E(Function.toString);Ut(Wt.inspectSource)||(Wt.inspectSource=function(e){return Gt(e)});var Jt,Zt,Xt,Qt=Wt.inspectSource,Yt=P,en=Qt,tn=r.WeakMap,nn=Yt(tn)&&/native code/.test(en(tn)),rn=ke.exports,on=Pe,sn=rn("keys"),an=function(e){return sn[e]||(sn[e]=on(e))},ln={},cn=nn,un=r,dn=E,hn=$,pn=Pt,fn=Le,mn=De,gn=an,vn=ln,yn=un.TypeError,bn=un.WeakMap;if(cn||mn.state){var wn=mn.state||(mn.state=new bn),kn=dn(wn.get),Cn=dn(wn.has),En=dn(wn.set);Jt=function(e,t){if(Cn(wn,e))throw new yn("Object already initialized");return t.facade=e,En(wn,e,t),t},Zt=function(e){return kn(wn,e)||{}},Xt=function(e){return Cn(wn,e)};}else {var xn=gn("state");vn[xn]=!0,Jt=function(e,t){if(fn(e,xn))throw new yn("Object already initialized");return t.facade=e,pn(e,xn,t),t},Zt=function(e){return fn(e,xn)?e[xn]:{}},Xt=function(e){return fn(e,xn)};}var Sn={set:Jt,get:Zt,has:Xt,enforce:function(e){return Xt(e)?Zt(e):Jt(e,{})},getterFor:function(e){return function(t){var n;if(!hn(t)||(n=Zt(t)).type!==e)throw yn("Incompatible receiver, "+e+" required");return n}}},Dn=o,Mn=P,On=Le,An=s,Nn=qt.CONFIGURABLE,_n=Qt,Tn=Sn.enforce,Ln=Sn.get,Rn=Object.defineProperty,Fn=An&&!Dn((function(){return 8!==Rn((function(){}),"length",{value:8}).length})),Bn=String(String).split("String"),In=zt.exports=function(e,t,n){"Symbol("===String(t).slice(0,7)&&(t="["+String(t).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),n&&n.getter&&(t="get "+t),n&&n.setter&&(t="set "+t),(!On(e,"name")||Nn&&e.name!==t)&&(An?Rn(e,"name",{value:t,configurable:!0}):e.name=t),Fn&&n&&On(n,"arity")&&e.length!==n.arity&&Rn(e,"length",{value:n.arity});try{n&&On(n,"constructor")&&n.constructor?An&&Rn(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0);}catch(e){}var r=Tn(e);return On(r,"source")||(r.source=Bn.join("string"==typeof t?t:"")),e};Function.prototype.toString=In((function(){return Mn(this)&&Ln(this).source||_n(this)}),"toString");var Pn=P,zn=Ct,$n=zt.exports,jn=xe,Hn=function(e,t,n,r){r||(r={});var i=r.enumerable,o=void 0!==r.name?r.name:t;if(Pn(n)&&$n(n,o,r),r.global)i?e[t]=n:jn(t,n);else {try{r.unsafe?e[t]&&(i=!0):delete e[t];}catch(e){}i?e[t]=n:zn.f(e,t,{value:n,enumerable:!1,configurable:!r.nonConfigurable,writable:!r.nonWritable});}return e},Vn={},Kn=Math.ceil,qn=Math.floor,Un=Math.trunc||function(e){var t=+e;return (t>0?qn:Kn)(t)},Wn=function(e){var t=+e;return t!=t||0===t?0:Un(t)},Gn=Wn,Jn=Math.max,Zn=Math.min,Xn=Wn,Qn=Math.min,Yn=function(e){return e>0?Qn(Xn(e),9007199254740991):0},er=Yn,tr=function(e){return er(e.length)},nr=I,rr=function(e,t){var n=Gn(e);return n<0?Jn(n+t,0):Zn(n,t)},ir=tr,or=function(e){return function(t,n,r){var i,o=nr(t),s=ir(o),a=rr(r,s);if(e&&n!=n){for(;s>a;)if((i=o[a++])!=i)return !0}else for(;s>a;a++)if((e||a in o)&&o[a]===n)return e||a||0;return !e&&-1}},sr={includes:or(!0),indexOf:or(!1)},ar=Le,lr=I,cr=sr.indexOf,ur=ln,dr=E([].push),hr=function(e,t){var n,r=lr(e),i=0,o=[];for(n in r)!ar(ur,n)&&ar(r,n)&&dr(o,n);for(;t.length>i;)ar(r,n=t[i++])&&(~cr(o,n)||dr(o,n));return o},pr=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],fr=hr,mr=pr.concat("length","prototype");Vn.f=Object.getOwnPropertyNames||function(e){return fr(e,mr)};var gr={};gr.f=Object.getOwnPropertySymbols;var vr=K,yr=Vn,br=gr,wr=Mt,kr=E([].concat),Cr=vr("Reflect","ownKeys")||function(e){var t=yr.f(wr(e)),n=br.f;return n?kr(t,n(e)):t},Er=Le,xr=Cr,Sr=i,Dr=Ct,Mr=o,Or=P,Ar=/#|\.prototype\./,Nr=function(e,t){var n=Tr[_r(e)];return n==Rr||n!=Lr&&(Or(t)?Mr(t):!!t)},_r=Nr.normalize=function(e){return String(e).replace(Ar,".").toLowerCase()},Tr=Nr.data={},Lr=Nr.NATIVE="N",Rr=Nr.POLYFILL="P",Fr=Nr,Br=r,Ir=i.f,Pr=Pt,zr=Hn,$r=xe,jr=function(e,t,n){for(var r=xr(t),i=Dr.f,o=Sr.f,s=0;s<r.length;s++){var a=r[s];Er(e,a)||n&&Er(n,a)||i(e,a,o(t,a));}},Hr=Fr,Vr=function(e,t){var n,r,i,o,s,a=e.target,l=e.global,c=e.stat;if(n=l?Br:c?Br[a]||$r(a,{}):(Br[a]||{}).prototype)for(r in t){if(o=t[r],i=e.dontCallGetSet?(s=Ir(n,r))&&s.value:n[r],!Hr(l?r:a+(c?".":"#")+r,e.forced)&&void 0!==i){if(typeof o==typeof i)continue;jr(o,i);}(e.sham||i&&i.sham)&&Pr(o,"sham",!0),zr(n,r,o,e);}},Kr={};Kr[Je("toStringTag")]="z";var qr="[object z]"===String(Kr),Ur=qr,Wr=P,Gr=M,Jr=Je("toStringTag"),Zr=Object,Xr="Arguments"==Gr(function(){return arguments}()),Qr=Ur?Gr:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=Zr(e),Jr))?n:Xr?Gr(t):"Object"==(r=Gr(t))&&Wr(t.callee)?"Arguments":r},Yr=Qr,ei=String,ti=function(e){if("Symbol"===Yr(e))throw TypeError("Cannot convert a Symbol value to a string");return ei(e)},ni=Mt,ri=o,ii=r.RegExp,oi=ri((function(){var e=ii("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),si=oi||ri((function(){return !ii("a","y").sticky})),ai={BROKEN_CARET:oi||ri((function(){var e=ii("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:si,UNSUPPORTED_Y:oi},li={},ci=hr,ui=pr,di=Object.keys||function(e){return ci(e,ui)},hi=s,pi=Et,fi=Ct,mi=Mt,gi=I,vi=di;li.f=hi&&!pi?Object.defineProperties:function(e,t){mi(e);for(var n,r=gi(t),i=vi(t),o=i.length,s=0;o>s;)fi.f(e,n=i[s++],r[n]);return e};var yi,bi=K("document","documentElement"),wi=Mt,ki=li,Ci=pr,Ei=ln,xi=bi,Si=ut,Di=an("IE_PROTO"),Mi=function(){},Oi=function(e){return "<script>"+e+"<\/script>"},Ai=function(e){e.write(Oi("")),e.close();var t=e.parentWindow.Object;return e=null,t},Ni=function(){try{yi=new ActiveXObject("htmlfile");}catch(e){}var e,t;Ni="undefined"!=typeof document?document.domain&&yi?Ai(yi):((t=Si("iframe")).style.display="none",xi.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(Oi("document.F=Object")),e.close(),e.F):Ai(yi);for(var n=Ci.length;n--;)delete Ni.prototype[Ci[n]];return Ni()};Ei[Di]=!0;var _i,Ti,Li=Object.create||function(e,t){var n;return null!==e?(Mi.prototype=wi(e),n=new Mi,Mi.prototype=null,n[Di]=e):n=Ni(),void 0===t?n:ki.f(n,t)},Ri=o,Fi=r.RegExp,Bi=Ri((function(){var e=Fi(".","s");return !(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),Ii=o,Pi=r.RegExp,zi=Ii((function(){var e=Pi("(?<a>b)","g");return "b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),$i=u,ji=E,Hi=ti,Vi=function(){var e=ni(this),t="";return e.hasIndices&&(t+="d"),e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.unicodeSets&&(t+="v"),e.sticky&&(t+="y"),t},Ki=ai,qi=ke.exports,Ui=Li,Wi=Sn.get,Gi=Bi,Ji=zi,Zi=qi("native-string-replace",String.prototype.replace),Xi=RegExp.prototype.exec,Qi=Xi,Yi=ji("".charAt),eo=ji("".indexOf),to=ji("".replace),no=ji("".slice),ro=(Ti=/b*/g,$i(Xi,_i=/a/,"a"),$i(Xi,Ti,"a"),0!==_i.lastIndex||0!==Ti.lastIndex),io=Ki.BROKEN_CARET,oo=void 0!==/()??/.exec("")[1];(ro||oo||io||Gi||Ji)&&(Qi=function(e){var t,n,r,i,o,s,a,l=this,c=Wi(l),u=Hi(e),d=c.raw;if(d)return d.lastIndex=l.lastIndex,t=$i(Qi,d,u),l.lastIndex=d.lastIndex,t;var h=c.groups,p=io&&l.sticky,f=$i(Vi,l),m=l.source,g=0,v=u;if(p&&(f=to(f,"y",""),-1===eo(f,"g")&&(f+="g"),v=no(u,l.lastIndex),l.lastIndex>0&&(!l.multiline||l.multiline&&"\n"!==Yi(u,l.lastIndex-1))&&(m="(?: "+m+")",v=" "+v,g++),n=new RegExp("^(?:"+m+")",f)),oo&&(n=new RegExp("^"+m+"$(?!\\s)",f)),ro&&(r=l.lastIndex),i=$i(Xi,p?n:l,v),p?i?(i.input=no(i.input,g),i[0]=no(i[0],g),i.index=l.lastIndex,l.lastIndex+=i[0].length):l.lastIndex=0:ro&&i&&(l.lastIndex=l.global?i.index+i[0].length:r),oo&&i&&i.length>1&&$i(Zi,i[0],n,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0);})),i&&h)for(i.groups=s=Ui(null),o=0;o<h.length;o++)s[(a=h[o])[0]]=i[a[1]];return i});var so=Qi;Vr({target:"RegExp",proto:!0,forced:/./.exec!==so},{exec:so});var ao=a,lo=Function.prototype,co=lo.apply,uo=lo.call,ho="object"==typeof Reflect&&Reflect.apply||(ao?uo.bind(co):function(){return uo.apply(co,arguments)}),po=E,fo=Hn,mo=so,go=o,vo=Je,yo=Pt,bo=vo("species"),wo=RegExp.prototype,ko=function(e,t,n,r){var i=vo(e),o=!go((function(){var t={};return t[i]=function(){return 7},7!=""[e](t)})),s=o&&!go((function(){var t=!1,n=/a/;return "split"===e&&((n={}).constructor={},n.constructor[bo]=function(){return n},n.flags="",n[i]=/./[i]),n.exec=function(){return t=!0,null},n[i](""),!t}));if(!o||!s||n){var a=po(/./[i]),l=t(i,""[e],(function(e,t,n,r,i){var s=po(e),l=t.exec;return l===mo||l===wo.exec?o&&!i?{done:!0,value:a(t,n,r)}:{done:!0,value:s(n,t,r)}:{done:!1}}));fo(String.prototype,e,l[0]),fo(wo,i,l[1]);}r&&yo(wo[i],"sham",!0);},Co=E,Eo=Wn,xo=ti,So=R,Do=Co("".charAt),Mo=Co("".charCodeAt),Oo=Co("".slice),Ao=function(e){return function(t,n){var r,i,o=xo(So(t)),s=Eo(n),a=o.length;return s<0||s>=a?e?"":void 0:(r=Mo(o,s))<55296||r>56319||s+1===a||(i=Mo(o,s+1))<56320||i>57343?e?Do(o,s):r:e?Oo(o,s,s+2):i-56320+(r-55296<<10)+65536}},No={codeAt:Ao(!1),charAt:Ao(!0)},_o=No.charAt,To=function(e,t,n){return t+(n?_o(e,t).length:1)},Lo=E,Ro=Ne,Fo=Math.floor,Bo=Lo("".charAt),Io=Lo("".replace),Po=Lo("".slice),zo=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,$o=/\$([$&'`]|\d{1,2})/g,jo=u,Ho=Mt,Vo=P,Ko=M,qo=so,Uo=TypeError,Wo=function(e,t){var n=e.exec;if(Vo(n)){var r=jo(n,e,t);return null!==r&&Ho(r),r}if("RegExp"===Ko(e))return jo(qo,e,t);throw Uo("RegExp#exec called on incompatible receiver")},Go=ho,Jo=u,Zo=E,Xo=ko,Qo=o,Yo=Mt,es=P,ts=Wn,ns=Yn,rs=ti,is=R,ss=To,as=ge,ls=function(e,t,n,r,i,o){var s=n+e.length,a=r.length,l=$o;return void 0!==i&&(i=Ro(i),l=zo),Io(o,l,(function(o,l){var c;switch(Bo(l,0)){case"$":return "$";case"&":return e;case"`":return Po(t,0,n);case"'":return Po(t,s);case"<":c=i[Po(l,1,-1)];break;default:var u=+l;if(0===u)return o;if(u>a){var d=Fo(u/10);return 0===d?o:d<=a?void 0===r[d-1]?Bo(l,1):r[d-1]+Bo(l,1):o}c=r[u-1];}return void 0===c?"":c}))},cs=Wo,us=Je("replace"),ds=Math.max,hs=Math.min,ps=Zo([].concat),fs=Zo([].push),ms=Zo("".indexOf),gs=Zo("".slice),vs="$0"==="a".replace(/./,"$0"),ys=!!/./[us]&&""===/./[us]("a","$0");function bs(e){this.content=e;}function ws(e,t,n){for(let r=0;;r++){if(r==e.childCount||r==t.childCount)return e.childCount==t.childCount?null:n;let i=e.child(r),o=t.child(r);if(i!=o){if(!i.sameMarkup(o))return n;if(i.isText&&i.text!=o.text){for(let e=0;i.text[e]==o.text[e];e++)n++;return n}if(i.content.size||o.content.size){let e=ws(i.content,o.content,n+1);if(null!=e)return e}n+=i.nodeSize;}else n+=i.nodeSize;}}function ks(e,t,n,r){for(let i=e.childCount,o=t.childCount;;){if(0==i||0==o)return i==o?null:{a:n,b:r};let s=e.child(--i),a=t.child(--o),l=s.nodeSize;if(s!=a){if(!s.sameMarkup(a))return {a:n,b:r};if(s.isText&&s.text!=a.text){let e=0,t=Math.min(s.text.length,a.text.length);for(;e<t&&s.text[s.text.length-e-1]==a.text[a.text.length-e-1];)e++,n--,r--;return {a:n,b:r}}if(s.content.size||a.content.size){let e=ks(s.content,a.content,n-1,r-1);if(e)return e}n-=l,r-=l;}else n-=l,r-=l;}}Xo("replace",(function(e,t,n){var r=ys?"$":"$0";return [function(e,n){var r=is(this),i=null==e?void 0:as(e,us);return i?Jo(i,e,r,n):Jo(t,rs(r),e,n)},function(e,i){var o=Yo(this),s=rs(e);if("string"==typeof i&&-1===ms(i,r)&&-1===ms(i,"$<")){var a=n(t,o,s,i);if(a.done)return a.value}var l=es(i);l||(i=rs(i));var c=o.global;if(c){var u=o.unicode;o.lastIndex=0;}for(var d=[];;){var h=cs(o,s);if(null===h)break;if(fs(d,h),!c)break;""===rs(h[0])&&(o.lastIndex=ss(s,ns(o.lastIndex),u));}for(var p,f="",m=0,g=0;g<d.length;g++){for(var v=rs((h=d[g])[0]),y=ds(hs(ts(h.index),s.length),0),b=[],w=1;w<h.length;w++)fs(b,void 0===(p=h[w])?p:String(p));var k=h.groups;if(l){var C=ps([v],b,y,s);void 0!==k&&fs(C,k);var E=rs(Go(i,void 0,C));}else E=ls(v,s,y,b,k,i);y>=m&&(f+=gs(s,m,y)+E,m=y+v.length);}return f+gs(s,m)}]}),!!Qo((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!vs||ys),bs.prototype={constructor:bs,find:function(e){for(var t=0;t<this.content.length;t+=2)if(this.content[t]===e)return t;return -1},get:function(e){var t=this.find(e);return -1==t?void 0:this.content[t+1]},update:function(e,t,n){var r=n&&n!=e?this.remove(n):this,i=r.find(e),o=r.content.slice();return -1==i?o.push(n||e,t):(o[i+1]=t,n&&(o[i]=n)),new bs(o)},remove:function(e){var t=this.find(e);if(-1==t)return this;var n=this.content.slice();return n.splice(t,2),new bs(n)},addToStart:function(e,t){return new bs([e,t].concat(this.remove(e).content))},addToEnd:function(e,t){var n=this.remove(e).content.slice();return n.push(e,t),new bs(n)},addBefore:function(e,t,n){var r=this.remove(t),i=r.content.slice(),o=r.find(e);return i.splice(-1==o?i.length:o,0,t,n),new bs(i)},forEach:function(e){for(var t=0;t<this.content.length;t+=2)e(this.content[t],this.content[t+1]);},prepend:function(e){return (e=bs.from(e)).size?new bs(e.content.concat(this.subtract(e).content)):this},append:function(e){return (e=bs.from(e)).size?new bs(this.subtract(e).content.concat(e.content)):this},subtract:function(e){var t=this;e=bs.from(e);for(var n=0;n<e.content.length;n+=2)t=t.remove(e.content[n]);return t},get size(){return this.content.length>>1}},bs.from=function(e){if(e instanceof bs)return e;var t=[];if(e)for(var n in e)t.push(n,e[n]);return new bs(t)};class Cs{constructor(e,t){if(this.content=e,this.size=t||0,null==t)for(let t=0;t<e.length;t++)this.size+=e[t].nodeSize;}nodesBetween(e,t,n,r=0,i){for(let o=0,s=0;s<t;o++){let a=this.content[o],l=s+a.nodeSize;if(l>e&&!1!==n(a,r+s,i||null,o)&&a.content.size){let i=s+1;a.nodesBetween(Math.max(0,e-i),Math.min(a.content.size,t-i),n,r+i);}s=l;}}descendants(e){this.nodesBetween(0,this.size,e);}textBetween(e,t,n,r){let i="",o=!0;return this.nodesBetween(e,t,((s,a)=>{s.isText?(i+=s.text.slice(Math.max(e,a)-a,t-a),o=!n):s.isLeaf?(r?i+="function"==typeof r?r(s):r:s.type.spec.leafText&&(i+=s.type.spec.leafText(s)),o=!n):!o&&s.isBlock&&(i+=n,o=!0);}),0),i}append(e){if(!e.size)return this;if(!this.size)return e;let t=this.lastChild,n=e.firstChild,r=this.content.slice(),i=0;for(t.isText&&t.sameMarkup(n)&&(r[r.length-1]=t.withText(t.text+n.text),i=1);i<e.content.length;i++)r.push(e.content[i]);return new Cs(r,this.size+e.size)}cut(e,t=this.size){if(0==e&&t==this.size)return this;let n=[],r=0;if(t>e)for(let i=0,o=0;o<t;i++){let s=this.content[i],a=o+s.nodeSize;a>e&&((o<e||a>t)&&(s=s.isText?s.cut(Math.max(0,e-o),Math.min(s.text.length,t-o)):s.cut(Math.max(0,e-o-1),Math.min(s.content.size,t-o-1))),n.push(s),r+=s.nodeSize),o=a;}return new Cs(n,r)}cutByIndex(e,t){return e==t?Cs.empty:0==e&&t==this.content.length?this:new Cs(this.content.slice(e,t))}replaceChild(e,t){let n=this.content[e];if(n==t)return this;let r=this.content.slice(),i=this.size+t.nodeSize-n.nodeSize;return r[e]=t,new Cs(r,i)}addToStart(e){return new Cs([e].concat(this.content),this.size+e.nodeSize)}addToEnd(e){return new Cs(this.content.concat(e),this.size+e.nodeSize)}eq(e){if(this.content.length!=e.content.length)return !1;for(let t=0;t<this.content.length;t++)if(!this.content[t].eq(e.content[t]))return !1;return !0}get firstChild(){return this.content.length?this.content[0]:null}get lastChild(){return this.content.length?this.content[this.content.length-1]:null}get childCount(){return this.content.length}child(e){let t=this.content[e];if(!t)throw new RangeError("Index "+e+" out of range for "+this);return t}maybeChild(e){return this.content[e]||null}forEach(e){for(let t=0,n=0;t<this.content.length;t++){let r=this.content[t];e(r,n,t),n+=r.nodeSize;}}findDiffStart(e,t=0){return ws(this,e,t)}findDiffEnd(e,t=this.size,n=e.size){return ks(this,e,t,n)}findIndex(e,t=-1){if(0==e)return xs(0,e);if(e==this.size)return xs(this.content.length,e);if(e>this.size||e<0)throw new RangeError(`Position ${e} outside of fragment (${this})`);for(let n=0,r=0;;n++){let i=r+this.child(n).nodeSize;if(i>=e)return i==e||t>0?xs(n+1,i):xs(n,r);r=i;}}toString(){return "<"+this.toStringInner()+">"}toStringInner(){return this.content.join(", ")}toJSON(){return this.content.length?this.content.map((e=>e.toJSON())):null}static fromJSON(e,t){if(!t)return Cs.empty;if(!Array.isArray(t))throw new RangeError("Invalid input for Fragment.fromJSON");return new Cs(t.map(e.nodeFromJSON))}static fromArray(e){if(!e.length)return Cs.empty;let t,n=0;for(let r=0;r<e.length;r++){let i=e[r];n+=i.nodeSize,r&&i.isText&&e[r-1].sameMarkup(i)?(t||(t=e.slice(0,r)),t[t.length-1]=i.withText(t[t.length-1].text+i.text)):t&&t.push(i);}return new Cs(t||e,n)}static from(e){if(!e)return Cs.empty;if(e instanceof Cs)return e;if(Array.isArray(e))return this.fromArray(e);if(e.attrs)return new Cs([e],e.nodeSize);throw new RangeError("Can not convert "+e+" to a Fragment"+(e.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}Cs.empty=new Cs([],0);const Es={index:0,offset:0};function xs(e,t){return Es.index=e,Es.offset=t,Es}function Ss(e,t){if(e===t)return !0;if(!e||"object"!=typeof e||!t||"object"!=typeof t)return !1;let n=Array.isArray(e);if(Array.isArray(t)!=n)return !1;if(n){if(e.length!=t.length)return !1;for(let n=0;n<e.length;n++)if(!Ss(e[n],t[n]))return !1}else {for(let n in e)if(!(n in t)||!Ss(e[n],t[n]))return !1;for(let n in t)if(!(n in e))return !1}return !0}class Ds{constructor(e,t){this.type=e,this.attrs=t;}addToSet(e){let t,n=!1;for(let r=0;r<e.length;r++){let i=e[r];if(this.eq(i))return e;if(this.type.excludes(i.type))t||(t=e.slice(0,r));else {if(i.type.excludes(this.type))return e;!n&&i.type.rank>this.type.rank&&(t||(t=e.slice(0,r)),t.push(this),n=!0),t&&t.push(i);}}return t||(t=e.slice()),n||t.push(this),t}removeFromSet(e){for(let t=0;t<e.length;t++)if(this.eq(e[t]))return e.slice(0,t).concat(e.slice(t+1));return e}isInSet(e){for(let t=0;t<e.length;t++)if(this.eq(e[t]))return !0;return !1}eq(e){return this==e||this.type==e.type&&Ss(this.attrs,e.attrs)}toJSON(){let e={type:this.type.name};for(let t in this.attrs){e.attrs=this.attrs;break}return e}static fromJSON(e,t){if(!t)throw new RangeError("Invalid input for Mark.fromJSON");let n=e.marks[t.type];if(!n)throw new RangeError(`There is no mark type ${t.type} in this schema`);return n.create(t.attrs)}static sameSet(e,t){if(e==t)return !0;if(e.length!=t.length)return !1;for(let n=0;n<e.length;n++)if(!e[n].eq(t[n]))return !1;return !0}static setFrom(e){if(!e||Array.isArray(e)&&0==e.length)return Ds.none;if(e instanceof Ds)return [e];let t=e.slice();return t.sort(((e,t)=>e.type.rank-t.type.rank)),t}}Ds.none=[];class Ms extends Error{}class Os{constructor(e,t,n){this.content=e,this.openStart=t,this.openEnd=n;}get size(){return this.content.size-this.openStart-this.openEnd}insertAt(e,t){let n=Ns(this.content,e+this.openStart,t);return n&&new Os(n,this.openStart,this.openEnd)}removeBetween(e,t){return new Os(As(this.content,e+this.openStart,t+this.openStart),this.openStart,this.openEnd)}eq(e){return this.content.eq(e.content)&&this.openStart==e.openStart&&this.openEnd==e.openEnd}toString(){return this.content+"("+this.openStart+","+this.openEnd+")"}toJSON(){if(!this.content.size)return null;let e={content:this.content.toJSON()};return this.openStart>0&&(e.openStart=this.openStart),this.openEnd>0&&(e.openEnd=this.openEnd),e}static fromJSON(e,t){if(!t)return Os.empty;let n=t.openStart||0,r=t.openEnd||0;if("number"!=typeof n||"number"!=typeof r)throw new RangeError("Invalid input for Slice.fromJSON");return new Os(Cs.fromJSON(e,t.content),n,r)}static maxOpen(e,t=!0){let n=0,r=0;for(let r=e.firstChild;r&&!r.isLeaf&&(t||!r.type.spec.isolating);r=r.firstChild)n++;for(let n=e.lastChild;n&&!n.isLeaf&&(t||!n.type.spec.isolating);n=n.lastChild)r++;return new Os(e,n,r)}}function As(e,t,n){let{index:r,offset:i}=e.findIndex(t),o=e.maybeChild(r),{index:s,offset:a}=e.findIndex(n);if(i==t||o.isText){if(a!=n&&!e.child(s).isText)throw new RangeError("Removing non-flat range");return e.cut(0,t).append(e.cut(n))}if(r!=s)throw new RangeError("Removing non-flat range");return e.replaceChild(r,o.copy(As(o.content,t-i-1,n-i-1)))}function Ns(e,t,n,r){let{index:i,offset:o}=e.findIndex(t),s=e.maybeChild(i);if(o==t||s.isText)return r&&!r.canReplace(i,i,n)?null:e.cut(0,t).append(n).append(e.cut(t));let a=Ns(s.content,t-o-1,n);return a&&e.replaceChild(i,s.copy(a))}function _s(e,t,n){if(n.openStart>e.depth)throw new Ms("Inserted content deeper than insertion position");if(e.depth-n.openStart!=t.depth-n.openEnd)throw new Ms("Inconsistent open depths");return Ts(e,t,n,0)}function Ts(e,t,n,r){let i=e.index(r),o=e.node(r);if(i==t.index(r)&&r<e.depth-n.openStart){let s=Ts(e,t,n,r+1);return o.copy(o.content.replaceChild(i,s))}if(n.content.size){if(n.openStart||n.openEnd||e.depth!=r||t.depth!=r){let{start:i,end:s}=function(e,t){let n=t.depth-e.openStart,r=t.node(n).copy(e.content);for(let e=n-1;e>=0;e--)r=t.node(e).copy(Cs.from(r));return {start:r.resolveNoCache(e.openStart+n),end:r.resolveNoCache(r.content.size-e.openEnd-n)}}(n,e);return Is(o,Ps(e,i,s,t,r))}{let r=e.parent,i=r.content;return Is(r,i.cut(0,e.parentOffset).append(n.content).append(i.cut(t.parentOffset)))}}return Is(o,zs(e,t,r))}function Ls(e,t){if(!t.type.compatibleContent(e.type))throw new Ms("Cannot join "+t.type.name+" onto "+e.type.name)}function Rs(e,t,n){let r=e.node(n);return Ls(r,t.node(n)),r}function Fs(e,t){let n=t.length-1;n>=0&&e.isText&&e.sameMarkup(t[n])?t[n]=e.withText(t[n].text+e.text):t.push(e);}function Bs(e,t,n,r){let i=(t||e).node(n),o=0,s=t?t.index(n):i.childCount;e&&(o=e.index(n),e.depth>n?o++:e.textOffset&&(Fs(e.nodeAfter,r),o++));for(let e=o;e<s;e++)Fs(i.child(e),r);t&&t.depth==n&&t.textOffset&&Fs(t.nodeBefore,r);}function Is(e,t){if(!e.type.validContent(t))throw new Ms("Invalid content for node "+e.type.name);return e.copy(t)}function Ps(e,t,n,r,i){let o=e.depth>i&&Rs(e,t,i+1),s=r.depth>i&&Rs(n,r,i+1),a=[];return Bs(null,e,i,a),o&&s&&t.index(i)==n.index(i)?(Ls(o,s),Fs(Is(o,Ps(e,t,n,r,i+1)),a)):(o&&Fs(Is(o,zs(e,t,i+1)),a),Bs(t,n,i,a),s&&Fs(Is(s,zs(n,r,i+1)),a)),Bs(r,null,i,a),new Cs(a)}function zs(e,t,n){let r=[];if(Bs(null,e,n,r),e.depth>n){Fs(Is(Rs(e,t,n+1),zs(e,t,n+1)),r);}return Bs(t,null,n,r),new Cs(r)}Os.empty=new Os(Cs.empty,0,0);class $s{constructor(e,t,n){this.pos=e,this.path=t,this.parentOffset=n,this.depth=t.length/3-1;}resolveDepth(e){return null==e?this.depth:e<0?this.depth+e:e}get parent(){return this.node(this.depth)}get doc(){return this.node(0)}node(e){return this.path[3*this.resolveDepth(e)]}index(e){return this.path[3*this.resolveDepth(e)+1]}indexAfter(e){return e=this.resolveDepth(e),this.index(e)+(e!=this.depth||this.textOffset?1:0)}start(e){return 0==(e=this.resolveDepth(e))?0:this.path[3*e-1]+1}end(e){return e=this.resolveDepth(e),this.start(e)+this.node(e).content.size}before(e){if(!(e=this.resolveDepth(e)))throw new RangeError("There is no position before the top-level node");return e==this.depth+1?this.pos:this.path[3*e-1]}after(e){if(!(e=this.resolveDepth(e)))throw new RangeError("There is no position after the top-level node");return e==this.depth+1?this.pos:this.path[3*e-1]+this.path[3*e].nodeSize}get textOffset(){return this.pos-this.path[this.path.length-1]}get nodeAfter(){let e=this.parent,t=this.index(this.depth);if(t==e.childCount)return null;let n=this.pos-this.path[this.path.length-1],r=e.child(t);return n?e.child(t).cut(n):r}get nodeBefore(){let e=this.index(this.depth),t=this.pos-this.path[this.path.length-1];return t?this.parent.child(e).cut(0,t):0==e?null:this.parent.child(e-1)}posAtIndex(e,t){t=this.resolveDepth(t);let n=this.path[3*t],r=0==t?0:this.path[3*t-1]+1;for(let t=0;t<e;t++)r+=n.child(t).nodeSize;return r}marks(){let e=this.parent,t=this.index();if(0==e.content.size)return Ds.none;if(this.textOffset)return e.child(t).marks;let n=e.maybeChild(t-1),r=e.maybeChild(t);if(!n){let e=n;n=r,r=e;}let i=n.marks;for(var o=0;o<i.length;o++)!1!==i[o].type.spec.inclusive||r&&i[o].isInSet(r.marks)||(i=i[o--].removeFromSet(i));return i}marksAcross(e){let t=this.parent.maybeChild(this.index());if(!t||!t.isInline)return null;let n=t.marks,r=e.parent.maybeChild(e.index());for(var i=0;i<n.length;i++)!1!==n[i].type.spec.inclusive||r&&n[i].isInSet(r.marks)||(n=n[i--].removeFromSet(n));return n}sharedDepth(e){for(let t=this.depth;t>0;t--)if(this.start(t)<=e&&this.end(t)>=e)return t;return 0}blockRange(e=this,t){if(e.pos<this.pos)return e.blockRange(this);for(let n=this.depth-(this.parent.inlineContent||this.pos==e.pos?1:0);n>=0;n--)if(e.pos<=this.end(n)&&(!t||t(this.node(n))))return new Ks(this,e,n);return null}sameParent(e){return this.pos-this.parentOffset==e.pos-e.parentOffset}max(e){return e.pos>this.pos?e:this}min(e){return e.pos<this.pos?e:this}toString(){let e="";for(let t=1;t<=this.depth;t++)e+=(e?"/":"")+this.node(t).type.name+"_"+this.index(t-1);return e+":"+this.parentOffset}static resolve(e,t){if(!(t>=0&&t<=e.content.size))throw new RangeError("Position "+t+" out of range");let n=[],r=0,i=t;for(let t=e;;){let{index:e,offset:o}=t.content.findIndex(i),s=i-o;if(n.push(t,e,r+o),!s)break;if(t=t.child(e),t.isText)break;i=s-1,r+=o+1;}return new $s(t,n,i)}static resolveCached(e,t){for(let n=0;n<js.length;n++){let r=js[n];if(r.pos==t&&r.doc==e)return r}let n=js[Hs]=$s.resolve(e,t);return Hs=(Hs+1)%Vs,n}}let js=[],Hs=0,Vs=12;class Ks{constructor(e,t,n){this.$from=e,this.$to=t,this.depth=n;}get start(){return this.$from.before(this.depth+1)}get end(){return this.$to.after(this.depth+1)}get parent(){return this.$from.node(this.depth)}get startIndex(){return this.$from.index(this.depth)}get endIndex(){return this.$to.indexAfter(this.depth)}}const qs=Object.create(null);class Us{constructor(e,t,n,r=Ds.none){this.type=e,this.attrs=t,this.marks=r,this.content=n||Cs.empty;}get nodeSize(){return this.isLeaf?1:2+this.content.size}get childCount(){return this.content.childCount}child(e){return this.content.child(e)}maybeChild(e){return this.content.maybeChild(e)}forEach(e){this.content.forEach(e);}nodesBetween(e,t,n,r=0){this.content.nodesBetween(e,t,n,r,this);}descendants(e){this.nodesBetween(0,this.content.size,e);}get textContent(){return this.isLeaf&&this.type.spec.leafText?this.type.spec.leafText(this):this.textBetween(0,this.content.size,"")}textBetween(e,t,n,r){return this.content.textBetween(e,t,n,r)}get firstChild(){return this.content.firstChild}get lastChild(){return this.content.lastChild}eq(e){return this==e||this.sameMarkup(e)&&this.content.eq(e.content)}sameMarkup(e){return this.hasMarkup(e.type,e.attrs,e.marks)}hasMarkup(e,t,n){return this.type==e&&Ss(this.attrs,t||e.defaultAttrs||qs)&&Ds.sameSet(this.marks,n||Ds.none)}copy(e=null){return e==this.content?this:new Us(this.type,this.attrs,e,this.marks)}mark(e){return e==this.marks?this:new Us(this.type,this.attrs,this.content,e)}cut(e,t=this.content.size){return 0==e&&t==this.content.size?this:this.copy(this.content.cut(e,t))}slice(e,t=this.content.size,n=!1){if(e==t)return Os.empty;let r=this.resolve(e),i=this.resolve(t),o=n?0:r.sharedDepth(t),s=r.start(o),a=r.node(o).content.cut(r.pos-s,i.pos-s);return new Os(a,r.depth-o,i.depth-o)}replace(e,t,n){return _s(this.resolve(e),this.resolve(t),n)}nodeAt(e){for(let t=this;;){let{index:n,offset:r}=t.content.findIndex(e);if(t=t.maybeChild(n),!t)return null;if(r==e||t.isText)return t;e-=r+1;}}childAfter(e){let{index:t,offset:n}=this.content.findIndex(e);return {node:this.content.maybeChild(t),index:t,offset:n}}childBefore(e){if(0==e)return {node:null,index:0,offset:0};let{index:t,offset:n}=this.content.findIndex(e);if(n<e)return {node:this.content.child(t),index:t,offset:n};let r=this.content.child(t-1);return {node:r,index:t-1,offset:n-r.nodeSize}}resolve(e){return $s.resolveCached(this,e)}resolveNoCache(e){return $s.resolve(this,e)}rangeHasMark(e,t,n){let r=!1;return t>e&&this.nodesBetween(e,t,(e=>(n.isInSet(e.marks)&&(r=!0),!r))),r}get isBlock(){return this.type.isBlock}get isTextblock(){return this.type.isTextblock}get inlineContent(){return this.type.inlineContent}get isInline(){return this.type.isInline}get isText(){return this.type.isText}get isLeaf(){return this.type.isLeaf}get isAtom(){return this.type.isAtom}toString(){if(this.type.spec.toDebugString)return this.type.spec.toDebugString(this);let e=this.type.name;return this.content.size&&(e+="("+this.content.toStringInner()+")"),Gs(this.marks,e)}contentMatchAt(e){let t=this.type.contentMatch.matchFragment(this.content,0,e);if(!t)throw new Error("Called contentMatchAt on a node with invalid content");return t}canReplace(e,t,n=Cs.empty,r=0,i=n.childCount){let o=this.contentMatchAt(e).matchFragment(n,r,i),s=o&&o.matchFragment(this.content,t);if(!s||!s.validEnd)return !1;for(let e=r;e<i;e++)if(!this.type.allowsMarks(n.child(e).marks))return !1;return !0}canReplaceWith(e,t,n,r){if(r&&!this.type.allowsMarks(r))return !1;let i=this.contentMatchAt(e).matchType(n),o=i&&i.matchFragment(this.content,t);return !!o&&o.validEnd}canAppend(e){return e.content.size?this.canReplace(this.childCount,this.childCount,e.content):this.type.compatibleContent(e.type)}check(){if(!this.type.validContent(this.content))throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0,50)}`);let e=Ds.none;for(let t=0;t<this.marks.length;t++)e=this.marks[t].addToSet(e);if(!Ds.sameSet(e,this.marks))throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((e=>e.type.name))}`);this.content.forEach((e=>e.check()));}toJSON(){let e={type:this.type.name};for(let t in this.attrs){e.attrs=this.attrs;break}return this.content.size&&(e.content=this.content.toJSON()),this.marks.length&&(e.marks=this.marks.map((e=>e.toJSON()))),e}static fromJSON(e,t){if(!t)throw new RangeError("Invalid input for Node.fromJSON");let n=null;if(t.marks){if(!Array.isArray(t.marks))throw new RangeError("Invalid mark data for Node.fromJSON");n=t.marks.map(e.markFromJSON);}if("text"==t.type){if("string"!=typeof t.text)throw new RangeError("Invalid text node in JSON");return e.text(t.text,n)}let r=Cs.fromJSON(e,t.content);return e.nodeType(t.type).create(t.attrs,r,n)}}Us.prototype.text=void 0;class Ws extends Us{constructor(e,t,n,r){if(super(e,t,null,r),!n)throw new RangeError("Empty text nodes are not allowed");this.text=n;}toString(){return this.type.spec.toDebugString?this.type.spec.toDebugString(this):Gs(this.marks,JSON.stringify(this.text))}get textContent(){return this.text}textBetween(e,t){return this.text.slice(e,t)}get nodeSize(){return this.text.length}mark(e){return e==this.marks?this:new Ws(this.type,this.attrs,this.text,e)}withText(e){return e==this.text?this:new Ws(this.type,this.attrs,e,this.marks)}cut(e=0,t=this.text.length){return 0==e&&t==this.text.length?this:this.withText(this.text.slice(e,t))}eq(e){return this.sameMarkup(e)&&this.text==e.text}toJSON(){let e=super.toJSON();return e.text=this.text,e}}function Gs(e,t){for(let n=e.length-1;n>=0;n--)t=e[n].type.name+"("+t+")";return t}class Js{constructor(e){this.validEnd=e,this.next=[],this.wrapCache=[];}static parse(e,t){let n=new Zs(e,t);if(null==n.next)return Js.empty;let r=Xs(n);n.next&&n.err("Unexpected trailing text");let i=function(e){let t=Object.create(null);return n(ra(e,0));function n(r){let i=[];r.forEach((t=>{e[t].forEach((({term:t,to:n})=>{if(!t)return;let r;for(let e=0;e<i.length;e++)i[e][0]==t&&(r=i[e][1]);ra(e,n).forEach((e=>{r||i.push([t,r=[]]),-1==r.indexOf(e)&&r.push(e);}));}));}));let o=t[r.join(",")]=new Js(r.indexOf(e.length-1)>-1);for(let e=0;e<i.length;e++){let r=i[e][1].sort(na);o.next.push({type:i[e][0],next:t[r.join(",")]||n(r)});}return o}}(function(e){let t=[[]];return i(o(e,0),n()),t;function n(){return t.push([])-1}function r(e,n,r){let i={term:r,to:n};return t[e].push(i),i}function i(e,t){e.forEach((e=>e.to=t));}function o(e,t){if("choice"==e.type)return e.exprs.reduce(((e,n)=>e.concat(o(n,t))),[]);if("seq"!=e.type){if("star"==e.type){let s=n();return r(t,s),i(o(e.expr,s),s),[r(s)]}if("plus"==e.type){let s=n();return i(o(e.expr,t),s),i(o(e.expr,s),s),[r(s)]}if("opt"==e.type)return [r(t)].concat(o(e.expr,t));if("range"==e.type){let s=t;for(let t=0;t<e.min;t++){let t=n();i(o(e.expr,s),t),s=t;}if(-1==e.max)i(o(e.expr,s),s);else for(let t=e.min;t<e.max;t++){let t=n();r(s,t),i(o(e.expr,s),t),s=t;}return [r(s)]}if("name"==e.type)return [r(t,void 0,e.value)];throw new Error("Unknown expr type")}for(let r=0;;r++){let s=o(e.exprs[r],t);if(r==e.exprs.length-1)return s;i(s,t=n());}}}(r));return function(e,t){for(let n=0,r=[e];n<r.length;n++){let e=r[n],i=!e.validEnd,o=[];for(let t=0;t<e.next.length;t++){let{type:n,next:s}=e.next[t];o.push(n.name),!i||n.isText||n.hasRequiredAttrs()||(i=!1),-1==r.indexOf(s)&&r.push(s);}i&&t.err("Only non-generatable nodes ("+o.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)");}}(i,n),i}matchType(e){for(let t=0;t<this.next.length;t++)if(this.next[t].type==e)return this.next[t].next;return null}matchFragment(e,t=0,n=e.childCount){let r=this;for(let i=t;r&&i<n;i++)r=r.matchType(e.child(i).type);return r}get inlineContent(){return this.next.length&&this.next[0].type.isInline}get defaultType(){for(let e=0;e<this.next.length;e++){let{type:t}=this.next[e];if(!t.isText&&!t.hasRequiredAttrs())return t}return null}compatible(e){for(let t=0;t<this.next.length;t++)for(let n=0;n<e.next.length;n++)if(this.next[t].type==e.next[n].type)return !0;return !1}fillBefore(e,t=!1,n=0){let r=[this];return function i(o,s){let a=o.matchFragment(e,n);if(a&&(!t||a.validEnd))return Cs.from(s.map((e=>e.createAndFill())));for(let e=0;e<o.next.length;e++){let{type:t,next:n}=o.next[e];if(!t.isText&&!t.hasRequiredAttrs()&&-1==r.indexOf(n)){r.push(n);let e=i(n,s.concat(t));if(e)return e}}return null}(this,[])}findWrapping(e){for(let t=0;t<this.wrapCache.length;t+=2)if(this.wrapCache[t]==e)return this.wrapCache[t+1];let t=this.computeWrapping(e);return this.wrapCache.push(e,t),t}computeWrapping(e){let t=Object.create(null),n=[{match:this,type:null,via:null}];for(;n.length;){let r=n.shift(),i=r.match;if(i.matchType(e)){let e=[];for(let t=r;t.type;t=t.via)e.push(t.type);return e.reverse()}for(let e=0;e<i.next.length;e++){let{type:o,next:s}=i.next[e];o.isLeaf||o.hasRequiredAttrs()||o.name in t||r.type&&!s.validEnd||(n.push({match:o.contentMatch,type:o,via:r}),t[o.name]=!0);}}return null}get edgeCount(){return this.next.length}edge(e){if(e>=this.next.length)throw new RangeError(`There's no ${e}th edge in this content match`);return this.next[e]}toString(){let e=[];return function t(n){e.push(n);for(let r=0;r<n.next.length;r++)-1==e.indexOf(n.next[r].next)&&t(n.next[r].next);}(this),e.map(((t,n)=>{let r=n+(t.validEnd?"*":" ")+" ";for(let n=0;n<t.next.length;n++)r+=(n?", ":"")+t.next[n].type.name+"->"+e.indexOf(t.next[n].next);return r})).join("\n")}}Js.empty=new Js(!0);class Zs{constructor(e,t){this.string=e,this.nodeTypes=t,this.inline=null,this.pos=0,this.tokens=e.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&&this.tokens.pop(),""==this.tokens[0]&&this.tokens.shift();}get next(){return this.tokens[this.pos]}eat(e){return this.next==e&&(this.pos++||!0)}err(e){throw new SyntaxError(e+" (in content expression '"+this.string+"')")}}function Xs(e){let t=[];do{t.push(Qs(e));}while(e.eat("|"));return 1==t.length?t[0]:{type:"choice",exprs:t}}function Qs(e){let t=[];do{t.push(Ys(e));}while(e.next&&")"!=e.next&&"|"!=e.next);return 1==t.length?t[0]:{type:"seq",exprs:t}}function Ys(e){let t=function(e){if(e.eat("(")){let t=Xs(e);return e.eat(")")||e.err("Missing closing paren"),t}if(!/\W/.test(e.next)){let t=function(e,t){let n=e.nodeTypes,r=n[t];if(r)return [r];let i=[];for(let e in n){let r=n[e];r.groups.indexOf(t)>-1&&i.push(r);}0==i.length&&e.err("No node type or group '"+t+"' found");return i}(e,e.next).map((t=>(null==e.inline?e.inline=t.isInline:e.inline!=t.isInline&&e.err("Mixing inline and block content"),{type:"name",value:t})));return e.pos++,1==t.length?t[0]:{type:"choice",exprs:t}}e.err("Unexpected token '"+e.next+"'");}(e);for(;;)if(e.eat("+"))t={type:"plus",expr:t};else if(e.eat("*"))t={type:"star",expr:t};else if(e.eat("?"))t={type:"opt",expr:t};else {if(!e.eat("{"))break;t=ta(e,t);}return t}function ea(e){/\D/.test(e.next)&&e.err("Expected number, got '"+e.next+"'");let t=Number(e.next);return e.pos++,t}function ta(e,t){let n=ea(e),r=n;return e.eat(",")&&(r="}"!=e.next?ea(e):-1),e.eat("}")||e.err("Unclosed braced range"),{type:"range",min:n,max:r,expr:t}}function na(e,t){return t-e}function ra(e,t){let n=[];return function t(r){let i=e[r];if(1==i.length&&!i[0].term)return t(i[0].to);n.push(r);for(let e=0;e<i.length;e++){let{term:r,to:o}=i[e];r||-1!=n.indexOf(o)||t(o);}}(t),n.sort(na)}function ia(e){let t=Object.create(null);for(let n in e){let r=e[n];if(!r.hasDefault)return null;t[n]=r.default;}return t}function oa(e,t){let n=Object.create(null);for(let r in e){let i=t&&t[r];if(void 0===i){let t=e[r];if(!t.hasDefault)throw new RangeError("No value supplied for attribute "+r);i=t.default;}n[r]=i;}return n}function sa(e){let t=Object.create(null);if(e)for(let n in e)t[n]=new la(e[n]);return t}class aa{constructor(e,t,n){this.name=e,this.schema=t,this.spec=n,this.markSet=null,this.groups=n.group?n.group.split(" "):[],this.attrs=sa(n.attrs),this.defaultAttrs=ia(this.attrs),this.contentMatch=null,this.inlineContent=null,this.isBlock=!(n.inline||"text"==e),this.isText="text"==e;}get isInline(){return !this.isBlock}get isTextblock(){return this.isBlock&&this.inlineContent}get isLeaf(){return this.contentMatch==Js.empty}get isAtom(){return this.isLeaf||!!this.spec.atom}get whitespace(){return this.spec.whitespace||(this.spec.code?"pre":"normal")}hasRequiredAttrs(){for(let e in this.attrs)if(this.attrs[e].isRequired)return !0;return !1}compatibleContent(e){return this==e||this.contentMatch.compatible(e.contentMatch)}computeAttrs(e){return !e&&this.defaultAttrs?this.defaultAttrs:oa(this.attrs,e)}create(e=null,t,n){if(this.isText)throw new Error("NodeType.create can't construct text nodes");return new Us(this,this.computeAttrs(e),Cs.from(t),Ds.setFrom(n))}createChecked(e=null,t,n){if(t=Cs.from(t),!this.validContent(t))throw new RangeError("Invalid content for node "+this.name);return new Us(this,this.computeAttrs(e),t,Ds.setFrom(n))}createAndFill(e=null,t,n){if(e=this.computeAttrs(e),(t=Cs.from(t)).size){let e=this.contentMatch.fillBefore(t);if(!e)return null;t=e.append(t);}let r=this.contentMatch.matchFragment(t),i=r&&r.fillBefore(Cs.empty,!0);return i?new Us(this,e,t.append(i),Ds.setFrom(n)):null}validContent(e){let t=this.contentMatch.matchFragment(e);if(!t||!t.validEnd)return !1;for(let t=0;t<e.childCount;t++)if(!this.allowsMarks(e.child(t).marks))return !1;return !0}allowsMarkType(e){return null==this.markSet||this.markSet.indexOf(e)>-1}allowsMarks(e){if(null==this.markSet)return !0;for(let t=0;t<e.length;t++)if(!this.allowsMarkType(e[t].type))return !1;return !0}allowedMarks(e){if(null==this.markSet)return e;let t;for(let n=0;n<e.length;n++)this.allowsMarkType(e[n].type)?t&&t.push(e[n]):t||(t=e.slice(0,n));return t?t.length?t:Ds.none:e}static compile(e,t){let n=Object.create(null);e.forEach(((e,r)=>n[e]=new aa(e,t,r)));let r=t.spec.topNode||"doc";if(!n[r])throw new RangeError("Schema is missing its top node type ('"+r+"')");if(!n.text)throw new RangeError("Every schema needs a 'text' type");for(let e in n.text.attrs)throw new RangeError("The text node type should not have attributes");return n}}class la{constructor(e){this.hasDefault=Object.prototype.hasOwnProperty.call(e,"default"),this.default=e.default;}get isRequired(){return !this.hasDefault}}class ca{constructor(e,t,n,r){this.name=e,this.rank=t,this.schema=n,this.spec=r,this.attrs=sa(r.attrs),this.excluded=null;let i=ia(this.attrs);this.instance=i?new Ds(this,i):null;}create(e=null){return !e&&this.instance?this.instance:new Ds(this,oa(this.attrs,e))}static compile(e,t){let n=Object.create(null),r=0;return e.forEach(((e,i)=>n[e]=new ca(e,r++,t,i))),n}removeFromSet(e){for(var t=0;t<e.length;t++)e[t].type==this&&(e=e.slice(0,t).concat(e.slice(t+1)),t--);return e}isInSet(e){for(let t=0;t<e.length;t++)if(e[t].type==this)return e[t]}excludes(e){return this.excluded.indexOf(e)>-1}}class ua{constructor(e){this.cached=Object.create(null),this.spec={nodes:bs.from(e.nodes),marks:bs.from(e.marks||{}),topNode:e.topNode},this.nodes=aa.compile(this.spec.nodes,this),this.marks=ca.compile(this.spec.marks,this);let t=Object.create(null);for(let e in this.nodes){if(e in this.marks)throw new RangeError(e+" can not be both a node and a mark");let n=this.nodes[e],r=n.spec.content||"",i=n.spec.marks;n.contentMatch=t[r]||(t[r]=Js.parse(r,this.nodes)),n.inlineContent=n.contentMatch.inlineContent,n.markSet="_"==i?null:i?da(this,i.split(" ")):""!=i&&n.inlineContent?null:[];}for(let e in this.marks){let t=this.marks[e],n=t.spec.excludes;t.excluded=null==n?[t]:""==n?[]:da(this,n.split(" "));}this.nodeFromJSON=this.nodeFromJSON.bind(this),this.markFromJSON=this.markFromJSON.bind(this),this.topNodeType=this.nodes[this.spec.topNode||"doc"],this.cached.wrappings=Object.create(null);}node(e,t=null,n,r){if("string"==typeof e)e=this.nodeType(e);else {if(!(e instanceof aa))throw new RangeError("Invalid node type: "+e);if(e.schema!=this)throw new RangeError("Node type from different schema used ("+e.name+")")}return e.createChecked(t,n,r)}text(e,t){let n=this.nodes.text;return new Ws(n,n.defaultAttrs,e,Ds.setFrom(t))}mark(e,t){return "string"==typeof e&&(e=this.marks[e]),e.create(t)}nodeFromJSON(e){return Us.fromJSON(this,e)}markFromJSON(e){return Ds.fromJSON(this,e)}nodeType(e){let t=this.nodes[e];if(!t)throw new RangeError("Unknown node type: "+e);return t}}function da(e,t){let n=[];for(let r=0;r<t.length;r++){let i=t[r],o=e.marks[i],s=o;if(o)n.push(o);else for(let t in e.marks){let r=e.marks[t];("_"==i||r.spec.group&&r.spec.group.split(" ").indexOf(i)>-1)&&n.push(s=r);}if(!s)throw new SyntaxError("Unknown mark type: '"+t[r]+"'")}return n}class ha{constructor(e,t){this.schema=e,this.rules=t,this.tags=[],this.styles=[],t.forEach((e=>{e.tag?this.tags.push(e):e.style&&this.styles.push(e);})),this.normalizeLists=!this.tags.some((t=>{if(!/^(ul|ol)\b/.test(t.tag)||!t.node)return !1;let n=e.nodes[t.node];return n.contentMatch.matchType(n)}));}parse(e,t={}){let n=new ya(this,t,!1);return n.addAll(e,t.from,t.to),n.finish()}parseSlice(e,t={}){let n=new ya(this,t,!0);return n.addAll(e,t.from,t.to),Os.maxOpen(n.finish())}matchTag(e,t,n){for(let r=n?this.tags.indexOf(n)+1:0;r<this.tags.length;r++){let n=this.tags[r];if(ba(e,n.tag)&&(void 0===n.namespace||e.namespaceURI==n.namespace)&&(!n.context||t.matchesContext(n.context))){if(n.getAttrs){let t=n.getAttrs(e);if(!1===t)continue;n.attrs=t||void 0;}return n}}}matchStyle(e,t,n,r){for(let i=r?this.styles.indexOf(r)+1:0;i<this.styles.length;i++){let r=this.styles[i],o=r.style;if(!(0!=o.indexOf(e)||r.context&&!n.matchesContext(r.context)||o.length>e.length&&(61!=o.charCodeAt(e.length)||o.slice(e.length+1)!=t))){if(r.getAttrs){let e=r.getAttrs(t);if(!1===e)continue;r.attrs=e||void 0;}return r}}}static schemaRules(e){let t=[];function n(e){let n=null==e.priority?50:e.priority,r=0;for(;r<t.length;r++){let e=t[r];if((null==e.priority?50:e.priority)<n)break}t.splice(r,0,e);}for(let t in e.marks){let r=e.marks[t].spec.parseDOM;r&&r.forEach((e=>{n(e=wa(e)),e.mark=t;}));}for(let t in e.nodes){let r=e.nodes[t].spec.parseDOM;r&&r.forEach((e=>{n(e=wa(e)),e.node=t;}));}return t}static fromSchema(e){return e.cached.domParser||(e.cached.domParser=new ha(e,ha.schemaRules(e)))}}const pa={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},fa={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},ma={ol:!0,ul:!0};function ga(e,t,n){return null!=t?(t?1:0)|("full"===t?2:0):e&&"pre"==e.whitespace?3:-5&n}class va{constructor(e,t,n,r,i,o,s){this.type=e,this.attrs=t,this.marks=n,this.pendingMarks=r,this.solid=i,this.options=s,this.content=[],this.activeMarks=Ds.none,this.stashMarks=[],this.match=o||(4&s?null:e.contentMatch);}findWrapping(e){if(!this.match){if(!this.type)return [];let t=this.type.contentMatch.fillBefore(Cs.from(e));if(!t){let t,n=this.type.contentMatch;return (t=n.findWrapping(e.type))?(this.match=n,t):null}this.match=this.type.contentMatch.matchFragment(t);}return this.match.findWrapping(e.type)}finish(e){if(!(1&this.options)){let e,t=this.content[this.content.length-1];if(t&&t.isText&&(e=/[ \t\r\n\u000c]+$/.exec(t.text))){let n=t;t.text.length==e[0].length?this.content.pop():this.content[this.content.length-1]=n.withText(n.text.slice(0,n.text.length-e[0].length));}}let t=Cs.from(this.content);return !e&&this.match&&(t=t.append(this.match.fillBefore(Cs.empty,!0))),this.type?this.type.create(this.attrs,t,this.marks):t}popFromStashMark(e){for(let t=this.stashMarks.length-1;t>=0;t--)if(e.eq(this.stashMarks[t]))return this.stashMarks.splice(t,1)[0]}applyPending(e){for(let t=0,n=this.pendingMarks;t<n.length;t++){let r=n[t];(this.type?this.type.allowsMarkType(r.type):ka(r.type,e))&&!r.isInSet(this.activeMarks)&&(this.activeMarks=r.addToSet(this.activeMarks),this.pendingMarks=r.removeFromSet(this.pendingMarks));}}inlineContext(e){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:e.parentNode&&!pa.hasOwnProperty(e.parentNode.nodeName.toLowerCase())}}class ya{constructor(e,t,n){this.parser=e,this.options=t,this.isOpen=n,this.open=0;let r,i=t.topNode,o=ga(null,t.preserveWhitespace,0)|(n?4:0);r=i?new va(i.type,i.attrs,Ds.none,Ds.none,!0,t.topMatch||i.type.contentMatch,o):new va(n?null:e.schema.topNodeType,null,Ds.none,Ds.none,!0,null,o),this.nodes=[r],this.find=t.findPositions,this.needsBlock=!1;}get top(){return this.nodes[this.open]}addDOM(e){if(3==e.nodeType)this.addTextNode(e);else if(1==e.nodeType){let t=e.getAttribute("style"),n=t?this.readStyles(function(e){let t,n=/\s*([\w-]+)\s*:\s*([^;]+)/g,r=[];for(;t=n.exec(e);)r.push(t[1],t[2].trim());return r}(t)):null,r=this.top;if(null!=n)for(let e=0;e<n.length;e++)this.addPendingMark(n[e]);if(this.addElement(e),null!=n)for(let e=0;e<n.length;e++)this.removePendingMark(n[e],r);}}addTextNode(e){let t=e.nodeValue,n=this.top;if(2&n.options||n.inlineContext(e)||/[^ \t\r\n\u000c]/.test(t)){if(1&n.options)t=2&n.options?t.replace(/\r\n?/g,"\n"):t.replace(/\r?\n|\r/g," ");else if(t=t.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(t)&&this.open==this.nodes.length-1){let r=n.content[n.content.length-1],i=e.previousSibling;(!r||i&&"BR"==i.nodeName||r.isText&&/[ \t\r\n\u000c]$/.test(r.text))&&(t=t.slice(1));}t&&this.insertNode(this.parser.schema.text(t)),this.findInText(e);}else this.findInside(e);}addElement(e,t){let n,r=e.nodeName.toLowerCase();ma.hasOwnProperty(r)&&this.parser.normalizeLists&&function(e){for(let t=e.firstChild,n=null;t;t=t.nextSibling){let e=1==t.nodeType?t.nodeName.toLowerCase():null;e&&ma.hasOwnProperty(e)&&n?(n.appendChild(t),t=n):"li"==e?n=t:e&&(n=null);}}(e);let i=this.options.ruleFromNode&&this.options.ruleFromNode(e)||(n=this.parser.matchTag(e,this,t));if(i?i.ignore:fa.hasOwnProperty(r))this.findInside(e),this.ignoreFallback(e);else if(!i||i.skip||i.closeParent){i&&i.closeParent?this.open=Math.max(0,this.open-1):i&&i.skip.nodeType&&(e=i.skip);let t,n=this.top,o=this.needsBlock;if(pa.hasOwnProperty(r))t=!0,n.type||(this.needsBlock=!0);else if(!e.firstChild)return void this.leafFallback(e);this.addAll(e),t&&this.sync(n),this.needsBlock=o;}else this.addElementByRule(e,i,!1===i.consuming?n:void 0);}leafFallback(e){"BR"==e.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(e.ownerDocument.createTextNode("\n"));}ignoreFallback(e){"BR"!=e.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"));}readStyles(e){let t=Ds.none;e:for(let n=0;n<e.length;n+=2)for(let r;;){let i=this.parser.matchStyle(e[n],e[n+1],this,r);if(!i)continue e;if(i.ignore)return null;if(t=this.parser.schema.marks[i.mark].create(i.attrs).addToSet(t),!1!==i.consuming)break;r=i;}return t}addElementByRule(e,t,n){let r,i,o;if(t.node)i=this.parser.schema.nodes[t.node],i.isLeaf?this.insertNode(i.create(t.attrs))||this.leafFallback(e):r=this.enter(i,t.attrs||null,t.preserveWhitespace);else {o=this.parser.schema.marks[t.mark].create(t.attrs),this.addPendingMark(o);}let s=this.top;if(i&&i.isLeaf)this.findInside(e);else if(n)this.addElement(e,n);else if(t.getContent)this.findInside(e),t.getContent(e,this.parser.schema).forEach((e=>this.insertNode(e)));else {let n=e;"string"==typeof t.contentElement?n=e.querySelector(t.contentElement):"function"==typeof t.contentElement?n=t.contentElement(e):t.contentElement&&(n=t.contentElement),this.findAround(e,n,!0),this.addAll(n);}r&&this.sync(s)&&this.open--,o&&this.removePendingMark(o,s);}addAll(e,t,n){let r=t||0;for(let i=t?e.childNodes[t]:e.firstChild,o=null==n?null:e.childNodes[n];i!=o;i=i.nextSibling,++r)this.findAtPoint(e,r),this.addDOM(i);this.findAtPoint(e,r);}findPlace(e){let t,n;for(let r=this.open;r>=0;r--){let i=this.nodes[r],o=i.findWrapping(e);if(o&&(!t||t.length>o.length)&&(t=o,n=i,!o.length))break;if(i.solid)break}if(!t)return !1;this.sync(n);for(let e=0;e<t.length;e++)this.enterInner(t[e],null,!1);return !0}insertNode(e){if(e.isInline&&this.needsBlock&&!this.top.type){let e=this.textblockFromContext();e&&this.enterInner(e);}if(this.findPlace(e)){this.closeExtra();let t=this.top;t.applyPending(e.type),t.match&&(t.match=t.match.matchType(e.type));let n=t.activeMarks;for(let r=0;r<e.marks.length;r++)t.type&&!t.type.allowsMarkType(e.marks[r].type)||(n=e.marks[r].addToSet(n));return t.content.push(e.mark(n)),!0}return !1}enter(e,t,n){let r=this.findPlace(e.create(t));return r&&this.enterInner(e,t,!0,n),r}enterInner(e,t=null,n=!1,r){this.closeExtra();let i=this.top;i.applyPending(e),i.match=i.match&&i.match.matchType(e);let o=ga(e,r,i.options);4&i.options&&0==i.content.length&&(o|=4),this.nodes.push(new va(e,t,i.activeMarks,i.pendingMarks,n,null,o)),this.open++;}closeExtra(e=!1){let t=this.nodes.length-1;if(t>this.open){for(;t>this.open;t--)this.nodes[t-1].content.push(this.nodes[t].finish(e));this.nodes.length=this.open+1;}}finish(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}sync(e){for(let t=this.open;t>=0;t--)if(this.nodes[t]==e)return this.open=t,!0;return !1}get currentPos(){this.closeExtra();let e=0;for(let t=this.open;t>=0;t--){let n=this.nodes[t].content;for(let t=n.length-1;t>=0;t--)e+=n[t].nodeSize;t&&e++;}return e}findAtPoint(e,t){if(this.find)for(let n=0;n<this.find.length;n++)this.find[n].node==e&&this.find[n].offset==t&&(this.find[n].pos=this.currentPos);}findInside(e){if(this.find)for(let t=0;t<this.find.length;t++)null==this.find[t].pos&&1==e.nodeType&&e.contains(this.find[t].node)&&(this.find[t].pos=this.currentPos);}findAround(e,t,n){if(e!=t&&this.find)for(let r=0;r<this.find.length;r++)if(null==this.find[r].pos&&1==e.nodeType&&e.contains(this.find[r].node)){t.compareDocumentPosition(this.find[r].node)&(n?2:4)&&(this.find[r].pos=this.currentPos);}}findInText(e){if(this.find)for(let t=0;t<this.find.length;t++)this.find[t].node==e&&(this.find[t].pos=this.currentPos-(e.nodeValue.length-this.find[t].offset));}matchesContext(e){if(e.indexOf("|")>-1)return e.split(/\s*\|\s*/).some(this.matchesContext,this);let t=e.split("/"),n=this.options.context,r=!(this.isOpen||n&&n.parent.type!=this.nodes[0].type),i=-(n?n.depth+1:0)+(r?0:1),o=(e,s)=>{for(;e>=0;e--){let a=t[e];if(""==a){if(e==t.length-1||0==e)continue;for(;s>=i;s--)if(o(e-1,s))return !0;return !1}{let e=s>0||0==s&&r?this.nodes[s].type:n&&s>=i?n.node(s-i).type:null;if(!e||e.name!=a&&-1==e.groups.indexOf(a))return !1;s--;}}return !0};return o(t.length-1,this.open)}textblockFromContext(){let e=this.options.context;if(e)for(let t=e.depth;t>=0;t--){let n=e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;if(n&&n.isTextblock&&n.defaultAttrs)return n}for(let e in this.parser.schema.nodes){let t=this.parser.schema.nodes[e];if(t.isTextblock&&t.defaultAttrs)return t}}addPendingMark(e){let t=function(e,t){for(let n=0;n<t.length;n++)if(e.eq(t[n]))return t[n]}(e,this.top.pendingMarks);t&&this.top.stashMarks.push(t),this.top.pendingMarks=e.addToSet(this.top.pendingMarks);}removePendingMark(e,t){for(let n=this.open;n>=0;n--){let r=this.nodes[n];if(r.pendingMarks.lastIndexOf(e)>-1)r.pendingMarks=e.removeFromSet(r.pendingMarks);else {r.activeMarks=e.removeFromSet(r.activeMarks);let t=r.popFromStashMark(e);t&&r.type&&r.type.allowsMarkType(t.type)&&(r.activeMarks=t.addToSet(r.activeMarks));}if(r==t)break}}}function ba(e,t){return (e.matches||e.msMatchesSelector||e.webkitMatchesSelector||e.mozMatchesSelector).call(e,t)}function wa(e){let t={};for(let n in e)t[n]=e[n];return t}function ka(e,t){let n=t.schema.nodes;for(let r in n){let i=n[r];if(!i.allowsMarkType(e))continue;let o=[],s=e=>{o.push(e);for(let n=0;n<e.edgeCount;n++){let{type:r,next:i}=e.edge(n);if(r==t)return !0;if(o.indexOf(i)<0&&s(i))return !0}};if(s(i.contentMatch))return !0}}class Ca{constructor(e,t){this.nodes=e,this.marks=t;}serializeFragment(e,t={},n){n||(n=xa(t).createDocumentFragment());let r=n,i=[];return e.forEach((e=>{if(i.length||e.marks.length){let n=0,o=0;for(;n<i.length&&o<e.marks.length;){let t=e.marks[o];if(this.marks[t.type.name]){if(!t.eq(i[n][0])||!1===t.type.spec.spanning)break;n++,o++;}else o++;}for(;n<i.length;)r=i.pop()[1];for(;o<e.marks.length;){let n=e.marks[o++],s=this.serializeMark(n,e.isInline,t);s&&(i.push([n,r]),r.appendChild(s.dom),r=s.contentDOM||s.dom);}}r.appendChild(this.serializeNodeInner(e,t));})),n}serializeNodeInner(e,t){let{dom:n,contentDOM:r}=Ca.renderSpec(xa(t),this.nodes[e.type.name](e));if(r){if(e.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(e.content,t,r);}return n}serializeNode(e,t={}){let n=this.serializeNodeInner(e,t);for(let r=e.marks.length-1;r>=0;r--){let i=this.serializeMark(e.marks[r],e.isInline,t);i&&((i.contentDOM||i.dom).appendChild(n),n=i.dom);}return n}serializeMark(e,t,n={}){let r=this.marks[e.type.name];return r&&Ca.renderSpec(xa(n),r(e,t))}static renderSpec(e,t,n=null){if("string"==typeof t)return {dom:e.createTextNode(t)};if(null!=t.nodeType)return {dom:t};if(t.dom&&null!=t.dom.nodeType)return t;let r,i=t[0],o=i.indexOf(" ");o>0&&(n=i.slice(0,o),i=i.slice(o+1));let s=n?e.createElementNS(n,i):e.createElement(i),a=t[1],l=1;if(a&&"object"==typeof a&&null==a.nodeType&&!Array.isArray(a)){l=2;for(let e in a)if(null!=a[e]){let t=e.indexOf(" ");t>0?s.setAttributeNS(e.slice(0,t),e.slice(t+1),a[e]):s.setAttribute(e,a[e]);}}for(let i=l;i<t.length;i++){let o=t[i];if(0===o){if(i<t.length-1||i>l)throw new RangeError("Content hole must be the only child of its parent node");return {dom:s,contentDOM:s}}{let{dom:t,contentDOM:i}=Ca.renderSpec(e,o,n);if(s.appendChild(t),i){if(r)throw new RangeError("Multiple content holes");r=i;}}}return {dom:s,contentDOM:r}}static fromSchema(e){return e.cached.domSerializer||(e.cached.domSerializer=new Ca(this.nodesFromSchema(e),this.marksFromSchema(e)))}static nodesFromSchema(e){let t=Ea(e.nodes);return t.text||(t.text=e=>e.text),t}static marksFromSchema(e){return Ea(e.marks)}}function Ea(e){let t={};for(let n in e){let r=e[n].spec.toDOM;r&&(t[n]=r);}return t}function xa(e){return e.document||window.document}const Sa=Math.pow(2,16);function Da(e,t){return e+t*Sa}function Ma(e){return 65535&e}class Oa{constructor(e,t,n){this.pos=e,this.delInfo=t,this.recover=n;}get deleted(){return (8&this.delInfo)>0}get deletedBefore(){return (5&this.delInfo)>0}get deletedAfter(){return (6&this.delInfo)>0}get deletedAcross(){return (4&this.delInfo)>0}}class Aa{constructor(e,t=!1){if(this.ranges=e,this.inverted=t,!e.length&&Aa.empty)return Aa.empty}recover(e){let t=0,n=Ma(e);if(!this.inverted)for(let e=0;e<n;e++)t+=this.ranges[3*e+2]-this.ranges[3*e+1];return this.ranges[3*n]+t+function(e){return (e-(65535&e))/Sa}(e)}mapResult(e,t=1){return this._map(e,t,!1)}map(e,t=1){return this._map(e,t,!0)}_map(e,t,n){let r=0,i=this.inverted?2:1,o=this.inverted?1:2;for(let s=0;s<this.ranges.length;s+=3){let a=this.ranges[s]-(this.inverted?r:0);if(a>e)break;let l=this.ranges[s+i],c=this.ranges[s+o],u=a+l;if(e<=u){let i=a+r+((l?e==a?-1:e==u?1:t:t)<0?0:c);if(n)return i;let o=e==(t<0?a:u)?null:Da(s/3,e-a),d=e==a?2:e==u?1:4;return (t<0?e!=a:e!=u)&&(d|=8),new Oa(i,d,o)}r+=c-l;}return n?e+r:new Oa(e+r,0,null)}touches(e,t){let n=0,r=Ma(t),i=this.inverted?2:1,o=this.inverted?1:2;for(let t=0;t<this.ranges.length;t+=3){let s=this.ranges[t]-(this.inverted?n:0);if(s>e)break;let a=this.ranges[t+i];if(e<=s+a&&t==3*r)return !0;n+=this.ranges[t+o]-a;}return !1}forEach(e){let t=this.inverted?2:1,n=this.inverted?1:2;for(let r=0,i=0;r<this.ranges.length;r+=3){let o=this.ranges[r],s=o-(this.inverted?i:0),a=o+(this.inverted?0:i),l=this.ranges[r+t],c=this.ranges[r+n];e(s,s+l,a,a+c),i+=c-l;}}invert(){return new Aa(this.ranges,!this.inverted)}toString(){return (this.inverted?"-":"")+JSON.stringify(this.ranges)}static offset(e){return 0==e?Aa.empty:new Aa(e<0?[0,-e,0]:[0,0,e])}}Aa.empty=new Aa([]);class Na{constructor(e=[],t,n=0,r=e.length){this.maps=e,this.mirror=t,this.from=n,this.to=r;}slice(e=0,t=this.maps.length){return new Na(this.maps,this.mirror,e,t)}copy(){return new Na(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}appendMap(e,t){this.to=this.maps.push(e),null!=t&&this.setMirror(this.maps.length-1,t);}appendMapping(e){for(let t=0,n=this.maps.length;t<e.maps.length;t++){let r=e.getMirror(t);this.appendMap(e.maps[t],null!=r&&r<t?n+r:void 0);}}getMirror(e){if(this.mirror)for(let t=0;t<this.mirror.length;t++)if(this.mirror[t]==e)return this.mirror[t+(t%2?-1:1)]}setMirror(e,t){this.mirror||(this.mirror=[]),this.mirror.push(e,t);}appendMappingInverted(e){for(let t=e.maps.length-1,n=this.maps.length+e.maps.length;t>=0;t--){let r=e.getMirror(t);this.appendMap(e.maps[t].invert(),null!=r&&r>t?n-r-1:void 0);}}invert(){let e=new Na;return e.appendMappingInverted(this),e}map(e,t=1){if(this.mirror)return this._map(e,t,!0);for(let n=this.from;n<this.to;n++)e=this.maps[n].map(e,t);return e}mapResult(e,t=1){return this._map(e,t,!1)}_map(e,t,n){let r=0;for(let n=this.from;n<this.to;n++){let i=this.maps[n].mapResult(e,t);if(null!=i.recover){let t=this.getMirror(n);if(null!=t&&t>n&&t<this.to){n=t,e=this.maps[t].recover(i.recover);continue}}r|=i.delInfo,e=i.pos;}return n?e:new Oa(e,r,null)}}const _a=Object.create(null);class Ta{getMap(){return Aa.empty}merge(e){return null}static fromJSON(e,t){if(!t||!t.stepType)throw new RangeError("Invalid input for Step.fromJSON");let n=_a[t.stepType];if(!n)throw new RangeError(`No step type ${t.stepType} defined`);return n.fromJSON(e,t)}static jsonID(e,t){if(e in _a)throw new RangeError("Duplicate use of step JSON ID "+e);return _a[e]=t,t.prototype.jsonID=e,t}}class La{constructor(e,t){this.doc=e,this.failed=t;}static ok(e){return new La(e,null)}static fail(e){return new La(null,e)}static fromReplace(e,t,n,r){try{return La.ok(e.replace(t,n,r))}catch(e){if(e instanceof Ms)return La.fail(e.message);throw e}}}function Ra(e,t,n){let r=[];for(let i=0;i<e.childCount;i++){let o=e.child(i);o.content.size&&(o=o.copy(Ra(o.content,t,o))),o.isInline&&(o=t(o,n,i)),r.push(o);}return Cs.fromArray(r)}class Fa extends Ta{constructor(e,t,n){super(),this.from=e,this.to=t,this.mark=n;}apply(e){let t=e.slice(this.from,this.to),n=e.resolve(this.from),r=n.node(n.sharedDepth(this.to)),i=new Os(Ra(t.content,((e,t)=>e.isAtom&&t.type.allowsMarkType(this.mark.type)?e.mark(this.mark.addToSet(e.marks)):e),r),t.openStart,t.openEnd);return La.fromReplace(e,this.from,this.to,i)}invert(){return new Ba(this.from,this.to,this.mark)}map(e){let t=e.mapResult(this.from,1),n=e.mapResult(this.to,-1);return t.deleted&&n.deleted||t.pos>=n.pos?null:new Fa(t.pos,n.pos,this.mark)}merge(e){return e instanceof Fa&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new Fa(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}toJSON(){return {stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new Fa(t.from,t.to,e.markFromJSON(t.mark))}}Ta.jsonID("addMark",Fa);class Ba extends Ta{constructor(e,t,n){super(),this.from=e,this.to=t,this.mark=n;}apply(e){let t=e.slice(this.from,this.to),n=new Os(Ra(t.content,(e=>e.mark(this.mark.removeFromSet(e.marks))),e),t.openStart,t.openEnd);return La.fromReplace(e,this.from,this.to,n)}invert(){return new Fa(this.from,this.to,this.mark)}map(e){let t=e.mapResult(this.from,1),n=e.mapResult(this.to,-1);return t.deleted&&n.deleted||t.pos>=n.pos?null:new Ba(t.pos,n.pos,this.mark)}merge(e){return e instanceof Ba&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new Ba(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}toJSON(){return {stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}static fromJSON(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new Ba(t.from,t.to,e.markFromJSON(t.mark))}}Ta.jsonID("removeMark",Ba);class Ia extends Ta{constructor(e,t,n,r=!1){super(),this.from=e,this.to=t,this.slice=n,this.structure=r;}apply(e){return this.structure&&za(e,this.from,this.to)?La.fail("Structure replace would overwrite content"):La.fromReplace(e,this.from,this.to,this.slice)}getMap(){return new Aa([this.from,this.to-this.from,this.slice.size])}invert(e){return new Ia(this.from,this.from+this.slice.size,e.slice(this.from,this.to))}map(e){let t=e.mapResult(this.from,1),n=e.mapResult(this.to,-1);return t.deletedAcross&&n.deletedAcross?null:new Ia(t.pos,Math.max(t.pos,n.pos),this.slice)}merge(e){if(!(e instanceof Ia)||e.structure||this.structure)return null;if(this.from+this.slice.size!=e.from||this.slice.openEnd||e.slice.openStart){if(e.to!=this.from||this.slice.openStart||e.slice.openEnd)return null;{let t=this.slice.size+e.slice.size==0?Os.empty:new Os(e.slice.content.append(this.slice.content),e.slice.openStart,this.slice.openEnd);return new Ia(e.from,this.to,t,this.structure)}}{let t=this.slice.size+e.slice.size==0?Os.empty:new Os(this.slice.content.append(e.slice.content),this.slice.openStart,e.slice.openEnd);return new Ia(this.from,this.to+(e.to-e.from),t,this.structure)}}toJSON(){let e={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(e.slice=this.slice.toJSON()),this.structure&&(e.structure=!0),e}static fromJSON(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new Ia(t.from,t.to,Os.fromJSON(e,t.slice),!!t.structure)}}Ta.jsonID("replace",Ia);class Pa extends Ta{constructor(e,t,n,r,i,o,s=!1){super(),this.from=e,this.to=t,this.gapFrom=n,this.gapTo=r,this.slice=i,this.insert=o,this.structure=s;}apply(e){if(this.structure&&(za(e,this.from,this.gapFrom)||za(e,this.gapTo,this.to)))return La.fail("Structure gap-replace would overwrite content");let t=e.slice(this.gapFrom,this.gapTo);if(t.openStart||t.openEnd)return La.fail("Gap is not a flat range");let n=this.slice.insertAt(this.insert,t.content);return n?La.fromReplace(e,this.from,this.to,n):La.fail("Content does not fit in gap")}getMap(){return new Aa([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}invert(e){let t=this.gapTo-this.gapFrom;return new Pa(this.from,this.from+this.slice.size+t,this.from+this.insert,this.from+this.insert+t,e.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}map(e){let t=e.mapResult(this.from,1),n=e.mapResult(this.to,-1),r=e.map(this.gapFrom,-1),i=e.map(this.gapTo,1);return t.deletedAcross&&n.deletedAcross||r<t.pos||i>n.pos?null:new Pa(t.pos,n.pos,r,i,this.slice,this.insert,this.structure)}toJSON(){let e={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(e.slice=this.slice.toJSON()),this.structure&&(e.structure=!0),e}static fromJSON(e,t){if("number"!=typeof t.from||"number"!=typeof t.to||"number"!=typeof t.gapFrom||"number"!=typeof t.gapTo||"number"!=typeof t.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new Pa(t.from,t.to,t.gapFrom,t.gapTo,Os.fromJSON(e,t.slice),t.insert,!!t.structure)}}function za(e,t,n){let r=e.resolve(t),i=n-t,o=r.depth;for(;i>0&&o>0&&r.indexAfter(o)==r.node(o).childCount;)o--,i--;if(i>0){let e=r.node(o).maybeChild(r.indexAfter(o));for(;i>0;){if(!e||e.isLeaf)return !0;e=e.firstChild,i--;}}return !1}function $a(e,t,n){return (0==t||e.canReplace(t,e.childCount))&&(n==e.childCount||e.canReplace(0,n))}function ja(e){let t=e.parent.content.cutByIndex(e.startIndex,e.endIndex);for(let n=e.depth;;--n){let r=e.$from.node(n),i=e.$from.index(n),o=e.$to.indexAfter(n);if(n<e.depth&&r.canReplace(i,o,t))return n;if(0==n||r.type.spec.isolating||!$a(r,i,o))break}return null}function Ha(e,t,n=null,r=e){let i=function(e,t){let{parent:n,startIndex:r,endIndex:i}=e,o=n.contentMatchAt(r).findWrapping(t);if(!o)return null;let s=o.length?o[0]:t;return n.canReplaceWith(r,i,s)?o:null}(e,t),o=i&&function(e,t){let{parent:n,startIndex:r,endIndex:i}=e,o=n.child(r),s=t.contentMatch.findWrapping(o.type);if(!s)return null;let a=(s.length?s[s.length-1]:t).contentMatch;for(let e=r;a&&e<i;e++)a=a.matchType(n.child(e).type);return a&&a.validEnd?s:null}(r,t);return o?i.map(Va).concat({type:t,attrs:n}).concat(o.map(Va)):null}function Va(e){return {type:e,attrs:null}}function Ka(e,t,n=1,r){let i=e.resolve(t),o=i.depth-n,s=r&&r[r.length-1]||i.parent;if(o<0||i.parent.type.spec.isolating||!i.parent.canReplace(i.index(),i.parent.childCount)||!s.type.validContent(i.parent.content.cutByIndex(i.index(),i.parent.childCount)))return !1;for(let e=i.depth-1,t=n-2;e>o;e--,t--){let n=i.node(e),o=i.index(e);if(n.type.spec.isolating)return !1;let s=n.content.cutByIndex(o,n.childCount),a=r&&r[t]||n;if(a!=n&&(s=s.replaceChild(0,a.type.create(a.attrs))),!n.canReplace(o+1,n.childCount)||!a.type.validContent(s))return !1}let a=i.indexAfter(o),l=r&&r[0];return i.node(o).canReplaceWith(a,a,l?l.type:i.node(o+1).type)}function qa(e,t){let n=e.resolve(t),r=n.index();return i=n.nodeBefore,o=n.nodeAfter,!(!i||!o||i.isLeaf||!i.canAppend(o))&&n.parent.canReplace(r,r+1);var i,o;}function Ua(e,t,n){let r=e.resolve(t);if(!n.content.size)return t;let i=n.content;for(let e=0;e<n.openStart;e++)i=i.firstChild.content;for(let e=1;e<=(0==n.openStart&&n.size?2:1);e++)for(let t=r.depth;t>=0;t--){let n=t==r.depth?0:r.pos<=(r.start(t+1)+r.end(t+1))/2?-1:1,o=r.index(t)+(n>0?1:0),s=r.node(t),a=!1;if(1==e)a=s.canReplace(o,o,i);else {let e=s.contentMatchAt(o).findWrapping(i.firstChild.type);a=e&&s.canReplaceWith(o,o,e[0]);}if(a)return 0==n?r.pos:n<0?r.before(t+1):r.after(t+1)}return null}function Wa(e,t,n=t,r=Os.empty){if(t==n&&!r.size)return null;let i=e.resolve(t),o=e.resolve(n);return Ga(i,o,r)?new Ia(t,n,r):new Ja(i,o,r).fit()}function Ga(e,t,n){return !n.openStart&&!n.openEnd&&e.start()==t.start()&&e.parent.canReplace(e.index(),t.index(),n.content)}Ta.jsonID("replaceAround",Pa);class Ja{constructor(e,t,n){this.$from=e,this.$to=t,this.unplaced=n,this.frontier=[],this.placed=Cs.empty;for(let t=0;t<=e.depth;t++){let n=e.node(t);this.frontier.push({type:n.type,match:n.contentMatchAt(e.indexAfter(t))});}for(let t=e.depth;t>0;t--)this.placed=Cs.from(e.node(t).copy(this.placed));}get depth(){return this.frontier.length-1}fit(){for(;this.unplaced.size;){let e=this.findFittable();e?this.placeNodes(e):this.openMore()||this.dropNode();}let e=this.mustMoveInline(),t=this.placed.size-this.depth-this.$from.depth,n=this.$from,r=this.close(e<0?this.$to:n.doc.resolve(e));if(!r)return null;let i=this.placed,o=n.depth,s=r.depth;for(;o&&s&&1==i.childCount;)i=i.firstChild.content,o--,s--;let a=new Os(i,o,s);return e>-1?new Pa(n.pos,e,this.$to.pos,this.$to.end(),a,t):a.size||n.pos!=this.$to.pos?new Ia(n.pos,r.pos,a):null}findFittable(){for(let e=1;e<=2;e++)for(let t=this.unplaced.openStart;t>=0;t--){let n,r=null;t?(r=Qa(this.unplaced.content,t-1).firstChild,n=r.content):n=this.unplaced.content;let i=n.firstChild;for(let n=this.depth;n>=0;n--){let o,{type:s,match:a}=this.frontier[n],l=null;if(1==e&&(i?a.matchType(i.type)||(l=a.fillBefore(Cs.from(i),!1)):r&&s.compatibleContent(r.type)))return {sliceDepth:t,frontierDepth:n,parent:r,inject:l};if(2==e&&i&&(o=a.findWrapping(i.type)))return {sliceDepth:t,frontierDepth:n,parent:r,wrap:o};if(r&&a.matchType(r.type))break}}}openMore(){let{content:e,openStart:t,openEnd:n}=this.unplaced,r=Qa(e,t);return !(!r.childCount||r.firstChild.isLeaf)&&(this.unplaced=new Os(e,t+1,Math.max(n,r.size+t>=e.size-n?t+1:0)),!0)}dropNode(){let{content:e,openStart:t,openEnd:n}=this.unplaced,r=Qa(e,t);if(r.childCount<=1&&t>0){let i=e.size-t<=t+r.size;this.unplaced=new Os(Za(e,t-1,1),t-1,i?t-1:n);}else this.unplaced=new Os(Za(e,t,1),t,n);}placeNodes({sliceDepth:e,frontierDepth:t,parent:n,inject:r,wrap:i}){for(;this.depth>t;)this.closeFrontierNode();if(i)for(let e=0;e<i.length;e++)this.openFrontierNode(i[e]);let o=this.unplaced,s=n?n.content:o.content,a=o.openStart-e,l=0,c=[],{match:u,type:d}=this.frontier[t];if(r){for(let e=0;e<r.childCount;e++)c.push(r.child(e));u=u.matchFragment(r);}let h=s.size+e-(o.content.size-o.openEnd);for(;l<s.childCount;){let e=s.child(l),t=u.matchType(e.type);if(!t)break;l++,(l>1||0==a||e.content.size)&&(u=t,c.push(Ya(e.mark(d.allowedMarks(e.marks)),1==l?a:0,l==s.childCount?h:-1)));}let p=l==s.childCount;p||(h=-1),this.placed=Xa(this.placed,t,Cs.from(c)),this.frontier[t].match=u,p&&h<0&&n&&n.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();for(let e=0,t=s;e<h;e++){let e=t.lastChild;this.frontier.push({type:e.type,match:e.contentMatchAt(e.childCount)}),t=e.content;}this.unplaced=p?0==e?Os.empty:new Os(Za(o.content,e-1,1),e-1,h<0?o.openEnd:e-1):new Os(Za(o.content,e,l),o.openStart,o.openEnd);}mustMoveInline(){if(!this.$to.parent.isTextblock)return -1;let e,t=this.frontier[this.depth];if(!t.type.isTextblock||!el(this.$to,this.$to.depth,t.type,t.match,!1)||this.$to.depth==this.depth&&(e=this.findCloseLevel(this.$to))&&e.depth==this.depth)return -1;let{depth:n}=this.$to,r=this.$to.after(n);for(;n>1&&r==this.$to.end(--n);)++r;return r}findCloseLevel(e){e:for(let t=Math.min(this.depth,e.depth);t>=0;t--){let{match:n,type:r}=this.frontier[t],i=t<e.depth&&e.end(t+1)==e.pos+(e.depth-(t+1)),o=el(e,t,r,n,i);if(o){for(let n=t-1;n>=0;n--){let{match:t,type:r}=this.frontier[n],i=el(e,n,r,t,!0);if(!i||i.childCount)continue e}return {depth:t,fit:o,move:i?e.doc.resolve(e.after(t+1)):e}}}}close(e){let t=this.findCloseLevel(e);if(!t)return null;for(;this.depth>t.depth;)this.closeFrontierNode();t.fit.childCount&&(this.placed=Xa(this.placed,t.depth,t.fit)),e=t.move;for(let n=t.depth+1;n<=e.depth;n++){let t=e.node(n),r=t.type.contentMatch.fillBefore(t.content,!0,e.index(n));this.openFrontierNode(t.type,t.attrs,r);}return e}openFrontierNode(e,t=null,n){let r=this.frontier[this.depth];r.match=r.match.matchType(e),this.placed=Xa(this.placed,this.depth,Cs.from(e.create(t,n))),this.frontier.push({type:e,match:e.contentMatch});}closeFrontierNode(){let e=this.frontier.pop().match.fillBefore(Cs.empty,!0);e.childCount&&(this.placed=Xa(this.placed,this.frontier.length,e));}}function Za(e,t,n){return 0==t?e.cutByIndex(n,e.childCount):e.replaceChild(0,e.firstChild.copy(Za(e.firstChild.content,t-1,n)))}function Xa(e,t,n){return 0==t?e.append(n):e.replaceChild(e.childCount-1,e.lastChild.copy(Xa(e.lastChild.content,t-1,n)))}function Qa(e,t){for(let n=0;n<t;n++)e=e.firstChild.content;return e}function Ya(e,t,n){if(t<=0)return e;let r=e.content;return t>1&&(r=r.replaceChild(0,Ya(r.firstChild,t-1,1==r.childCount?n-1:0))),t>0&&(r=e.type.contentMatch.fillBefore(r).append(r),n<=0&&(r=r.append(e.type.contentMatch.matchFragment(r).fillBefore(Cs.empty,!0)))),e.copy(r)}function el(e,t,n,r,i){let o=e.node(t),s=i?e.indexAfter(t):e.index(t);if(s==o.childCount&&!n.compatibleContent(o.type))return null;let a=r.fillBefore(o.content,!0,s);return a&&!function(e,t,n){for(let r=n;r<t.childCount;r++)if(!e.allowsMarks(t.child(r).marks))return !0;return !1}(n,o.content,s)?a:null}function tl(e){return e.spec.defining||e.spec.definingForContent}function nl(e,t,n,r,i){if(t<n){let i=e.firstChild;e=e.replaceChild(0,i.copy(nl(i.content,t+1,n,r,i)));}if(t>r){let t=i.contentMatchAt(0),n=t.fillBefore(e).append(e);e=n.append(t.matchFragment(n).fillBefore(Cs.empty,!0));}return e}function rl(e,t){let n=[];for(let r=Math.min(e.depth,t.depth);r>=0;r--){let i=e.start(r);if(i<e.pos-(e.depth-r)||t.end(r)>t.pos+(t.depth-r)||e.node(r).type.spec.isolating||t.node(r).type.spec.isolating)break;(i==t.start(r)||r==e.depth&&r==t.depth&&e.parent.inlineContent&&t.parent.inlineContent&&r&&t.start(r-1)==i-1)&&n.push(r);}return n}let il=class extends Error{};il=function e(t){let n=Error.call(this,t);return n.__proto__=e.prototype,n},(il.prototype=Object.create(Error.prototype)).constructor=il,il.prototype.name="TransformError";class ol{constructor(e){this.doc=e,this.steps=[],this.docs=[],this.mapping=new Na;}get before(){return this.docs.length?this.docs[0]:this.doc}step(e){let t=this.maybeStep(e);if(t.failed)throw new il(t.failed);return this}maybeStep(e){let t=e.apply(this.doc);return t.failed||this.addStep(e,t.doc),t}get docChanged(){return this.steps.length>0}addStep(e,t){this.docs.push(this.doc),this.steps.push(e),this.mapping.appendMap(e.getMap()),this.doc=t;}replace(e,t=e,n=Os.empty){let r=Wa(this.doc,e,t,n);return r&&this.step(r),this}replaceWith(e,t,n){return this.replace(e,t,new Os(Cs.from(n),0,0))}delete(e,t){return this.replace(e,t,Os.empty)}insert(e,t){return this.replaceWith(e,e,t)}replaceRange(e,t,n){return function(e,t,n,r){if(!r.size)return e.deleteRange(t,n);let i=e.doc.resolve(t),o=e.doc.resolve(n);if(Ga(i,o,r))return e.step(new Ia(t,n,r));let s=rl(i,e.doc.resolve(n));0==s[s.length-1]&&s.pop();let a=-(i.depth+1);s.unshift(a);for(let e=i.depth,t=i.pos-1;e>0;e--,t--){let n=i.node(e).type.spec;if(n.defining||n.definingAsContext||n.isolating)break;s.indexOf(e)>-1?a=e:i.before(e)==t&&s.splice(1,0,-e);}let l=s.indexOf(a),c=[],u=r.openStart;for(let e=r.content,t=0;;t++){let n=e.firstChild;if(c.push(n),t==r.openStart)break;e=n.content;}for(let e=u-1;e>=0;e--){let t=c[e].type,n=tl(t);if(n&&i.node(l).type!=t)u=e;else if(n||!t.isTextblock)break}for(let t=r.openStart;t>=0;t--){let a=(t+u+1)%(r.openStart+1),d=c[a];if(d)for(let t=0;t<s.length;t++){let c=s[(t+l)%s.length],u=!0;c<0&&(u=!1,c=-c);let h=i.node(c-1),p=i.index(c-1);if(h.canReplaceWith(p,p,d.type,d.marks))return e.replace(i.before(c),u?o.after(c):n,new Os(nl(r.content,0,r.openStart,a),a,r.openEnd))}}let d=e.steps.length;for(let a=s.length-1;a>=0&&(e.replace(t,n,r),!(e.steps.length>d));a--){let e=s[a];e<0||(t=i.before(e),n=o.after(e));}}(this,e,t,n),this}replaceRangeWith(e,t,n){return function(e,t,n,r){if(!r.isInline&&t==n&&e.doc.resolve(t).parent.content.size){let i=function(e,t,n){let r=e.resolve(t);if(r.parent.canReplaceWith(r.index(),r.index(),n))return t;if(0==r.parentOffset)for(let e=r.depth-1;e>=0;e--){let t=r.index(e);if(r.node(e).canReplaceWith(t,t,n))return r.before(e+1);if(t>0)return null}if(r.parentOffset==r.parent.content.size)for(let e=r.depth-1;e>=0;e--){let t=r.indexAfter(e);if(r.node(e).canReplaceWith(t,t,n))return r.after(e+1);if(t<r.node(e).childCount)return null}return null}(e.doc,t,r.type);null!=i&&(t=n=i);}e.replaceRange(t,n,new Os(Cs.from(r),0,0));}(this,e,t,n),this}deleteRange(e,t){return function(e,t,n){let r=e.doc.resolve(t),i=e.doc.resolve(n),o=rl(r,i);for(let t=0;t<o.length;t++){let n=o[t],s=t==o.length-1;if(s&&0==n||r.node(n).type.contentMatch.validEnd)return e.delete(r.start(n),i.end(n));if(n>0&&(s||r.node(n-1).canReplace(r.index(n-1),i.indexAfter(n-1))))return e.delete(r.before(n),i.after(n))}for(let o=1;o<=r.depth&&o<=i.depth;o++)if(t-r.start(o)==r.depth-o&&n>r.end(o)&&i.end(o)-n!=i.depth-o)return e.delete(r.before(o),n);e.delete(t,n);}(this,e,t),this}lift(e,t){return function(e,t,n){let{$from:r,$to:i,depth:o}=t,s=r.before(o+1),a=i.after(o+1),l=s,c=a,u=Cs.empty,d=0;for(let e=o,t=!1;e>n;e--)t||r.index(e)>0?(t=!0,u=Cs.from(r.node(e).copy(u)),d++):l--;let h=Cs.empty,p=0;for(let e=o,t=!1;e>n;e--)t||i.after(e+1)<i.end(e)?(t=!0,h=Cs.from(i.node(e).copy(h)),p++):c++;e.step(new Pa(l,c,s,a,new Os(u.append(h),d,p),u.size-d,!0));}(this,e,t),this}join(e,t=1){return function(e,t,n){let r=new Ia(t-n,t+n,Os.empty,!0);e.step(r);}(this,e,t),this}wrap(e,t){return function(e,t,n){let r=Cs.empty;for(let e=n.length-1;e>=0;e--){if(r.size){let t=n[e].type.contentMatch.matchFragment(r);if(!t||!t.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}r=Cs.from(n[e].type.create(n[e].attrs,r));}let i=t.start,o=t.end;e.step(new Pa(i,o,i,o,new Os(r,0,0),n.length,!0));}(this,e,t),this}setBlockType(e,t=e,n,r=null){return function(e,t,n,r,i){if(!r.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");let o=e.steps.length;e.doc.nodesBetween(t,n,((t,n)=>{if(t.isTextblock&&!t.hasMarkup(r,i)&&function(e,t,n){let r=e.resolve(t),i=r.index();return r.parent.canReplaceWith(i,i+1,n)}(e.doc,e.mapping.slice(o).map(n),r)){e.clearIncompatible(e.mapping.slice(o).map(n,1),r);let s=e.mapping.slice(o),a=s.map(n,1),l=s.map(n+t.nodeSize,1);return e.step(new Pa(a,l,a+1,l-1,new Os(Cs.from(r.create(i,null,t.marks)),0,0),1,!0)),!1}}));}(this,e,t,n,r),this}setNodeMarkup(e,t,n=null,r=[]){return function(e,t,n,r,i){let o=e.doc.nodeAt(t);if(!o)throw new RangeError("No node at given position");n||(n=o.type);let s=n.create(r,null,i||o.marks);if(o.isLeaf)return e.replaceWith(t,t+o.nodeSize,s);if(!n.validContent(o.content))throw new RangeError("Invalid content for node type "+n.name);e.step(new Pa(t,t+o.nodeSize,t+1,t+o.nodeSize-1,new Os(Cs.from(s),0,0),1,!0));}(this,e,t,n,r),this}split(e,t=1,n){return function(e,t,n=1,r){let i=e.doc.resolve(t),o=Cs.empty,s=Cs.empty;for(let e=i.depth,t=i.depth-n,a=n-1;e>t;e--,a--){o=Cs.from(i.node(e).copy(o));let t=r&&r[a];s=Cs.from(t?t.type.create(t.attrs,s):i.node(e).copy(s));}e.step(new Ia(t,t,new Os(o.append(s),n,n),!0));}(this,e,t,n),this}addMark(e,t,n){return function(e,t,n,r){let i,o,s=[],a=[];e.doc.nodesBetween(t,n,((e,l,c)=>{if(!e.isInline)return;let u=e.marks;if(!r.isInSet(u)&&c.type.allowsMarkType(r.type)){let c=Math.max(l,t),d=Math.min(l+e.nodeSize,n),h=r.addToSet(u);for(let e=0;e<u.length;e++)u[e].isInSet(h)||(i&&i.to==c&&i.mark.eq(u[e])?i.to=d:s.push(i=new Ba(c,d,u[e])));o&&o.to==c?o.to=d:a.push(o=new Fa(c,d,r));}})),s.forEach((t=>e.step(t))),a.forEach((t=>e.step(t)));}(this,e,t,n),this}removeMark(e,t,n){return function(e,t,n,r){let i=[],o=0;e.doc.nodesBetween(t,n,((e,s)=>{if(!e.isInline)return;o++;let a=null;if(r instanceof ca){let t,n=e.marks;for(;t=r.isInSet(n);)(a||(a=[])).push(t),n=t.removeFromSet(n);}else r?r.isInSet(e.marks)&&(a=[r]):a=e.marks;if(a&&a.length){let r=Math.min(s+e.nodeSize,n);for(let e=0;e<a.length;e++){let n,l=a[e];for(let e=0;e<i.length;e++){let t=i[e];t.step==o-1&&l.eq(i[e].style)&&(n=t);}n?(n.to=r,n.step=o):i.push({style:l,from:Math.max(s,t),to:r,step:o});}}})),i.forEach((t=>e.step(new Ba(t.from,t.to,t.style))));}(this,e,t,n),this}clearIncompatible(e,t,n){return function(e,t,n,r=n.contentMatch){let i=e.doc.nodeAt(t),o=[],s=t+1;for(let t=0;t<i.childCount;t++){let a=i.child(t),l=s+a.nodeSize,c=r.matchType(a.type);if(c){r=c;for(let t=0;t<a.marks.length;t++)n.allowsMarkType(a.marks[t].type)||e.step(new Ba(s,l,a.marks[t]));}else o.push(new Ia(s,l,Os.empty));s=l;}if(!r.validEnd){let t=r.fillBefore(Cs.empty,!0);e.replace(s,s,new Os(t,0,0));}for(let t=o.length-1;t>=0;t--)e.step(o[t]);}(this,e,t,n),this}}const sl=Object.create(null);class al{constructor(e,t,n){this.$anchor=e,this.$head=t,this.ranges=n||[new ll(e.min(t),e.max(t))];}get anchor(){return this.$anchor.pos}get head(){return this.$head.pos}get from(){return this.$from.pos}get to(){return this.$to.pos}get $from(){return this.ranges[0].$from}get $to(){return this.ranges[0].$to}get empty(){let e=this.ranges;for(let t=0;t<e.length;t++)if(e[t].$from.pos!=e[t].$to.pos)return !1;return !0}content(){return this.$from.doc.slice(this.from,this.to,!0)}replace(e,t=Os.empty){let n=t.content.lastChild,r=null;for(let e=0;e<t.openEnd;e++)r=n,n=n.lastChild;let i=e.steps.length,o=this.ranges;for(let s=0;s<o.length;s++){let{$from:a,$to:l}=o[s],c=e.mapping.slice(i);e.replaceRange(c.map(a.pos),c.map(l.pos),s?Os.empty:t),0==s&&yl(e,i,(n?n.isInline:r&&r.isTextblock)?-1:1);}}replaceWith(e,t){let n=e.steps.length,r=this.ranges;for(let i=0;i<r.length;i++){let{$from:o,$to:s}=r[i],a=e.mapping.slice(n),l=a.map(o.pos),c=a.map(s.pos);i?e.deleteRange(l,c):(e.replaceRangeWith(l,c,t),yl(e,n,t.isInline?-1:1));}}static findFrom(e,t,n=!1){let r=e.parent.inlineContent?new dl(e):vl(e.node(0),e.parent,e.pos,e.index(),t,n);if(r)return r;for(let r=e.depth-1;r>=0;r--){let i=t<0?vl(e.node(0),e.node(r),e.before(r+1),e.index(r),t,n):vl(e.node(0),e.node(r),e.after(r+1),e.index(r)+1,t,n);if(i)return i}return null}static near(e,t=1){return this.findFrom(e,t)||this.findFrom(e,-t)||new ml(e.node(0))}static atStart(e){return vl(e,e,0,0,1)||new ml(e)}static atEnd(e){return vl(e,e,e.content.size,e.childCount,-1)||new ml(e)}static fromJSON(e,t){if(!t||!t.type)throw new RangeError("Invalid input for Selection.fromJSON");let n=sl[t.type];if(!n)throw new RangeError(`No selection type ${t.type} defined`);return n.fromJSON(e,t)}static jsonID(e,t){if(e in sl)throw new RangeError("Duplicate use of selection JSON ID "+e);return sl[e]=t,t.prototype.jsonID=e,t}getBookmark(){return dl.between(this.$anchor,this.$head).getBookmark()}}al.prototype.visible=!0;class ll{constructor(e,t){this.$from=e,this.$to=t;}}let cl=!1;function ul(e){cl||e.parent.inlineContent||(cl=!0,console.warn("TextSelection endpoint not pointing into a node with inline content ("+e.parent.type.name+")"));}class dl extends al{constructor(e,t=e){ul(e),ul(t),super(e,t);}get $cursor(){return this.$anchor.pos==this.$head.pos?this.$head:null}map(e,t){let n=e.resolve(t.map(this.head));if(!n.parent.inlineContent)return al.near(n);let r=e.resolve(t.map(this.anchor));return new dl(r.parent.inlineContent?r:n,n)}replace(e,t=Os.empty){if(super.replace(e,t),t==Os.empty){let t=this.$from.marksAcross(this.$to);t&&e.ensureMarks(t);}}eq(e){return e instanceof dl&&e.anchor==this.anchor&&e.head==this.head}getBookmark(){return new hl(this.anchor,this.head)}toJSON(){return {type:"text",anchor:this.anchor,head:this.head}}static fromJSON(e,t){if("number"!=typeof t.anchor||"number"!=typeof t.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new dl(e.resolve(t.anchor),e.resolve(t.head))}static create(e,t,n=t){let r=e.resolve(t);return new this(r,n==t?r:e.resolve(n))}static between(e,t,n){let r=e.pos-t.pos;if(n&&!r||(n=r>=0?1:-1),!t.parent.inlineContent){let e=al.findFrom(t,n,!0)||al.findFrom(t,-n,!0);if(!e)return al.near(t,n);t=e.$head;}return e.parent.inlineContent||(0==r||(e=(al.findFrom(e,-n,!0)||al.findFrom(e,n,!0)).$anchor).pos<t.pos!=r<0)&&(e=t),new dl(e,t)}}al.jsonID("text",dl);class hl{constructor(e,t){this.anchor=e,this.head=t;}map(e){return new hl(e.map(this.anchor),e.map(this.head))}resolve(e){return dl.between(e.resolve(this.anchor),e.resolve(this.head))}}class pl extends al{constructor(e){let t=e.nodeAfter,n=e.node(0).resolve(e.pos+t.nodeSize);super(e,n),this.node=t;}map(e,t){let{deleted:n,pos:r}=t.mapResult(this.anchor),i=e.resolve(r);return n?al.near(i):new pl(i)}content(){return new Os(Cs.from(this.node),0,0)}eq(e){return e instanceof pl&&e.anchor==this.anchor}toJSON(){return {type:"node",anchor:this.anchor}}getBookmark(){return new fl(this.anchor)}static fromJSON(e,t){if("number"!=typeof t.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new pl(e.resolve(t.anchor))}static create(e,t){return new pl(e.resolve(t))}static isSelectable(e){return !e.isText&&!1!==e.type.spec.selectable}}pl.prototype.visible=!1,al.jsonID("node",pl);class fl{constructor(e){this.anchor=e;}map(e){let{deleted:t,pos:n}=e.mapResult(this.anchor);return t?new hl(n,n):new fl(n)}resolve(e){let t=e.resolve(this.anchor),n=t.nodeAfter;return n&&pl.isSelectable(n)?new pl(t):al.near(t)}}class ml extends al{constructor(e){super(e.resolve(0),e.resolve(e.content.size));}replace(e,t=Os.empty){if(t==Os.empty){e.delete(0,e.doc.content.size);let t=al.atStart(e.doc);t.eq(e.selection)||e.setSelection(t);}else super.replace(e,t);}toJSON(){return {type:"all"}}static fromJSON(e){return new ml(e)}map(e){return new ml(e)}eq(e){return e instanceof ml}getBookmark(){return gl}}al.jsonID("all",ml);const gl={map(){return this},resolve:e=>new ml(e)};function vl(e,t,n,r,i,o=!1){if(t.inlineContent)return dl.create(e,n);for(let s=r-(i>0?0:1);i>0?s<t.childCount:s>=0;s+=i){let r=t.child(s);if(r.isAtom){if(!o&&pl.isSelectable(r))return pl.create(e,n-(i<0?r.nodeSize:0))}else {let t=vl(e,r,n+i,i<0?r.childCount:0,i,o);if(t)return t}n+=r.nodeSize*i;}return null}function yl(e,t,n){let r=e.steps.length-1;if(r<t)return;let i,o=e.steps[r];(o instanceof Ia||o instanceof Pa)&&(e.mapping.maps[r].forEach(((e,t,n,r)=>{null==i&&(i=r);})),e.setSelection(al.near(e.doc.resolve(i),n)));}class bl extends ol{constructor(e){super(e.doc),this.curSelectionFor=0,this.updated=0,this.meta=Object.create(null),this.time=Date.now(),this.curSelection=e.selection,this.storedMarks=e.storedMarks;}get selection(){return this.curSelectionFor<this.steps.length&&(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}setSelection(e){if(e.$from.doc!=this.doc)throw new RangeError("Selection passed to setSelection must point at the current document");return this.curSelection=e,this.curSelectionFor=this.steps.length,this.updated=-3&(1|this.updated),this.storedMarks=null,this}get selectionSet(){return (1&this.updated)>0}setStoredMarks(e){return this.storedMarks=e,this.updated|=2,this}ensureMarks(e){return Ds.sameSet(this.storedMarks||this.selection.$from.marks(),e)||this.setStoredMarks(e),this}addStoredMark(e){return this.ensureMarks(e.addToSet(this.storedMarks||this.selection.$head.marks()))}removeStoredMark(e){return this.ensureMarks(e.removeFromSet(this.storedMarks||this.selection.$head.marks()))}get storedMarksSet(){return (2&this.updated)>0}addStep(e,t){super.addStep(e,t),this.updated=-3&this.updated,this.storedMarks=null;}setTime(e){return this.time=e,this}replaceSelection(e){return this.selection.replace(this,e),this}replaceSelectionWith(e,t=!0){let n=this.selection;return t&&(e=e.mark(this.storedMarks||(n.empty?n.$from.marks():n.$from.marksAcross(n.$to)||Ds.none))),n.replaceWith(this,e),this}deleteSelection(){return this.selection.replace(this),this}insertText(e,t,n){let r=this.doc.type.schema;if(null==t)return e?this.replaceSelectionWith(r.text(e),!0):this.deleteSelection();{if(null==n&&(n=t),n=null==n?t:n,!e)return this.deleteRange(t,n);let i=this.storedMarks;if(!i){let e=this.doc.resolve(t);i=n==t?e.marks():e.marksAcross(this.doc.resolve(n));}return this.replaceRangeWith(t,n,r.text(e,i)),this.selection.empty||this.setSelection(al.near(this.selection.$to)),this}}setMeta(e,t){return this.meta["string"==typeof e?e:e.key]=t,this}getMeta(e){return this.meta["string"==typeof e?e:e.key]}get isGeneric(){for(let e in this.meta)return !1;return !0}scrollIntoView(){return this.updated|=4,this}get scrolledIntoView(){return (4&this.updated)>0}}function wl(e,t){return t&&e?e.bind(t):e}class kl{constructor(e,t,n){this.name=e,this.init=wl(t.init,n),this.apply=wl(t.apply,n);}}const Cl=[new kl("doc",{init:e=>e.doc||e.schema.topNodeType.createAndFill(),apply:e=>e.doc}),new kl("selection",{init:(e,t)=>e.selection||al.atStart(t.doc),apply:e=>e.selection}),new kl("storedMarks",{init:e=>e.storedMarks||null,apply:(e,t,n,r)=>r.selection.$cursor?e.storedMarks:null}),new kl("scrollToSelection",{init:()=>0,apply:(e,t)=>e.scrolledIntoView?t+1:t})];class El{constructor(e,t){this.schema=e,this.plugins=[],this.pluginsByKey=Object.create(null),this.fields=Cl.slice(),t&&t.forEach((e=>{if(this.pluginsByKey[e.key])throw new RangeError("Adding different instances of a keyed plugin ("+e.key+")");this.plugins.push(e),this.pluginsByKey[e.key]=e,e.spec.state&&this.fields.push(new kl(e.key,e.spec.state,e));}));}}class xl{constructor(e){this.config=e;}get schema(){return this.config.schema}get plugins(){return this.config.plugins}apply(e){return this.applyTransaction(e).state}filterTransaction(e,t=-1){for(let n=0;n<this.config.plugins.length;n++)if(n!=t){let t=this.config.plugins[n];if(t.spec.filterTransaction&&!t.spec.filterTransaction.call(t,e,this))return !1}return !0}applyTransaction(e){if(!this.filterTransaction(e))return {state:this,transactions:[]};let t=[e],n=this.applyInner(e),r=null;for(;;){let i=!1;for(let o=0;o<this.config.plugins.length;o++){let s=this.config.plugins[o];if(s.spec.appendTransaction){let a=r?r[o].n:0,l=r?r[o].state:this,c=a<t.length&&s.spec.appendTransaction.call(s,a?t.slice(a):t,l,n);if(c&&n.filterTransaction(c,o)){if(c.setMeta("appendedTransaction",e),!r){r=[];for(let e=0;e<this.config.plugins.length;e++)r.push(e<o?{state:n,n:t.length}:{state:this,n:0});}t.push(c),n=n.applyInner(c),i=!0;}r&&(r[o]={state:n,n:t.length});}}if(!i)return {state:n,transactions:t}}}applyInner(e){if(!e.before.eq(this.doc))throw new RangeError("Applying a mismatched transaction");let t=new xl(this.config),n=this.config.fields;for(let r=0;r<n.length;r++){let i=n[r];t[i.name]=i.apply(e,this[i.name],this,t);}return t}get tr(){return new bl(this)}static create(e){let t=new El(e.doc?e.doc.type.schema:e.schema,e.plugins),n=new xl(t);for(let r=0;r<t.fields.length;r++)n[t.fields[r].name]=t.fields[r].init(e,n);return n}reconfigure(e){let t=new El(this.schema,e.plugins),n=t.fields,r=new xl(t);for(let t=0;t<n.length;t++){let i=n[t].name;r[i]=this.hasOwnProperty(i)?this[i]:n[t].init(e,r);}return r}toJSON(e){let t={doc:this.doc.toJSON(),selection:this.selection.toJSON()};if(this.storedMarks&&(t.storedMarks=this.storedMarks.map((e=>e.toJSON()))),e&&"object"==typeof e)for(let n in e){if("doc"==n||"selection"==n)throw new RangeError("The JSON fields `doc` and `selection` are reserved");let r=e[n],i=r.spec.state;i&&i.toJSON&&(t[n]=i.toJSON.call(r,this[r.key]));}return t}static fromJSON(e,t,n){if(!t)throw new RangeError("Invalid input for EditorState.fromJSON");if(!e.schema)throw new RangeError("Required config field 'schema' missing");let r=new El(e.schema,e.plugins),i=new xl(r);return r.fields.forEach((r=>{if("doc"==r.name)i.doc=Us.fromJSON(e.schema,t.doc);else if("selection"==r.name)i.selection=al.fromJSON(i.doc,t.selection);else if("storedMarks"==r.name)t.storedMarks&&(i.storedMarks=t.storedMarks.map(e.schema.markFromJSON));else {if(n)for(let o in n){let s=n[o],a=s.spec.state;if(s.key==r.name&&a&&a.fromJSON&&Object.prototype.hasOwnProperty.call(t,o))return void(i[r.name]=a.fromJSON.call(s,e,t[o],i))}i[r.name]=r.init(e,i);}})),i}}function Sl(e,t,n){for(let r in e){let i=e[r];i instanceof Function?i=i.bind(t):"handleDOMEvents"==r&&(i=Sl(i,t,{})),n[r]=i;}return n}class Dl{constructor(e){this.spec=e,this.props={},e.props&&Sl(e.props,this,this.props),this.key=e.key?e.key.key:Ol("plugin");}getState(e){return e[this.key]}}const Ml=Object.create(null);function Ol(e){return e in Ml?e+"$"+ ++Ml[e]:(Ml[e]=0,e+"$")}class Al{constructor(e="key"){this.key=Ol(e);}get(e){return e.config.pluginsByKey[this.key]}getState(e){return e[this.key]}}const Nl="undefined"!=typeof navigator?navigator:null,_l="undefined"!=typeof document?document:null,Tl=Nl&&Nl.userAgent||"",Ll=/Edge\/(\d+)/.exec(Tl),Rl=/MSIE \d/.exec(Tl),Fl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Tl),Bl=!!(Rl||Fl||Ll),Il=Rl?document.documentMode:Fl?+Fl[1]:Ll?+Ll[1]:0,Pl=!Bl&&/gecko\/(\d+)/i.test(Tl);Pl&&(/Firefox\/(\d+)/.exec(Tl)||[0,0])[1];const zl=!Bl&&/Chrome\/(\d+)/.exec(Tl),$l=!!zl,jl=zl?+zl[1]:0,Hl=!Bl&&!!Nl&&/Apple Computer/.test(Nl.vendor),Vl=Hl&&(/Mobile\/\w+/.test(Tl)||!!Nl&&Nl.maxTouchPoints>2),Kl=Vl||!!Nl&&/Mac/.test(Nl.platform),ql=/Android \d/.test(Tl),Ul=!!_l&&"webkitFontSmoothing"in _l.documentElement.style,Wl=Ul?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,Gl=function(e){for(var t=0;;t++)if(!(e=e.previousSibling))return t},Jl=function(e){let t=e.assignedSlot||e.parentNode;return t&&11==t.nodeType?t.host:t};let Zl=null;const Xl=function(e,t,n){let r=Zl||(Zl=document.createRange());return r.setEnd(e,null==n?e.nodeValue.length:n),r.setStart(e,t||0),r},Ql=function(e,t,n,r){return n&&(ec(e,t,n,r,-1)||ec(e,t,n,r,1))},Yl=/^(img|br|input|textarea|hr)$/i;function ec(e,t,n,r,i){for(;;){if(e==n&&t==r)return !0;if(t==(i<0?0:tc(e))){let n=e.parentNode;if(!n||1!=n.nodeType||nc(e)||Yl.test(e.nodeName)||"false"==e.contentEditable)return !1;t=Gl(e)+(i<0?0:1),e=n;}else {if(1!=e.nodeType)return !1;if("false"==(e=e.childNodes[t+(i<0?-1:0)]).contentEditable)return !1;t=i<0?tc(e):0;}}}function tc(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}function nc(e){let t;for(let n=e;n&&!(t=n.pmViewDesc);n=n.parentNode);return t&&t.node&&t.node.isBlock&&(t.dom==e||t.contentDOM==e)}const rc=function(e){let t=e.isCollapsed;return t&&$l&&e.rangeCount&&!e.getRangeAt(0).collapsed&&(t=!1),t};function ic(e,t){let n=document.createEvent("Event");return n.initEvent("keydown",!0,!0),n.keyCode=e,n.key=n.code=t,n}function oc(e){return {left:0,right:e.documentElement.clientWidth,top:0,bottom:e.documentElement.clientHeight}}function sc(e,t){return "number"==typeof e?e:e[t]}function ac(e){let t=e.getBoundingClientRect(),n=t.width/e.offsetWidth||1,r=t.height/e.offsetHeight||1;return {left:t.left,right:t.left+e.clientWidth*n,top:t.top,bottom:t.top+e.clientHeight*r}}function lc(e,t,n){let r=e.someProp("scrollThreshold")||0,i=e.someProp("scrollMargin")||5,o=e.dom.ownerDocument;for(let s=n||e.dom;s;s=Jl(s)){if(1!=s.nodeType)continue;let e=s,n=e==o.body,a=n?oc(o):ac(e),l=0,c=0;if(t.top<a.top+sc(r,"top")?c=-(a.top-t.top+sc(i,"top")):t.bottom>a.bottom-sc(r,"bottom")&&(c=t.bottom-a.bottom+sc(i,"bottom")),t.left<a.left+sc(r,"left")?l=-(a.left-t.left+sc(i,"left")):t.right>a.right-sc(r,"right")&&(l=t.right-a.right+sc(i,"right")),l||c)if(n)o.defaultView.scrollBy(l,c);else {let n=e.scrollLeft,r=e.scrollTop;c&&(e.scrollTop+=c),l&&(e.scrollLeft+=l);let i=e.scrollLeft-n,o=e.scrollTop-r;t={left:t.left-i,top:t.top-o,right:t.right-i,bottom:t.bottom-o};}if(n)break}}function cc(e){let t=[],n=e.ownerDocument;for(let r=e;r&&(t.push({dom:r,top:r.scrollTop,left:r.scrollLeft}),e!=n);r=Jl(r));return t}function uc(e,t){for(let n=0;n<e.length;n++){let{dom:r,top:i,left:o}=e[n];r.scrollTop!=i+t&&(r.scrollTop=i+t),r.scrollLeft!=o&&(r.scrollLeft=o);}}let dc=null;function hc(e,t){let n,r,i=2e8,o=0,s=t.top,a=t.top;for(let l=e.firstChild,c=0;l;l=l.nextSibling,c++){let e;if(1==l.nodeType)e=l.getClientRects();else {if(3!=l.nodeType)continue;e=Xl(l).getClientRects();}for(let u=0;u<e.length;u++){let d=e[u];if(d.top<=s&&d.bottom>=a){s=Math.max(d.bottom,s),a=Math.min(d.top,a);let e=d.left>t.left?d.left-t.left:d.right<t.left?t.left-d.right:0;if(e<i){n=l,i=e,r=e&&3==n.nodeType?{left:d.right<t.left?d.right:d.left,top:t.top}:t,1==l.nodeType&&e&&(o=c+(t.left>=(d.left+d.right)/2?1:0));continue}}!n&&(t.left>=d.right&&t.top>=d.top||t.left>=d.left&&t.top>=d.bottom)&&(o=c+1);}}return n&&3==n.nodeType?function(e,t){let n=e.nodeValue.length,r=document.createRange();for(let i=0;i<n;i++){r.setEnd(e,i+1),r.setStart(e,i);let n=gc(r,1);if(n.top!=n.bottom&&pc(t,n))return {node:e,offset:i+(t.left>=(n.left+n.right)/2?1:0)}}return {node:e,offset:0}}(n,r):!n||i&&1==n.nodeType?{node:e,offset:o}:hc(n,r)}function pc(e,t){return e.left>=t.left-1&&e.left<=t.right+1&&e.top>=t.top-1&&e.top<=t.bottom+1}function fc(e,t,n){let r=e.childNodes.length;if(r&&n.top<n.bottom)for(let i=Math.max(0,Math.min(r-1,Math.floor(r*(t.top-n.top)/(n.bottom-n.top))-2)),o=i;;){let n=e.childNodes[o];if(1==n.nodeType){let e=n.getClientRects();for(let r=0;r<e.length;r++){let i=e[r];if(pc(t,i))return fc(n,t,i)}}if((o=(o+1)%r)==i)break}return e}function mc(e,t){let n,r=e.dom.ownerDocument,i=0;if(r.caretPositionFromPoint)try{let e=r.caretPositionFromPoint(t.left,t.top);e&&({offsetNode:n,offset:i}=e);}catch(e){}if(!n&&r.caretRangeFromPoint){let e=r.caretRangeFromPoint(t.left,t.top);e&&({startContainer:n,startOffset:i}=e);}let o,s=(e.root.elementFromPoint?e.root:r).elementFromPoint(t.left,t.top+1);if(!s||!e.dom.contains(1!=s.nodeType?s.parentNode:s)){let n=e.dom.getBoundingClientRect();if(!pc(t,n))return null;if(s=fc(e.dom,t,n),!s)return null}if(Hl)for(let e=s;n&&e;e=Jl(e))e.draggable&&(n=void 0);if(s=function(e,t){let n=e.parentNode;return n&&/^li$/i.test(n.nodeName)&&t.left<e.getBoundingClientRect().left?n:e}(s,t),n){if(Pl&&1==n.nodeType&&(i=Math.min(i,n.childNodes.length),i<n.childNodes.length)){let e,r=n.childNodes[i];"IMG"==r.nodeName&&(e=r.getBoundingClientRect()).right<=t.left&&e.bottom>t.top&&i++;}n==e.dom&&i==n.childNodes.length-1&&1==n.lastChild.nodeType&&t.top>n.lastChild.getBoundingClientRect().bottom?o=e.state.doc.content.size:0!=i&&1==n.nodeType&&"BR"==n.childNodes[i-1].nodeName||(o=function(e,t,n,r){let i=-1;for(let n=t;n!=e.dom;){let t=e.docView.nearestDesc(n,!0);if(!t)return null;if(t.node.isBlock&&t.parent){let e=t.dom.getBoundingClientRect();if(e.left>r.left||e.top>r.top)i=t.posBefore;else {if(!(e.right<r.left||e.bottom<r.top))break;i=t.posAfter;}}n=t.dom.parentNode;}return i>-1?i:e.docView.posFromDOM(t,n,1)}(e,n,i,t));}null==o&&(o=function(e,t,n){let{node:r,offset:i}=hc(t,n),o=-1;if(1==r.nodeType&&!r.firstChild){let e=r.getBoundingClientRect();o=e.left!=e.right&&n.left>(e.left+e.right)/2?1:-1;}return e.docView.posFromDOM(r,i,o)}(e,s,t));let a=e.docView.nearestDesc(s,!0);return {pos:o,inside:a?a.posAtStart-a.border:-1}}function gc(e,t){let n=e.getClientRects();return n.length?n[t<0?0:n.length-1]:e.getBoundingClientRect()}const vc=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;function yc(e,t,n){let{node:r,offset:i}=e.docView.domFromPos(t,n<0?-1:1),o=Ul||Pl;if(3==r.nodeType){if(!o||!vc.test(r.nodeValue)&&(n<0?i:i!=r.nodeValue.length)){let e=i,t=i,o=n<0?1:-1;return n<0&&!i?(t++,o=-1):n>=0&&i==r.nodeValue.length?(e--,o=1):n<0?e--:t++,bc(gc(Xl(r,e,t),o),o<0)}{let e=gc(Xl(r,i,i),n);if(Pl&&i&&/\s/.test(r.nodeValue[i-1])&&i<r.nodeValue.length){let t=gc(Xl(r,i-1,i-1),-1);if(t.top==e.top){let n=gc(Xl(r,i,i+1),-1);if(n.top!=e.top)return bc(n,n.left<t.left)}}return e}}if(!e.state.doc.resolve(t).parent.inlineContent){if(i&&(n<0||i==tc(r))){let e=r.childNodes[i-1];if(1==e.nodeType)return wc(e.getBoundingClientRect(),!1)}if(i<tc(r)){let e=r.childNodes[i];if(1==e.nodeType)return wc(e.getBoundingClientRect(),!0)}return wc(r.getBoundingClientRect(),n>=0)}if(i&&(n<0||i==tc(r))){let e=r.childNodes[i-1],t=3==e.nodeType?Xl(e,tc(e)-(o?0:1)):1!=e.nodeType||"BR"==e.nodeName&&e.nextSibling?null:e;if(t)return bc(gc(t,1),!1)}if(i<tc(r)){let e=r.childNodes[i];for(;e.pmViewDesc&&e.pmViewDesc.ignoreForCoords;)e=e.nextSibling;let t=e?3==e.nodeType?Xl(e,0,o?0:1):1==e.nodeType?e:null:null;if(t)return bc(gc(t,-1),!0)}return bc(gc(3==r.nodeType?Xl(r):r,-n),n>=0)}function bc(e,t){if(0==e.width)return e;let n=t?e.left:e.right;return {top:e.top,bottom:e.bottom,left:n,right:n}}function wc(e,t){if(0==e.height)return e;let n=t?e.top:e.bottom;return {top:n,bottom:n,left:e.left,right:e.right}}function kc(e,t,n){let r=e.state,i=e.root.activeElement;r!=t&&e.updateState(t),i!=e.dom&&e.focus();try{return n()}finally{r!=t&&e.updateState(r),i!=e.dom&&i&&i.focus();}}const Cc=/[\u0590-\u08ac]/;let Ec=null,xc=null,Sc=!1;function Dc(e,t,n){return Ec==t&&xc==n?Sc:(Ec=t,xc=n,Sc="up"==n||"down"==n?function(e,t,n){let r=t.selection,i="up"==n?r.$from:r.$to;return kc(e,t,(()=>{let{node:t}=e.docView.domFromPos(i.pos,"up"==n?-1:1);for(;;){let n=e.docView.nearestDesc(t,!0);if(!n)break;if(n.node.isBlock){t=n.dom;break}t=n.dom.parentNode;}let r=yc(e,i.pos,1);for(let e=t.firstChild;e;e=e.nextSibling){let t;if(1==e.nodeType)t=e.getClientRects();else {if(3!=e.nodeType)continue;t=Xl(e,0,e.nodeValue.length).getClientRects();}for(let e=0;e<t.length;e++){let i=t[e];if(i.bottom>i.top+1&&("up"==n?r.top-i.top>2*(i.bottom-r.top):i.bottom-r.bottom>2*(r.bottom-i.top)))return !1}}return !0}))}(e,t,n):function(e,t,n){let{$head:r}=t.selection;if(!r.parent.isTextblock)return !1;let i=r.parentOffset,o=!i,s=i==r.parent.content.size,a=e.domSelection();return Cc.test(r.parent.textContent)&&a.modify?kc(e,t,(()=>{let t=a.getRangeAt(0),i=a.focusNode,o=a.focusOffset,s=a.caretBidiLevel;a.modify("move",n,"character");let l=!(r.depth?e.docView.domAfterPos(r.before()):e.dom).contains(1==a.focusNode.nodeType?a.focusNode:a.focusNode.parentNode)||i==a.focusNode&&o==a.focusOffset;return a.removeAllRanges(),a.addRange(t),null!=s&&(a.caretBidiLevel=s),l})):"left"==n||"backward"==n?o:s}(e,t,n))}class Mc{constructor(e,t,n,r){this.parent=e,this.children=t,this.dom=n,this.contentDOM=r,this.dirty=0,n.pmViewDesc=this;}matchesWidget(e){return !1}matchesMark(e){return !1}matchesNode(e,t,n){return !1}matchesHack(e){return !1}parseRule(){return null}stopEvent(e){return !1}get size(){let e=0;for(let t=0;t<this.children.length;t++)e+=this.children[t].size;return e}get border(){return 0}destroy(){this.parent=void 0,this.dom.pmViewDesc==this&&(this.dom.pmViewDesc=void 0);for(let e=0;e<this.children.length;e++)this.children[e].destroy();}posBeforeChild(e){for(let t=0,n=this.posAtStart;;t++){let r=this.children[t];if(r==e)return n;n+=r.size;}}get posBefore(){return this.parent.posBeforeChild(this)}get posAtStart(){return this.parent?this.parent.posBeforeChild(this)+this.border:0}get posAfter(){return this.posBefore+this.size}get posAtEnd(){return this.posAtStart+this.size-2*this.border}localPosFromDOM(e,t,n){if(this.contentDOM&&this.contentDOM.contains(1==e.nodeType?e:e.parentNode)){if(n<0){let n,r;if(e==this.contentDOM)n=e.childNodes[t-1];else {for(;e.parentNode!=this.contentDOM;)e=e.parentNode;n=e.previousSibling;}for(;n&&(!(r=n.pmViewDesc)||r.parent!=this);)n=n.previousSibling;return n?this.posBeforeChild(r)+r.size:this.posAtStart}{let n,r;if(e==this.contentDOM)n=e.childNodes[t];else {for(;e.parentNode!=this.contentDOM;)e=e.parentNode;n=e.nextSibling;}for(;n&&(!(r=n.pmViewDesc)||r.parent!=this);)n=n.nextSibling;return n?this.posBeforeChild(r):this.posAtEnd}}let r;if(e==this.dom&&this.contentDOM)r=t>Gl(this.contentDOM);else if(this.contentDOM&&this.contentDOM!=this.dom&&this.dom.contains(this.contentDOM))r=2&e.compareDocumentPosition(this.contentDOM);else if(this.dom.firstChild){if(0==t)for(let t=e;;t=t.parentNode){if(t==this.dom){r=!1;break}if(t.previousSibling)break}if(null==r&&t==e.childNodes.length)for(let t=e;;t=t.parentNode){if(t==this.dom){r=!0;break}if(t.nextSibling)break}}return (null==r?n>0:r)?this.posAtEnd:this.posAtStart}nearestDesc(e,t=!1){for(let n=!0,r=e;r;r=r.parentNode){let i,o=this.getDesc(r);if(o&&(!t||o.node)){if(!n||!(i=o.nodeDOM)||(1==i.nodeType?i.contains(1==e.nodeType?e:e.parentNode):i==e))return o;n=!1;}}}getDesc(e){let t=e.pmViewDesc;for(let e=t;e;e=e.parent)if(e==this)return t}posFromDOM(e,t,n){for(let r=e;r;r=r.parentNode){let i=this.getDesc(r);if(i)return i.localPosFromDOM(e,t,n)}return -1}descAt(e){for(let t=0,n=0;t<this.children.length;t++){let r=this.children[t],i=n+r.size;if(n==e&&i!=n){for(;!r.border&&r.children.length;)r=r.children[0];return r}if(e<i)return r.descAt(e-n-r.border);n=i;}}domFromPos(e,t){if(!this.contentDOM)return {node:this.dom,offset:0};let n,r=0,i=0;for(let t=0;r<this.children.length;r++){let n=this.children[r],o=t+n.size;if(o>e||n instanceof Rc){i=e-t;break}t=o;}if(i)return this.children[r].domFromPos(i-this.children[r].border,t);for(;r&&!(n=this.children[r-1]).size&&n instanceof Oc&&n.side>=0;r--);if(t<=0){let e,n=!0;for(;e=r?this.children[r-1]:null,e&&e.dom.parentNode!=this.contentDOM;r--,n=!1);return e&&t&&n&&!e.border&&!e.domAtom?e.domFromPos(e.size,t):{node:this.contentDOM,offset:e?Gl(e.dom)+1:0}}{let e,n=!0;for(;e=r<this.children.length?this.children[r]:null,e&&e.dom.parentNode!=this.contentDOM;r++,n=!1);return e&&n&&!e.border&&!e.domAtom?e.domFromPos(0,t):{node:this.contentDOM,offset:e?Gl(e.dom):this.contentDOM.childNodes.length}}}parseRange(e,t,n=0){if(0==this.children.length)return {node:this.contentDOM,from:e,to:t,fromOffset:0,toOffset:this.contentDOM.childNodes.length};let r=-1,i=-1;for(let o=n,s=0;;s++){let n=this.children[s],a=o+n.size;if(-1==r&&e<=a){let i=o+n.border;if(e>=i&&t<=a-n.border&&n.node&&n.contentDOM&&this.contentDOM.contains(n.contentDOM))return n.parseRange(e,t,i);e=o;for(let t=s;t>0;t--){let n=this.children[t-1];if(n.size&&n.dom.parentNode==this.contentDOM&&!n.emptyChildAt(1)){r=Gl(n.dom)+1;break}e-=n.size;}-1==r&&(r=0);}if(r>-1&&(a>t||s==this.children.length-1)){t=a;for(let e=s+1;e<this.children.length;e++){let n=this.children[e];if(n.size&&n.dom.parentNode==this.contentDOM&&!n.emptyChildAt(-1)){i=Gl(n.dom);break}t+=n.size;}-1==i&&(i=this.contentDOM.childNodes.length);break}o=a;}return {node:this.contentDOM,from:e,to:t,fromOffset:r,toOffset:i}}emptyChildAt(e){if(this.border||!this.contentDOM||!this.children.length)return !1;let t=this.children[e<0?0:this.children.length-1];return 0==t.size||t.emptyChildAt(e)}domAfterPos(e){let{node:t,offset:n}=this.domFromPos(e,0);if(1!=t.nodeType||n==t.childNodes.length)throw new RangeError("No node after pos "+e);return t.childNodes[n]}setSelection(e,t,n,r=!1){let i=Math.min(e,t),o=Math.max(e,t);for(let s=0,a=0;s<this.children.length;s++){let l=this.children[s],c=a+l.size;if(i>a&&o<c)return l.setSelection(e-a-l.border,t-a-l.border,n,r);a=c;}let s=this.domFromPos(e,e?-1:1),a=t==e?s:this.domFromPos(t,t?-1:1),l=n.getSelection(),c=!1;if((Pl||Hl)&&e==t){let{node:e,offset:t}=s;if(3==e.nodeType){if(c=!(!t||"\n"!=e.nodeValue[t-1]),c&&t==e.nodeValue.length)for(let t,n=e;n;n=n.parentNode){if(t=n.nextSibling){"BR"==t.nodeName&&(s=a={node:t.parentNode,offset:Gl(t)+1});break}let e=n.pmViewDesc;if(e&&e.node&&e.node.isBlock)break}}else {let n=e.childNodes[t-1];c=n&&("BR"==n.nodeName||"false"==n.contentEditable);}}if(Pl&&l.focusNode&&l.focusNode!=a.node&&1==l.focusNode.nodeType){let e=l.focusNode.childNodes[l.focusOffset];e&&"false"==e.contentEditable&&(r=!0);}if(!(r||c&&Hl)&&Ql(s.node,s.offset,l.anchorNode,l.anchorOffset)&&Ql(a.node,a.offset,l.focusNode,l.focusOffset))return;let u=!1;if((l.extend||e==t)&&!c){l.collapse(s.node,s.offset);try{e!=t&&l.extend(a.node,a.offset),u=!0;}catch(e){if(!(e instanceof DOMException))throw e}}if(!u){if(e>t){let e=s;s=a,a=e;}let n=document.createRange();n.setEnd(a.node,a.offset),n.setStart(s.node,s.offset),l.removeAllRanges(),l.addRange(n);}}ignoreMutation(e){return !this.contentDOM&&"selection"!=e.type}get contentLost(){return this.contentDOM&&this.contentDOM!=this.dom&&!this.dom.contains(this.contentDOM)}markDirty(e,t){for(let n=0,r=0;r<this.children.length;r++){let i=this.children[r],o=n+i.size;if(n==o?e<=o&&t>=n:e<o&&t>n){let r=n+i.border,s=o-i.border;if(e>=r&&t<=s)return this.dirty=e==n||t==o?2:1,void(e!=r||t!=s||!i.contentLost&&i.dom.parentNode==this.contentDOM?i.markDirty(e-r,t-r):i.dirty=3);i.dirty=i.dom!=i.contentDOM||i.dom.parentNode!=this.contentDOM||i.children.length?3:2;}n=o;}this.dirty=2;}markParentsDirty(){let e=1;for(let t=this.parent;t;t=t.parent,e++){let n=1==e?2:1;t.dirty<n&&(t.dirty=n);}}get domAtom(){return !1}get ignoreForCoords(){return !1}}class Oc extends Mc{constructor(e,t,n,r){let i,o=t.type.toDOM;if("function"==typeof o&&(o=o(n,(()=>i?i.parent?i.parent.posBeforeChild(i):void 0:r))),!t.type.spec.raw){if(1!=o.nodeType){let e=document.createElement("span");e.appendChild(o),o=e;}o.contentEditable="false",o.classList.add("ProseMirror-widget");}super(e,[],o,null),this.widget=t,this.widget=t,i=this;}matchesWidget(e){return 0==this.dirty&&e.type.eq(this.widget.type)}parseRule(){return {ignore:!0}}stopEvent(e){let t=this.widget.spec.stopEvent;return !!t&&t(e)}ignoreMutation(e){return "selection"!=e.type||this.widget.spec.ignoreSelection}destroy(){this.widget.type.destroy(this.dom),super.destroy();}get domAtom(){return !0}get side(){return this.widget.type.side}}class Ac extends Mc{constructor(e,t,n,r){super(e,[],t,null),this.textDOM=n,this.text=r;}get size(){return this.text.length}localPosFromDOM(e,t){return e!=this.textDOM?this.posAtStart+(t?this.size:0):this.posAtStart+t}domFromPos(e){return {node:this.textDOM,offset:e}}ignoreMutation(e){return "characterData"===e.type&&e.target.nodeValue==e.oldValue}}class Nc extends Mc{constructor(e,t,n,r){super(e,[],n,r),this.mark=t;}static create(e,t,n,r){let i=r.nodeViews[t.type.name],o=i&&i(t,r,n);return o&&o.dom||(o=Ca.renderSpec(document,t.type.spec.toDOM(t,n))),new Nc(e,t,o.dom,o.contentDOM||o.dom)}parseRule(){return 3&this.dirty||this.mark.type.spec.reparseInView?null:{mark:this.mark.type.name,attrs:this.mark.attrs,contentElement:this.contentDOM||void 0}}matchesMark(e){return 3!=this.dirty&&this.mark.eq(e)}markDirty(e,t){if(super.markDirty(e,t),0!=this.dirty){let e=this.parent;for(;!e.node;)e=e.parent;e.dirty<this.dirty&&(e.dirty=this.dirty),this.dirty=0;}}slice(e,t,n){let r=Nc.create(this.parent,this.mark,!0,n),i=this.children,o=this.size;t<o&&(i=Wc(i,t,o,n)),e>0&&(i=Wc(i,0,e,n));for(let e=0;e<i.length;e++)i[e].parent=r;return r.children=i,r}}class _c extends Mc{constructor(e,t,n,r,i,o,s,a,l){super(e,[],i,o),this.node=t,this.outerDeco=n,this.innerDeco=r,this.nodeDOM=s,o&&this.updateChildren(a,l);}static create(e,t,n,r,i,o){let s,a=i.nodeViews[t.type.name],l=a&&a(t,i,(()=>s?s.parent?s.parent.posBeforeChild(s):void 0:o),n,r),c=l&&l.dom,u=l&&l.contentDOM;if(t.isText)if(c){if(3!=c.nodeType)throw new RangeError("Text must be rendered as a DOM text node")}else c=document.createTextNode(t.text);else c||({dom:c,contentDOM:u}=Ca.renderSpec(document,t.type.spec.toDOM(t)));u||t.isText||"BR"==c.nodeName||(c.hasAttribute("contenteditable")||(c.contentEditable="false"),t.type.spec.draggable&&(c.draggable=!0));let d=c;return c=Hc(c,n,t),l?s=new Fc(e,t,n,r,c,u||null,d,l,i,o+1):t.isText?new Lc(e,t,n,r,c,d,i):new _c(e,t,n,r,c,u||null,d,i,o+1)}parseRule(){if(this.node.type.spec.reparseInView)return null;let e={node:this.node.type.name,attrs:this.node.attrs};if("pre"==this.node.type.whitespace&&(e.preserveWhitespace="full"),this.contentDOM)if(this.contentLost){for(let t=this.children.length-1;t>=0;t--){let n=this.children[t];if(this.dom.contains(n.dom.parentNode)){e.contentElement=n.dom.parentNode;break}}e.contentElement||(e.getContent=()=>Cs.empty);}else e.contentElement=this.contentDOM;else e.getContent=()=>this.node.content;return e}matchesNode(e,t,n){return 0==this.dirty&&e.eq(this.node)&&Vc(t,this.outerDeco)&&n.eq(this.innerDeco)}get size(){return this.node.nodeSize}get border(){return this.node.isLeaf?0:1}updateChildren(e,t){let n=this.node.inlineContent,r=t,i=e.composing?this.localCompositionInfo(e,t):null,o=i&&i.pos>-1?i:null,s=i&&i.pos<0,a=new qc(this,o&&o.node);!function(e,t,n,r){let i=t.locals(e),o=0;if(0==i.length){for(let n=0;n<e.childCount;n++){let s=e.child(n);r(s,i,t.forChild(o,s),n),o+=s.nodeSize;}return}let s=0,a=[],l=null;for(let c=0;;){if(s<i.length&&i[s].to==o){let e,t=i[s++];for(;s<i.length&&i[s].to==o;)(e||(e=[t])).push(i[s++]);if(e){e.sort(Uc);for(let t=0;t<e.length;t++)n(e[t],c,!!l);}else n(t,c,!!l);}let u,d;if(l)d=-1,u=l,l=null;else {if(!(c<e.childCount))break;d=c,u=e.child(c++);}for(let e=0;e<a.length;e++)a[e].to<=o&&a.splice(e--,1);for(;s<i.length&&i[s].from<=o&&i[s].to>o;)a.push(i[s++]);let h=o+u.nodeSize;if(u.isText){let e=h;s<i.length&&i[s].from<e&&(e=i[s].from);for(let t=0;t<a.length;t++)a[t].to<e&&(e=a[t].to);e<h&&(l=u.cut(e-o),u=u.cut(0,e-o),h=e,d=-1);}r(u,u.isInline&&!u.isLeaf?a.filter((e=>!e.inline)):a.slice(),t.forChild(o,u),d),o=h;}}(this.node,this.innerDeco,((t,i,o)=>{t.spec.marks?a.syncToMarks(t.spec.marks,n,e):t.type.side>=0&&!o&&a.syncToMarks(i==this.node.childCount?Ds.none:this.node.child(i).marks,n,e),a.placeWidget(t,e,r);}),((t,o,l,c)=>{let u;a.syncToMarks(t.marks,n,e),a.findNodeMatch(t,o,l,c)||s&&e.state.selection.from>r&&e.state.selection.to<r+t.nodeSize&&(u=a.findIndexWithChild(i.node))>-1&&a.updateNodeAt(t,o,l,u,e)||a.updateNextNode(t,o,l,e,c)||a.addNode(t,o,l,e,r),r+=t.nodeSize;})),a.syncToMarks([],n,e),this.node.isTextblock&&a.addTextblockHacks(),a.destroyRest(),(a.changed||2==this.dirty)&&(o&&this.protectLocalComposition(e,o),Bc(this.contentDOM,this.children,e),Vl&&function(e){if("UL"==e.nodeName||"OL"==e.nodeName){let t=e.style.cssText;e.style.cssText=t+"; list-style: square !important",window.getComputedStyle(e).listStyle,e.style.cssText=t;}}(this.dom));}localCompositionInfo(e,t){let{from:n,to:r}=e.state.selection;if(!(e.state.selection instanceof dl)||n<t||r>t+this.node.content.size)return null;let i=e.domSelection(),o=function(e,t){for(;;){if(3==e.nodeType)return e;if(1==e.nodeType&&t>0){if(e.childNodes.length>t&&3==e.childNodes[t].nodeType)return e.childNodes[t];t=tc(e=e.childNodes[t-1]);}else {if(!(1==e.nodeType&&t<e.childNodes.length))return null;e=e.childNodes[t],t=0;}}}(i.focusNode,i.focusOffset);if(!o||!this.dom.contains(o.parentNode))return null;if(this.node.inlineContent){let e=o.nodeValue,i=function(e,t,n,r){for(let i=0,o=0;i<e.childCount&&o<=r;){let s=e.child(i++),a=o;if(o+=s.nodeSize,!s.isText)continue;let l=s.text;for(;i<e.childCount;){let t=e.child(i++);if(o+=t.nodeSize,!t.isText)break;l+=t.text;}if(o>=n){let e=a<r?l.lastIndexOf(t,r-a-1):-1;if(e>=0&&e+t.length+a>=n)return a+e;if(n==r&&l.length>=r+t.length-a&&l.slice(r-a,r-a+t.length)==t)return r}}return -1}(this.node.content,e,n-t,r-t);return i<0?null:{node:o,pos:i,text:e}}return {node:o,pos:-1,text:""}}protectLocalComposition(e,{node:t,pos:n,text:r}){if(this.getDesc(t))return;let i=t;for(;i.parentNode!=this.contentDOM;i=i.parentNode){for(;i.previousSibling;)i.parentNode.removeChild(i.previousSibling);for(;i.nextSibling;)i.parentNode.removeChild(i.nextSibling);i.pmViewDesc&&(i.pmViewDesc=void 0);}let o=new Ac(this,i,t,r);e.input.compositionNodes.push(o),this.children=Wc(this.children,n,n+r.length,e,o);}update(e,t,n,r){return !(3==this.dirty||!e.sameMarkup(this.node))&&(this.updateInner(e,t,n,r),!0)}updateInner(e,t,n,r){this.updateOuterDeco(t),this.node=e,this.innerDeco=n,this.contentDOM&&this.updateChildren(r,this.posAtStart),this.dirty=0;}updateOuterDeco(e){if(Vc(e,this.outerDeco))return;let t=1!=this.nodeDOM.nodeType,n=this.dom;this.dom=$c(this.dom,this.nodeDOM,zc(this.outerDeco,this.node,t),zc(e,this.node,t)),this.dom!=n&&(n.pmViewDesc=void 0,this.dom.pmViewDesc=this),this.outerDeco=e;}selectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.add("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||(this.dom.draggable=!0);}deselectNode(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.remove("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||this.dom.removeAttribute("draggable");}get domAtom(){return this.node.isAtom}}function Tc(e,t,n,r,i){return Hc(r,t,e),new _c(void 0,e,t,n,r,r,r,i,0)}class Lc extends _c{constructor(e,t,n,r,i,o,s){super(e,t,n,r,i,null,o,s,0);}parseRule(){let e=this.nodeDOM.parentNode;for(;e&&e!=this.dom&&!e.pmIsDeco;)e=e.parentNode;return {skip:e||!0}}update(e,t,n,r){return !(3==this.dirty||0!=this.dirty&&!this.inParent()||!e.sameMarkup(this.node))&&(this.updateOuterDeco(t),0==this.dirty&&e.text==this.node.text||e.text==this.nodeDOM.nodeValue||(this.nodeDOM.nodeValue=e.text,r.trackWrites==this.nodeDOM&&(r.trackWrites=null)),this.node=e,this.dirty=0,!0)}inParent(){let e=this.parent.contentDOM;for(let t=this.nodeDOM;t;t=t.parentNode)if(t==e)return !0;return !1}domFromPos(e){return {node:this.nodeDOM,offset:e}}localPosFromDOM(e,t,n){return e==this.nodeDOM?this.posAtStart+Math.min(t,this.node.text.length):super.localPosFromDOM(e,t,n)}ignoreMutation(e){return "characterData"!=e.type&&"selection"!=e.type}slice(e,t,n){let r=this.node.cut(e,t),i=document.createTextNode(r.text);return new Lc(this.parent,r,this.outerDeco,this.innerDeco,i,i,n)}markDirty(e,t){super.markDirty(e,t),this.dom==this.nodeDOM||0!=e&&t!=this.nodeDOM.nodeValue.length||(this.dirty=3);}get domAtom(){return !1}}class Rc extends Mc{parseRule(){return {ignore:!0}}matchesHack(e){return 0==this.dirty&&this.dom.nodeName==e}get domAtom(){return !0}get ignoreForCoords(){return "IMG"==this.dom.nodeName}}class Fc extends _c{constructor(e,t,n,r,i,o,s,a,l,c){super(e,t,n,r,i,o,s,l,c),this.spec=a;}update(e,t,n,r){if(3==this.dirty)return !1;if(this.spec.update){let i=this.spec.update(e,t,n);return i&&this.updateInner(e,t,n,r),i}return !(!this.contentDOM&&!e.isLeaf)&&super.update(e,t,n,r)}selectNode(){this.spec.selectNode?this.spec.selectNode():super.selectNode();}deselectNode(){this.spec.deselectNode?this.spec.deselectNode():super.deselectNode();}setSelection(e,t,n,r){this.spec.setSelection?this.spec.setSelection(e,t,n):super.setSelection(e,t,n,r);}destroy(){this.spec.destroy&&this.spec.destroy(),super.destroy();}stopEvent(e){return !!this.spec.stopEvent&&this.spec.stopEvent(e)}ignoreMutation(e){return this.spec.ignoreMutation?this.spec.ignoreMutation(e):super.ignoreMutation(e)}}function Bc(e,t,n){let r=e.firstChild,i=!1;for(let o=0;o<t.length;o++){let s=t[o],a=s.dom;if(a.parentNode==e){for(;a!=r;)r=Kc(r),i=!0;r=r.nextSibling;}else i=!0,e.insertBefore(a,r);if(s instanceof Nc){let t=r?r.previousSibling:e.lastChild;Bc(s.contentDOM,s.children,n),r=t?t.nextSibling:e.firstChild;}}for(;r;)r=Kc(r),i=!0;i&&n.trackWrites==e&&(n.trackWrites=null);}const Ic=function(e){e&&(this.nodeName=e);};Ic.prototype=Object.create(null);const Pc=[new Ic];function zc(e,t,n){if(0==e.length)return Pc;let r=n?Pc[0]:new Ic,i=[r];for(let o=0;o<e.length;o++){let s=e[o].type.attrs;if(s){s.nodeName&&i.push(r=new Ic(s.nodeName));for(let e in s){let o=s[e];null!=o&&(n&&1==i.length&&i.push(r=new Ic(t.isInline?"span":"div")),"class"==e?r.class=(r.class?r.class+" ":"")+o:"style"==e?r.style=(r.style?r.style+";":"")+o:"nodeName"!=e&&(r[e]=o));}}}return i}function $c(e,t,n,r){if(n==Pc&&r==Pc)return t;let i=t;for(let t=0;t<r.length;t++){let o=r[t],s=n[t];if(t){let t;s&&s.nodeName==o.nodeName&&i!=e&&(t=i.parentNode)&&t.nodeName.toLowerCase()==o.nodeName||(t=document.createElement(o.nodeName),t.pmIsDeco=!0,t.appendChild(i),s=Pc[0]),i=t;}jc(i,s||Pc[0],o);}return i}function jc(e,t,n){for(let r in t)"class"==r||"style"==r||"nodeName"==r||r in n||e.removeAttribute(r);for(let r in n)"class"!=r&&"style"!=r&&"nodeName"!=r&&n[r]!=t[r]&&e.setAttribute(r,n[r]);if(t.class!=n.class){let r=t.class?t.class.split(" ").filter(Boolean):[],i=n.class?n.class.split(" ").filter(Boolean):[];for(let t=0;t<r.length;t++)-1==i.indexOf(r[t])&&e.classList.remove(r[t]);for(let t=0;t<i.length;t++)-1==r.indexOf(i[t])&&e.classList.add(i[t]);0==e.classList.length&&e.removeAttribute("class");}if(t.style!=n.style){if(t.style){let n,r=/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;for(;n=r.exec(t.style);)e.style.removeProperty(n[1]);}n.style&&(e.style.cssText+=n.style);}}function Hc(e,t,n){return $c(e,e,Pc,zc(t,n,1!=e.nodeType))}function Vc(e,t){if(e.length!=t.length)return !1;for(let n=0;n<e.length;n++)if(!e[n].type.eq(t[n].type))return !1;return !0}function Kc(e){let t=e.nextSibling;return e.parentNode.removeChild(e),t}class qc{constructor(e,t){this.lock=t,this.index=0,this.stack=[],this.changed=!1,this.top=e,this.preMatch=function(e,t){let n=t,r=n.children.length,i=e.childCount,o=new Map,s=[];e:for(;i>0;){let a;for(;;)if(r){let e=n.children[r-1];if(!(e instanceof Nc)){a=e,r--;break}n=e,r=e.children.length;}else {if(n==t)break e;r=n.parent.children.indexOf(n),n=n.parent;}let l=a.node;if(l){if(l!=e.child(i-1))break;--i,o.set(a,i),s.push(a);}}return {index:i,matched:o,matches:s.reverse()}}(e.node.content,e);}destroyBetween(e,t){if(e!=t){for(let n=e;n<t;n++)this.top.children[n].destroy();this.top.children.splice(e,t-e),this.changed=!0;}}destroyRest(){this.destroyBetween(this.index,this.top.children.length);}syncToMarks(e,t,n){let r=0,i=this.stack.length>>1,o=Math.min(i,e.length);for(;r<o&&(r==i-1?this.top:this.stack[r+1<<1]).matchesMark(e[r])&&!1!==e[r].type.spec.spanning;)r++;for(;r<i;)this.destroyRest(),this.top.dirty=0,this.index=this.stack.pop(),this.top=this.stack.pop(),i--;for(;i<e.length;){this.stack.push(this.top,this.index+1);let r=-1;for(let t=this.index;t<Math.min(this.index+3,this.top.children.length);t++)if(this.top.children[t].matchesMark(e[i])){r=t;break}if(r>-1)r>this.index&&(this.changed=!0,this.destroyBetween(this.index,r)),this.top=this.top.children[this.index];else {let r=Nc.create(this.top,e[i],t,n);this.top.children.splice(this.index,0,r),this.top=r,this.changed=!0;}this.index=0,i++;}}findNodeMatch(e,t,n,r){let i,o=-1;if(r>=this.preMatch.index&&(i=this.preMatch.matches[r-this.preMatch.index]).parent==this.top&&i.matchesNode(e,t,n))o=this.top.children.indexOf(i,this.index);else for(let r=this.index,i=Math.min(this.top.children.length,r+5);r<i;r++){let i=this.top.children[r];if(i.matchesNode(e,t,n)&&!this.preMatch.matched.has(i)){o=r;break}}return !(o<0)&&(this.destroyBetween(this.index,o),this.index++,!0)}updateNodeAt(e,t,n,r,i){let o=this.top.children[r];return 3==o.dirty&&o.dom==o.contentDOM&&(o.dirty=2),!!o.update(e,t,n,i)&&(this.destroyBetween(this.index,r),this.index=r+1,!0)}findIndexWithChild(e){for(;;){let t=e.parentNode;if(!t)return -1;if(t==this.top.contentDOM){let t=e.pmViewDesc;if(t)for(let e=this.index;e<this.top.children.length;e++)if(this.top.children[e]==t)return e;return -1}e=t;}}updateNextNode(e,t,n,r,i){for(let o=this.index;o<this.top.children.length;o++){let s=this.top.children[o];if(s instanceof _c){let a=this.preMatch.matched.get(s);if(null!=a&&a!=i)return !1;let l=s.dom;if(!(this.lock&&(l==this.lock||1==l.nodeType&&l.contains(this.lock.parentNode))&&!(e.isText&&s.node&&s.node.isText&&s.nodeDOM.nodeValue==e.text&&3!=s.dirty&&Vc(t,s.outerDeco)))&&s.update(e,t,n,r))return this.destroyBetween(this.index,o),s.dom!=l&&(this.changed=!0),this.index++,!0;break}}return !1}addNode(e,t,n,r,i){this.top.children.splice(this.index++,0,_c.create(this.top,e,t,n,r,i)),this.changed=!0;}placeWidget(e,t,n){let r=this.index<this.top.children.length?this.top.children[this.index]:null;if(!r||!r.matchesWidget(e)||e!=r.widget&&r.widget.type.toDOM.parentNode){let r=new Oc(this.top,e,t,n);this.top.children.splice(this.index++,0,r),this.changed=!0;}else this.index++;}addTextblockHacks(){let e=this.top.children[this.index-1],t=this.top;for(;e instanceof Nc;)t=e,e=t.children[t.children.length-1];e&&e instanceof Lc&&!/\n$/.test(e.node.text)||((Hl||$l)&&e&&"false"==e.dom.contentEditable&&this.addHackNode("IMG",t),this.addHackNode("BR",this.top));}addHackNode(e,t){if(t==this.top&&this.index<t.children.length&&t.children[this.index].matchesHack(e))this.index++;else {let n=document.createElement(e);"IMG"==e&&(n.className="ProseMirror-separator",n.alt=""),"BR"==e&&(n.className="ProseMirror-trailingBreak");let r=new Rc(this.top,[],n,null);t!=this.top?t.children.push(r):t.children.splice(this.index++,0,r),this.changed=!0;}}}function Uc(e,t){return e.type.side-t.type.side}function Wc(e,t,n,r,i){let o=[];for(let s=0,a=0;s<e.length;s++){let l=e[s],c=a,u=a+=l.size;c>=n||u<=t?o.push(l):(c<t&&o.push(l.slice(0,t-c,r)),i&&(o.push(i),i=void 0),u>n&&o.push(l.slice(n-c,l.size,r)));}return o}function Gc(e,t=null){let n=e.domSelection(),r=e.state.doc;if(!n.focusNode)return null;let i=e.docView.nearestDesc(n.focusNode),o=i&&0==i.size,s=e.docView.posFromDOM(n.focusNode,n.focusOffset,1);if(s<0)return null;let a,l,c=r.resolve(s);if(rc(n)){for(a=c;i&&!i.node;)i=i.parent;let e=i.node;if(i&&e.isAtom&&pl.isSelectable(e)&&i.parent&&(!e.isInline||!function(e,t,n){for(let r=0==t,i=t==tc(e);r||i;){if(e==n)return !0;let t=Gl(e);if(!(e=e.parentNode))return !1;r=r&&0==t,i=i&&t==tc(e);}}(n.focusNode,n.focusOffset,i.dom))){let e=i.posBefore;l=new pl(s==e?c:r.resolve(e));}}else {let t=e.docView.posFromDOM(n.anchorNode,n.anchorOffset,1);if(t<0)return null;a=r.resolve(t);}if(!l){l=ru(e,a,c,"pointer"==t||e.state.selection.head<c.pos&&!o?1:-1);}return l}function Jc(e){return e.editable?e.hasFocus():ou(e)&&document.activeElement&&document.activeElement.contains(e.dom)}function Zc(e,t=!1){let n=e.state.selection;if(tu(e,n),Jc(e)){if(!t&&e.input.mouseDown&&e.input.mouseDown.allowDefault&&$l){let t=e.domSelection(),n=e.domObserver.currentSelection;if(t.anchorNode&&n.anchorNode&&Ql(t.anchorNode,t.anchorOffset,n.anchorNode,n.anchorOffset))return e.input.mouseDown.delayedSelectionSync=!0,void e.domObserver.setCurSelection()}if(e.domObserver.disconnectSelection(),e.cursorWrapper)!function(e){let t=e.domSelection(),n=document.createRange(),r=e.cursorWrapper.dom,i="IMG"==r.nodeName;i?n.setEnd(r.parentNode,Gl(r)+1):n.setEnd(r,0);n.collapse(!1),t.removeAllRanges(),t.addRange(n),!i&&!e.state.selection.visible&&Bl&&Il<=11&&(r.disabled=!0,r.disabled=!1);}(e);else {let r,i,{anchor:o,head:s}=n;!Xc||n instanceof dl||(n.$from.parent.inlineContent||(r=Qc(e,n.from)),n.empty||n.$from.parent.inlineContent||(i=Qc(e,n.to))),e.docView.setSelection(o,s,e.root,t),Xc&&(r&&eu(r),i&&eu(i)),n.visible?e.dom.classList.remove("ProseMirror-hideselection"):(e.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&function(e){let t=e.dom.ownerDocument;t.removeEventListener("selectionchange",e.input.hideSelectionGuard);let n=e.domSelection(),r=n.anchorNode,i=n.anchorOffset;t.addEventListener("selectionchange",e.input.hideSelectionGuard=()=>{n.anchorNode==r&&n.anchorOffset==i||(t.removeEventListener("selectionchange",e.input.hideSelectionGuard),setTimeout((()=>{Jc(e)&&!e.state.selection.visible||e.dom.classList.remove("ProseMirror-hideselection");}),20));});}(e));}e.domObserver.setCurSelection(),e.domObserver.connectSelection();}}const Xc=Hl||$l&&jl<63;function Qc(e,t){let{node:n,offset:r}=e.docView.domFromPos(t,0),i=r<n.childNodes.length?n.childNodes[r]:null,o=r?n.childNodes[r-1]:null;if(Hl&&i&&"false"==i.contentEditable)return Yc(i);if(!(i&&"false"!=i.contentEditable||o&&"false"!=o.contentEditable)){if(i)return Yc(i);if(o)return Yc(o)}}function Yc(e){return e.contentEditable="true",Hl&&e.draggable&&(e.draggable=!1,e.wasDraggable=!0),e}function eu(e){e.contentEditable="false",e.wasDraggable&&(e.draggable=!0,e.wasDraggable=null);}function tu(e,t){if(t instanceof pl){let n=e.docView.descAt(t.from);n!=e.lastSelectedViewDesc&&(nu(e),n&&n.selectNode(),e.lastSelectedViewDesc=n);}else nu(e);}function nu(e){e.lastSelectedViewDesc&&(e.lastSelectedViewDesc.parent&&e.lastSelectedViewDesc.deselectNode(),e.lastSelectedViewDesc=void 0);}function ru(e,t,n,r){return e.someProp("createSelectionBetween",(r=>r(e,t,n)))||dl.between(t,n,r)}function iu(e){return (!e.editable||e.root.activeElement==e.dom)&&ou(e)}function ou(e){let t=e.domSelection();if(!t.anchorNode)return !1;try{return e.dom.contains(3==t.anchorNode.nodeType?t.anchorNode.parentNode:t.anchorNode)&&(e.editable||e.dom.contains(3==t.focusNode.nodeType?t.focusNode.parentNode:t.focusNode))}catch(e){return !1}}function su(e,t){let{$anchor:n,$head:r}=e.selection,i=t>0?n.max(r):n.min(r),o=i.parent.inlineContent?i.depth?e.doc.resolve(t>0?i.after():i.before()):null:i;return o&&al.findFrom(o,t)}function au(e,t){return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()),!0}function lu(e,t,n){let r=e.state.selection;if(!(r instanceof dl)){if(r instanceof pl&&r.node.isInline)return au(e,new dl(t>0?r.$to:r.$from));{let n=su(e.state,t);return !!n&&au(e,n)}}if(!r.empty||n.indexOf("s")>-1)return !1;if(e.endOfTextblock(t>0?"right":"left")){let n=su(e.state,t);return !!(n&&n instanceof pl)&&au(e,n)}if(!(Kl&&n.indexOf("m")>-1)){let n,i=r.$head,o=i.textOffset?null:t<0?i.nodeBefore:i.nodeAfter;if(!o||o.isText)return !1;let s=t<0?i.pos-o.nodeSize:i.pos;return !!(o.isAtom||(n=e.docView.descAt(s))&&!n.contentDOM)&&(pl.isSelectable(o)?au(e,new pl(t<0?e.state.doc.resolve(i.pos-o.nodeSize):i)):!!Ul&&au(e,new dl(e.state.doc.resolve(t<0?s:s+o.nodeSize))))}}function cu(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}function uu(e){let t=e.pmViewDesc;return t&&0==t.size&&(e.nextSibling||"BR"!=e.nodeName)}function du(e){let t=e.domSelection(),n=t.focusNode,r=t.focusOffset;if(!n)return;let i,o,s=!1;for(Pl&&1==n.nodeType&&r<cu(n)&&uu(n.childNodes[r])&&(s=!0);;)if(r>0){if(1!=n.nodeType)break;{let e=n.childNodes[r-1];if(uu(e))i=n,o=--r;else {if(3!=e.nodeType)break;n=e,r=n.nodeValue.length;}}}else {if(pu(n))break;{let t=n.previousSibling;for(;t&&uu(t);)i=n.parentNode,o=Gl(t),t=t.previousSibling;if(t)n=t,r=cu(n);else {if(n=n.parentNode,n==e.dom)break;r=0;}}}s?fu(e,t,n,r):i&&fu(e,t,i,o);}function hu(e){let t=e.domSelection(),n=t.focusNode,r=t.focusOffset;if(!n)return;let i,o,s=cu(n);for(;;)if(r<s){if(1!=n.nodeType)break;if(!uu(n.childNodes[r]))break;i=n,o=++r;}else {if(pu(n))break;{let t=n.nextSibling;for(;t&&uu(t);)i=t.parentNode,o=Gl(t)+1,t=t.nextSibling;if(t)n=t,r=0,s=cu(n);else {if(n=n.parentNode,n==e.dom)break;r=s=0;}}}i&&fu(e,t,i,o);}function pu(e){let t=e.pmViewDesc;return t&&t.node&&t.node.isBlock}function fu(e,t,n,r){if(rc(t)){let e=document.createRange();e.setEnd(n,r),e.setStart(n,r),t.removeAllRanges(),t.addRange(e);}else t.extend&&t.extend(n,r);e.domObserver.setCurSelection();let{state:i}=e;setTimeout((()=>{e.state==i&&Zc(e);}),50);}function mu(e,t,n){let r=e.state.selection;if(r instanceof dl&&!r.empty||n.indexOf("s")>-1)return !1;if(Kl&&n.indexOf("m")>-1)return !1;let{$from:i,$to:o}=r;if(!i.parent.inlineContent||e.endOfTextblock(t<0?"up":"down")){let n=su(e.state,t);if(n&&n instanceof pl)return au(e,n)}if(!i.parent.inlineContent){let n=t<0?i:o,s=r instanceof ml?al.near(n,t):al.findFrom(n,t);return !!s&&au(e,s)}return !1}function gu(e,t){if(!(e.state.selection instanceof dl))return !0;let{$head:n,$anchor:r,empty:i}=e.state.selection;if(!n.sameParent(r))return !0;if(!i)return !1;if(e.endOfTextblock(t>0?"forward":"backward"))return !0;let o=!n.textOffset&&(t<0?n.nodeBefore:n.nodeAfter);if(o&&!o.isText){let r=e.state.tr;return t<0?r.delete(n.pos-o.nodeSize,n.pos):r.delete(n.pos,n.pos+o.nodeSize),e.dispatch(r),!0}return !1}function vu(e,t,n){e.domObserver.stop(),t.contentEditable=n,e.domObserver.start();}function yu(e,t){let n=t.keyCode,r=function(e){let t="";return e.ctrlKey&&(t+="c"),e.metaKey&&(t+="m"),e.altKey&&(t+="a"),e.shiftKey&&(t+="s"),t}(t);return 8==n||Kl&&72==n&&"c"==r?gu(e,-1)||du(e):46==n||Kl&&68==n&&"c"==r?gu(e,1)||hu(e):13==n||27==n||(37==n||Kl&&66==n&&"c"==r?lu(e,-1,r)||du(e):39==n||Kl&&70==n&&"c"==r?lu(e,1,r)||hu(e):38==n||Kl&&80==n&&"c"==r?mu(e,-1,r)||du(e):40==n||Kl&&78==n&&"c"==r?function(e){if(!Hl||e.state.selection.$head.parentOffset>0)return !1;let{focusNode:t,focusOffset:n}=e.domSelection();if(t&&1==t.nodeType&&0==n&&t.firstChild&&"false"==t.firstChild.contentEditable){let n=t.firstChild;vu(e,n,"true"),setTimeout((()=>vu(e,n,"false")),20);}return !1}(e)||mu(e,1,r)||hu(e):r==(Kl?"m":"c")&&(66==n||73==n||89==n||90==n))}function bu(e,t){let n=[],{content:r,openStart:i,openEnd:o}=t;for(;i>1&&o>1&&1==r.childCount&&1==r.firstChild.childCount;){i--,o--;let e=r.firstChild;n.push(e.type.name,e.attrs!=e.type.defaultAttrs?e.attrs:null),r=e.content;}let s=e.someProp("clipboardSerializer")||Ca.fromSchema(e.state.schema),a=Au(),l=a.createElement("div");l.appendChild(s.serializeFragment(r,{document:a}));let c,u=l.firstChild,d=0;for(;u&&1==u.nodeType&&(c=Mu[u.nodeName.toLowerCase()]);){for(let e=c.length-1;e>=0;e--){let t=a.createElement(c[e]);for(;l.firstChild;)t.appendChild(l.firstChild);l.appendChild(t),d++;}u=l.firstChild;}return u&&1==u.nodeType&&u.setAttribute("data-pm-slice",`${i} ${o}${d?` -${d}`:""} ${JSON.stringify(n)}`),{dom:l,text:e.someProp("clipboardTextSerializer",(e=>e(t)))||t.content.textBetween(0,t.content.size,"\n\n")}}function wu(e,t,n,r,i){let o,s,a=i.parent.type.spec.code;if(!n&&!t)return null;let l=t&&(r||a||!n);if(l){if(e.someProp("transformPastedText",(e=>{t=e(t,a||r);})),a)return t?new Os(Cs.from(e.state.schema.text(t.replace(/\r\n?/g,"\n"))),0,0):Os.empty;let n=e.someProp("clipboardTextParser",(e=>e(t,i,r)));if(n)s=n;else {let n=i.marks(),{schema:r}=e.state,s=Ca.fromSchema(r);o=document.createElement("div"),t.split(/(?:\r\n?|\n)+/).forEach((e=>{let t=o.appendChild(document.createElement("p"));e&&t.appendChild(s.serializeNode(r.text(e,n)));}));}}else e.someProp("transformPastedHTML",(e=>{n=e(n);})),o=function(e){let t=/^(\s*<meta [^>]*>)*/.exec(e);t&&(e=e.slice(t[0].length));let n,r=Au().createElement("div"),i=/<([a-z][^>\s]+)/i.exec(e);(n=i&&Mu[i[1].toLowerCase()])&&(e=n.map((e=>"<"+e+">")).join("")+e+n.map((e=>"</"+e+">")).reverse().join(""));if(r.innerHTML=e,n)for(let e=0;e<n.length;e++)r=r.querySelector(n[e])||r;return r}(n),Ul&&function(e){let t=e.querySelectorAll($l?"span:not([class]):not([style])":"span.Apple-converted-space");for(let n=0;n<t.length;n++){let r=t[n];1==r.childNodes.length&&" "==r.textContent&&r.parentNode&&r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "),r);}}(o);let c=o&&o.querySelector("[data-pm-slice]"),u=c&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice")||"");if(u&&u[3])for(let e=+u[3];e>0&&o.firstChild;e--)o=o.firstChild;if(!s){let t=e.someProp("clipboardParser")||e.someProp("domParser")||ha.fromSchema(e.state.schema);s=t.parseSlice(o,{preserveWhitespace:!(!l&&!u),context:i,ruleFromNode:e=>"BR"!=e.nodeName||e.nextSibling||!e.parentNode||ku.test(e.parentNode.nodeName)?null:{ignore:!0}});}if(u)s=function(e,t){if(!e.size)return e;let n,r=e.content.firstChild.type.schema;try{n=JSON.parse(t);}catch(t){return e}let{content:i,openStart:o,openEnd:s}=e;for(let e=n.length-2;e>=0;e-=2){let t=r.nodes[n[e]];if(!t||t.hasRequiredAttrs())break;i=Cs.from(t.create(n[e+1],i)),o++,s++;}return new Os(i,o,s)}(Du(s,+u[1],+u[2]),u[4]);else if(s=Os.maxOpen(function(e,t){if(e.childCount<2)return e;for(let n=t.depth;n>=0;n--){let r,i=t.node(n).contentMatchAt(t.index(n)),o=[];if(e.forEach((e=>{if(!o)return;let t,n=i.findWrapping(e.type);if(!n)return o=null;if(t=o.length&&r.length&&Eu(n,r,e,o[o.length-1],0))o[o.length-1]=t;else {o.length&&(o[o.length-1]=xu(o[o.length-1],r.length));let t=Cu(e,n);o.push(t),i=i.matchType(t.type),r=n;}})),o)return Cs.from(o)}return e}(s.content,i),!0),s.openStart||s.openEnd){let e=0,t=0;for(let t=s.content.firstChild;e<s.openStart&&!t.type.spec.isolating;e++,t=t.firstChild);for(let e=s.content.lastChild;t<s.openEnd&&!e.type.spec.isolating;t++,e=e.lastChild);s=Du(s,e,t);}return e.someProp("transformPasted",(e=>{s=e(s);})),s}const ku=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;function Cu(e,t,n=0){for(let r=t.length-1;r>=n;r--)e=t[r].create(null,Cs.from(e));return e}function Eu(e,t,n,r,i){if(i<e.length&&i<t.length&&e[i]==t[i]){let o=Eu(e,t,n,r.lastChild,i+1);if(o)return r.copy(r.content.replaceChild(r.childCount-1,o));if(r.contentMatchAt(r.childCount).matchType(i==e.length-1?n.type:e[i+1]))return r.copy(r.content.append(Cs.from(Cu(n,e,i+1))))}}function xu(e,t){if(0==t)return e;let n=e.content.replaceChild(e.childCount-1,xu(e.lastChild,t-1)),r=e.contentMatchAt(e.childCount).fillBefore(Cs.empty,!0);return e.copy(n.append(r))}function Su(e,t,n,r,i,o){let s=t<0?e.firstChild:e.lastChild,a=s.content;return i<r-1&&(a=Su(a,t,n,r,i+1,o)),i>=n&&(a=t<0?s.contentMatchAt(0).fillBefore(a,e.childCount>1||o<=i).append(a):a.append(s.contentMatchAt(s.childCount).fillBefore(Cs.empty,!0))),e.replaceChild(t<0?0:e.childCount-1,s.copy(a))}function Du(e,t,n){return t<e.openStart&&(e=new Os(Su(e.content,-1,t,e.openStart,0,e.openEnd),t,e.openEnd)),n<e.openEnd&&(e=new Os(Su(e.content,1,n,e.openEnd,0,0),e.openStart,n)),e}const Mu={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]};let Ou=null;function Au(){return Ou||(Ou=document.implementation.createHTMLDocument("title"))}const Nu={};let _u={};class Tu{constructor(){this.shiftKey=!1,this.mouseDown=null,this.lastKeyCode=null,this.lastKeyCodeTime=0,this.lastClick={time:0,x:0,y:0,type:""},this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastIOSEnter=0,this.lastIOSEnterFallbackTimeout=-1,this.lastAndroidDelete=0,this.composing=!1,this.composingTimeout=-1,this.compositionNodes=[],this.compositionEndedAt=-2e8,this.domChangeCount=0,this.eventHandlers=Object.create(null),this.hideSelectionGuard=null;}}function Lu(e,t){e.input.lastSelectionOrigin=t,e.input.lastSelectionTime=Date.now();}function Ru(e){e.someProp("handleDOMEvents",(t=>{for(let n in t)e.input.eventHandlers[n]||e.dom.addEventListener(n,e.input.eventHandlers[n]=t=>Fu(e,t));}));}function Fu(e,t){return e.someProp("handleDOMEvents",(n=>{let r=n[t.type];return !!r&&(r(e,t)||t.defaultPrevented)}))}function Bu(e,t){if(!t.bubbles)return !0;if(t.defaultPrevented)return !1;for(let n=t.target;n!=e.dom;n=n.parentNode)if(!n||11==n.nodeType||n.pmViewDesc&&n.pmViewDesc.stopEvent(t))return !1;return !0}function Iu(e){return {left:e.clientX,top:e.clientY}}function Pu(e,t,n,r,i){if(-1==r)return !1;let o=e.state.doc.resolve(r);for(let r=o.depth+1;r>0;r--)if(e.someProp(t,(t=>r>o.depth?t(e,n,o.nodeAfter,o.before(r),i,!0):t(e,n,o.node(r),o.before(r),i,!1))))return !0;return !1}function zu(e,t,n){e.focused||e.focus();let r=e.state.tr.setSelection(t);"pointer"==n&&r.setMeta("pointer",!0),e.dispatch(r);}function $u(e,t,n,r,i){return Pu(e,"handleClickOn",t,n,r)||e.someProp("handleClick",(n=>n(e,t,r)))||(i?function(e,t){if(-1==t)return !1;let n,r,i=e.state.selection;i instanceof pl&&(n=i.node);let o=e.state.doc.resolve(t);for(let e=o.depth+1;e>0;e--){let t=e>o.depth?o.nodeAfter:o.node(e);if(pl.isSelectable(t)){r=n&&i.$from.depth>0&&e>=i.$from.depth&&o.before(i.$from.depth+1)==i.$from.pos?o.before(i.$from.depth):o.before(e);break}}return null!=r&&(zu(e,pl.create(e.state.doc,r),"pointer"),!0)}(e,n):function(e,t){if(-1==t)return !1;let n=e.state.doc.resolve(t),r=n.nodeAfter;return !!(r&&r.isAtom&&pl.isSelectable(r))&&(zu(e,new pl(n),"pointer"),!0)}(e,n))}function ju(e,t,n,r){return Pu(e,"handleDoubleClickOn",t,n,r)||e.someProp("handleDoubleClick",(n=>n(e,t,r)))}function Hu(e,t,n,r){return Pu(e,"handleTripleClickOn",t,n,r)||e.someProp("handleTripleClick",(n=>n(e,t,r)))||function(e,t,n){if(0!=n.button)return !1;let r=e.state.doc;if(-1==t)return !!r.inlineContent&&(zu(e,dl.create(r,0,r.content.size),"pointer"),!0);let i=r.resolve(t);for(let t=i.depth+1;t>0;t--){let n=t>i.depth?i.nodeAfter:i.node(t),o=i.before(t);if(n.inlineContent)zu(e,dl.create(r,o+1,o+1+n.content.size),"pointer");else {if(!pl.isSelectable(n))continue;zu(e,pl.create(r,o),"pointer");}return !0}}(e,n,r)}function Vu(e){return Zu(e)}_u.keydown=(e,t)=>{let n=t;if(e.input.shiftKey=16==n.keyCode||n.shiftKey,!Uu(e,n)&&(e.input.lastKeyCode=n.keyCode,e.input.lastKeyCodeTime=Date.now(),!ql||!$l||13!=n.keyCode))if(229!=n.keyCode&&e.domObserver.forceFlush(),!Vl||13!=n.keyCode||n.ctrlKey||n.altKey||n.metaKey)e.someProp("handleKeyDown",(t=>t(e,n)))||yu(e,n)?n.preventDefault():Lu(e,"key");else {let t=Date.now();e.input.lastIOSEnter=t,e.input.lastIOSEnterFallbackTimeout=setTimeout((()=>{e.input.lastIOSEnter==t&&(e.someProp("handleKeyDown",(t=>t(e,ic(13,"Enter")))),e.input.lastIOSEnter=0);}),200);}},_u.keyup=(e,t)=>{16==t.keyCode&&(e.input.shiftKey=!1);},_u.keypress=(e,t)=>{let n=t;if(Uu(e,n)||!n.charCode||n.ctrlKey&&!n.altKey||Kl&&n.metaKey)return;if(e.someProp("handleKeyPress",(t=>t(e,n))))return void n.preventDefault();let r=e.state.selection;if(!(r instanceof dl&&r.$from.sameParent(r.$to))){let t=String.fromCharCode(n.charCode);e.someProp("handleTextInput",(n=>n(e,r.$from.pos,r.$to.pos,t)))||e.dispatch(e.state.tr.insertText(t).scrollIntoView()),n.preventDefault();}};const Ku=Kl?"metaKey":"ctrlKey";Nu.mousedown=(e,t)=>{let n=t;e.input.shiftKey=n.shiftKey;let r=Vu(e),i=Date.now(),o="singleClick";i-e.input.lastClick.time<500&&function(e,t){let n=t.x-e.clientX,r=t.y-e.clientY;return n*n+r*r<100}(n,e.input.lastClick)&&!n[Ku]&&("singleClick"==e.input.lastClick.type?o="doubleClick":"doubleClick"==e.input.lastClick.type&&(o="tripleClick")),e.input.lastClick={time:i,x:n.clientX,y:n.clientY,type:o};let s=e.posAtCoords(Iu(n));s&&("singleClick"==o?(e.input.mouseDown&&e.input.mouseDown.done(),e.input.mouseDown=new qu(e,s,n,!!r)):("doubleClick"==o?ju:Hu)(e,s.pos,s.inside,n)?n.preventDefault():Lu(e,"pointer"));};class qu{constructor(e,t,n,r){let i,o;if(this.view=e,this.pos=t,this.event=n,this.flushed=r,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=e.state.doc,this.selectNode=!!n[Ku],this.allowDefault=n.shiftKey,t.inside>-1)i=e.state.doc.nodeAt(t.inside),o=t.inside;else {let n=e.state.doc.resolve(t.pos);i=n.parent,o=n.depth?n.before():0;}const s=r?null:n.target,a=s?e.docView.nearestDesc(s,!0):null;this.target=a?a.dom:null;let{selection:l}=e.state;(0==n.button&&i.type.spec.draggable&&!1!==i.type.spec.selectable||l instanceof pl&&l.from<=o&&l.to>o)&&(this.mightDrag={node:i,pos:o,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!Pl||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((()=>{this.view.input.mouseDown==this&&this.target.setAttribute("contentEditable","false");}),20),this.view.domObserver.start()),e.root.addEventListener("mouseup",this.up=this.up.bind(this)),e.root.addEventListener("mousemove",this.move=this.move.bind(this)),Lu(e,"pointer");}done(){this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((()=>Zc(this.view))),this.view.input.mouseDown=null;}up(e){if(this.done(),!this.view.dom.contains(e.target))return;let t=this.pos;this.view.state.doc!=this.startDoc&&(t=this.view.posAtCoords(Iu(e))),this.allowDefault||!t?Lu(this.view,"pointer"):$u(this.view,t.pos,t.inside,e,this.selectNode)?e.preventDefault():0==e.button&&(this.flushed||Hl&&this.mightDrag&&!this.mightDrag.node.isAtom||$l&&!(this.view.state.selection instanceof dl)&&Math.min(Math.abs(t.pos-this.view.state.selection.from),Math.abs(t.pos-this.view.state.selection.to))<=2)?(zu(this.view,al.near(this.view.state.doc.resolve(t.pos)),"pointer"),e.preventDefault()):Lu(this.view,"pointer");}move(e){!this.allowDefault&&(Math.abs(this.event.x-e.clientX)>4||Math.abs(this.event.y-e.clientY)>4)&&(this.allowDefault=!0),Lu(this.view,"pointer"),0==e.buttons&&this.done();}}function Uu(e,t){return !!e.composing||!!(Hl&&Math.abs(t.timeStamp-e.input.compositionEndedAt)<500)&&(e.input.compositionEndedAt=-2e8,!0)}Nu.touchdown=e=>{Vu(e),Lu(e,"pointer");},Nu.contextmenu=e=>Vu(e);const Wu=ql?5e3:-1;function Gu(e,t){clearTimeout(e.input.composingTimeout),t>-1&&(e.input.composingTimeout=setTimeout((()=>Zu(e)),t));}function Ju(e){for(e.composing&&(e.input.composing=!1,e.input.compositionEndedAt=function(){let e=document.createEvent("Event");return e.initEvent("event",!0,!0),e.timeStamp}());e.input.compositionNodes.length>0;)e.input.compositionNodes.pop().markParentsDirty();}function Zu(e,t=!1){if(!(ql&&e.domObserver.flushingSoon>=0)){if(e.domObserver.forceFlush(),Ju(e),t||e.docView&&e.docView.dirty){let t=Gc(e);return t&&!t.eq(e.state.selection)?e.dispatch(e.state.tr.setSelection(t)):e.updateState(e.state),!0}return !1}}_u.compositionstart=_u.compositionupdate=e=>{if(!e.composing){e.domObserver.flush();let{state:t}=e,n=t.selection.$from;if(t.selection.empty&&(t.storedMarks||!n.textOffset&&n.parentOffset&&n.nodeBefore.marks.some((e=>!1===e.type.spec.inclusive))))e.markCursor=e.state.storedMarks||n.marks(),Zu(e,!0),e.markCursor=null;else if(Zu(e),Pl&&t.selection.empty&&n.parentOffset&&!n.textOffset&&n.nodeBefore.marks.length){let t=e.domSelection();for(let e=t.focusNode,n=t.focusOffset;e&&1==e.nodeType&&0!=n;){let r=n<0?e.lastChild:e.childNodes[n-1];if(!r)break;if(3==r.nodeType){t.collapse(r,r.nodeValue.length);break}e=r,n=-1;}}e.input.composing=!0;}Gu(e,Wu);},_u.compositionend=(e,t)=>{e.composing&&(e.input.composing=!1,e.input.compositionEndedAt=t.timeStamp,Gu(e,20));};const Xu=Bl&&Il<15||Vl&&Wl<604;function Qu(e,t,n,r){let i=wu(e,t,n,e.input.shiftKey,e.state.selection.$from);if(e.someProp("handlePaste",(t=>t(e,r,i||Os.empty))))return !0;if(!i)return !1;let o=function(e){return 0==e.openStart&&0==e.openEnd&&1==e.content.childCount?e.content.firstChild:null}(i),s=o?e.state.tr.replaceSelectionWith(o,e.input.shiftKey):e.state.tr.replaceSelection(i);return e.dispatch(s.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}Nu.copy=_u.cut=(e,t)=>{let n=t,r=e.state.selection,i="cut"==n.type;if(r.empty)return;let o=Xu?null:n.clipboardData,s=r.content(),{dom:a,text:l}=bu(e,s);o?(n.preventDefault(),o.clearData(),o.setData("text/html",a.innerHTML),o.setData("text/plain",l)):function(e,t){if(!e.dom.parentNode)return;let n=e.dom.parentNode.appendChild(document.createElement("div"));n.appendChild(t),n.style.cssText="position: fixed; left: -10000px; top: 10px";let r=getSelection(),i=document.createRange();i.selectNodeContents(t),e.dom.blur(),r.removeAllRanges(),r.addRange(i),setTimeout((()=>{n.parentNode&&n.parentNode.removeChild(n),e.focus();}),50);}(e,a),i&&e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"));},_u.paste=(e,t)=>{let n=t;if(e.composing&&!ql)return;let r=Xu?null:n.clipboardData;r&&Qu(e,r.getData("text/plain"),r.getData("text/html"),n)?n.preventDefault():function(e,t){if(!e.dom.parentNode)return;let n=e.input.shiftKey||e.state.selection.$from.parent.type.spec.code,r=e.dom.parentNode.appendChild(document.createElement(n?"textarea":"div"));n||(r.contentEditable="true"),r.style.cssText="position: fixed; left: -10000px; top: 10px",r.focus(),setTimeout((()=>{e.focus(),r.parentNode&&r.parentNode.removeChild(r),n?Qu(e,r.value,null,t):Qu(e,r.textContent,r.innerHTML,t);}),50);}(e,n);};class Yu{constructor(e,t){this.slice=e,this.move=t;}}const ed=Kl?"altKey":"ctrlKey";Nu.dragstart=(e,t)=>{let n=t,r=e.input.mouseDown;if(r&&r.done(),!n.dataTransfer)return;let i=e.state.selection,o=i.empty?null:e.posAtCoords(Iu(n));if(o&&o.pos>=i.from&&o.pos<=(i instanceof pl?i.to-1:i.to));else if(r&&r.mightDrag)e.dispatch(e.state.tr.setSelection(pl.create(e.state.doc,r.mightDrag.pos)));else if(n.target&&1==n.target.nodeType){let t=e.docView.nearestDesc(n.target,!0);t&&t.node.type.spec.draggable&&t!=e.docView&&e.dispatch(e.state.tr.setSelection(pl.create(e.state.doc,t.posBefore)));}let s=e.state.selection.content(),{dom:a,text:l}=bu(e,s);n.dataTransfer.clearData(),n.dataTransfer.setData(Xu?"Text":"text/html",a.innerHTML),n.dataTransfer.effectAllowed="copyMove",Xu||n.dataTransfer.setData("text/plain",l),e.dragging=new Yu(s,!n[ed]);},Nu.dragend=e=>{let t=e.dragging;window.setTimeout((()=>{e.dragging==t&&(e.dragging=null);}),50);},_u.dragover=_u.dragenter=(e,t)=>t.preventDefault(),_u.drop=(e,t)=>{let n=t,r=e.dragging;if(e.dragging=null,!n.dataTransfer)return;let i=e.posAtCoords(Iu(n));if(!i)return;let o=e.state.doc.resolve(i.pos);if(!o)return;let s=r&&r.slice;s?e.someProp("transformPasted",(e=>{s=e(s);})):s=wu(e,n.dataTransfer.getData(Xu?"Text":"text/plain"),Xu?null:n.dataTransfer.getData("text/html"),!1,o);let a=!(!r||n[ed]);if(e.someProp("handleDrop",(t=>t(e,n,s||Os.empty,a))))return void n.preventDefault();if(!s)return;n.preventDefault();let l=s?Ua(e.state.doc,o.pos,s):o.pos;null==l&&(l=o.pos);let c=e.state.tr;a&&c.deleteSelection();let u=c.mapping.map(l),d=0==s.openStart&&0==s.openEnd&&1==s.content.childCount,h=c.doc;if(d?c.replaceRangeWith(u,u,s.content.firstChild):c.replaceRange(u,u,s),c.doc.eq(h))return;let p=c.doc.resolve(u);if(d&&pl.isSelectable(s.content.firstChild)&&p.nodeAfter&&p.nodeAfter.sameMarkup(s.content.firstChild))c.setSelection(new pl(p));else {let t=c.mapping.map(l);c.mapping.maps[c.mapping.maps.length-1].forEach(((e,n,r,i)=>t=i)),c.setSelection(ru(e,p,c.doc.resolve(t)));}e.focus(),e.dispatch(c.setMeta("uiEvent","drop"));},Nu.focus=e=>{e.focused||(e.domObserver.stop(),e.dom.classList.add("ProseMirror-focused"),e.domObserver.start(),e.focused=!0,setTimeout((()=>{e.docView&&e.hasFocus()&&!e.domObserver.currentSelection.eq(e.domSelection())&&Zc(e);}),20));},Nu.blur=(e,t)=>{let n=t;e.focused&&(e.domObserver.stop(),e.dom.classList.remove("ProseMirror-focused"),e.domObserver.start(),n.relatedTarget&&e.dom.contains(n.relatedTarget)&&e.domObserver.currentSelection.clear(),e.focused=!1);},Nu.beforeinput=(e,t)=>{if($l&&ql&&"deleteContentBackward"==t.inputType){e.domObserver.flushSoon();let{domChangeCount:t}=e.input;setTimeout((()=>{if(e.input.domChangeCount!=t)return;if(e.dom.blur(),e.focus(),e.someProp("handleKeyDown",(t=>t(e,ic(8,"Backspace")))))return;let{$cursor:n}=e.state.selection;n&&n.pos>0&&e.dispatch(e.state.tr.delete(n.pos-1,n.pos).scrollIntoView());}),50);}};for(let e in _u)Nu[e]=_u[e];function td(e,t){if(e==t)return !0;for(let n in e)if(e[n]!==t[n])return !1;for(let n in t)if(!(n in e))return !1;return !0}class nd{constructor(e,t){this.toDOM=e,this.spec=t||ad,this.side=this.spec.side||0;}map(e,t,n,r){let{pos:i,deleted:o}=e.mapResult(t.from+r,this.side<0?-1:1);return o?null:new od(i-n,i-n,this)}valid(){return !0}eq(e){return this==e||e instanceof nd&&(this.spec.key&&this.spec.key==e.spec.key||this.toDOM==e.toDOM&&td(this.spec,e.spec))}destroy(e){this.spec.destroy&&this.spec.destroy(e);}}class rd{constructor(e,t){this.attrs=e,this.spec=t||ad;}map(e,t,n,r){let i=e.map(t.from+r,this.spec.inclusiveStart?-1:1)-n,o=e.map(t.to+r,this.spec.inclusiveEnd?1:-1)-n;return i>=o?null:new od(i,o,this)}valid(e,t){return t.from<t.to}eq(e){return this==e||e instanceof rd&&td(this.attrs,e.attrs)&&td(this.spec,e.spec)}static is(e){return e.type instanceof rd}destroy(){}}class id{constructor(e,t){this.attrs=e,this.spec=t||ad;}map(e,t,n,r){let i=e.mapResult(t.from+r,1);if(i.deleted)return null;let o=e.mapResult(t.to+r,-1);return o.deleted||o.pos<=i.pos?null:new od(i.pos-n,o.pos-n,this)}valid(e,t){let n,{index:r,offset:i}=e.content.findIndex(t.from);return i==t.from&&!(n=e.child(r)).isText&&i+n.nodeSize==t.to}eq(e){return this==e||e instanceof id&&td(this.attrs,e.attrs)&&td(this.spec,e.spec)}destroy(){}}class od{constructor(e,t,n){this.from=e,this.to=t,this.type=n;}copy(e,t){return new od(e,t,this.type)}eq(e,t=0){return this.type.eq(e.type)&&this.from+t==e.from&&this.to+t==e.to}map(e,t,n){return this.type.map(e,this,t,n)}static widget(e,t,n){return new od(e,e,new nd(t,n))}static inline(e,t,n,r){return new od(e,t,new rd(n,r))}static node(e,t,n,r){return new od(e,t,new id(n,r))}get spec(){return this.type.spec}get inline(){return this.type instanceof rd}}const sd=[],ad={};class ld{constructor(e,t){this.local=e.length?e:sd,this.children=t.length?t:sd;}static create(e,t){return t.length?fd(t,e,0,ad):cd}find(e,t,n){let r=[];return this.findInner(null==e?0:e,null==t?1e9:t,r,0,n),r}findInner(e,t,n,r,i){for(let o=0;o<this.local.length;o++){let s=this.local[o];s.from<=t&&s.to>=e&&(!i||i(s.spec))&&n.push(s.copy(s.from+r,s.to+r));}for(let o=0;o<this.children.length;o+=3)if(this.children[o]<t&&this.children[o+1]>e){let s=this.children[o]+1;this.children[o+2].findInner(e-s,t-s,n,r+s,i);}}map(e,t,n){return this==cd||0==e.maps.length?this:this.mapInner(e,t,0,0,n||ad)}mapInner(e,t,n,r,i){let o;for(let s=0;s<this.local.length;s++){let a=this.local[s].map(e,n,r);a&&a.type.valid(t,a)?(o||(o=[])).push(a):i.onRemove&&i.onRemove(this.local[s].spec);}return this.children.length?function(e,t,n,r,i,o,s){let a=e.slice(),l=(e,t,n,r)=>{for(let s=0;s<a.length;s+=3){let l,c=a[s+1];if(c<0||e>c+o)continue;let u=a[s]+o;t>=u?a[s+1]=e<=u?-2:-1:n>=i&&(l=r-n-(t-e))&&(a[s]+=l,a[s+1]+=l);}};for(let e=0;e<n.maps.length;e++)n.maps[e].forEach(l);let c=!1;for(let t=0;t<a.length;t+=3)if(a[t+1]<0){if(-2==a[t+1]){c=!0,a[t+1]=-1;continue}let l=n.map(e[t]+o),u=l-i;if(u<0||u>=r.content.size){c=!0;continue}let d=n.map(e[t+1]+o,-1)-i,{index:h,offset:p}=r.content.findIndex(u),f=r.maybeChild(h);if(f&&p==u&&p+f.nodeSize==d){let r=a[t+2].mapInner(n,f,l+1,e[t]+o+1,s);r!=cd?(a[t]=u,a[t+1]=d,a[t+2]=r):(a[t+1]=-2,c=!0);}else c=!0;}if(c){let l=function(e,t,n,r,i,o,s){function a(e,t){for(let o=0;o<e.local.length;o++){let a=e.local[o].map(r,i,t);a?n.push(a):s.onRemove&&s.onRemove(e.local[o].spec);}for(let n=0;n<e.children.length;n+=3)a(e.children[n+2],e.children[n]+t+1);}for(let n=0;n<e.length;n+=3)-1==e[n+1]&&a(e[n+2],t[n]+o+1);return n}(a,e,t,n,i,o,s),c=fd(l,r,0,s);t=c.local;for(let e=0;e<a.length;e+=3)a[e+1]<0&&(a.splice(e,3),e-=3);for(let e=0,t=0;e<c.children.length;e+=3){let n=c.children[e];for(;t<a.length&&a[t]<n;)t+=3;a.splice(t,0,c.children[e],c.children[e+1],c.children[e+2]);}}return new ld(t.sort(md),a)}(this.children,o||[],e,t,n,r,i):o?new ld(o.sort(md),sd):cd}add(e,t){return t.length?this==cd?ld.create(e,t):this.addInner(e,t,0):this}addInner(e,t,n){let r,i=0;e.forEach(((e,o)=>{let s,a=o+n;if(s=hd(t,e,a)){for(r||(r=this.children.slice());i<r.length&&r[i]<o;)i+=3;r[i]==o?r[i+2]=r[i+2].addInner(e,s,a+1):r.splice(i,0,o,o+e.nodeSize,fd(s,e,a+1,ad)),i+=3;}}));let o=dd(i?pd(t):t,-n);for(let t=0;t<o.length;t++)o[t].type.valid(e,o[t])||o.splice(t--,1);return new ld(o.length?this.local.concat(o).sort(md):this.local,r||this.children)}remove(e){return 0==e.length||this==cd?this:this.removeInner(e,0)}removeInner(e,t){let n=this.children,r=this.local;for(let r=0;r<n.length;r+=3){let i,o=n[r]+t,s=n[r+1]+t;for(let t,n=0;n<e.length;n++)(t=e[n])&&t.from>o&&t.to<s&&(e[n]=null,(i||(i=[])).push(t));if(!i)continue;n==this.children&&(n=this.children.slice());let a=n[r+2].removeInner(i,o+1);a!=cd?n[r+2]=a:(n.splice(r,3),r-=3);}if(r.length)for(let n,i=0;i<e.length;i++)if(n=e[i])for(let e=0;e<r.length;e++)r[e].eq(n,t)&&(r==this.local&&(r=this.local.slice()),r.splice(e--,1));return n==this.children&&r==this.local?this:r.length||n.length?new ld(r,n):cd}forChild(e,t){if(this==cd)return this;if(t.isLeaf)return ld.empty;let n,r;for(let t=0;t<this.children.length;t+=3)if(this.children[t]>=e){this.children[t]==e&&(n=this.children[t+2]);break}let i=e+1,o=i+t.content.size;for(let e=0;e<this.local.length;e++){let t=this.local[e];if(t.from<o&&t.to>i&&t.type instanceof rd){let e=Math.max(i,t.from)-i,n=Math.min(o,t.to)-i;e<n&&(r||(r=[])).push(t.copy(e,n));}}if(r){let e=new ld(r.sort(md),sd);return n?new ud([e,n]):e}return n||cd}eq(e){if(this==e)return !0;if(!(e instanceof ld)||this.local.length!=e.local.length||this.children.length!=e.children.length)return !1;for(let t=0;t<this.local.length;t++)if(!this.local[t].eq(e.local[t]))return !1;for(let t=0;t<this.children.length;t+=3)if(this.children[t]!=e.children[t]||this.children[t+1]!=e.children[t+1]||!this.children[t+2].eq(e.children[t+2]))return !1;return !0}locals(e){return gd(this.localsInner(e))}localsInner(e){if(this==cd)return sd;if(e.inlineContent||!this.local.some(rd.is))return this.local;let t=[];for(let e=0;e<this.local.length;e++)this.local[e].type instanceof rd||t.push(this.local[e]);return t}}ld.empty=new ld([],[]),ld.removeOverlap=gd;const cd=ld.empty;class ud{constructor(e){this.members=e;}map(e,t){const n=this.members.map((n=>n.map(e,t,ad)));return ud.from(n)}forChild(e,t){if(t.isLeaf)return ld.empty;let n=[];for(let r=0;r<this.members.length;r++){let i=this.members[r].forChild(e,t);i!=cd&&(i instanceof ud?n=n.concat(i.members):n.push(i));}return ud.from(n)}eq(e){if(!(e instanceof ud)||e.members.length!=this.members.length)return !1;for(let t=0;t<this.members.length;t++)if(!this.members[t].eq(e.members[t]))return !1;return !0}locals(e){let t,n=!0;for(let r=0;r<this.members.length;r++){let i=this.members[r].localsInner(e);if(i.length)if(t){n&&(t=t.slice(),n=!1);for(let e=0;e<i.length;e++)t.push(i[e]);}else t=i;}return t?gd(n?t:t.sort(md)):sd}static from(e){switch(e.length){case 0:return cd;case 1:return e[0];default:return new ud(e)}}}function dd(e,t){if(!t||!e.length)return e;let n=[];for(let r=0;r<e.length;r++){let i=e[r];n.push(new od(i.from+t,i.to+t,i.type));}return n}function hd(e,t,n){if(t.isLeaf)return null;let r=n+t.nodeSize,i=null;for(let t,o=0;o<e.length;o++)(t=e[o])&&t.from>n&&t.to<r&&((i||(i=[])).push(t),e[o]=null);return i}function pd(e){let t=[];for(let n=0;n<e.length;n++)null!=e[n]&&t.push(e[n]);return t}function fd(e,t,n,r){let i=[],o=!1;t.forEach(((t,s)=>{let a=hd(e,t,s+n);if(a){o=!0;let e=fd(a,t,n+s+1,r);e!=cd&&i.push(s,s+t.nodeSize,e);}}));let s=dd(o?pd(e):e,-n).sort(md);for(let e=0;e<s.length;e++)s[e].type.valid(t,s[e])||(r.onRemove&&r.onRemove(s[e].spec),s.splice(e--,1));return s.length||i.length?new ld(s,i):cd}function md(e,t){return e.from-t.from||e.to-t.to}function gd(e){let t=e;for(let n=0;n<t.length-1;n++){let r=t[n];if(r.from!=r.to)for(let i=n+1;i<t.length;i++){let o=t[i];if(o.from!=r.from){o.from<r.to&&(t==e&&(t=e.slice()),t[n]=r.copy(r.from,o.from),vd(t,i,r.copy(o.from,r.to)));break}o.to!=r.to&&(t==e&&(t=e.slice()),t[i]=o.copy(o.from,r.to),vd(t,i+1,o.copy(r.to,o.to)));}}return t}function vd(e,t,n){for(;t<e.length&&md(n,e[t])>0;)t++;e.splice(t,0,n);}function yd(e){let t=[];return e.someProp("decorations",(n=>{let r=n(e.state);r&&r!=cd&&t.push(r);})),e.cursorWrapper&&t.push(ld.create(e.state.doc,[e.cursorWrapper.deco])),ud.from(t)}const bd={childList:!0,characterData:!0,characterDataOldValue:!0,attributes:!0,attributeOldValue:!0,subtree:!0},wd=Bl&&Il<=11;class kd{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0;}set(e){this.anchorNode=e.anchorNode,this.anchorOffset=e.anchorOffset,this.focusNode=e.focusNode,this.focusOffset=e.focusOffset;}clear(){this.anchorNode=this.focusNode=null;}eq(e){return e.anchorNode==this.anchorNode&&e.anchorOffset==this.anchorOffset&&e.focusNode==this.focusNode&&e.focusOffset==this.focusOffset}}class Cd{constructor(e,t){this.view=e,this.handleDOMChange=t,this.queue=[],this.flushingSoon=-1,this.observer=null,this.currentSelection=new kd,this.onCharData=null,this.suppressingSelectionUpdates=!1,this.observer=window.MutationObserver&&new window.MutationObserver((e=>{for(let t=0;t<e.length;t++)this.queue.push(e[t]);Bl&&Il<=11&&e.some((e=>"childList"==e.type&&e.removedNodes.length||"characterData"==e.type&&e.oldValue.length>e.target.nodeValue.length))?this.flushSoon():this.flush();})),wd&&(this.onCharData=e=>{this.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),this.flushSoon();}),this.onSelectionChange=this.onSelectionChange.bind(this);}flushSoon(){this.flushingSoon<0&&(this.flushingSoon=window.setTimeout((()=>{this.flushingSoon=-1,this.flush();}),20));}forceFlush(){this.flushingSoon>-1&&(window.clearTimeout(this.flushingSoon),this.flushingSoon=-1,this.flush());}start(){this.observer&&this.observer.observe(this.view.dom,bd),this.onCharData&&this.view.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.connectSelection();}stop(){if(this.observer){let e=this.observer.takeRecords();if(e.length){for(let t=0;t<e.length;t++)this.queue.push(e[t]);window.setTimeout((()=>this.flush()),20);}this.observer.disconnect();}this.onCharData&&this.view.dom.removeEventListener("DOMCharacterDataModified",this.onCharData),this.disconnectSelection();}connectSelection(){this.view.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange);}disconnectSelection(){this.view.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange);}suppressSelectionUpdates(){this.suppressingSelectionUpdates=!0,setTimeout((()=>this.suppressingSelectionUpdates=!1),50);}onSelectionChange(){if(iu(this.view)){if(this.suppressingSelectionUpdates)return Zc(this.view);if(Bl&&Il<=11&&!this.view.state.selection.empty){let e=this.view.domSelection();if(e.focusNode&&Ql(e.focusNode,e.focusOffset,e.anchorNode,e.anchorOffset))return this.flushSoon()}this.flush();}}setCurSelection(){this.currentSelection.set(this.view.domSelection());}ignoreSelectionChange(e){if(0==e.rangeCount)return !0;let t=e.getRangeAt(0).commonAncestorContainer,n=this.view.docView.nearestDesc(t);return n&&n.ignoreMutation({type:"selection",target:3==t.nodeType?t.parentNode:t})?(this.setCurSelection(),!0):void 0}flush(){if(!this.view.docView||this.flushingSoon>-1)return;let e=this.observer?this.observer.takeRecords():[];this.queue.length&&(e=this.queue.concat(e),this.queue.length=0);let t=this.view.domSelection(),n=!this.suppressingSelectionUpdates&&!this.currentSelection.eq(t)&&iu(this.view)&&!this.ignoreSelectionChange(t),r=-1,i=-1,o=!1,s=[];if(this.view.editable)for(let t=0;t<e.length;t++){let n=this.registerMutation(e[t],s);n&&(r=r<0?n.from:Math.min(n.from,r),i=i<0?n.to:Math.max(n.to,i),n.typeOver&&(o=!0));}if(Pl&&s.length>1){let e=s.filter((e=>"BR"==e.nodeName));if(2==e.length){let t=e[0],n=e[1];t.parentNode&&t.parentNode.parentNode==n.parentNode?n.remove():t.remove();}}(r>-1||n)&&(r>-1&&(this.view.docView.markDirty(r,i),function(e){if(Ed)return;Ed=!0,"normal"==getComputedStyle(e.dom).whiteSpace&&console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");}(this.view)),this.handleDOMChange(r,i,o,s),this.view.docView&&this.view.docView.dirty?this.view.updateState(this.view.state):this.currentSelection.eq(t)||Zc(this.view),this.currentSelection.set(t));}registerMutation(e,t){if(t.indexOf(e.target)>-1)return null;let n=this.view.docView.nearestDesc(e.target);if("attributes"==e.type&&(n==this.view.docView||"contenteditable"==e.attributeName||"style"==e.attributeName&&!e.oldValue&&!e.target.getAttribute("style")))return null;if(!n||n.ignoreMutation(e))return null;if("childList"==e.type){for(let n=0;n<e.addedNodes.length;n++)t.push(e.addedNodes[n]);if(n.contentDOM&&n.contentDOM!=n.dom&&!n.contentDOM.contains(e.target))return {from:n.posBefore,to:n.posAfter};let r=e.previousSibling,i=e.nextSibling;if(Bl&&Il<=11&&e.addedNodes.length)for(let t=0;t<e.addedNodes.length;t++){let{previousSibling:n,nextSibling:o}=e.addedNodes[t];(!n||Array.prototype.indexOf.call(e.addedNodes,n)<0)&&(r=n),(!o||Array.prototype.indexOf.call(e.addedNodes,o)<0)&&(i=o);}let o=r&&r.parentNode==e.target?Gl(r)+1:0,s=n.localPosFromDOM(e.target,o,-1),a=i&&i.parentNode==e.target?Gl(i):e.target.childNodes.length;return {from:s,to:n.localPosFromDOM(e.target,a,1)}}return "attributes"==e.type?{from:n.posAtStart-n.border,to:n.posAtEnd+n.border}:{from:n.posAtStart,to:n.posAtEnd,typeOver:e.target.nodeValue==e.oldValue}}}let Ed=!1;function xd(e){let t=e.pmViewDesc;if(t)return t.parseRule();if("BR"==e.nodeName&&e.parentNode){if(Hl&&/^(ul|ol)$/i.test(e.parentNode.nodeName)){let e=document.createElement("div");return e.appendChild(document.createElement("li")),{skip:e}}if(e.parentNode.lastChild==e||Hl&&/^(tr|table)$/i.test(e.parentNode.nodeName))return {ignore:!0}}else if("IMG"==e.nodeName&&e.getAttribute("mark-placeholder"))return {ignore:!0};return null}function Sd(e,t,n,r,i){if(t<0){let t=e.input.lastSelectionTime>Date.now()-50?e.input.lastSelectionOrigin:null,n=Gc(e,t);if(n&&!e.state.selection.eq(n)){let r=e.state.tr.setSelection(n);"pointer"==t?r.setMeta("pointer",!0):"key"==t&&r.scrollIntoView(),e.dispatch(r);}return}let o=e.state.doc.resolve(t),s=o.sharedDepth(n);t=o.before(s+1),n=e.state.doc.resolve(n).after(s+1);let a=e.state.selection,l=function(e,t,n){let r,{node:i,fromOffset:o,toOffset:s,from:a,to:l}=e.docView.parseRange(t,n),c=e.domSelection(),u=c.anchorNode;if(u&&e.dom.contains(1==u.nodeType?u:u.parentNode)&&(r=[{node:u,offset:c.anchorOffset}],rc(c)||r.push({node:c.focusNode,offset:c.focusOffset})),$l&&8===e.input.lastKeyCode)for(let e=s;e>o;e--){let t=i.childNodes[e-1],n=t.pmViewDesc;if("BR"==t.nodeName&&!n){s=e;break}if(!n||n.size)break}let d=e.state.doc,h=e.someProp("domParser")||ha.fromSchema(e.state.schema),p=d.resolve(a),f=null,m=h.parse(i,{topNode:p.parent,topMatch:p.parent.contentMatchAt(p.index()),topOpen:!0,from:o,to:s,preserveWhitespace:"pre"!=p.parent.type.whitespace||"full",findPositions:r,ruleFromNode:xd,context:p});if(r&&null!=r[0].pos){let e=r[0].pos,t=r[1]&&r[1].pos;null==t&&(t=e),f={anchor:e+a,head:t+a};}return {doc:m,sel:f,from:a,to:l}}(e,t,n);if($l&&e.cursorWrapper&&l.sel&&l.sel.anchor==e.cursorWrapper.deco.from){let t=e.cursorWrapper.deco.type.toDOM.nextSibling,n=t&&t.nodeValue?t.nodeValue.length:1;l.sel={anchor:l.sel.anchor+n,head:l.sel.anchor+n};}let c,u,d=e.state.doc,h=d.slice(l.from,l.to);8===e.input.lastKeyCode&&Date.now()-100<e.input.lastKeyCodeTime?(c=e.state.selection.to,u="end"):(c=e.state.selection.from,u="start"),e.input.lastKeyCode=null;let p=function(e,t,n,r,i){let o=e.findDiffStart(t,n);if(null==o)return null;let{a:s,b:a}=e.findDiffEnd(t,n+e.size,n+t.size);if("end"==i){r-=s+Math.max(0,o-Math.min(s,a))-o;}if(s<o&&e.size<t.size){o-=r<=o&&r>=s?o-r:0,a=o+(a-s),s=o;}else if(a<o){o-=r<=o&&r>=a?o-r:0,s=o+(s-a),a=o;}return {start:o,endA:s,endB:a}}(h.content,l.doc.content,l.from,c,u);if((Vl&&e.input.lastIOSEnter>Date.now()-225||ql)&&i.some((e=>"DIV"==e.nodeName||"P"==e.nodeName))&&(!p||p.endA>=p.endB)&&e.someProp("handleKeyDown",(t=>t(e,ic(13,"Enter")))))return void(e.input.lastIOSEnter=0);if(!p){if(!(r&&a instanceof dl&&!a.empty&&a.$head.sameParent(a.$anchor))||e.composing||l.sel&&l.sel.anchor!=l.sel.head){if(l.sel){let t=Dd(e,e.state.doc,l.sel);t&&!t.eq(e.state.selection)&&e.dispatch(e.state.tr.setSelection(t));}return}p={start:a.from,endA:a.to,endB:a.to};}e.input.domChangeCount++,e.state.selection.from<e.state.selection.to&&p.start==p.endB&&e.state.selection instanceof dl&&(p.start>e.state.selection.from&&p.start<=e.state.selection.from+2&&e.state.selection.from>=l.from?p.start=e.state.selection.from:p.endA<e.state.selection.to&&p.endA>=e.state.selection.to-2&&e.state.selection.to<=l.to&&(p.endB+=e.state.selection.to-p.endA,p.endA=e.state.selection.to)),Bl&&Il<=11&&p.endB==p.start+1&&p.endA==p.start&&p.start>l.from&&"  "==l.doc.textBetween(p.start-l.from-1,p.start-l.from+1)&&(p.start--,p.endA--,p.endB--);let f,m=l.doc.resolveNoCache(p.start-l.from),g=l.doc.resolveNoCache(p.endB-l.from),v=d.resolve(p.start),y=m.sameParent(g)&&m.parent.inlineContent&&v.end()>=p.endA;if((Vl&&e.input.lastIOSEnter>Date.now()-225&&(!y||i.some((e=>"DIV"==e.nodeName||"P"==e.nodeName)))||!y&&m.pos<l.doc.content.size&&(f=al.findFrom(l.doc.resolve(m.pos+1),1,!0))&&f.head==g.pos)&&e.someProp("handleKeyDown",(t=>t(e,ic(13,"Enter")))))return void(e.input.lastIOSEnter=0);if(e.state.selection.anchor>p.start&&function(e,t,n,r,i){if(!r.parent.isTextblock||n-t<=i.pos-r.pos||Md(r,!0,!1)<i.pos)return !1;let o=e.resolve(t);if(o.parentOffset<o.parent.content.size||!o.parent.isTextblock)return !1;let s=e.resolve(Md(o,!0,!0));return !(!s.parent.isTextblock||s.pos>n||Md(s,!0,!1)<n)&&r.parent.content.cut(r.parentOffset).eq(s.parent.content)}(d,p.start,p.endA,m,g)&&e.someProp("handleKeyDown",(t=>t(e,ic(8,"Backspace")))))return void(ql&&$l&&e.domObserver.suppressSelectionUpdates());$l&&ql&&p.endB==p.start&&(e.input.lastAndroidDelete=Date.now()),ql&&!y&&m.start()!=g.start()&&0==g.parentOffset&&m.depth==g.depth&&l.sel&&l.sel.anchor==l.sel.head&&l.sel.head==p.endA&&(p.endB-=2,g=l.doc.resolveNoCache(p.endB-l.from),setTimeout((()=>{e.someProp("handleKeyDown",(function(t){return t(e,ic(13,"Enter"))}));}),20));let b,w,k,C=p.start,E=p.endA;if(y)if(m.pos==g.pos)Bl&&Il<=11&&0==m.parentOffset&&(e.domObserver.suppressSelectionUpdates(),setTimeout((()=>Zc(e)),20)),b=e.state.tr.delete(C,E),w=d.resolve(p.start).marksAcross(d.resolve(p.endA));else if(p.endA==p.endB&&(k=function(e,t){let n,r,i,o=e.firstChild.marks,s=t.firstChild.marks,a=o,l=s;for(let e=0;e<s.length;e++)a=s[e].removeFromSet(a);for(let e=0;e<o.length;e++)l=o[e].removeFromSet(l);if(1==a.length&&0==l.length)r=a[0],n="add",i=e=>e.mark(r.addToSet(e.marks));else {if(0!=a.length||1!=l.length)return null;r=l[0],n="remove",i=e=>e.mark(r.removeFromSet(e.marks));}let c=[];for(let e=0;e<t.childCount;e++)c.push(i(t.child(e)));if(Cs.from(c).eq(e))return {mark:r,type:n}}(m.parent.content.cut(m.parentOffset,g.parentOffset),v.parent.content.cut(v.parentOffset,p.endA-v.start()))))b=e.state.tr,"add"==k.type?b.addMark(C,E,k.mark):b.removeMark(C,E,k.mark);else if(m.parent.child(m.index()).isText&&m.index()==g.index()-(g.textOffset?0:1)){let t=m.parent.textBetween(m.parentOffset,g.parentOffset);if(e.someProp("handleTextInput",(n=>n(e,C,E,t))))return;b=e.state.tr.insertText(t,C,E);}if(b||(b=e.state.tr.replace(C,E,l.doc.slice(p.start-l.from,p.endB-l.from))),l.sel){let t=Dd(e,b.doc,l.sel);t&&!($l&&ql&&e.composing&&t.empty&&(p.start!=p.endB||e.input.lastAndroidDelete<Date.now()-100)&&(t.head==C||t.head==b.mapping.map(E)-1)||Bl&&t.empty&&t.head==C)&&b.setSelection(t);}w&&b.ensureMarks(w),e.dispatch(b.scrollIntoView());}function Dd(e,t,n){return Math.max(n.anchor,n.head)>t.content.size?null:ru(e,t.resolve(n.anchor),t.resolve(n.head))}function Md(e,t,n){let r=e.depth,i=t?e.end():e.pos;for(;r>0&&(t||e.indexAfter(r)==e.node(r).childCount);)r--,i++,t=!1;if(n){let t=e.node(r).maybeChild(e.indexAfter(r));for(;t&&!t.isLeaf;)t=t.firstChild,i++;}return i}class Od{constructor(e,t){this._root=null,this.focused=!1,this.trackWrites=null,this.mounted=!1,this.markCursor=null,this.cursorWrapper=null,this.lastSelectedViewDesc=void 0,this.input=new Tu,this.prevDirectPlugins=[],this.pluginViews=[],this.dragging=null,this._props=t,this.state=t.state,this.directPlugins=t.plugins||[],this.directPlugins.forEach(Ld),this.dispatch=this.dispatch.bind(this),this.dom=e&&e.mount||document.createElement("div"),e&&(e.appendChild?e.appendChild(this.dom):"function"==typeof e?e(this.dom):e.mount&&(this.mounted=!0)),this.editable=_d(this),Nd(this),this.nodeViews=Td(this),this.docView=Tc(this.state.doc,Ad(this),yd(this),this.dom,this),this.domObserver=new Cd(this,((e,t,n,r)=>Sd(this,e,t,n,r))),this.domObserver.start(),function(e){for(let t in Nu){let n=Nu[t];e.dom.addEventListener(t,e.input.eventHandlers[t]=t=>{!Bu(e,t)||Fu(e,t)||!e.editable&&t.type in _u||n(e,t);});}Hl&&e.dom.addEventListener("input",(()=>null)),Ru(e);}(this),this.updatePluginViews();}get composing(){return this.input.composing}get props(){if(this._props.state!=this.state){let e=this._props;this._props={};for(let t in e)this._props[t]=e[t];this._props.state=this.state;}return this._props}update(e){e.handleDOMEvents!=this._props.handleDOMEvents&&Ru(this),this._props=e,e.plugins&&(e.plugins.forEach(Ld),this.directPlugins=e.plugins),this.updateStateInner(e.state,!0);}setProps(e){let t={};for(let e in this._props)t[e]=this._props[e];t.state=this.state;for(let n in e)t[n]=e[n];this.update(t);}updateState(e){this.updateStateInner(e,this.state.plugins!=e.plugins);}updateStateInner(e,t){let n=this.state,r=!1,i=!1;if(e.storedMarks&&this.composing&&(Ju(this),i=!0),this.state=e,t){let e=Td(this);((function(e,t){let n=0,r=0;for(let r in e){if(e[r]!=t[r])return !0;n++;}for(let e in t)r++;return n!=r}))(e,this.nodeViews)&&(this.nodeViews=e,r=!0),Ru(this);}this.editable=_d(this),Nd(this);let o=yd(this),s=Ad(this),a=t?"reset":e.scrollToSelection>n.scrollToSelection?"to selection":"preserve",l=r||!this.docView.matchesNode(e.doc,s,o);!l&&e.selection.eq(n.selection)||(i=!0);let c="preserve"==a&&i&&null==this.dom.style.overflowAnchor&&function(e){let t,n,r=e.dom.getBoundingClientRect(),i=Math.max(0,r.top);for(let o=(r.left+r.right)/2,s=i+1;s<Math.min(innerHeight,r.bottom);s+=5){let r=e.root.elementFromPoint(o,s);if(!r||r==e.dom||!e.dom.contains(r))continue;let a=r.getBoundingClientRect();if(a.top>=i-20){t=r,n=a.top;break}}return {refDOM:t,refTop:n,stack:cc(e.dom)}}(this);if(i){this.domObserver.stop();let t=l&&(Bl||$l)&&!this.composing&&!n.selection.empty&&!e.selection.empty&&function(e,t){let n=Math.min(e.$anchor.sharedDepth(e.head),t.$anchor.sharedDepth(t.head));return e.$anchor.start(n)!=t.$anchor.start(n)}(n.selection,e.selection);if(l){let n=$l?this.trackWrites=this.domSelection().focusNode:null;!r&&this.docView.update(e.doc,s,o,this)||(this.docView.updateOuterDeco([]),this.docView.destroy(),this.docView=Tc(e.doc,s,o,this.dom,this)),n&&!this.trackWrites&&(t=!0);}t||!(this.input.mouseDown&&this.domObserver.currentSelection.eq(this.domSelection())&&function(e){let t=e.docView.domFromPos(e.state.selection.anchor,0),n=e.domSelection();return Ql(t.node,t.offset,n.anchorNode,n.anchorOffset)}(this))?Zc(this,t):(tu(this,e.selection),this.domObserver.setCurSelection()),this.domObserver.start();}if(this.updatePluginViews(n),"reset"==a)this.dom.scrollTop=0;else if("to selection"==a){let t=this.domSelection().focusNode;if(this.someProp("handleScrollToSelection",(e=>e(this))));else if(e.selection instanceof pl){let n=this.docView.domAfterPos(e.selection.from);1==n.nodeType&&lc(this,n.getBoundingClientRect(),t);}else lc(this,this.coordsAtPos(e.selection.head,1),t);}else c&&function({refDOM:e,refTop:t,stack:n}){let r=e?e.getBoundingClientRect().top:0;uc(n,0==r?0:r-t);}(c);}destroyPluginViews(){let e;for(;e=this.pluginViews.pop();)e.destroy&&e.destroy();}updatePluginViews(e){if(e&&e.plugins==this.state.plugins&&this.directPlugins==this.prevDirectPlugins)for(let t=0;t<this.pluginViews.length;t++){let n=this.pluginViews[t];n.update&&n.update(this,e);}else {this.prevDirectPlugins=this.directPlugins,this.destroyPluginViews();for(let e=0;e<this.directPlugins.length;e++){let t=this.directPlugins[e];t.spec.view&&this.pluginViews.push(t.spec.view(this));}for(let e=0;e<this.state.plugins.length;e++){let t=this.state.plugins[e];t.spec.view&&this.pluginViews.push(t.spec.view(this));}}}someProp(e,t){let n,r=this._props&&this._props[e];if(null!=r&&(n=t?t(r):r))return n;for(let r=0;r<this.directPlugins.length;r++){let i=this.directPlugins[r].props[e];if(null!=i&&(n=t?t(i):i))return n}let i=this.state.plugins;if(i)for(let r=0;r<i.length;r++){let o=i[r].props[e];if(null!=o&&(n=t?t(o):o))return n}}hasFocus(){return this.root.activeElement==this.dom}focus(){this.domObserver.stop(),this.editable&&function(e){if(e.setActive)return e.setActive();if(dc)return e.focus(dc);let t=cc(e);e.focus(null==dc?{get preventScroll(){return dc={preventScroll:!0},!0}}:void 0),dc||(dc=!1,uc(t,0));}(this.dom),Zc(this),this.domObserver.start();}get root(){let e=this._root;if(null==e)for(let e=this.dom.parentNode;e;e=e.parentNode)if(9==e.nodeType||11==e.nodeType&&e.host)return e.getSelection||(Object.getPrototypeOf(e).getSelection=()=>e.ownerDocument.getSelection()),this._root=e;return e||document}posAtCoords(e){return mc(this,e)}coordsAtPos(e,t=1){return yc(this,e,t)}domAtPos(e,t=0){return this.docView.domFromPos(e,t)}nodeDOM(e){let t=this.docView.descAt(e);return t?t.nodeDOM:null}posAtDOM(e,t,n=-1){let r=this.docView.posFromDOM(e,t,n);if(null==r)throw new RangeError("DOM position not inside the editor");return r}endOfTextblock(e,t){return Dc(this,t||this.state,e)}destroy(){this.docView&&(!function(e){e.domObserver.stop();for(let t in e.input.eventHandlers)e.dom.removeEventListener(t,e.input.eventHandlers[t]);clearTimeout(e.input.composingTimeout),clearTimeout(e.input.lastIOSEnterFallbackTimeout);}(this),this.destroyPluginViews(),this.mounted?(this.docView.update(this.state.doc,[],yd(this),this),this.dom.textContent=""):this.dom.parentNode&&this.dom.parentNode.removeChild(this.dom),this.docView.destroy(),this.docView=null);}get isDestroyed(){return null==this.docView}dispatchEvent(e){return function(e,t){Fu(e,t)||!Nu[t.type]||!e.editable&&t.type in _u||Nu[t.type](e,t);}(this,e)}dispatch(e){let t=this._props.dispatchTransaction;t?t.call(this,e):this.updateState(this.state.apply(e));}domSelection(){return this.root.getSelection()}}function Ad(e){let t=Object.create(null);return t.class="ProseMirror",t.contenteditable=String(e.editable),t.translate="no",e.someProp("attributes",(n=>{if("function"==typeof n&&(n=n(e.state)),n)for(let e in n)"class"==e&&(t.class+=" "+n[e]),"style"==e?t.style=(t.style?t.style+";":"")+n[e]:t[e]||"contenteditable"==e||"nodeName"==e||(t[e]=String(n[e]));})),[od.node(0,e.state.doc.content.size,t)]}function Nd(e){if(e.markCursor){let t=document.createElement("img");t.className="ProseMirror-separator",t.setAttribute("mark-placeholder","true"),t.setAttribute("alt",""),e.cursorWrapper={dom:t,deco:od.widget(e.state.selection.head,t,{raw:!0,marks:e.markCursor})};}else e.cursorWrapper=null;}function _d(e){return !e.someProp("editable",(t=>!1===t(e.state)))}function Td(e){let t=Object.create(null);function n(e){for(let n in e)Object.prototype.hasOwnProperty.call(t,n)||(t[n]=e[n]);}return e.someProp("nodeViews",n),e.someProp("markViews",n),t}function Ld(e){if(e.spec.state||e.spec.filterTransaction||e.spec.appendTransaction)throw new RangeError("Plugins passed directly to the view must not have a state component")}for(var Rd={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},Fd={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},Bd="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent),Id="undefined"!=typeof navigator&&/Apple Computer/.test(navigator.vendor),Pd="undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent),zd="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),$d="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),jd=Bd&&(zd||+Bd[1]<57)||Pd&&zd,Hd=0;Hd<10;Hd++)Rd[48+Hd]=Rd[96+Hd]=String(Hd);for(Hd=1;Hd<=24;Hd++)Rd[Hd+111]="F"+Hd;for(Hd=65;Hd<=90;Hd++)Rd[Hd]=String.fromCharCode(Hd+32),Fd[Hd]=String.fromCharCode(Hd);for(var Vd in Rd)Fd.hasOwnProperty(Vd)||(Fd[Vd]=Rd[Vd]);const Kd="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function qd(e){let t,n,r,i,o=e.split(/-(?!$)/),s=o[o.length-1];"Space"==s&&(s=" ");for(let e=0;e<o.length-1;e++){let s=o[e];if(/^(cmd|meta|m)$/i.test(s))i=!0;else if(/^a(lt)?$/i.test(s))t=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else if(/^s(hift)?$/i.test(s))r=!0;else {if(!/^mod$/i.test(s))throw new Error("Unrecognized modifier name: "+s);Kd?i=!0:n=!0;}}return t&&(s="Alt-"+s),n&&(s="Ctrl-"+s),i&&(s="Meta-"+s),r&&(s="Shift-"+s),s}function Ud(e,t,n){return t.altKey&&(e="Alt-"+e),t.ctrlKey&&(e="Ctrl-"+e),t.metaKey&&(e="Meta-"+e),!1!==n&&t.shiftKey&&(e="Shift-"+e),e}function Wd(e){let t=function(e){let t=Object.create(null);for(let n in e)t[qd(n)]=e[n];return t}(e);return function(e,n){let r,i=function(e){var t=!(jd&&(e.ctrlKey||e.altKey||e.metaKey)||(Id||$d)&&e.shiftKey&&e.key&&1==e.key.length||"Unidentified"==e.key)&&e.key||(e.shiftKey?Fd:Rd)[e.keyCode]||e.key||"Unidentified";return "Esc"==t&&(t="Escape"),"Del"==t&&(t="Delete"),"Left"==t&&(t="ArrowLeft"),"Up"==t&&(t="ArrowUp"),"Right"==t&&(t="ArrowRight"),"Down"==t&&(t="ArrowDown"),t}(n),o=1==i.length&&" "!=i,s=t[Ud(i,n,!o)];if(s&&s(e.state,e.dispatch,e))return !0;if(o&&(n.shiftKey||n.altKey||n.metaKey||i.charCodeAt(0)>127)&&(r=Rd[n.keyCode])&&r!=i){let i=t[Ud(r,n,!0)];if(i&&i(e.state,e.dispatch,e))return !0}else if(o&&n.shiftKey){let r=t[Ud(i,n,!0)];if(r&&r(e.state,e.dispatch,e))return !0}return !1}}function Gd(e,t,n=!1){for(let r=e;r;r="start"==t?r.firstChild:r.lastChild){if(r.isTextblock)return !0;if(n&&1!=r.childCount)return !1}return !1}function Jd(e){if(!e.parent.type.spec.isolating)for(let t=e.depth-1;t>=0;t--){if(e.index(t)>0)return e.doc.resolve(e.before(t+1));if(e.node(t).type.spec.isolating)break}return null}function Zd(e){if(!e.parent.type.spec.isolating)for(let t=e.depth-1;t>=0;t--){let n=e.node(t);if(e.index(t)+1<n.childCount)return e.doc.resolve(e.after(t+1));if(n.type.spec.isolating)break}return null}function Xd(e){for(let t=0;t<e.edgeCount;t++){let{type:n}=e.edge(t);if(n.isTextblock&&!n.hasRequiredAttrs())return n}return null}function Qd(e,t,n){let r,i,o=t.nodeBefore,s=t.nodeAfter;if(o.type.spec.isolating||s.type.spec.isolating)return !1;if(function(e,t,n){let r=t.nodeBefore,i=t.nodeAfter,o=t.index();return !(!(r&&i&&r.type.compatibleContent(i.type))||(!r.content.size&&t.parent.canReplace(o-1,o)?(n&&n(e.tr.delete(t.pos-r.nodeSize,t.pos).scrollIntoView()),0):!t.parent.canReplace(o,o+1)||!i.isTextblock&&!qa(e.doc,t.pos)||(n&&n(e.tr.clearIncompatible(t.pos,r.type,r.contentMatchAt(r.childCount)).join(t.pos).scrollIntoView()),0)))}(e,t,n))return !0;let a=t.parent.canReplace(t.index(),t.index()+1);if(a&&(r=(i=o.contentMatchAt(o.childCount)).findWrapping(s.type))&&i.matchType(r[0]||s.type).validEnd){if(n){let i=t.pos+s.nodeSize,a=Cs.empty;for(let e=r.length-1;e>=0;e--)a=Cs.from(r[e].create(null,a));a=Cs.from(o.copy(a));let l=e.tr.step(new Pa(t.pos-1,i,t.pos,i,new Os(a,1,0),r.length,!0)),c=i+2*r.length;qa(l.doc,c)&&l.join(c),n(l.scrollIntoView());}return !0}let l=al.findFrom(t,1),c=l&&l.$from.blockRange(l.$to),u=c&&ja(c);if(null!=u&&u>=t.depth)return n&&n(e.tr.lift(c,u).scrollIntoView()),!0;if(a&&Gd(s,"start",!0)&&Gd(o,"end")){let r=o,i=[];for(;i.push(r),!r.isTextblock;)r=r.lastChild;let a=s,l=1;for(;!a.isTextblock;a=a.firstChild)l++;if(r.canReplace(r.childCount,r.childCount,a.content)){if(n){let r=Cs.empty;for(let e=i.length-1;e>=0;e--)r=Cs.from(i[e].copy(r));n(e.tr.step(new Pa(t.pos-i.length,t.pos+s.nodeSize,t.pos+l,t.pos+s.nodeSize-l,new Os(r,i.length,0),0,!0)).scrollIntoView());}return !0}}return !1}function Yd(e){return function(t,n){let r=t.selection,i=e<0?r.$from:r.$to,o=i.depth;for(;i.node(o).isInline;){if(!o)return !1;o--;}return !!i.node(o).isTextblock&&(n&&n(t.tr.setSelection(dl.create(t.doc,e<0?i.start(o):i.end(o)))),!0)}}const eh=Yd(-1),th=Yd(1);function nh(e,t=null){return function(n,r){let{from:i,to:o}=n.selection,s=!1;return n.doc.nodesBetween(i,o,((r,i)=>{if(s)return !1;if(r.isTextblock&&!r.hasMarkup(e,t))if(r.type==e)s=!0;else {let t=n.doc.resolve(i),r=t.index();s=t.parent.canReplaceWith(r,r+1,e);}})),!!s&&(r&&r(n.tr.setBlockType(i,o,e,t).scrollIntoView()),!0)}}function rh(e,t=null){return function(n,r){let{$from:i,$to:o}=n.selection,s=i.blockRange(o),a=!1,l=s;if(!s)return !1;if(s.depth>=2&&i.node(s.depth-1).type.compatibleContent(e)&&0==s.startIndex){if(0==i.index(s.depth-1))return !1;let e=n.doc.resolve(s.start-2);l=new Ks(e,e,s.depth),s.endIndex<s.parent.childCount&&(s=new Ks(i,n.doc.resolve(o.end(s.depth)),s.depth)),a=!0;}let c=Ha(l,e,t,s);return !!c&&(r&&r(function(e,t,n,r,i){let o=Cs.empty;for(let e=n.length-1;e>=0;e--)o=Cs.from(n[e].type.create(n[e].attrs,o));e.step(new Pa(t.start-(r?2:0),t.end,t.start,t.end,new Os(o,0,0),n.length,!0));let s=0;for(let e=0;e<n.length;e++)n[e].type==i&&(s=e+1);let a=n.length-s,l=t.start+n.length-(r?2:0),c=t.parent;for(let n=t.startIndex,r=t.endIndex,i=!0;n<r;n++,i=!1)!i&&Ka(e.doc,l,a)&&(e.split(l,a),l+=2*a),l+=c.child(n).nodeSize;return e}(n.tr,s,c,a,e).scrollIntoView()),!0)}}function ih(e){return function(t,n){let{$from:r,$to:i}=t.selection,o=r.blockRange(i,(t=>t.childCount>0&&t.firstChild.type==e));return !!o&&(!n||(r.node(o.depth-1).type==e?function(e,t,n,r){let i=e.tr,o=r.end,s=r.$to.end(r.depth);o<s&&(i.step(new Pa(o-1,s,o,s,new Os(Cs.from(n.create(null,r.parent.copy())),1,0),1,!0)),r=new Ks(i.doc.resolve(r.$from.pos),i.doc.resolve(s),r.depth));return t(i.lift(r,ja(r)).scrollIntoView()),!0}(t,n,e,o):function(e,t,n){let r=e.tr,i=n.parent;for(let e=n.end,t=n.endIndex-1,o=n.startIndex;t>o;t--)e-=i.child(t).nodeSize,r.delete(e-1,e+1);let o=r.doc.resolve(n.start),s=o.nodeAfter;if(r.mapping.map(n.end)!=n.start+o.nodeAfter.nodeSize)return !1;let a=0==n.startIndex,l=n.endIndex==i.childCount,c=o.node(-1),u=o.index(-1);if(!c.canReplace(u+(a?0:1),u+1,s.content.append(l?Cs.empty:Cs.from(i))))return !1;let d=o.pos,h=d+s.nodeSize;return r.step(new Pa(d-(a?1:0),h+(l?1:0),d+1,h-1,new Os((a?Cs.empty:Cs.from(i.copy(Cs.empty))).append(l?Cs.empty:Cs.from(i.copy(Cs.empty))),a?0:1,l?0:1),a?0:1)),t(r.scrollIntoView()),!0}(t,n,o)))}}function oh(e){const{state:t,transaction:n}=e;let{selection:r}=n,{doc:i}=n,{storedMarks:o}=n;return {...t,apply:t.apply.bind(t),applyTransaction:t.applyTransaction.bind(t),filterTransaction:t.filterTransaction,plugins:t.plugins,schema:t.schema,reconfigure:t.reconfigure.bind(t),toJSON:t.toJSON.bind(t),get storedMarks(){return o},get selection(){return r},get doc(){return i},get tr(){return r=n.selection,i=n.doc,o=n.storedMarks,n}}}"undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):"undefined"!=typeof os&&os.platform&&os.platform();class sh{constructor(e){this.editor=e.editor,this.rawCommands=this.editor.extensionManager.commands,this.customState=e.state;}get hasCustomState(){return !!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:e,editor:t,state:n}=this,{view:r}=t,{tr:i}=n,o=this.buildProps(i);return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,(...e)=>{const n=t(...e)(o);return i.getMeta("preventDispatch")||this.hasCustomState||r.dispatch(i),n}])))}get chain(){return ()=>this.createChain()}get can(){return ()=>this.createCan()}createChain(e,t=!0){const{rawCommands:n,editor:r,state:i}=this,{view:o}=r,s=[],a=!!e,l=e||i.tr,c={...Object.fromEntries(Object.entries(n).map((([e,n])=>[e,(...e)=>{const r=this.buildProps(l,t),i=n(...e)(r);return s.push(i),c}]))),run:()=>(a||!t||l.getMeta("preventDispatch")||this.hasCustomState||o.dispatch(l),s.every((e=>!0===e)))};return c}createCan(e){const{rawCommands:t,state:n}=this,r=void 0,i=e||n.tr,o=this.buildProps(i,r),s=Object.fromEntries(Object.entries(t).map((([e,t])=>[e,(...e)=>t(...e)({...o,dispatch:r})])));return {...s,chain:()=>this.createChain(i,r)}}buildProps(e,t=!0){const{rawCommands:n,editor:r,state:i}=this,{view:o}=r;i.storedMarks&&e.setStoredMarks(i.storedMarks);const s={tr:e,editor:r,view:o,state:oh({state:i,transaction:e}),dispatch:t?()=>{}:void 0,chain:()=>this.createChain(e),can:()=>this.createCan(e),get commands(){return Object.fromEntries(Object.entries(n).map((([e,t])=>[e,(...e)=>t(...e)(s)])))}};return s}}function ah(e,t,n){if(void 0===e.config[t]&&e.parent)return ah(e.parent,t,n);if("function"==typeof e.config[t]){return e.config[t].bind({...n,parent:e.parent?ah(e.parent,t,n):null})}return e.config[t]}function lh(e){return {baseExtensions:e.filter((e=>"extension"===e.type)),nodeExtensions:e.filter((e=>"node"===e.type)),markExtensions:e.filter((e=>"mark"===e.type))}}function ch(e){const t=[],{nodeExtensions:n,markExtensions:r}=lh(e),i=[...n,...r],o={default:null,rendered:!0,renderHTML:null,parseHTML:null,keepOnSplit:!0,isRequired:!1};return e.forEach((e=>{const n=ah(e,"addGlobalAttributes",{name:e.name,options:e.options,storage:e.storage});if(!n)return;n().forEach((e=>{e.types.forEach((n=>{Object.entries(e.attributes).forEach((([e,r])=>{t.push({type:n,name:e,attribute:{...o,...r}});}));}));}));})),i.forEach((e=>{const n={name:e.name,options:e.options,storage:e.storage},r=ah(e,"addAttributes",n);if(!r)return;const i=r();Object.entries(i).forEach((([n,r])=>{const i={...o,...r};r.isRequired&&void 0===r.default&&delete i.default,t.push({type:e.name,name:n,attribute:i});}));})),t}function uh(e,t){if("string"==typeof e){if(!t.nodes[e])throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);return t.nodes[e]}return e}function dh(...e){return e.filter((e=>!!e)).reduce(((e,t)=>{const n={...e};return Object.entries(t).forEach((([e,t])=>{n[e]?n[e]="class"===e?[n[e],t].join(" "):"style"===e?[n[e],t].join("; "):t:n[e]=t;})),n}),{})}function hh(e,t){return t.filter((e=>e.attribute.rendered)).map((t=>t.attribute.renderHTML?t.attribute.renderHTML(e.attrs)||{}:{[t.name]:e.attrs[t.name]})).reduce(((e,t)=>dh(e,t)),{})}function ph(e){return "function"==typeof e}function fh(e,t,...n){return ph(e)?t?e.bind(t)(...n):e(...n):e}function mh(e,t){return e.style?e:{...e,getAttrs:n=>{const r=e.getAttrs?e.getAttrs(n):e.attrs;if(!1===r)return !1;const i=t.reduce(((e,t)=>{const r=t.attribute.parseHTML?t.attribute.parseHTML(n):function(e){return "string"!=typeof e?e:e.match(/^[+-]?(?:\d*\.)?\d+$/)?Number(e):"true"===e||"false"!==e&&e}(n.getAttribute(t.name));return null==r?e:{...e,[t.name]:r}}),{});return {...r,...i}}}}function gh(e){return Object.fromEntries(Object.entries(e).filter((([e,t])=>("attrs"!==e||!function(e={}){return 0===Object.keys(e).length&&e.constructor===Object}(t))&&null!=t)))}function vh(e,t){return t.nodes[e]||t.marks[e]||null}function yh(e,t){return Array.isArray(t)?t.some((t=>("string"==typeof t?t:t.name)===e.name)):t}function bh(e){return "[object RegExp]"===Object.prototype.toString.call(e)}class wh{constructor(e){this.find=e.find,this.handler=e.handler;}}function kh(e){var t;const{editor:n,from:r,to:i,text:o,rules:s,plugin:a}=e,{view:l}=n;if(l.composing)return !1;const c=l.state.doc.resolve(r);if(c.parent.type.spec.code||(null===(t=c.nodeBefore||c.nodeAfter)||void 0===t?void 0:t.marks.find((e=>e.type.spec.code))))return !1;let u=!1;const d=((e,t=500)=>{let n="";return e.parent.nodesBetween(Math.max(0,e.parentOffset-t),e.parentOffset,((t,r,i,o)=>{var s,a,l;n+=(null===(a=(s=t.type.spec).toText)||void 0===a?void 0:a.call(s,{node:t,pos:r,parent:i,index:o}))||(null===(l=e.nodeBefore)||void 0===l?void 0:l.text)||"%leaf%";})),n})(c)+o;return s.forEach((e=>{if(u)return;const t=((e,t)=>{if(bh(t))return t.exec(e);const n=t(e);if(!n)return null;const r=[];return r.push(n.text),r.index=n.index,r.input=e,r.data=n.data,n.replaceWith&&(n.text.includes(n.replaceWith)||console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),r.push(n.replaceWith)),r})(d,e.find);if(!t)return;const s=l.state.tr,c=oh({state:l.state,transaction:s}),h={from:r-(t[0].length-o.length),to:i},{commands:p,chain:f,can:m}=new sh({editor:n,state:c});null!==e.handler({state:c,range:h,match:t,commands:p,chain:f,can:m})&&s.steps.length&&(s.setMeta(a,{transform:s,from:r,to:i,text:o}),l.dispatch(s),u=!0);})),u}function Ch(e){const{editor:t,rules:n}=e,r=new Dl({state:{init:()=>null,apply(e,t){const n=e.getMeta(r);return n||(e.selectionSet||e.docChanged?null:t)}},props:{handleTextInput:(e,i,o,s)=>kh({editor:t,from:i,to:o,text:s,rules:n,plugin:r}),handleDOMEvents:{compositionend:e=>(setTimeout((()=>{const{$cursor:i}=e.state.selection;i&&kh({editor:t,from:i.pos,to:i.pos,text:"",rules:n,plugin:r});})),!1)},handleKeyDown(e,i){if("Enter"!==i.key)return !1;const{$cursor:o}=e.state.selection;return !!o&&kh({editor:t,from:o.pos,to:o.pos,text:"\n",rules:n,plugin:r})}},isInputRules:!0});return r}class Eh{constructor(e){this.find=e.find,this.handler=e.handler;}}function xh(e){const{editor:t,state:n,from:r,to:i,rule:o}=e,{commands:s,chain:a,can:l}=new sh({editor:t,state:n}),c=[];n.doc.nodesBetween(r,i,((e,t)=>{if(!e.isTextblock||e.type.spec.code)return;const u=Math.max(r,t),d=Math.min(i,t+e.content.size),h=((e,t)=>{if(bh(t))return [...e.matchAll(t)];const n=t(e);return n?n.map((t=>{const n=[];return n.push(t.text),n.index=t.index,n.input=e,n.data=t.data,t.replaceWith&&(t.text.includes(t.replaceWith)||console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'),n.push(t.replaceWith)),n})):[]})(e.textBetween(u-t,d-t,void 0,"￼"),o.find);h.forEach((e=>{if(void 0===e.index)return;const t=u+e.index+1,r=t+e[0].length,i={from:n.tr.mapping.map(t),to:n.tr.mapping.map(r)},d=o.handler({state:n,range:i,match:e,commands:s,chain:a,can:l});c.push(d);}));}));return c.every((e=>null!==e))}function Sh(e){const{editor:t,rules:n}=e;let r=null,i=!1,o=!1;const s=n.map((e=>new Dl({view(e){const t=t=>{var n;r=(null===(n=e.dom.parentElement)||void 0===n?void 0:n.contains(t.target))?e.dom.parentElement:null;};return window.addEventListener("dragstart",t),{destroy(){window.removeEventListener("dragstart",t);}}},props:{handleDOMEvents:{drop:e=>(o=r===e.dom.parentElement,!1),paste:(e,t)=>{var n;const r=null===(n=t.clipboardData)||void 0===n?void 0:n.getData("text/html");return i=!!(null==r?void 0:r.includes("data-pm-slice")),!1}}},appendTransaction:(n,r,s)=>{const a=n[0],l="paste"===a.getMeta("uiEvent")&&!i,c="drop"===a.getMeta("uiEvent")&&!o;if(!l&&!c)return;const u=r.doc.content.findDiffStart(s.doc.content),d=r.doc.content.findDiffEnd(s.doc.content);if("number"!=typeof u||!d||u===d.b)return;const h=s.tr,p=oh({state:s,transaction:h});return xh({editor:t,state:p,from:Math.max(u-1,0),to:d.b,rule:e})&&h.steps.length?h:void 0}})));return s}class Dh{constructor(e,t){this.splittableMarks=[],this.editor=t,this.extensions=Dh.resolve(e),this.schema=function(e){var t;const n=ch(e),{nodeExtensions:r,markExtensions:i}=lh(e),o=null===(t=r.find((e=>ah(e,"topNode"))))||void 0===t?void 0:t.name,s=Object.fromEntries(r.map((t=>{const r=n.filter((e=>e.type===t.name)),i={name:t.name,options:t.options,storage:t.storage},o=gh({...e.reduce(((e,n)=>{const r=ah(n,"extendNodeSchema",i);return {...e,...r?r(t):{}}}),{}),content:fh(ah(t,"content",i)),marks:fh(ah(t,"marks",i)),group:fh(ah(t,"group",i)),inline:fh(ah(t,"inline",i)),atom:fh(ah(t,"atom",i)),selectable:fh(ah(t,"selectable",i)),draggable:fh(ah(t,"draggable",i)),code:fh(ah(t,"code",i)),defining:fh(ah(t,"defining",i)),isolating:fh(ah(t,"isolating",i)),attrs:Object.fromEntries(r.map((e=>{var t;return [e.name,{default:null===(t=null==e?void 0:e.attribute)||void 0===t?void 0:t.default}]})))}),s=fh(ah(t,"parseHTML",i));s&&(o.parseDOM=s.map((e=>mh(e,r))));const a=ah(t,"renderHTML",i);a&&(o.toDOM=e=>a({node:e,HTMLAttributes:hh(e,r)}));const l=ah(t,"renderText",i);return l&&(o.toText=l),[t.name,o]}))),a=Object.fromEntries(i.map((t=>{const r=n.filter((e=>e.type===t.name)),i={name:t.name,options:t.options,storage:t.storage},o=gh({...e.reduce(((e,n)=>{const r=ah(n,"extendMarkSchema",i);return {...e,...r?r(t):{}}}),{}),inclusive:fh(ah(t,"inclusive",i)),excludes:fh(ah(t,"excludes",i)),group:fh(ah(t,"group",i)),spanning:fh(ah(t,"spanning",i)),code:fh(ah(t,"code",i)),attrs:Object.fromEntries(r.map((e=>{var t;return [e.name,{default:null===(t=null==e?void 0:e.attribute)||void 0===t?void 0:t.default}]})))}),s=fh(ah(t,"parseHTML",i));s&&(o.parseDOM=s.map((e=>mh(e,r))));const a=ah(t,"renderHTML",i);return a&&(o.toDOM=e=>a({mark:e,HTMLAttributes:hh(e,r)})),[t.name,o]})));return new ua({topNode:o,nodes:s,marks:a})}(this.extensions),this.extensions.forEach((e=>{var t;this.editor.extensionStorage[e.name]=e.storage;const n={name:e.name,options:e.options,storage:e.storage,editor:this.editor,type:vh(e.name,this.schema)};if("mark"===e.type){(null===(t=fh(ah(e,"keepOnSplit",n)))||void 0===t||t)&&this.splittableMarks.push(e.name);}const r=ah(e,"onBeforeCreate",n);r&&this.editor.on("beforeCreate",r);const i=ah(e,"onCreate",n);i&&this.editor.on("create",i);const o=ah(e,"onUpdate",n);o&&this.editor.on("update",o);const s=ah(e,"onSelectionUpdate",n);s&&this.editor.on("selectionUpdate",s);const a=ah(e,"onTransaction",n);a&&this.editor.on("transaction",a);const l=ah(e,"onFocus",n);l&&this.editor.on("focus",l);const c=ah(e,"onBlur",n);c&&this.editor.on("blur",c);const u=ah(e,"onDestroy",n);u&&this.editor.on("destroy",u);}));}static resolve(e){const t=Dh.sort(Dh.flatten(e)),n=function(e){const t=e.filter(((t,n)=>e.indexOf(t)!==n));return [...new Set(t)]}(t.map((e=>e.name)));return n.length&&console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((e=>`'${e}'`)).join(", ")}]. This can lead to issues.`),t}static flatten(e){return e.map((e=>{const t=ah(e,"addExtensions",{name:e.name,options:e.options,storage:e.storage});return t?[e,...this.flatten(t())]:e})).flat(10)}static sort(e){return e.sort(((e,t)=>{const n=ah(e,"priority")||100,r=ah(t,"priority")||100;return n>r?-1:n<r?1:0}))}get commands(){return this.extensions.reduce(((e,t)=>{const n=ah(t,"addCommands",{name:t.name,options:t.options,storage:t.storage,editor:this.editor,type:vh(t.name,this.schema)});return n?{...e,...n()}:e}),{})}get plugins(){const{editor:e}=this,t=Dh.sort([...this.extensions].reverse()),n=[],r=[],i=t.map((t=>{const i={name:t.name,options:t.options,storage:t.storage,editor:e,type:vh(t.name,this.schema)},o=[],s=ah(t,"addKeyboardShortcuts",i);if(s){const t=function(e){return new Dl({props:{handleKeyDown:Wd(e)}})}(Object.fromEntries(Object.entries(s()).map((([t,n])=>[t,()=>n({editor:e})]))));o.push(t);}const a=ah(t,"addInputRules",i);yh(t,e.options.enableInputRules)&&a&&n.push(...a());const l=ah(t,"addPasteRules",i);yh(t,e.options.enablePasteRules)&&l&&r.push(...l());const c=ah(t,"addProseMirrorPlugins",i);if(c){const e=c();o.push(...e);}return o})).flat();return [Ch({editor:e,rules:n}),...Sh({editor:e,rules:r}),...i]}get attributes(){return ch(this.extensions)}get nodeViews(){const{editor:e}=this,{nodeExtensions:t}=lh(this.extensions);return Object.fromEntries(t.filter((e=>!!ah(e,"addNodeView"))).map((t=>{const n=this.attributes.filter((e=>e.type===t.name)),r={name:t.name,options:t.options,storage:t.storage,editor:e,type:uh(t.name,this.schema)},i=ah(t,"addNodeView",r);if(!i)return [];return [t.name,(r,o,s,a)=>{const l=hh(r,n);return i()({editor:e,node:r,getPos:s,decorations:a,HTMLAttributes:l,extension:t})}]})))}}function Mh(e){return "Object"===function(e){return Object.prototype.toString.call(e).slice(8,-1)}(e)&&(e.constructor===Object&&Object.getPrototypeOf(e)===Object.prototype)}function Oh(e,t){const n={...e};return Mh(e)&&Mh(t)&&Object.keys(t).forEach((r=>{Mh(t[r])?r in e?n[r]=Oh(e[r],t[r]):Object.assign(n,{[r]:t[r]}):Object.assign(n,{[r]:t[r]});})),n}class Ah{constructor(e={}){this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...e},this.name=this.config.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=fh(ah(this,"addOptions",{name:this.name}))),this.storage=fh(ah(this,"addStorage",{name:this.name,options:this.options}))||{};}static create(e={}){return new Ah(e)}configure(e={}){const t=this.extend();return t.options=Oh(this.options,e),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}extend(e={}){const t=new Ah(e);return t.parent=this,this.child=t,t.name=e.name?e.name:t.parent.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),t.options=fh(ah(t,"addOptions",{name:t.name})),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}}function Nh(e,t,n){const{from:r,to:i}=t,{blockSeparator:o="\n\n",textSerializers:s={}}=n||{};let a="",l=!0;return e.nodesBetween(r,i,((e,n,c,u)=>{var d;const h=null==s?void 0:s[e.type.name];h?(e.isBlock&&!l&&(a+=o,l=!0),c&&(a+=h({node:e,pos:n,parent:c,index:u,range:t}))):e.isText?(a+=null===(d=null==e?void 0:e.text)||void 0===d?void 0:d.slice(Math.max(r,n)-n,i-n),l=!1):e.isBlock&&!l&&(a+=o,l=!0);})),a}function _h(e){return Object.fromEntries(Object.entries(e.nodes).filter((([,e])=>e.spec.toText)).map((([e,t])=>[e,t.spec.toText])))}const Th=Ah.create({name:"clipboardTextSerializer",addProseMirrorPlugins(){return [new Dl({key:new Al("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:e}=this,{state:t,schema:n}=e,{doc:r,selection:i}=t,{ranges:o}=i,s=Math.min(...o.map((e=>e.$from.pos))),a=Math.max(...o.map((e=>e.$to.pos)));return Nh(r,{from:s,to:a},{textSerializers:_h(n)})}}})]}});function Lh(e,t,n={strict:!0}){const r=Object.keys(t);return !r.length||r.every((r=>n.strict?t[r]===e[r]:bh(t[r])?t[r].test(e[r]):t[r]===e[r]))}function Rh(e,t,n={}){return e.find((e=>e.type===t&&Lh(e.attrs,n)))}function Fh(e,t,n={}){return !!Rh(e,t,n)}function Bh(e,t,n={}){if(!e||!t)return;let r=e.parent.childAfter(e.parentOffset);if(e.parentOffset===r.offset&&0!==r.offset&&(r=e.parent.childBefore(e.parentOffset)),!r.node)return;const i=Rh([...r.node.marks],t,n);if(!i)return;let o=r.index,s=e.start()+r.offset,a=o+1,l=s+r.node.nodeSize;for(Rh([...r.node.marks],t,n);o>0&&i.isInSet(e.parent.child(o-1).marks);)o-=1,s-=e.parent.child(o).nodeSize;for(;a<e.parent.childCount&&Fh([...e.parent.child(a).marks],t,n);)l+=e.parent.child(a).nodeSize,a+=1;return {from:s,to:l}}function Ih(e,t){if("string"==typeof e){if(!t.marks[e])throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);return t.marks[e]}return e}function Ph(e){return e&&"object"==typeof e&&!Array.isArray(e)&&!function(e){var t;return "class"===(null===(t=e.constructor)||void 0===t?void 0:t.toString().substring(0,5))}(e)}function zh(e){return Ph(e)&&e instanceof dl}function $h(e=0,t=0,n=0){return Math.min(Math.max(e,t),n)}function jh(e,t=null){if(!t)return null;const n=al.atStart(e),r=al.atEnd(e);if("start"===t||!0===t)return n;if("end"===t)return r;const i=n.from,o=r.to;return "all"===t?dl.create(e,$h(0,i,o),$h(e.content.size,i,o)):dl.create(e,$h(t,i,o),$h(t,i,o))}function Hh(){return ["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}function Vh(e){const t=`<body>${e}</body>`;return (new window.DOMParser).parseFromString(t,"text/html").body}function Kh(e,t,n){if(n={slice:!0,parseOptions:{},...n},"object"==typeof e&&null!==e)try{return Array.isArray(e)?Cs.fromArray(e.map((e=>t.nodeFromJSON(e)))):t.nodeFromJSON(e)}catch(r){return console.warn("[tiptap warn]: Invalid content.","Passed value:",e,"Error:",r),Kh("",t,n)}if("string"==typeof e){const r=ha.fromSchema(t);return n.slice?r.parseSlice(Vh(e),n.parseOptions).content:r.parse(Vh(e),n.parseOptions)}return Kh("",t,n)}function qh(){return "undefined"!=typeof navigator&&/Mac/.test(navigator.platform)}function Uh(e,t,n={}){const{from:r,to:i,empty:o}=e.selection,s=t?uh(t,e.schema):null,a=[];e.doc.nodesBetween(r,i,((e,t)=>{if(e.isText)return;const n=Math.max(r,t),o=Math.min(i,t+e.nodeSize);a.push({node:e,from:n,to:o});}));const l=i-r,c=a.filter((e=>!s||s.name===e.node.type.name)).filter((e=>Lh(e.node.attrs,n,{strict:!1})));if(o)return !!c.length;return c.reduce(((e,t)=>e+t.to-t.from),0)>=l}function Wh(e,t){return t.nodes[e]?"node":t.marks[e]?"mark":null}function Gh(e,t){const n="string"==typeof t?[t]:t;return Object.keys(e).reduce(((t,r)=>(n.includes(r)||(t[r]=e[r]),t)),{})}function Jh(e,t,n={}){return Kh(e,t,{slice:!1,parseOptions:n})}function Zh(e,t){const n=Ih(t,e.schema),{from:r,to:i,empty:o}=e.selection,s=[];o?(e.storedMarks&&s.push(...e.storedMarks),s.push(...e.selection.$head.marks())):e.doc.nodesBetween(r,i,(e=>{s.push(...e.marks);}));const a=s.find((e=>e.type.name===n.name));return a?{...a.attrs}:{}}function Xh(e,t,n){return Object.fromEntries(Object.entries(n).filter((([n])=>{const r=e.find((e=>e.type===t&&e.name===n));return !!r&&r.attribute.keepOnSplit})))}function Qh(e,t){const n=e.storedMarks||e.selection.$to.parentOffset&&e.selection.$from.marks();if(n){const r=n.filter((e=>null==t?void 0:t.includes(e.type.name)));e.tr.ensureMarks(r);}}function Yh(e,t){for(let n=e.depth;n>0;n-=1){const r=e.node(n);if(t(r))return {pos:n>0?e.before(n):0,start:e.start(n),depth:n,node:r}}}function ep(e){return t=>Yh(t.$from,e)}function tp(e,t){const{nodeExtensions:n}=lh(t),r=n.find((t=>t.name===e));if(!r)return !1;const i=fh(ah(r,"group",{name:r.name,options:r.options,storage:r.storage}));return "string"==typeof i&&i.split(" ").includes("list")}const np=(e,t)=>{const n=ep((e=>e.type===t))(e.selection);if(!n)return !0;const r=e.doc.resolve(Math.max(0,n.pos-1)).before(n.depth);if(void 0===r)return !0;const i=e.doc.nodeAt(r);return n.node.type!==(null==i?void 0:i.type)||!qa(e.doc,n.pos)||(e.join(n.pos),!0)},rp=(e,t)=>{const n=ep((e=>e.type===t))(e.selection);if(!n)return !0;const r=e.doc.resolve(n.start).after(n.depth);if(void 0===r)return !0;const i=e.doc.nodeAt(r);return n.node.type!==(null==i?void 0:i.type)||!qa(e.doc,r)||(e.join(r),!0)};function ip(e,t,n={}){const{empty:r,ranges:i}=e.selection,o=t?Ih(t,e.schema):null;if(r)return !!(e.storedMarks||e.selection.$from.marks()).filter((e=>!o||o.name===e.type.name)).find((e=>Lh(e.attrs,n,{strict:!1})));let s=0;const a=[];if(i.forEach((({$from:t,$to:n})=>{const r=t.pos,i=n.pos;e.doc.nodesBetween(r,i,((e,t)=>{if(!e.isText&&!e.marks.length)return;const n=Math.max(r,t),o=Math.min(i,t+e.nodeSize);s+=o-n,a.push(...e.marks.map((e=>({mark:e,from:n,to:o}))));}));})),0===s)return !1;const l=a.filter((e=>!o||o.name===e.mark.type.name)).filter((e=>Lh(e.mark.attrs,n,{strict:!1}))).reduce(((e,t)=>e+t.to-t.from),0),c=a.filter((e=>!o||e.mark.type!==o&&e.mark.type.excludes(o))).reduce(((e,t)=>e+t.to-t.from),0);return (l>0?l+c:l)>=s}var op=Object.freeze({__proto__:null,blur:()=>({editor:e,view:t})=>(requestAnimationFrame((()=>{var n;e.isDestroyed||(t.dom.blur(),null===(n=null===window||void 0===window?void 0:window.getSelection())||void 0===n||n.removeAllRanges());})),!0),clearContent:(e=!1)=>({commands:t})=>t.setContent("",e),clearNodes:()=>({state:e,tr:t,dispatch:n})=>{const{selection:r}=t,{ranges:i}=r;return !n||(i.forEach((({$from:n,$to:r})=>{e.doc.nodesBetween(n.pos,r.pos,((e,n)=>{if(e.type.isText)return;const{doc:r,mapping:i}=t,o=r.resolve(i.map(n)),s=r.resolve(i.map(n+e.nodeSize)),a=o.blockRange(s);if(!a)return;const l=ja(a);if(e.type.isTextblock){const{defaultType:e}=o.parent.contentMatchAt(o.index());t.setNodeMarkup(a.start,e);}(l||0===l)&&t.lift(a,l);}));})),!0)},command:e=>t=>e(t),createParagraphNear:()=>({state:e,dispatch:t})=>((e,t)=>{let n=e.selection,{$from:r,$to:i}=n;if(n instanceof ml||r.parent.inlineContent||i.parent.inlineContent)return !1;let o=Xd(i.parent.contentMatchAt(i.indexAfter()));if(!o||!o.isTextblock)return !1;if(t){let n=(!r.parentOffset&&i.index()<i.parent.childCount?r:i).pos,s=e.tr.insert(n,o.createAndFill());s.setSelection(dl.create(s.doc,n+1)),t(s.scrollIntoView());}return !0})(e,t),deleteNode:e=>({tr:t,state:n,dispatch:r})=>{const i=uh(e,n.schema),o=t.selection.$anchor;for(let e=o.depth;e>0;e-=1){if(o.node(e).type===i){if(r){const n=o.before(e),r=o.after(e);t.delete(n,r).scrollIntoView();}return !0}}return !1},deleteRange:e=>({tr:t,dispatch:n})=>{const{from:r,to:i}=e;return n&&t.delete(r,i),!0},deleteSelection:()=>({state:e,dispatch:t})=>((e,t)=>!e.selection.empty&&(t&&t(e.tr.deleteSelection().scrollIntoView()),!0))(e,t),enter:()=>({commands:e})=>e.keyboardShortcut("Enter"),exitCode:()=>({state:e,dispatch:t})=>((e,t)=>{let{$head:n,$anchor:r}=e.selection;if(!n.parent.type.spec.code||!n.sameParent(r))return !1;let i=n.node(-1),o=n.indexAfter(-1),s=Xd(i.contentMatchAt(o));if(!s||!i.canReplaceWith(o,o,s))return !1;if(t){let r=n.after(),i=e.tr.replaceWith(r,r,s.createAndFill());i.setSelection(al.near(i.doc.resolve(r),1)),t(i.scrollIntoView());}return !0})(e,t),extendMarkRange:(e,t={})=>({tr:n,state:r,dispatch:i})=>{const o=Ih(e,r.schema),{doc:s,selection:a}=n,{$from:l,from:c,to:u}=a;if(i){const e=Bh(l,o,t);if(e&&e.from<=c&&e.to>=u){const t=dl.create(s,e.from,e.to);n.setSelection(t);}}return !0},first:e=>t=>{const n="function"==typeof e?e(t):e;for(let e=0;e<n.length;e+=1)if(n[e](t))return !0;return !1},focus:(e=null,t={})=>({editor:n,view:r,tr:i,dispatch:o})=>{t={scrollIntoView:!0,...t};const s=()=>{Hh()&&r.dom.focus(),requestAnimationFrame((()=>{n.isDestroyed||(r.focus(),(null==t?void 0:t.scrollIntoView)&&n.commands.scrollIntoView());}));};if(r.hasFocus()&&null===e||!1===e)return !0;if(o&&null===e&&!zh(n.state.selection))return s(),!0;const a=jh(i.doc,e)||n.state.selection,l=n.state.selection.eq(a);return o&&(l||i.setSelection(a),l&&i.storedMarks&&i.setStoredMarks(i.storedMarks),s()),!0},forEach:(e,t)=>n=>e.every(((e,r)=>t(e,{...n,index:r}))),insertContent:(e,t)=>({tr:n,commands:r})=>r.insertContentAt({from:n.selection.from,to:n.selection.to},e,t),insertContentAt:(e,t,n)=>({tr:r,dispatch:i,editor:o})=>{if(i){n={parseOptions:{},updateSelection:!0,...n};const i=Kh(t,o.schema,{parseOptions:{preserveWhitespace:"full",...n.parseOptions}});if("<>"===i.toString())return !0;let{from:s,to:a}="number"==typeof e?{from:e,to:e}:e,l=!0,c=!0;if((i.toString().startsWith("<")?i:[i]).forEach((e=>{e.check(),l=!!l&&(e.isText&&0===e.marks.length),c=!!c&&e.isBlock;})),s===a&&c){const{parent:e}=r.doc.resolve(s);e.isTextblock&&!e.type.spec.code&&!e.childCount&&(s-=1,a+=1);}l?r.insertText(t,s,a):r.replaceWith(s,a,i),n.updateSelection&&function(e,t,n){const r=e.steps.length-1;if(r<t)return;const i=e.steps[r];if(!(i instanceof Ia||i instanceof Pa))return;const o=e.mapping.maps[r];let s=0;o.forEach(((e,t,n,r)=>{0===s&&(s=r);})),e.setSelection(al.near(e.doc.resolve(s),n));}(r,r.steps.length-1,-1);}return !0},joinBackward:()=>({state:e,dispatch:t})=>((e,t,n)=>{let{$cursor:r}=e.selection;if(!r||(n?!n.endOfTextblock("backward",e):r.parentOffset>0))return !1;let i=Jd(r);if(!i){let n=r.blockRange(),i=n&&ja(n);return null!=i&&(t&&t(e.tr.lift(n,i).scrollIntoView()),!0)}let o=i.nodeBefore;if(!o.type.spec.isolating&&Qd(e,i,t))return !0;if(0==r.parent.content.size&&(Gd(o,"end")||pl.isSelectable(o))){let n=Wa(e.doc,r.before(),r.after(),Os.empty);if(n&&n.slice.size<n.to-n.from){if(t){let r=e.tr.step(n);r.setSelection(Gd(o,"end")?al.findFrom(r.doc.resolve(r.mapping.map(i.pos,-1)),-1):pl.create(r.doc,i.pos-o.nodeSize)),t(r.scrollIntoView());}return !0}}return !(!o.isAtom||i.depth!=r.depth-1||(t&&t(e.tr.delete(i.pos-o.nodeSize,i.pos).scrollIntoView()),0))})(e,t),joinForward:()=>({state:e,dispatch:t})=>((e,t,n)=>{let{$cursor:r}=e.selection;if(!r||(n?!n.endOfTextblock("forward",e):r.parentOffset<r.parent.content.size))return !1;let i=Zd(r);if(!i)return !1;let o=i.nodeAfter;if(Qd(e,i,t))return !0;if(0==r.parent.content.size&&(Gd(o,"start")||pl.isSelectable(o))){let n=Wa(e.doc,r.before(),r.after(),Os.empty);if(n&&n.slice.size<n.to-n.from){if(t){let r=e.tr.step(n);r.setSelection(Gd(o,"start")?al.findFrom(r.doc.resolve(r.mapping.map(i.pos)),1):pl.create(r.doc,r.mapping.map(i.pos))),t(r.scrollIntoView());}return !0}}return !(!o.isAtom||i.depth!=r.depth-1||(t&&t(e.tr.delete(i.pos,i.pos+o.nodeSize).scrollIntoView()),0))})(e,t),keyboardShortcut:e=>({editor:t,view:n,tr:r,dispatch:i})=>{const o=function(e){const t=e.split(/-(?!$)/);let n,r,i,o,s=t[t.length-1];"Space"===s&&(s=" ");for(let e=0;e<t.length-1;e+=1){const s=t[e];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))n=!0;else if(/^(c|ctrl|control)$/i.test(s))r=!0;else if(/^s(hift)?$/i.test(s))i=!0;else {if(!/^mod$/i.test(s))throw new Error(`Unrecognized modifier name: ${s}`);Hh()||qh()?o=!0:r=!0;}}return n&&(s=`Alt-${s}`),r&&(s=`Ctrl-${s}`),o&&(s=`Meta-${s}`),i&&(s=`Shift-${s}`),s}(e).split(/-(?!$)/),s=o.find((e=>!["Alt","Ctrl","Meta","Shift"].includes(e))),a=new KeyboardEvent("keydown",{key:"Space"===s?" ":s,altKey:o.includes("Alt"),ctrlKey:o.includes("Ctrl"),metaKey:o.includes("Meta"),shiftKey:o.includes("Shift"),bubbles:!0,cancelable:!0}),l=t.captureTransaction((()=>{n.someProp("handleKeyDown",(e=>e(n,a)));}));return null==l||l.steps.forEach((e=>{const t=e.map(r.mapping);t&&i&&r.maybeStep(t);})),!0},lift:(e,t={})=>({state:n,dispatch:r})=>!!Uh(n,uh(e,n.schema),t)&&((e,t)=>{let{$from:n,$to:r}=e.selection,i=n.blockRange(r),o=i&&ja(i);return null!=o&&(t&&t(e.tr.lift(i,o).scrollIntoView()),!0)})(n,r),liftEmptyBlock:()=>({state:e,dispatch:t})=>((e,t)=>{let{$cursor:n}=e.selection;if(!n||n.parent.content.size)return !1;if(n.depth>1&&n.after()!=n.end(-1)){let r=n.before();if(Ka(e.doc,r))return t&&t(e.tr.split(r).scrollIntoView()),!0}let r=n.blockRange(),i=r&&ja(r);return null!=i&&(t&&t(e.tr.lift(r,i).scrollIntoView()),!0)})(e,t),liftListItem:e=>({state:t,dispatch:n})=>ih(uh(e,t.schema))(t,n),newlineInCode:()=>({state:e,dispatch:t})=>((e,t)=>{let{$head:n,$anchor:r}=e.selection;return !(!n.parent.type.spec.code||!n.sameParent(r)||(t&&t(e.tr.insertText("\n").scrollIntoView()),0))})(e,t),resetAttributes:(e,t)=>({tr:n,state:r,dispatch:i})=>{let o=null,s=null;const a=Wh("string"==typeof e?e:e.name,r.schema);return !!a&&("node"===a&&(o=uh(e,r.schema)),"mark"===a&&(s=Ih(e,r.schema)),i&&n.selection.ranges.forEach((e=>{r.doc.nodesBetween(e.$from.pos,e.$to.pos,((e,r)=>{o&&o===e.type&&n.setNodeMarkup(r,void 0,Gh(e.attrs,t)),s&&e.marks.length&&e.marks.forEach((i=>{s===i.type&&n.addMark(r,r+e.nodeSize,s.create(Gh(i.attrs,t)));}));}));})),!0)},scrollIntoView:()=>({tr:e,dispatch:t})=>(t&&e.scrollIntoView(),!0),selectAll:()=>({tr:e,commands:t})=>t.setTextSelection({from:0,to:e.doc.content.size}),selectNodeBackward:()=>({state:e,dispatch:t})=>((e,t,n)=>{let{$head:r,empty:i}=e.selection,o=r;if(!i)return !1;if(r.parent.isTextblock){if(n?!n.endOfTextblock("backward",e):r.parentOffset>0)return !1;o=Jd(r);}let s=o&&o.nodeBefore;return !(!s||!pl.isSelectable(s)||(t&&t(e.tr.setSelection(pl.create(e.doc,o.pos-s.nodeSize)).scrollIntoView()),0))})(e,t),selectNodeForward:()=>({state:e,dispatch:t})=>((e,t,n)=>{let{$head:r,empty:i}=e.selection,o=r;if(!i)return !1;if(r.parent.isTextblock){if(n?!n.endOfTextblock("forward",e):r.parentOffset<r.parent.content.size)return !1;o=Zd(r);}let s=o&&o.nodeAfter;return !(!s||!pl.isSelectable(s)||(t&&t(e.tr.setSelection(pl.create(e.doc,o.pos)).scrollIntoView()),0))})(e,t),selectParentNode:()=>({state:e,dispatch:t})=>((e,t)=>{let n,{$from:r,to:i}=e.selection,o=r.sharedDepth(i);return 0!=o&&(n=r.before(o),t&&t(e.tr.setSelection(pl.create(e.doc,n))),!0)})(e,t),selectTextblockEnd:()=>({state:e,dispatch:t})=>th(e,t),selectTextblockStart:()=>({state:e,dispatch:t})=>eh(e,t),setContent:(e,t=!1,n={})=>({tr:r,editor:i,dispatch:o})=>{const{doc:s}=r,a=Jh(e,i.schema,n);return o&&r.replaceWith(0,s.content.size,a).setMeta("preventUpdate",!t),!0},setMark:(e,t={})=>({tr:n,state:r,dispatch:i})=>{const{selection:o}=n,{empty:s,ranges:a}=o,l=Ih(e,r.schema);if(i)if(s){const e=Zh(r,l);n.addStoredMark(l.create({...e,...t}));}else a.forEach((e=>{const i=e.$from.pos,o=e.$to.pos;r.doc.nodesBetween(i,o,((e,r)=>{const s=Math.max(r,i),a=Math.min(r+e.nodeSize,o);e.marks.find((e=>e.type===l))?e.marks.forEach((e=>{l===e.type&&n.addMark(s,a,l.create({...e.attrs,...t}));})):n.addMark(s,a,l.create(t));}));}));return !0},setMeta:(e,t)=>({tr:n})=>(n.setMeta(e,t),!0),setNode:(e,t={})=>({state:n,dispatch:r,chain:i})=>{const o=uh(e,n.schema);return o.isTextblock?i().command((({commands:e})=>!!nh(o,t)(n)||e.clearNodes())).command((({state:e})=>nh(o,t)(e,r))).run():(console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),!1)},setNodeSelection:e=>({tr:t,dispatch:n})=>{if(n){const{doc:n}=t,r=al.atStart(n).from,i=al.atEnd(n).to,o=$h(e,r,i),s=pl.create(n,o);t.setSelection(s);}return !0},setTextSelection:e=>({tr:t,dispatch:n})=>{if(n){const{doc:n}=t,{from:r,to:i}="number"==typeof e?{from:e,to:e}:e,o=dl.atStart(n).from,s=dl.atEnd(n).to,a=$h(r,o,s),l=$h(i,o,s),c=dl.create(n,a,l);t.setSelection(c);}return !0},sinkListItem:e=>({state:t,dispatch:n})=>{const r=uh(e,t.schema);return (i=r,function(e,t){let{$from:n,$to:r}=e.selection,o=n.blockRange(r,(e=>e.childCount>0&&e.firstChild.type==i));if(!o)return !1;let s=o.startIndex;if(0==s)return !1;let a=o.parent,l=a.child(s-1);if(l.type!=i)return !1;if(t){let n=l.lastChild&&l.lastChild.type==a.type,r=Cs.from(n?i.create():null),s=new Os(Cs.from(i.create(null,Cs.from(a.type.create(null,r)))),n?3:1,0),c=o.start,u=o.end;t(e.tr.step(new Pa(c-(n?3:1),u,c,u,s,1,!0)).scrollIntoView());}return !0})(t,n);var i;},splitBlock:({keepMarks:e=!0}={})=>({tr:t,state:n,dispatch:r,editor:i})=>{const{selection:o,doc:s}=t,{$from:a,$to:l}=o,c=Xh(i.extensionManager.attributes,a.node().type.name,a.node().attrs);if(o instanceof pl&&o.node.isBlock)return !(!a.parentOffset||!Ka(s,a.pos))&&(r&&(e&&Qh(n,i.extensionManager.splittableMarks),t.split(a.pos).scrollIntoView()),!0);if(!a.parent.isBlock)return !1;if(r){const r=l.parentOffset===l.parent.content.size;o instanceof dl&&t.deleteSelection();const s=0===a.depth?void 0:function(e){for(let t=0;t<e.edgeCount;t+=1){const{type:n}=e.edge(t);if(n.isTextblock&&!n.hasRequiredAttrs())return n}return null}(a.node(-1).contentMatchAt(a.indexAfter(-1)));let u=r&&s?[{type:s,attrs:c}]:void 0,d=Ka(t.doc,t.mapping.map(a.pos),1,u);if(u||d||!Ka(t.doc,t.mapping.map(a.pos),1,s?[{type:s}]:void 0)||(d=!0,u=s?[{type:s,attrs:c}]:void 0),d&&(t.split(t.mapping.map(a.pos),1,u),s&&!r&&!a.parentOffset&&a.parent.type!==s)){const e=t.mapping.map(a.before()),n=t.doc.resolve(e);a.node(-1).canReplaceWith(n.index(),n.index()+1,s)&&t.setNodeMarkup(t.mapping.map(a.before()),s);}e&&Qh(n,i.extensionManager.splittableMarks),t.scrollIntoView();}return !0},splitListItem:e=>({tr:t,state:n,dispatch:r,editor:i})=>{var o;const s=uh(e,n.schema),{$from:a,$to:l}=n.selection,c=n.selection.node;if(c&&c.isBlock||a.depth<2||!a.sameParent(l))return !1;const u=a.node(-1);if(u.type!==s)return !1;const d=i.extensionManager.attributes;if(0===a.parent.content.size&&a.node(-1).childCount===a.indexAfter(-1)){if(2===a.depth||a.node(-3).type!==s||a.index(-2)!==a.node(-2).childCount-1)return !1;if(r){let e=Cs.empty;const n=a.index(-1)?1:a.index(-2)?2:3;for(let t=a.depth-n;t>=a.depth-3;t-=1)e=Cs.from(a.node(t).copy(e));const r=a.indexAfter(-1)<a.node(-2).childCount?1:a.indexAfter(-2)<a.node(-3).childCount?2:3,i=Xh(d,a.node().type.name,a.node().attrs),l=(null===(o=s.contentMatch.defaultType)||void 0===o?void 0:o.createAndFill(i))||void 0;e=e.append(Cs.from(s.createAndFill(null,l)||void 0));const c=a.before(a.depth-(n-1));t.replace(c,a.after(-r),new Os(e,4-n,0));let u=-1;t.doc.nodesBetween(c,t.doc.content.size,((e,t)=>{if(u>-1)return !1;e.isTextblock&&0===e.content.size&&(u=t+1);})),u>-1&&t.setSelection(dl.near(t.doc.resolve(u))),t.scrollIntoView();}return !0}const h=l.pos===a.end()?u.contentMatchAt(0).defaultType:null,p=Xh(d,u.type.name,u.attrs),f=Xh(d,a.node().type.name,a.node().attrs);t.delete(a.pos,l.pos);const m=h?[{type:s,attrs:p},{type:h,attrs:f}]:[{type:s,attrs:p}];return !!Ka(t.doc,a.pos,2)&&(r&&t.split(a.pos,2,m).scrollIntoView(),!0)},toggleList:(e,t)=>({editor:n,tr:r,state:i,dispatch:o,chain:s,commands:a,can:l})=>{const{extensions:c}=n.extensionManager,u=uh(e,i.schema),d=uh(t,i.schema),{selection:h}=i,{$from:p,$to:f}=h,m=p.blockRange(f);if(!m)return !1;const g=ep((e=>tp(e.type.name,c)))(h);if(m.depth>=1&&g&&m.depth-g.depth<=1){if(g.node.type===u)return a.liftListItem(d);if(tp(g.node.type.name,c)&&u.validContent(g.node.content)&&o)return s().command((()=>(r.setNodeMarkup(g.pos,u),!0))).command((()=>np(r,u))).command((()=>rp(r,u))).run()}return s().command((()=>!!l().wrapInList(u)||a.clearNodes())).wrapInList(u).command((()=>np(r,u))).command((()=>rp(r,u))).run()},toggleMark:(e,t={},n={})=>({state:r,commands:i})=>{const{extendEmptyMarkRange:o=!1}=n,s=Ih(e,r.schema);return ip(r,s,t)?i.unsetMark(s,{extendEmptyMarkRange:o}):i.setMark(s,t)},toggleNode:(e,t,n={})=>({state:r,commands:i})=>{const o=uh(e,r.schema),s=uh(t,r.schema);return Uh(r,o,n)?i.setNode(s):i.setNode(o,n)},toggleWrap:(e,t={})=>({state:n,commands:r})=>{const i=uh(e,n.schema);return Uh(n,i,t)?r.lift(i):r.wrapIn(i,t)},undoInputRule:()=>({state:e,dispatch:t})=>{const n=e.plugins;for(let r=0;r<n.length;r+=1){const i=n[r];let o;if(i.spec.isInputRules&&(o=i.getState(e))){if(t){const t=e.tr,n=o.transform;for(let e=n.steps.length-1;e>=0;e-=1)t.step(n.steps[e].invert(n.docs[e]));if(o.text){const n=t.doc.resolve(o.from).marks();t.replaceWith(o.from,o.to,e.schema.text(o.text,n));}else t.delete(o.from,o.to);}return !0}}return !1},unsetAllMarks:()=>({tr:e,dispatch:t})=>{const{selection:n}=e,{empty:r,ranges:i}=n;return r||t&&i.forEach((t=>{e.removeMark(t.$from.pos,t.$to.pos);})),!0},unsetMark:(e,t={})=>({tr:n,state:r,dispatch:i})=>{var o;const{extendEmptyMarkRange:s=!1}=t,{selection:a}=n,l=Ih(e,r.schema),{$from:c,empty:u,ranges:d}=a;if(!i)return !0;if(u&&s){let{from:e,to:t}=a;const r=null===(o=c.marks().find((e=>e.type===l)))||void 0===o?void 0:o.attrs,i=Bh(c,l,r);i&&(e=i.from,t=i.to),n.removeMark(e,t,l);}else d.forEach((e=>{n.removeMark(e.$from.pos,e.$to.pos,l);}));return n.removeStoredMark(l),!0},updateAttributes:(e,t={})=>({tr:n,state:r,dispatch:i})=>{let o=null,s=null;const a=Wh("string"==typeof e?e:e.name,r.schema);return !!a&&("node"===a&&(o=uh(e,r.schema)),"mark"===a&&(s=Ih(e,r.schema)),i&&n.selection.ranges.forEach((e=>{const i=e.$from.pos,a=e.$to.pos;r.doc.nodesBetween(i,a,((e,r)=>{o&&o===e.type&&n.setNodeMarkup(r,void 0,{...e.attrs,...t}),s&&e.marks.length&&e.marks.forEach((o=>{if(s===o.type){const l=Math.max(r,i),c=Math.min(r+e.nodeSize,a);n.addMark(l,c,s.create({...o.attrs,...t}));}}));}));})),!0)},wrapIn:(e,t={})=>({state:n,dispatch:r})=>function(e,t=null){return function(n,r){let{$from:i,$to:o}=n.selection,s=i.blockRange(o),a=s&&Ha(s,e,t);return !!a&&(r&&r(n.tr.wrap(s,a).scrollIntoView()),!0)}}(uh(e,n.schema),t)(n,r),wrapInList:(e,t={})=>({state:n,dispatch:r})=>rh(uh(e,n.schema),t)(n,r)});const sp=Ah.create({name:"commands",addCommands:()=>({...op})}),ap=Ah.create({name:"editable",addProseMirrorPlugins(){return [new Dl({key:new Al("editable"),props:{editable:()=>this.editor.options.editable}})]}}),lp=Ah.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:e}=this;return [new Dl({key:new Al("focusEvents"),props:{handleDOMEvents:{focus:(t,n)=>{e.isFocused=!0;const r=e.state.tr.setMeta("focus",{event:n}).setMeta("addToHistory",!1);return t.dispatch(r),!1},blur:(t,n)=>{e.isFocused=!1;const r=e.state.tr.setMeta("blur",{event:n}).setMeta("addToHistory",!1);return t.dispatch(r),!1}}}})]}}),cp=Ah.create({name:"keymap",addKeyboardShortcuts(){const e=()=>this.editor.commands.first((({commands:e})=>[()=>e.undoInputRule(),()=>e.command((({tr:t})=>{const{selection:n,doc:r}=t,{empty:i,$anchor:o}=n,{pos:s,parent:a}=o,l=al.atStart(r).from===s;return !(!(i&&l&&a.type.isTextblock)||a.textContent.length)&&e.clearNodes()})),()=>e.deleteSelection(),()=>e.joinBackward(),()=>e.selectNodeBackward()])),t=()=>this.editor.commands.first((({commands:e})=>[()=>e.deleteSelection(),()=>e.joinForward(),()=>e.selectNodeForward()])),n={Enter:()=>this.editor.commands.first((({commands:e})=>[()=>e.newlineInCode(),()=>e.createParagraphNear(),()=>e.liftEmptyBlock(),()=>e.splitBlock()])),"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:e,"Mod-Backspace":e,"Shift-Backspace":e,Delete:t,"Mod-Delete":t,"Mod-a":()=>this.editor.commands.selectAll()},r={...n},i={...n,"Ctrl-h":e,"Alt-Backspace":e,"Ctrl-d":t,"Ctrl-Alt-Backspace":t,"Alt-Delete":t,"Alt-d":t,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return Hh()||qh()?i:r},addProseMirrorPlugins(){return [new Dl({key:new Al("clearDocument"),appendTransaction:(e,t,n)=>{if(!(e.some((e=>e.docChanged))&&!t.doc.eq(n.doc)))return;const{empty:r,from:i,to:o}=t.selection,s=al.atStart(t.doc).from,a=al.atEnd(t.doc).to,l=i===s&&o===a,c=0===n.doc.textBetween(0,n.doc.content.size," "," ").length;if(r||!l||!c)return;const u=n.tr,d=oh({state:n,transaction:u}),{commands:h}=new sh({editor:this.editor,state:d});return h.clearNodes(),u.steps.length?u:void 0}})]}}),up=Ah.create({name:"tabindex",addProseMirrorPlugins(){return [new Dl({key:new Al("tabindex"),props:{attributes:this.editor.isEditable?{tabindex:"0"}:{}}})]}});var dp=Object.freeze({__proto__:null,ClipboardTextSerializer:Th,Commands:sp,Editable:ap,FocusEvents:lp,Keymap:cp,Tabindex:up});function hp(e,t){const n=Wh("string"==typeof t?t:t.name,e.schema);return "node"===n?function(e,t){const n=uh(t,e.schema),{from:r,to:i}=e.selection,o=[];e.doc.nodesBetween(r,i,(e=>{o.push(e);}));const s=o.reverse().find((e=>e.type.name===n.name));return s?{...s.attrs}:{}}(e,t):"mark"===n?Zh(e,t):{}}function pp(e,t){const n=[];return e.descendants(((e,r)=>{t(e)&&n.push({node:e,pos:r});})),n}function fp(e){const t=function(e,t=JSON.stringify){const n={};return e.filter((e=>{const r=t(e);return !Object.prototype.hasOwnProperty.call(n,r)&&(n[r]=!0)}))}(e);return 1===t.length?t:t.filter(((e,n)=>{const r=t.filter(((e,t)=>t!==n));return !r.some((t=>e.oldRange.from>=t.oldRange.from&&e.oldRange.to<=t.oldRange.to&&e.newRange.from>=t.newRange.from&&e.newRange.to<=t.newRange.to))}))}function mp(e,t,n){const r=[];return e===t?n.resolve(e).marks().forEach((t=>{const i=Bh(n.resolve(e-1),t.type);i&&r.push({mark:t,...i});})):n.nodesBetween(e,t,((e,t)=>{r.push(...e.marks.map((n=>({from:t,to:t+e.nodeSize,mark:n}))));})),r}function gp(e){return Ph(e)&&e instanceof pl}function vp(e,t,n){const r=e.state.doc.content.size,i=$h(t,0,r),o=$h(n,0,r),s=e.coordsAtPos(i),a=e.coordsAtPos(o,-1),l=Math.min(s.top,a.top),c=Math.max(s.bottom,a.bottom),u=Math.min(s.left,a.left),d=Math.max(s.right,a.right),h={top:l,bottom:c,left:u,right:d,width:d-u,height:c-l,x:u,y:l};return {...h,toJSON:()=>h}}function yp(e){return new wh({find:e.find,handler:({state:t,range:n,match:r})=>{const i=fh(e.getAttributes,void 0,r);if(!1===i||null===i)return null;const{tr:o}=t,s=r[r.length-1],a=r[0];let l=n.to;if(s){const r=a.search(/\S/),c=n.from+a.indexOf(s),u=c+s.length;if(mp(n.from,n.to,t.doc).filter((t=>t.mark.type.excluded.find((n=>n===e.type&&n!==t.mark.type)))).filter((e=>e.to>c)).length)return null;u<n.to&&o.delete(u,n.to),c>n.from&&o.delete(n.from+r,c),l=n.from+r+s.length,o.addMark(n.from+r,l,e.type.create(i||{})),o.removeStoredMark(e.type);}}})}function bp(e){return new wh({find:e.find,handler:({state:t,range:n,match:r})=>{const i=fh(e.getAttributes,void 0,r)||{},{tr:o}=t,s=n.from;let a=n.to;if(r[1]){let t=s+r[0].lastIndexOf(r[1]);t>a?t=a:a=t+r[1].length;const n=r[0][r[0].length-1];o.insertText(n,s+r[0].length-1),o.replaceWith(t,a,e.type.create(i));}else r[0]&&o.replaceWith(s,a,e.type.create(i));}})}function wp(e){return new wh({find:e.find,handler:({state:t,range:n,match:r})=>{const i=t.doc.resolve(n.from),o=fh(e.getAttributes,void 0,r)||{};if(!i.node(-1).canReplaceWith(i.index(-1),i.indexAfter(-1),e.type))return null;t.tr.delete(n.from,n.to).setBlockType(n.from,n.from,e.type,o);}})}function kp(e){return new wh({find:e.find,handler:({state:t,range:n,match:r})=>{let i=e.replace,o=n.from;const s=n.to;if(r[1]){const e=r[0].lastIndexOf(r[1]);i+=r[0].slice(e+r[1].length),o+=e;const t=o-s;t>0&&(i=r[0].slice(e-t,e)+i,o=s);}t.tr.insertText(i,o,s);}})}function Cp(e){return new wh({find:e.find,handler:({state:t,range:n,match:r})=>{const i=fh(e.getAttributes,void 0,r)||{},o=t.tr.delete(n.from,n.to),s=o.doc.resolve(n.from).blockRange(),a=s&&Ha(s,e.type,i);if(!a)return null;o.wrap(s,a);const l=o.doc.resolve(n.from-1).nodeBefore;l&&l.type===e.type&&qa(o.doc,n.from-1)&&(!e.joinPredicate||e.joinPredicate(r,l))&&o.join(n.from-1);}})}class Ep{constructor(e={}){this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...e},this.name=this.config.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=fh(ah(this,"addOptions",{name:this.name}))),this.storage=fh(ah(this,"addStorage",{name:this.name,options:this.options}))||{};}static create(e={}){return new Ep(e)}configure(e={}){const t=this.extend();return t.options=Oh(this.options,e),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}extend(e={}){const t=new Ep(e);return t.parent=this,this.child=t,t.name=e.name?e.name:t.parent.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),t.options=fh(ah(t,"addOptions",{name:t.name})),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}}class xp{constructor(e={}){this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...e},this.name=this.config.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),this.options=this.config.defaultOptions,this.config.addOptions&&(this.options=fh(ah(this,"addOptions",{name:this.name}))),this.storage=fh(ah(this,"addStorage",{name:this.name,options:this.options}))||{};}static create(e={}){return new xp(e)}configure(e={}){const t=this.extend();return t.options=Oh(this.options,e),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}extend(e={}){const t=new xp(e);return t.parent=this,this.child=t,t.name=e.name?e.name:t.parent.name,e.defaultOptions&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`),t.options=fh(ah(t,"addOptions",{name:t.name})),t.storage=fh(ah(t,"addStorage",{name:t.name,options:t.options})),t}}function Sp(e){return new Eh({find:e.find,handler:({state:t,range:n,match:r})=>{const i=fh(e.getAttributes,void 0,r);if(!1===i||null===i)return null;const{tr:o}=t,s=r[r.length-1],a=r[0];let l=n.to;if(s){const r=a.search(/\S/),c=n.from+a.indexOf(s),u=c+s.length;if(mp(n.from,n.to,t.doc).filter((t=>t.mark.type.excluded.find((n=>n===e.type&&n!==t.mark.type)))).filter((e=>e.to>c)).length)return null;u<n.to&&o.delete(u,n.to),c>n.from&&o.delete(n.from+r,c),l=n.from+r+s.length,o.addMark(n.from+r,l,e.type.create(i||{})),o.removeStoredMark(e.type);}}})}var Dp="top",Mp="bottom",Op="right",Ap="left",Np=[Dp,Mp,Op,Ap],_p=Np.reduce((function(e,t){return e.concat([t+"-start",t+"-end"])}),[]),Tp=[].concat(Np,["auto"]).reduce((function(e,t){return e.concat([t,t+"-start",t+"-end"])}),[]),Lp=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function Rp(e){return e?(e.nodeName||"").toLowerCase():null}function Fp(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function Bp(e){return e instanceof Fp(e).Element||e instanceof Element}function Ip(e){return e instanceof Fp(e).HTMLElement||e instanceof HTMLElement}function Pp(e){return "undefined"!=typeof ShadowRoot&&(e instanceof Fp(e).ShadowRoot||e instanceof ShadowRoot)}var zp={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},i=t.elements[e];Ip(i)&&Rp(i)&&(Object.assign(i.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?i.removeAttribute(e):i.setAttribute(e,!0===t?"":t);})));}));},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],i=t.attributes[e]||{},o=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});Ip(r)&&Rp(r)&&(Object.assign(r.style,o),Object.keys(i).forEach((function(e){r.removeAttribute(e);})));}));}},requires:["computeStyles"]};function $p(e){return e.split("-")[0]}var jp=Math.max,Hp=Math.min,Vp=Math.round;function Kp(e,t){void 0===t&&(t=!1);var n=e.getBoundingClientRect(),r=1,i=1;if(Ip(e)&&t){var o=e.offsetHeight,s=e.offsetWidth;s>0&&(r=Vp(n.width)/s||1),o>0&&(i=Vp(n.height)/o||1);}return {width:n.width/r,height:n.height/i,top:n.top/i,right:n.right/r,bottom:n.bottom/i,left:n.left/r,x:n.left/r,y:n.top/i}}function qp(e){var t=Kp(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function Up(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return !0;if(n&&Pp(n)){var r=t;do{if(r&&e.isSameNode(r))return !0;r=r.parentNode||r.host;}while(r)}return !1}function Wp(e){return Fp(e).getComputedStyle(e)}function Gp(e){return ["table","td","th"].indexOf(Rp(e))>=0}function Jp(e){return ((Bp(e)?e.ownerDocument:e.document)||window.document).documentElement}function Zp(e){return "html"===Rp(e)?e:e.assignedSlot||e.parentNode||(Pp(e)?e.host:null)||Jp(e)}function Xp(e){return Ip(e)&&"fixed"!==Wp(e).position?e.offsetParent:null}function Qp(e){for(var t=Fp(e),n=Xp(e);n&&Gp(n)&&"static"===Wp(n).position;)n=Xp(n);return n&&("html"===Rp(n)||"body"===Rp(n)&&"static"===Wp(n).position)?t:n||function(e){var t=-1!==navigator.userAgent.toLowerCase().indexOf("firefox");if(-1!==navigator.userAgent.indexOf("Trident")&&Ip(e)&&"fixed"===Wp(e).position)return null;var n=Zp(e);for(Pp(n)&&(n=n.host);Ip(n)&&["html","body"].indexOf(Rp(n))<0;){var r=Wp(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode;}return null}(e)||t}function Yp(e){return ["top","bottom"].indexOf(e)>=0?"x":"y"}function ef(e,t,n){return jp(e,Hp(t,n))}function tf(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function nf(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}var rf={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,i=e.options,o=n.elements.arrow,s=n.modifiersData.popperOffsets,a=$p(n.placement),l=Yp(a),c=[Ap,Op].indexOf(a)>=0?"height":"width";if(o&&s){var u=function(e,t){return tf("number"!=typeof(e="function"==typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:nf(e,Np))}(i.padding,n),d=qp(o),h="y"===l?Dp:Ap,p="y"===l?Mp:Op,f=n.rects.reference[c]+n.rects.reference[l]-s[l]-n.rects.popper[c],m=s[l]-n.rects.reference[l],g=Qp(o),v=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,y=f/2-m/2,b=u[h],w=v-d[c]-u[p],k=v/2-d[c]/2+y,C=ef(b,k,w),E=l;n.modifiersData[r]=((t={})[E]=C,t.centerOffset=C-k,t);}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!=typeof r||(r=t.elements.popper.querySelector(r)))&&Up(t.elements.popper,r)&&(t.elements.arrow=r);},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function of(e){return e.split("-")[1]}var sf={top:"auto",right:"auto",bottom:"auto",left:"auto"};function af(e){var t,n=e.popper,r=e.popperRect,i=e.placement,o=e.variation,s=e.offsets,a=e.position,l=e.gpuAcceleration,c=e.adaptive,u=e.roundOffsets,d=e.isFixed,h=s.x,p=void 0===h?0:h,f=s.y,m=void 0===f?0:f,g="function"==typeof u?u({x:p,y:m}):{x:p,y:m};p=g.x,m=g.y;var v=s.hasOwnProperty("x"),y=s.hasOwnProperty("y"),b=Ap,w=Dp,k=window;if(c){var C=Qp(n),E="clientHeight",x="clientWidth";if(C===Fp(n)&&"static"!==Wp(C=Jp(n)).position&&"absolute"===a&&(E="scrollHeight",x="scrollWidth"),i===Dp||(i===Ap||i===Op)&&"end"===o)w=Mp,m-=(d&&C===k&&k.visualViewport?k.visualViewport.height:C[E])-r.height,m*=l?1:-1;if(i===Ap||(i===Dp||i===Mp)&&"end"===o)b=Op,p-=(d&&C===k&&k.visualViewport?k.visualViewport.width:C[x])-r.width,p*=l?1:-1;}var S,D=Object.assign({position:a},c&&sf),M=!0===u?function(e){var t=e.x,n=e.y,r=window.devicePixelRatio||1;return {x:Vp(t*r)/r||0,y:Vp(n*r)/r||0}}({x:p,y:m}):{x:p,y:m};return p=M.x,m=M.y,l?Object.assign({},D,((S={})[w]=y?"0":"",S[b]=v?"0":"",S.transform=(k.devicePixelRatio||1)<=1?"translate("+p+"px, "+m+"px)":"translate3d("+p+"px, "+m+"px, 0)",S)):Object.assign({},D,((t={})[w]=y?m+"px":"",t[b]=v?p+"px":"",t.transform="",t))}var lf={passive:!0};var cf={left:"right",right:"left",bottom:"top",top:"bottom"};function uf(e){return e.replace(/left|right|bottom|top/g,(function(e){return cf[e]}))}var df={start:"end",end:"start"};function hf(e){return e.replace(/start|end/g,(function(e){return df[e]}))}function pf(e){var t=Fp(e);return {scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function ff(e){return Kp(Jp(e)).left+pf(e).scrollLeft}function mf(e){var t=Wp(e),n=t.overflow,r=t.overflowX,i=t.overflowY;return /auto|scroll|overlay|hidden/.test(n+i+r)}function gf(e){return ["html","body","#document"].indexOf(Rp(e))>=0?e.ownerDocument.body:Ip(e)&&mf(e)?e:gf(Zp(e))}function vf(e,t){var n;void 0===t&&(t=[]);var r=gf(e),i=r===(null==(n=e.ownerDocument)?void 0:n.body),o=Fp(r),s=i?[o].concat(o.visualViewport||[],mf(r)?r:[]):r,a=t.concat(s);return i?a:a.concat(vf(Zp(s)))}function yf(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function bf(e,t){return "viewport"===t?yf(function(e){var t=Fp(e),n=Jp(e),r=t.visualViewport,i=n.clientWidth,o=n.clientHeight,s=0,a=0;return r&&(i=r.width,o=r.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(s=r.offsetLeft,a=r.offsetTop)),{width:i,height:o,x:s+ff(e),y:a}}(e)):Bp(t)?function(e){var t=Kp(e);return t.top=t.top+e.clientTop,t.left=t.left+e.clientLeft,t.bottom=t.top+e.clientHeight,t.right=t.left+e.clientWidth,t.width=e.clientWidth,t.height=e.clientHeight,t.x=t.left,t.y=t.top,t}(t):yf(function(e){var t,n=Jp(e),r=pf(e),i=null==(t=e.ownerDocument)?void 0:t.body,o=jp(n.scrollWidth,n.clientWidth,i?i.scrollWidth:0,i?i.clientWidth:0),s=jp(n.scrollHeight,n.clientHeight,i?i.scrollHeight:0,i?i.clientHeight:0),a=-r.scrollLeft+ff(e),l=-r.scrollTop;return "rtl"===Wp(i||n).direction&&(a+=jp(n.clientWidth,i?i.clientWidth:0)-o),{width:o,height:s,x:a,y:l}}(Jp(e)))}function wf(e,t,n){var r="clippingParents"===t?function(e){var t=vf(Zp(e)),n=["absolute","fixed"].indexOf(Wp(e).position)>=0&&Ip(e)?Qp(e):e;return Bp(n)?t.filter((function(e){return Bp(e)&&Up(e,n)&&"body"!==Rp(e)})):[]}(e):[].concat(t),i=[].concat(r,[n]),o=i[0],s=i.reduce((function(t,n){var r=bf(e,n);return t.top=jp(r.top,t.top),t.right=Hp(r.right,t.right),t.bottom=Hp(r.bottom,t.bottom),t.left=jp(r.left,t.left),t}),bf(e,o));return s.width=s.right-s.left,s.height=s.bottom-s.top,s.x=s.left,s.y=s.top,s}function kf(e){var t,n=e.reference,r=e.element,i=e.placement,o=i?$p(i):null,s=i?of(i):null,a=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2;switch(o){case Dp:t={x:a,y:n.y-r.height};break;case Mp:t={x:a,y:n.y+n.height};break;case Op:t={x:n.x+n.width,y:l};break;case Ap:t={x:n.x-r.width,y:l};break;default:t={x:n.x,y:n.y};}var c=o?Yp(o):null;if(null!=c){var u="y"===c?"height":"width";switch(s){case"start":t[c]=t[c]-(n[u]/2-r[u]/2);break;case"end":t[c]=t[c]+(n[u]/2-r[u]/2);}}return t}function Cf(e,t){void 0===t&&(t={});var n=t,r=n.placement,i=void 0===r?e.placement:r,o=n.boundary,s=void 0===o?"clippingParents":o,a=n.rootBoundary,l=void 0===a?"viewport":a,c=n.elementContext,u=void 0===c?"popper":c,d=n.altBoundary,h=void 0!==d&&d,p=n.padding,f=void 0===p?0:p,m=tf("number"!=typeof f?f:nf(f,Np)),g="popper"===u?"reference":"popper",v=e.rects.popper,y=e.elements[h?g:u],b=wf(Bp(y)?y:y.contextElement||Jp(e.elements.popper),s,l),w=Kp(e.elements.reference),k=kf({reference:w,element:v,strategy:"absolute",placement:i}),C=yf(Object.assign({},v,k)),E="popper"===u?C:w,x={top:b.top-E.top+m.top,bottom:E.bottom-b.bottom+m.bottom,left:b.left-E.left+m.left,right:E.right-b.right+m.right},S=e.modifiersData.offset;if("popper"===u&&S){var D=S[i];Object.keys(x).forEach((function(e){var t=[Op,Mp].indexOf(e)>=0?1:-1,n=[Dp,Mp].indexOf(e)>=0?"y":"x";x[e]+=D[n]*t;}));}return x}function Ef(e,t){void 0===t&&(t={});var n=t,r=n.placement,i=n.boundary,o=n.rootBoundary,s=n.padding,a=n.flipVariations,l=n.allowedAutoPlacements,c=void 0===l?Tp:l,u=of(r),d=u?a?_p:_p.filter((function(e){return of(e)===u})):Np,h=d.filter((function(e){return c.indexOf(e)>=0}));0===h.length&&(h=d);var p=h.reduce((function(t,n){return t[n]=Cf(e,{placement:n,boundary:i,rootBoundary:o,padding:s})[$p(n)],t}),{});return Object.keys(p).sort((function(e,t){return p[e]-p[t]}))}var xf={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var i=n.mainAxis,o=void 0===i||i,s=n.altAxis,a=void 0===s||s,l=n.fallbackPlacements,c=n.padding,u=n.boundary,d=n.rootBoundary,h=n.altBoundary,p=n.flipVariations,f=void 0===p||p,m=n.allowedAutoPlacements,g=t.options.placement,v=$p(g),y=l||(v===g||!f?[uf(g)]:function(e){if("auto"===$p(e))return [];var t=uf(e);return [hf(e),t,hf(t)]}(g)),b=[g].concat(y).reduce((function(e,n){return e.concat("auto"===$p(n)?Ef(t,{placement:n,boundary:u,rootBoundary:d,padding:c,flipVariations:f,allowedAutoPlacements:m}):n)}),[]),w=t.rects.reference,k=t.rects.popper,C=new Map,E=!0,x=b[0],S=0;S<b.length;S++){var D=b[S],M=$p(D),O="start"===of(D),A=[Dp,Mp].indexOf(M)>=0,N=A?"width":"height",_=Cf(t,{placement:D,boundary:u,rootBoundary:d,altBoundary:h,padding:c}),T=A?O?Op:Ap:O?Mp:Dp;w[N]>k[N]&&(T=uf(T));var L=uf(T),R=[];if(o&&R.push(_[M]<=0),a&&R.push(_[T]<=0,_[L]<=0),R.every((function(e){return e}))){x=D,E=!1;break}C.set(D,R);}if(E)for(var F=function(e){var t=b.find((function(t){var n=C.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return x=t,"break"},B=f?3:1;B>0;B--){if("break"===F(B))break}t.placement!==x&&(t.modifiersData[r]._skip=!0,t.placement=x,t.reset=!0);}},requiresIfExists:["offset"],data:{_skip:!1}};function Sf(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function Df(e){return [Dp,Op,Mp,Ap].some((function(t){return e[t]>=0}))}var Mf={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,i=n.offset,o=void 0===i?[0,0]:i,s=Tp.reduce((function(e,n){return e[n]=function(e,t,n){var r=$p(e),i=[Ap,Dp].indexOf(r)>=0?-1:1,o="function"==typeof n?n(Object.assign({},t,{placement:e})):n,s=o[0],a=o[1];return s=s||0,a=(a||0)*i,[Ap,Op].indexOf(r)>=0?{x:a,y:s}:{x:s,y:a}}(n,t.rects,o),e}),{}),a=s[t.placement],l=a.x,c=a.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=c),t.modifiersData[r]=s;}};var Of={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,i=n.mainAxis,o=void 0===i||i,s=n.altAxis,a=void 0!==s&&s,l=n.boundary,c=n.rootBoundary,u=n.altBoundary,d=n.padding,h=n.tether,p=void 0===h||h,f=n.tetherOffset,m=void 0===f?0:f,g=Cf(t,{boundary:l,rootBoundary:c,padding:d,altBoundary:u}),v=$p(t.placement),y=of(t.placement),b=!y,w=Yp(v),k="x"===w?"y":"x",C=t.modifiersData.popperOffsets,E=t.rects.reference,x=t.rects.popper,S="function"==typeof m?m(Object.assign({},t.rects,{placement:t.placement})):m,D="number"==typeof S?{mainAxis:S,altAxis:S}:Object.assign({mainAxis:0,altAxis:0},S),M=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,O={x:0,y:0};if(C){if(o){var A,N="y"===w?Dp:Ap,_="y"===w?Mp:Op,T="y"===w?"height":"width",L=C[w],R=L+g[N],F=L-g[_],B=p?-x[T]/2:0,I="start"===y?E[T]:x[T],P="start"===y?-x[T]:-E[T],z=t.elements.arrow,$=p&&z?qp(z):{width:0,height:0},j=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},H=j[N],V=j[_],K=ef(0,E[T],$[T]),q=b?E[T]/2-B-K-H-D.mainAxis:I-K-H-D.mainAxis,U=b?-E[T]/2+B+K+V+D.mainAxis:P+K+V+D.mainAxis,W=t.elements.arrow&&Qp(t.elements.arrow),G=W?"y"===w?W.clientTop||0:W.clientLeft||0:0,J=null!=(A=null==M?void 0:M[w])?A:0,Z=L+U-J,X=ef(p?Hp(R,L+q-J-G):R,L,p?jp(F,Z):F);C[w]=X,O[w]=X-L;}if(a){var Q,Y="x"===w?Dp:Ap,ee="x"===w?Mp:Op,te=C[k],ne="y"===k?"height":"width",re=te+g[Y],ie=te-g[ee],oe=-1!==[Dp,Ap].indexOf(v),se=null!=(Q=null==M?void 0:M[k])?Q:0,ae=oe?re:te-E[ne]-x[ne]-se+D.altAxis,le=oe?te+E[ne]+x[ne]-se-D.altAxis:ie,ce=p&&oe?function(e,t,n){var r=ef(e,t,n);return r>n?n:r}(ae,te,le):ef(p?ae:re,te,p?le:ie);C[k]=ce,O[k]=ce-te;}t.modifiersData[r]=O;}},requiresIfExists:["offset"]};function Af(e,t,n){void 0===n&&(n=!1);var r,i,o=Ip(t),s=Ip(t)&&function(e){var t=e.getBoundingClientRect(),n=Vp(t.width)/e.offsetWidth||1,r=Vp(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(t),a=Jp(t),l=Kp(e,s),c={scrollLeft:0,scrollTop:0},u={x:0,y:0};return (o||!o&&!n)&&(("body"!==Rp(t)||mf(a))&&(c=(r=t)!==Fp(r)&&Ip(r)?{scrollLeft:(i=r).scrollLeft,scrollTop:i.scrollTop}:pf(r)),Ip(t)?((u=Kp(t,!0)).x+=t.clientLeft,u.y+=t.clientTop):a&&(u.x=ff(a))),{x:l.left+c.scrollLeft-u.x,y:l.top+c.scrollTop-u.y,width:l.width,height:l.height}}function Nf(e){var t=new Map,n=new Set,r=[];function i(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&i(r);}})),r.push(e);}return e.forEach((function(e){t.set(e.name,e);})),e.forEach((function(e){n.has(e.name)||i(e);})),r}var _f={placement:"bottom",modifiers:[],strategy:"absolute"};function Tf(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return !t.some((function(e){return !(e&&"function"==typeof e.getBoundingClientRect)}))}function Lf(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,i=t.defaultOptions,o=void 0===i?_f:i;return function(e,t,n){void 0===n&&(n=o);var i,s,a={placement:"bottom",orderedModifiers:[],options:Object.assign({},_f,o),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},l=[],c=!1,u={state:a,setOptions:function(n){var i="function"==typeof n?n(a.options):n;d(),a.options=Object.assign({},o,a.options,i),a.scrollParents={reference:Bp(e)?vf(e):e.contextElement?vf(e.contextElement):[],popper:vf(t)};var s=function(e){var t=Nf(e);return Lp.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{});return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,a.options.modifiers)));return a.orderedModifiers=s.filter((function(e){return e.enabled})),a.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,i=e.effect;if("function"==typeof i){var o=i({state:a,name:t,instance:u,options:r}),s=function(){};l.push(o||s);}})),u.update()},forceUpdate:function(){if(!c){var e=a.elements,t=e.reference,n=e.popper;if(Tf(t,n)){a.rects={reference:Af(t,Qp(n),"fixed"===a.options.strategy),popper:qp(n)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(e){return a.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<a.orderedModifiers.length;r++)if(!0!==a.reset){var i=a.orderedModifiers[r],o=i.fn,s=i.options,l=void 0===s?{}:s,d=i.name;"function"==typeof o&&(a=o({state:a,options:l,name:d,instance:u})||a);}else a.reset=!1,r=-1;}}},update:(i=function(){return new Promise((function(e){u.forceUpdate(),e(a);}))},function(){return s||(s=new Promise((function(e){Promise.resolve().then((function(){s=void 0,e(i());}));}))),s}),destroy:function(){d(),c=!0;}};if(!Tf(e,t))return u;function d(){l.forEach((function(e){return e()})),l=[];}return u.setOptions(n).then((function(e){!c&&n.onFirstUpdate&&n.onFirstUpdate(e);})),u}}var Rf=Lf({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,n=e.instance,r=e.options,i=r.scroll,o=void 0===i||i,s=r.resize,a=void 0===s||s,l=Fp(t.elements.popper),c=[].concat(t.scrollParents.reference,t.scrollParents.popper);return o&&c.forEach((function(e){e.addEventListener("scroll",n.update,lf);})),a&&l.addEventListener("resize",n.update,lf),function(){o&&c.forEach((function(e){e.removeEventListener("scroll",n.update,lf);})),a&&l.removeEventListener("resize",n.update,lf);}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=kf({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement});},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,i=void 0===r||r,o=n.adaptive,s=void 0===o||o,a=n.roundOffsets,l=void 0===a||a,c={placement:$p(t.placement),variation:of(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:i,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,af(Object.assign({},c,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:s,roundOffsets:l})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,af(Object.assign({},c,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement});},data:{}},zp,Mf,xf,Of,rf,{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,i=t.rects.popper,o=t.modifiersData.preventOverflow,s=Cf(t,{elementContext:"reference"}),a=Cf(t,{altBoundary:!0}),l=Sf(s,r),c=Sf(a,i,o),u=Df(l),d=Df(c);t.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:c,isReferenceHidden:u,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":u,"data-popper-escaped":d});}}]}),Ff={passive:!0,capture:!0},Bf=function(){return document.body};function If(e,t,n){if(Array.isArray(e)){var r=e[t];return null==r?Array.isArray(n)?n[t]:n:r}return e}function Pf(e,t){var n={}.toString.call(e);return 0===n.indexOf("[object")&&n.indexOf(t+"]")>-1}function zf(e,t){return "function"==typeof e?e.apply(void 0,t):e}function $f(e,t){return 0===t?e:function(r){clearTimeout(n),n=setTimeout((function(){e(r);}),t);};var n;}function jf(e){return [].concat(e)}function Hf(e,t){-1===e.indexOf(t)&&e.push(t);}function Vf(e){return [].slice.call(e)}function Kf(e){return Object.keys(e).reduce((function(t,n){return void 0!==e[n]&&(t[n]=e[n]),t}),{})}function qf(){return document.createElement("div")}function Uf(e){return ["Element","Fragment"].some((function(t){return Pf(e,t)}))}function Wf(e){return Uf(e)?[e]:function(e){return Pf(e,"NodeList")}(e)?Vf(e):Array.isArray(e)?e:Vf(document.querySelectorAll(e))}function Gf(e,t){e.forEach((function(e){e&&(e.style.transitionDuration=t+"ms");}));}function Jf(e,t){e.forEach((function(e){e&&e.setAttribute("data-state",t);}));}function Zf(e,t,n){var r=t+"EventListener";["transitionend","webkitTransitionEnd"].forEach((function(t){e[r](t,n);}));}function Xf(e,t){for(var n=t;n;){var r;if(e.contains(n))return !0;n=null==n.getRootNode||null==(r=n.getRootNode())?void 0:r.host;}return !1}var Qf={isTouch:!1},Yf=0;function em(){Qf.isTouch||(Qf.isTouch=!0,window.performance&&document.addEventListener("mousemove",tm));}function tm(){var e=performance.now();e-Yf<20&&(Qf.isTouch=!1,document.removeEventListener("mousemove",tm)),Yf=e;}function nm(){var e,t=document.activeElement;if((e=t)&&e._tippy&&e._tippy.reference===e){var n=t._tippy;t.blur&&!n.state.isVisible&&t.blur();}}var rm=!!("undefined"!=typeof window&&"undefined"!=typeof document)&&!!window.msCrypto,im=Object.assign({appendTo:Bf,aria:{content:"auto",expanded:"auto"},delay:0,duration:[300,250],getReferenceClientRect:null,hideOnClick:!0,ignoreAttributes:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,moveTransition:"",offset:[0,10],onAfterUpdate:function(){},onBeforeUpdate:function(){},onCreate:function(){},onDestroy:function(){},onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},onUntrigger:function(){},onClickOutside:function(){},placement:"top",plugins:[],popperOptions:{},render:null,showOnCreate:!1,touch:!0,trigger:"mouseenter focus",triggerTarget:null},{animateFill:!1,followCursor:!1,inlinePositioning:!1,sticky:!1},{allowHTML:!1,animation:"fade",arrow:!0,content:"",inertia:!1,maxWidth:350,role:"tooltip",theme:"",zIndex:9999}),om=Object.keys(im);function sm(e){var t=(e.plugins||[]).reduce((function(t,n){var r,i=n.name,o=n.defaultValue;i&&(t[i]=void 0!==e[i]?e[i]:null!=(r=im[i])?r:o);return t}),{});return Object.assign({},e,t)}function am(e,t){var n=Object.assign({},t,{content:zf(t.content,[e])},t.ignoreAttributes?{}:function(e,t){var n=(t?Object.keys(sm(Object.assign({},im,{plugins:t}))):om).reduce((function(t,n){var r=(e.getAttribute("data-tippy-"+n)||"").trim();if(!r)return t;if("content"===n)t[n]=r;else try{t[n]=JSON.parse(r);}catch(e){t[n]=r;}return t}),{});return n}(e,t.plugins));return n.aria=Object.assign({},im.aria,n.aria),n.aria={expanded:"auto"===n.aria.expanded?t.interactive:n.aria.expanded,content:"auto"===n.aria.content?t.interactive?null:"describedby":n.aria.content},n}function lm(e,t){e.innerHTML=t;}function cm(e){var t=qf();return !0===e?t.className="tippy-arrow":(t.className="tippy-svg-arrow",Uf(e)?t.appendChild(e):lm(t,e)),t}function um(e,t){Uf(t.content)?(lm(e,""),e.appendChild(t.content)):"function"!=typeof t.content&&(t.allowHTML?lm(e,t.content):e.textContent=t.content);}function dm(e){var t=e.firstElementChild,n=Vf(t.children);return {box:t,content:n.find((function(e){return e.classList.contains("tippy-content")})),arrow:n.find((function(e){return e.classList.contains("tippy-arrow")||e.classList.contains("tippy-svg-arrow")})),backdrop:n.find((function(e){return e.classList.contains("tippy-backdrop")}))}}function hm(e){var t=qf(),n=qf();n.className="tippy-box",n.setAttribute("data-state","hidden"),n.setAttribute("tabindex","-1");var r=qf();function i(n,r){var i=dm(t),o=i.box,s=i.content,a=i.arrow;r.theme?o.setAttribute("data-theme",r.theme):o.removeAttribute("data-theme"),"string"==typeof r.animation?o.setAttribute("data-animation",r.animation):o.removeAttribute("data-animation"),r.inertia?o.setAttribute("data-inertia",""):o.removeAttribute("data-inertia"),o.style.maxWidth="number"==typeof r.maxWidth?r.maxWidth+"px":r.maxWidth,r.role?o.setAttribute("role",r.role):o.removeAttribute("role"),n.content===r.content&&n.allowHTML===r.allowHTML||um(s,e.props),r.arrow?a?n.arrow!==r.arrow&&(o.removeChild(a),o.appendChild(cm(r.arrow))):o.appendChild(cm(r.arrow)):a&&o.removeChild(a);}return r.className="tippy-content",r.setAttribute("data-state","hidden"),um(r,e.props),t.appendChild(n),n.appendChild(r),i(e.props,e.props),{popper:t,onUpdate:i}}hm.$$tippy=!0;var pm=1,fm=[],mm=[];function gm(e,t){var n,r,i,o,s,a,l,c,u=am(e,Object.assign({},im,sm(Kf(t)))),d=!1,h=!1,p=!1,f=!1,m=[],g=$f(W,u.interactiveDebounce),v=pm++,y=(c=u.plugins).filter((function(e,t){return c.indexOf(e)===t})),b={id:v,reference:e,popper:qf(),popperInstance:null,props:u,state:{isEnabled:!0,isVisible:!1,isDestroyed:!1,isMounted:!1,isShown:!1},plugins:y,clearDelayTimeouts:function(){clearTimeout(n),clearTimeout(r),cancelAnimationFrame(i);},setProps:function(t){if(b.state.isDestroyed)return;L("onBeforeUpdate",[b,t]),q();var n=b.props,r=am(e,Object.assign({},n,Kf(t),{ignoreAttributes:!0}));b.props=r,K(),n.interactiveDebounce!==r.interactiveDebounce&&(B(),g=$f(W,r.interactiveDebounce));n.triggerTarget&&!r.triggerTarget?jf(n.triggerTarget).forEach((function(e){e.removeAttribute("aria-expanded");})):r.triggerTarget&&e.removeAttribute("aria-expanded");F(),T(),C&&C(n,r);b.popperInstance&&(X(),Y().forEach((function(e){requestAnimationFrame(e._tippy.popperInstance.forceUpdate);})));L("onAfterUpdate",[b,t]);},setContent:function(e){b.setProps({content:e});},show:function(){var e=b.state.isVisible,t=b.state.isDestroyed,n=!b.state.isEnabled,r=Qf.isTouch&&!b.props.touch,i=If(b.props.duration,0,im.duration);if(e||t||n||r)return;if(O().hasAttribute("disabled"))return;if(L("onShow",[b],!1),!1===b.props.onShow(b))return;b.state.isVisible=!0,M()&&(k.style.visibility="visible");T(),$(),b.state.isMounted||(k.style.transition="none");if(M()){var o=N(),s=o.box,l=o.content;Gf([s,l],0);}a=function(){var e;if(b.state.isVisible&&!f){if(f=!0,k.offsetHeight,k.style.transition=b.props.moveTransition,M()&&b.props.animation){var t=N(),n=t.box,r=t.content;Gf([n,r],i),Jf([n,r],"visible");}R(),F(),Hf(mm,b),null==(e=b.popperInstance)||e.forceUpdate(),L("onMount",[b]),b.props.animation&&M()&&function(e,t){H(e,t);}(i,(function(){b.state.isShown=!0,L("onShown",[b]);}));}},function(){var e,t=b.props.appendTo,n=O();e=b.props.interactive&&t===Bf||"parent"===t?n.parentNode:zf(t,[n]);e.contains(k)||e.appendChild(k);b.state.isMounted=!0,X();}();},hide:function(){var e=!b.state.isVisible,t=b.state.isDestroyed,n=!b.state.isEnabled,r=If(b.props.duration,1,im.duration);if(e||t||n)return;if(L("onHide",[b],!1),!1===b.props.onHide(b))return;b.state.isVisible=!1,b.state.isShown=!1,f=!1,d=!1,M()&&(k.style.visibility="hidden");if(B(),j(),T(!0),M()){var i=N(),o=i.box,s=i.content;b.props.animation&&(Gf([o,s],r),Jf([o,s],"hidden"));}R(),F(),b.props.animation?M()&&function(e,t){H(e,(function(){!b.state.isVisible&&k.parentNode&&k.parentNode.contains(k)&&t();}));}(r,b.unmount):b.unmount();},hideWithInteractivity:function(e){A().addEventListener("mousemove",g),Hf(fm,g),g(e);},enable:function(){b.state.isEnabled=!0;},disable:function(){b.hide(),b.state.isEnabled=!1;},unmount:function(){b.state.isVisible&&b.hide();if(!b.state.isMounted)return;Q(),Y().forEach((function(e){e._tippy.unmount();})),k.parentNode&&k.parentNode.removeChild(k);mm=mm.filter((function(e){return e!==b})),b.state.isMounted=!1,L("onHidden",[b]);},destroy:function(){if(b.state.isDestroyed)return;b.clearDelayTimeouts(),b.unmount(),q(),delete e._tippy,b.state.isDestroyed=!0,L("onDestroy",[b]);}};if(!u.render)return b;var w=u.render(b),k=w.popper,C=w.onUpdate;k.setAttribute("data-tippy-root",""),k.id="tippy-"+b.id,b.popper=k,e._tippy=b,k._tippy=b;var E=y.map((function(e){return e.fn(b)})),x=e.hasAttribute("aria-expanded");return K(),F(),T(),L("onCreate",[b]),u.showOnCreate&&ee(),k.addEventListener("mouseenter",(function(){b.props.interactive&&b.state.isVisible&&b.clearDelayTimeouts();})),k.addEventListener("mouseleave",(function(){b.props.interactive&&b.props.trigger.indexOf("mouseenter")>=0&&A().addEventListener("mousemove",g);})),b;function S(){var e=b.props.touch;return Array.isArray(e)?e:[e,0]}function D(){return "hold"===S()[0]}function M(){var e;return !(null==(e=b.props.render)||!e.$$tippy)}function O(){return l||e}function A(){var e,t,n=O().parentNode;return n?null!=(t=jf(n)[0])&&null!=(e=t.ownerDocument)&&e.body?t.ownerDocument:document:document}function N(){return dm(k)}function _(e){return b.state.isMounted&&!b.state.isVisible||Qf.isTouch||o&&"focus"===o.type?0:If(b.props.delay,e?0:1,im.delay)}function T(e){void 0===e&&(e=!1),k.style.pointerEvents=b.props.interactive&&!e?"":"none",k.style.zIndex=""+b.props.zIndex;}function L(e,t,n){var r;(void 0===n&&(n=!0),E.forEach((function(n){n[e]&&n[e].apply(n,t);})),n)&&(r=b.props)[e].apply(r,t);}function R(){var t=b.props.aria;if(t.content){var n="aria-"+t.content,r=k.id;jf(b.props.triggerTarget||e).forEach((function(e){var t=e.getAttribute(n);if(b.state.isVisible)e.setAttribute(n,t?t+" "+r:r);else {var i=t&&t.replace(r,"").trim();i?e.setAttribute(n,i):e.removeAttribute(n);}}));}}function F(){!x&&b.props.aria.expanded&&jf(b.props.triggerTarget||e).forEach((function(e){b.props.interactive?e.setAttribute("aria-expanded",b.state.isVisible&&e===O()?"true":"false"):e.removeAttribute("aria-expanded");}));}function B(){A().removeEventListener("mousemove",g),fm=fm.filter((function(e){return e!==g}));}function I(t){if(!Qf.isTouch||!p&&"mousedown"!==t.type){var n=t.composedPath&&t.composedPath()[0]||t.target;if(!b.props.interactive||!Xf(k,n)){if(jf(b.props.triggerTarget||e).some((function(e){return Xf(e,n)}))){if(Qf.isTouch)return;if(b.state.isVisible&&b.props.trigger.indexOf("click")>=0)return}else L("onClickOutside",[b,t]);!0===b.props.hideOnClick&&(b.clearDelayTimeouts(),b.hide(),h=!0,setTimeout((function(){h=!1;})),b.state.isMounted||j());}}}function P(){p=!0;}function z(){p=!1;}function $(){var e=A();e.addEventListener("mousedown",I,!0),e.addEventListener("touchend",I,Ff),e.addEventListener("touchstart",z,Ff),e.addEventListener("touchmove",P,Ff);}function j(){var e=A();e.removeEventListener("mousedown",I,!0),e.removeEventListener("touchend",I,Ff),e.removeEventListener("touchstart",z,Ff),e.removeEventListener("touchmove",P,Ff);}function H(e,t){var n=N().box;function r(e){e.target===n&&(Zf(n,"remove",r),t());}if(0===e)return t();Zf(n,"remove",s),Zf(n,"add",r),s=r;}function V(t,n,r){void 0===r&&(r=!1),jf(b.props.triggerTarget||e).forEach((function(e){e.addEventListener(t,n,r),m.push({node:e,eventType:t,handler:n,options:r});}));}function K(){var e;D()&&(V("touchstart",U,{passive:!0}),V("touchend",G,{passive:!0})),(e=b.props.trigger,e.split(/\s+/).filter(Boolean)).forEach((function(e){if("manual"!==e)switch(V(e,U),e){case"mouseenter":V("mouseleave",G);break;case"focus":V(rm?"focusout":"blur",J);break;case"focusin":V("focusout",J);}}));}function q(){m.forEach((function(e){var t=e.node,n=e.eventType,r=e.handler,i=e.options;t.removeEventListener(n,r,i);})),m=[];}function U(e){var t,n=!1;if(b.state.isEnabled&&!Z(e)&&!h){var r="focus"===(null==(t=o)?void 0:t.type);o=e,l=e.currentTarget,F(),!b.state.isVisible&&Pf(e,"MouseEvent")&&fm.forEach((function(t){return t(e)})),"click"===e.type&&(b.props.trigger.indexOf("mouseenter")<0||d)&&!1!==b.props.hideOnClick&&b.state.isVisible?n=!0:ee(e),"click"===e.type&&(d=!n),n&&!r&&te(e);}}function W(e){var t=e.target,n=O().contains(t)||k.contains(t);if("mousemove"!==e.type||!n){var r=Y().concat(k).map((function(e){var t,n=null==(t=e._tippy.popperInstance)?void 0:t.state;return n?{popperRect:e.getBoundingClientRect(),popperState:n,props:u}:null})).filter(Boolean);(function(e,t){var n=t.clientX,r=t.clientY;return e.every((function(e){var t=e.popperRect,i=e.popperState,o=e.props.interactiveBorder,s=i.placement.split("-")[0],a=i.modifiersData.offset;if(!a)return !0;var l="bottom"===s?a.top.y:0,c="top"===s?a.bottom.y:0,u="right"===s?a.left.x:0,d="left"===s?a.right.x:0,h=t.top-r+l>o,p=r-t.bottom-c>o,f=t.left-n+u>o,m=n-t.right-d>o;return h||p||f||m}))})(r,e)&&(B(),te(e));}}function G(e){Z(e)||b.props.trigger.indexOf("click")>=0&&d||(b.props.interactive?b.hideWithInteractivity(e):te(e));}function J(e){b.props.trigger.indexOf("focusin")<0&&e.target!==O()||b.props.interactive&&e.relatedTarget&&k.contains(e.relatedTarget)||te(e);}function Z(e){return !!Qf.isTouch&&D()!==e.type.indexOf("touch")>=0}function X(){Q();var t=b.props,n=t.popperOptions,r=t.placement,i=t.offset,o=t.getReferenceClientRect,s=t.moveTransition,l=M()?dm(k).arrow:null,c=o?{getBoundingClientRect:o,contextElement:o.contextElement||O()}:e,u={name:"$$tippy",enabled:!0,phase:"beforeWrite",requires:["computeStyles"],fn:function(e){var t=e.state;if(M()){var n=N().box;["placement","reference-hidden","escaped"].forEach((function(e){"placement"===e?n.setAttribute("data-placement",t.placement):t.attributes.popper["data-popper-"+e]?n.setAttribute("data-"+e,""):n.removeAttribute("data-"+e);})),t.attributes.popper={};}}},d=[{name:"offset",options:{offset:i}},{name:"preventOverflow",options:{padding:{top:2,bottom:2,left:5,right:5}}},{name:"flip",options:{padding:5}},{name:"computeStyles",options:{adaptive:!s}},u];M()&&l&&d.push({name:"arrow",options:{element:l,padding:3}}),d.push.apply(d,(null==n?void 0:n.modifiers)||[]),b.popperInstance=Rf(c,k,Object.assign({},n,{placement:r,onFirstUpdate:a,modifiers:d}));}function Q(){b.popperInstance&&(b.popperInstance.destroy(),b.popperInstance=null);}function Y(){return Vf(k.querySelectorAll("[data-tippy-root]"))}function ee(e){b.clearDelayTimeouts(),e&&L("onTrigger",[b,e]),$();var t=_(!0),r=S(),i=r[0],o=r[1];Qf.isTouch&&"hold"===i&&o&&(t=o),t?n=setTimeout((function(){b.show();}),t):b.show();}function te(e){if(b.clearDelayTimeouts(),L("onUntrigger",[b,e]),b.state.isVisible){if(!(b.props.trigger.indexOf("mouseenter")>=0&&b.props.trigger.indexOf("click")>=0&&["mouseleave","mousemove"].indexOf(e.type)>=0&&d)){var t=_(!1);t?r=setTimeout((function(){b.state.isVisible&&b.hide();}),t):i=requestAnimationFrame((function(){b.hide();}));}}else j();}}function vm(e,t){void 0===t&&(t={});var n=im.plugins.concat(t.plugins||[]);document.addEventListener("touchstart",em,Ff),window.addEventListener("blur",nm);var r=Object.assign({},t,{plugins:n}),i=Wf(e).reduce((function(e,t){var n=t&&gm(t,r);return n&&e.push(n),e}),[]);return Uf(e)?i[0]:i}vm.defaultProps=im,vm.setDefaultProps=function(e){Object.keys(e).forEach((function(t){im[t]=e[t];}));},vm.currentInput=Qf,Object.assign({},zp,{effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow);}}),vm.setDefaultProps({render:hm});class ym{constructor({editor:e,element:t,view:n,tippyOptions:r={},shouldShow:i}){this.preventHide=!1,this.shouldShow=({view:e,state:t,from:n,to:r})=>{const{doc:i,selection:o}=t,{empty:s}=o,a=!i.textBetween(n,r).length&&zh(t.selection);return !(!e.hasFocus()||s||a)},this.mousedownHandler=()=>{this.preventHide=!0;},this.dragstartHandler=()=>{this.hide();},this.focusHandler=()=>{setTimeout((()=>this.update(this.editor.view)));},this.blurHandler=({event:e})=>{var t;this.preventHide?this.preventHide=!1:(null==e?void 0:e.relatedTarget)&&(null===(t=this.element.parentNode)||void 0===t?void 0:t.contains(e.relatedTarget))||this.hide();},this.editor=e,this.element=t,this.view=n,i&&(this.shouldShow=i),this.element.addEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.view.dom.addEventListener("dragstart",this.dragstartHandler),this.editor.on("focus",this.focusHandler),this.editor.on("blur",this.blurHandler),this.tippyOptions=r,this.element.remove(),this.element.style.visibility="visible";}createTooltip(){const{element:e}=this.editor.options,t=!!e.parentElement;!this.tippy&&t&&(this.tippy=vm(e,{duration:0,getReferenceClientRect:null,content:this.element,interactive:!0,trigger:"manual",placement:"top",hideOnClick:"toggle",...this.tippyOptions}),this.tippy.popper.firstChild&&this.tippy.popper.firstChild.addEventListener("blur",(e=>{this.blurHandler({event:e});})));}update(e,t){var n,r,i;const{state:o,composing:s}=e,{doc:a,selection:l}=o,c=t&&t.doc.eq(a)&&t.selection.eq(l);if(s||c)return;this.createTooltip();const{ranges:u}=l,d=Math.min(...u.map((e=>e.$from.pos))),h=Math.max(...u.map((e=>e.$to.pos)));(null===(n=this.shouldShow)||void 0===n?void 0:n.call(this,{editor:this.editor,view:e,state:o,oldState:t,from:d,to:h}))?(null===(r=this.tippy)||void 0===r||r.setProps({getReferenceClientRect:(null===(i=this.tippyOptions)||void 0===i?void 0:i.getReferenceClientRect)||(()=>{if(gp(o.selection)){const t=e.nodeDOM(d);if(t)return t.getBoundingClientRect()}return vp(e,d,h)})}),this.show()):this.hide();}show(){var e;null===(e=this.tippy)||void 0===e||e.show();}hide(){var e;null===(e=this.tippy)||void 0===e||e.hide();}destroy(){var e;null===(e=this.tippy)||void 0===e||e.destroy(),this.element.removeEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.view.dom.removeEventListener("dragstart",this.dragstartHandler),this.editor.off("focus",this.focusHandler),this.editor.off("blur",this.blurHandler);}}const bm=e=>new Dl({key:"string"==typeof e.pluginKey?new Al(e.pluginKey):e.pluginKey,view:t=>new ym({view:t,...e})});Ah.create({name:"bubbleMenu",addOptions:()=>({element:null,tippyOptions:{},pluginKey:"bubbleMenu",shouldShow:null}),addProseMirrorPlugins(){return this.options.element?[bm({pluginKey:this.options.pluginKey,editor:this.editor,element:this.options.element,tippyOptions:this.options.tippyOptions,shouldShow:this.options.shouldShow})]:[]}});class wm{constructor({editor:e,element:t,view:n,tippyOptions:r={},shouldShow:i}){this.preventHide=!1,this.shouldShow=({view:e,state:t})=>{const{selection:n}=t,{$anchor:r,empty:i}=n,o=1===r.depth,s=r.parent.isTextblock&&!r.parent.type.spec.code&&!r.parent.textContent;return !!(e.hasFocus()&&i&&o&&s)},this.mousedownHandler=()=>{this.preventHide=!0;},this.focusHandler=()=>{setTimeout((()=>this.update(this.editor.view)));},this.blurHandler=({event:e})=>{var t;this.preventHide?this.preventHide=!1:(null==e?void 0:e.relatedTarget)&&(null===(t=this.element.parentNode)||void 0===t?void 0:t.contains(e.relatedTarget))||this.hide();},this.editor=e,this.element=t,this.view=n,i&&(this.shouldShow=i),this.element.addEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.editor.on("focus",this.focusHandler),this.editor.on("blur",this.blurHandler),this.tippyOptions=r,this.element.remove(),this.element.style.visibility="visible";}createTooltip(){const{element:e}=this.editor.options,t=!!e.parentElement;!this.tippy&&t&&(this.tippy=vm(e,{duration:0,getReferenceClientRect:null,content:this.element,interactive:!0,trigger:"manual",placement:"right",hideOnClick:"toggle",...this.tippyOptions}),this.tippy.popper.firstChild&&this.tippy.popper.firstChild.addEventListener("blur",(e=>{this.blurHandler({event:e});})));}update(e,t){var n,r,i;const{state:o}=e,{doc:s,selection:a}=o,{from:l,to:c}=a;if(t&&t.doc.eq(s)&&t.selection.eq(a))return;this.createTooltip();(null===(n=this.shouldShow)||void 0===n?void 0:n.call(this,{editor:this.editor,view:e,state:o,oldState:t}))?(null===(r=this.tippy)||void 0===r||r.setProps({getReferenceClientRect:(null===(i=this.tippyOptions)||void 0===i?void 0:i.getReferenceClientRect)||(()=>vp(e,l,c))}),this.show()):this.hide();}show(){var e;null===(e=this.tippy)||void 0===e||e.show();}hide(){var e;null===(e=this.tippy)||void 0===e||e.hide();}destroy(){var e;null===(e=this.tippy)||void 0===e||e.destroy(),this.element.removeEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.editor.off("focus",this.focusHandler),this.editor.off("blur",this.blurHandler);}}const km=e=>new Dl({key:"string"==typeof e.pluginKey?new Al(e.pluginKey):e.pluginKey,view:t=>new wm({view:t,...e})});Ah.create({name:"floatingMenu",addOptions:()=>({element:null,tippyOptions:{},pluginKey:"floatingMenu",shouldShow:null}),addProseMirrorPlugins(){return this.options.element?[km({pluginKey:this.options.pluginKey,editor:this.editor,element:this.options.element,tippyOptions:this.options.tippyOptions,shouldShow:this.options.shouldShow})]:[]}});const Cm={name:"BubbleMenu",props:{pluginKey:{type:[String,Object],default:"bubbleMenu"},editor:{type:Object,required:!0},tippyOptions:{type:Object,default:()=>({})},shouldShow:{type:Function,default:null}},watch:{editor:{immediate:!0,handler(e){e&&this.$nextTick((()=>{e.registerPlugin(bm({pluginKey:this.pluginKey,editor:e,element:this.$el,tippyOptions:this.tippyOptions,shouldShow:this.shouldShow}));}));}}},render(e){return e("div",{style:{visibility:"hidden"}},this.$slots.default)},beforeDestroy(){this.editor.unregisterPlugin(this.pluginKey);}};class Em extends class extends class{constructor(){this.callbacks={};}on(e,t){return this.callbacks[e]||(this.callbacks[e]=[]),this.callbacks[e].push(t),this}emit(e,...t){const n=this.callbacks[e];return n&&n.forEach((e=>e.apply(this,t))),this}off(e,t){const n=this.callbacks[e];return n&&(t?this.callbacks[e]=n.filter((e=>e!==t)):delete this.callbacks[e]),this}removeAllListeners(){this.callbacks={};}}{constructor(e={}){super(),this.isFocused=!1,this.extensionStorage={},this.options={element:document.createElement("div"),content:"",injectCSS:!0,injectNonce:void 0,extensions:[],autofocus:!1,editable:!0,editorProps:{},parseOptions:{},enableInputRules:!0,enablePasteRules:!0,enableCoreExtensions:!0,onBeforeCreate:()=>null,onCreate:()=>null,onUpdate:()=>null,onSelectionUpdate:()=>null,onTransaction:()=>null,onFocus:()=>null,onBlur:()=>null,onDestroy:()=>null},this.isCapturingTransaction=!1,this.capturedTransaction=null,this.setOptions(e),this.createExtensionManager(),this.createCommandManager(),this.createSchema(),this.on("beforeCreate",this.options.onBeforeCreate),this.emit("beforeCreate",{editor:this}),this.createView(),this.injectCSS(),this.on("create",this.options.onCreate),this.on("update",this.options.onUpdate),this.on("selectionUpdate",this.options.onSelectionUpdate),this.on("transaction",this.options.onTransaction),this.on("focus",this.options.onFocus),this.on("blur",this.options.onBlur),this.on("destroy",this.options.onDestroy),window.setTimeout((()=>{this.isDestroyed||(this.commands.focus(this.options.autofocus),this.emit("create",{editor:this}));}),0);}get storage(){return this.extensionStorage}get commands(){return this.commandManager.commands}chain(){return this.commandManager.chain()}can(){return this.commandManager.can()}injectCSS(){this.options.injectCSS&&document&&(this.css=function(e,t){const n=document.querySelector("style[data-tiptap-style]");if(null!==n)return n;const r=document.createElement("style");return t&&r.setAttribute("nonce",t),r.setAttribute("data-tiptap-style",""),r.innerHTML=e,document.getElementsByTagName("head")[0].appendChild(r),r}('.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}',this.options.injectNonce));}setOptions(e={}){this.options={...this.options,...e},this.view&&this.state&&!this.isDestroyed&&(this.options.editorProps&&this.view.setProps(this.options.editorProps),this.view.updateState(this.state));}setEditable(e){this.setOptions({editable:e});}get isEditable(){return this.options.editable&&this.view&&this.view.editable}get state(){return this.view.state}registerPlugin(e,t){const n=ph(t)?t(e,[...this.state.plugins]):[...this.state.plugins,e],r=this.state.reconfigure({plugins:n});this.view.updateState(r);}unregisterPlugin(e){if(this.isDestroyed)return;const t="string"==typeof e?`${e}$`:e.key,n=this.state.reconfigure({plugins:this.state.plugins.filter((e=>!e.key.startsWith(t)))});this.view.updateState(n);}createExtensionManager(){const e=[...this.options.enableCoreExtensions?Object.values(dp):[],...this.options.extensions].filter((e=>["extension","node","mark"].includes(null==e?void 0:e.type)));this.extensionManager=new Dh(e,this);}createCommandManager(){this.commandManager=new sh({editor:this});}createSchema(){this.schema=this.extensionManager.schema;}createView(){const e=Jh(this.options.content,this.schema,this.options.parseOptions),t=jh(e,this.options.autofocus);this.view=new Od(this.options.element,{...this.options.editorProps,dispatchTransaction:this.dispatchTransaction.bind(this),state:xl.create({doc:e,selection:t||void 0})});const n=this.state.reconfigure({plugins:this.extensionManager.plugins});this.view.updateState(n),this.createNodeViews();this.view.dom.editor=this;}createNodeViews(){this.view.setProps({nodeViews:this.extensionManager.nodeViews});}captureTransaction(e){this.isCapturingTransaction=!0,e(),this.isCapturingTransaction=!1;const t=this.capturedTransaction;return this.capturedTransaction=null,t}dispatchTransaction(e){if(this.isCapturingTransaction)return this.capturedTransaction?void e.steps.forEach((e=>{var t;return null===(t=this.capturedTransaction)||void 0===t?void 0:t.step(e)})):void(this.capturedTransaction=e);const t=this.state.apply(e),n=!this.state.selection.eq(t.selection);this.view.updateState(t),this.emit("transaction",{editor:this,transaction:e}),n&&this.emit("selectionUpdate",{editor:this,transaction:e});const r=e.getMeta("focus"),i=e.getMeta("blur");r&&this.emit("focus",{editor:this,event:r.event,transaction:e}),i&&this.emit("blur",{editor:this,event:i.event,transaction:e}),e.docChanged&&!e.getMeta("preventUpdate")&&this.emit("update",{editor:this,transaction:e});}getAttributes(e){return hp(this.state,e)}isActive(e,t){const n="string"==typeof e?e:null,r="string"==typeof e?t:e;return function(e,t,n={}){if(!t)return Uh(e,null,n)||ip(e,null,n);const r=Wh(t,e.schema);return "node"===r?Uh(e,t,n):"mark"===r&&ip(e,t,n)}(this.state,n,r)}getJSON(){return this.state.doc.toJSON()}getHTML(){return function(e,t){const n=Ca.fromSchema(t).serializeFragment(e),r=document.implementation.createHTMLDocument().createElement("div");return r.appendChild(n),r.innerHTML}(this.state.doc.content,this.schema)}getText(e){const{blockSeparator:t="\n\n",textSerializers:n={}}=e||{};return function(e,t){return Nh(e,{from:0,to:e.content.size},t)}(this.state.doc,{blockSeparator:t,textSerializers:{...n,..._h(this.schema)}})}get isEmpty(){return function(e){var t;const n=null===(t=e.type.createAndFill())||void 0===t?void 0:t.toJSON(),r=e.toJSON();return JSON.stringify(n)===JSON.stringify(r)}(this.state.doc)}getCharacterCount(){return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'),this.state.doc.content.size-2}destroy(){this.emit("destroy"),this.view&&this.view.destroy(),this.removeAllListeners();}get isDestroyed(){var e;return !(null===(e=this.view)||void 0===e?void 0:e.docView)}}{constructor(){super(...arguments),this.contentComponent=null;}}const xm={name:"EditorContent",props:{editor:{default:null,type:Object}},watch:{editor:{immediate:!0,handler(e){e&&e.options.element&&this.$nextTick((()=>{const t=this.$el;t&&e.options.element.firstChild&&(t.append(...e.options.element.childNodes),e.contentComponent=this,e.setOptions({element:t}),e.createNodeViews());}));}}},render:e=>e("div"),beforeDestroy(){const{editor:e}=this;if(!e)return;if(e.isDestroyed||e.view.setProps({nodeViews:{}}),e.contentComponent=null,!e.options.element.firstChild)return;const t=document.createElement("div");t.append(...e.options.element.childNodes),e.setOptions({element:t});}},Sm={name:"FloatingMenu",props:{pluginKey:{type:[String,Object],default:"floatingMenu"},editor:{type:Object,required:!0},tippyOptions:{type:Object,default:()=>({})},shouldShow:{type:Function,default:null}},watch:{editor:{immediate:!0,handler(e){e&&this.$nextTick((()=>{e.registerPlugin(km({pluginKey:this.pluginKey,editor:e,element:this.$el,tippyOptions:this.tippyOptions,shouldShow:this.shouldShow}));}));}}},render(e){return e("div",{style:{visibility:"hidden"}},this.$slots.default)},beforeDestroy(){this.editor.unregisterPlugin(this.pluginKey);}},Dm=/^\s*>\s$/,Mm=xp.create({name:"blockquote",addOptions:()=>({HTMLAttributes:{}}),content:"block+",group:"block",defining:!0,parseHTML:()=>[{tag:"blockquote"}],renderHTML({HTMLAttributes:e}){return ["blockquote",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setBlockquote:()=>({commands:e})=>e.wrapIn(this.name),toggleBlockquote:()=>({commands:e})=>e.toggleWrap(this.name),unsetBlockquote:()=>({commands:e})=>e.lift(this.name)}},addKeyboardShortcuts(){return {"Mod-Shift-b":()=>this.editor.commands.toggleBlockquote()}},addInputRules(){return [Cp({find:Dm,type:this.type})]}}),Om=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,Am=/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,Nm=/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,_m=/(?:^|\s)((?:__)((?:[^__]+))(?:__))/g,Tm=Ep.create({name:"bold",addOptions:()=>({HTMLAttributes:{}}),parseHTML:()=>[{tag:"strong"},{tag:"b",getAttrs:e=>"normal"!==e.style.fontWeight&&null},{style:"font-weight",getAttrs:e=>/^(bold(er)?|[5-9]\d{2,})$/.test(e)&&null}],renderHTML({HTMLAttributes:e}){return ["strong",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setBold:()=>({commands:e})=>e.setMark(this.name),toggleBold:()=>({commands:e})=>e.toggleMark(this.name),unsetBold:()=>({commands:e})=>e.unsetMark(this.name)}},addKeyboardShortcuts(){return {"Mod-b":()=>this.editor.commands.toggleBold(),"Mod-B":()=>this.editor.commands.toggleBold()}},addInputRules(){return [yp({find:Om,type:this.type}),yp({find:Nm,type:this.type})]},addPasteRules(){return [Sp({find:Am,type:this.type}),Sp({find:_m,type:this.type})]}}),Lm=/^\s*([-+*])\s$/,Rm=xp.create({name:"bulletList",addOptions:()=>({itemTypeName:"listItem",HTMLAttributes:{}}),group:"block list",content(){return `${this.options.itemTypeName}+`},parseHTML:()=>[{tag:"ul"}],renderHTML({HTMLAttributes:e}){return ["ul",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {toggleBulletList:()=>({commands:e})=>e.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return {"Mod-Shift-8":()=>this.editor.commands.toggleBulletList()}},addInputRules(){return [Cp({find:Lm,type:this.type})]}}),Fm=/(?:^|\s)((?:`)((?:[^`]+))(?:`))$/,Bm=/(?:^|\s)((?:`)((?:[^`]+))(?:`))/g,Im=Ep.create({name:"code",addOptions:()=>({HTMLAttributes:{}}),excludes:"_",code:!0,parseHTML:()=>[{tag:"code"}],renderHTML({HTMLAttributes:e}){return ["code",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setCode:()=>({commands:e})=>e.setMark(this.name),toggleCode:()=>({commands:e})=>e.toggleMark(this.name),unsetCode:()=>({commands:e})=>e.unsetMark(this.name)}},addKeyboardShortcuts(){return {"Mod-e":()=>this.editor.commands.toggleCode()}},addInputRules(){return [yp({find:Fm,type:this.type})]},addPasteRules(){return [Sp({find:Bm,type:this.type})]}}),Pm=/^```([a-z]+)?[\s\n]$/,zm=/^~~~([a-z]+)?[\s\n]$/,$m=xp.create({name:"codeBlock",addOptions:()=>({languageClassPrefix:"language-",exitOnTripleEnter:!0,exitOnArrowDown:!0,HTMLAttributes:{}}),content:"text*",marks:"",group:"block",code:!0,defining:!0,addAttributes(){return {language:{default:null,parseHTML:e=>{var t;const{languageClassPrefix:n}=this.options,r=[...(null===(t=e.firstElementChild)||void 0===t?void 0:t.classList)||[]].filter((e=>e.startsWith(n))).map((e=>e.replace(n,"")))[0];return r||null},rendered:!1}}},parseHTML:()=>[{tag:"pre",preserveWhitespace:"full"}],renderHTML({node:e,HTMLAttributes:t}){return ["pre",dh(this.options.HTMLAttributes,t),["code",{class:e.attrs.language?this.options.languageClassPrefix+e.attrs.language:null},0]]},addCommands(){return {setCodeBlock:e=>({commands:t})=>t.setNode(this.name,e),toggleCodeBlock:e=>({commands:t})=>t.toggleNode(this.name,"paragraph",e)}},addKeyboardShortcuts(){return {"Mod-Alt-c":()=>this.editor.commands.toggleCodeBlock(),Backspace:()=>{const{empty:e,$anchor:t}=this.editor.state.selection,n=1===t.pos;return !(!e||t.parent.type.name!==this.name)&&(!(!n&&t.parent.textContent.length)&&this.editor.commands.clearNodes())},Enter:({editor:e})=>{if(!this.options.exitOnTripleEnter)return !1;const{state:t}=e,{selection:n}=t,{$from:r,empty:i}=n;if(!i||r.parent.type!==this.type)return !1;const o=r.parentOffset===r.parent.nodeSize-2,s=r.parent.textContent.endsWith("\n\n");return !(!o||!s)&&e.chain().command((({tr:e})=>(e.delete(r.pos-2,r.pos),!0))).exitCode().run()},ArrowDown:({editor:e})=>{if(!this.options.exitOnArrowDown)return !1;const{state:t}=e,{selection:n,doc:r}=t,{$from:i,empty:o}=n;if(!o||i.parent.type!==this.type)return !1;if(!(i.parentOffset===i.parent.nodeSize-2))return !1;const s=i.after();if(void 0===s)return !1;return !r.nodeAt(s)&&e.commands.exitCode()}}},addInputRules(){return [wp({find:Pm,type:this.type,getAttributes:e=>({language:e[1]})}),wp({find:zm,type:this.type,getAttributes:e=>({language:e[1]})})]},addProseMirrorPlugins(){return [new Dl({key:new Al("codeBlockVSCodeHandler"),props:{handlePaste:(e,t)=>{if(!t.clipboardData)return !1;if(this.editor.isActive(this.type.name))return !1;const n=t.clipboardData.getData("text/plain"),r=t.clipboardData.getData("vscode-editor-data"),i=r?JSON.parse(r):void 0,o=null==i?void 0:i.mode;if(!n||!o)return !1;const{tr:s}=e.state;return s.replaceSelectionWith(this.type.create({language:o})),s.setSelection(dl.near(s.doc.resolve(Math.max(0,s.selection.from-2)))),s.insertText(n.replace(/\r\n?/g,"\n")),s.setMeta("paste",!0),e.dispatch(s),!0}}})]}}),jm=xp.create({name:"doc",topNode:!0,content:"block+"});function Hm(e={}){return new Dl({view:t=>new Vm(t,e)})}class Vm{constructor(e,t){this.editorView=e,this.cursorPos=null,this.element=null,this.timeout=-1,this.width=t.width||1,this.color=t.color||"black",this.class=t.class,this.handlers=["dragover","dragend","drop","dragleave"].map((t=>{let n=e=>{this[t](e);};return e.dom.addEventListener(t,n),{name:t,handler:n}}));}destroy(){this.handlers.forEach((({name:e,handler:t})=>this.editorView.dom.removeEventListener(e,t)));}update(e,t){null!=this.cursorPos&&t.doc!=e.state.doc&&(this.cursorPos>e.state.doc.content.size?this.setCursor(null):this.updateOverlay());}setCursor(e){e!=this.cursorPos&&(this.cursorPos=e,null==e?(this.element.parentNode.removeChild(this.element),this.element=null):this.updateOverlay());}updateOverlay(){let e,t=this.editorView.state.doc.resolve(this.cursorPos);if(!t.parent.inlineContent){let n=t.nodeBefore,r=t.nodeAfter;if(n||r){let t=this.editorView.nodeDOM(this.cursorPos-(n?n.nodeSize:0)).getBoundingClientRect(),i=n?t.bottom:t.top;n&&r&&(i=(i+this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top)/2),e={left:t.left,right:t.right,top:i-this.width/2,bottom:i+this.width/2};}}if(!e){let t=this.editorView.coordsAtPos(this.cursorPos);e={left:t.left-this.width/2,right:t.left+this.width/2,top:t.top,bottom:t.bottom};}let n,r,i=this.editorView.dom.offsetParent;if(this.element||(this.element=i.appendChild(document.createElement("div")),this.class&&(this.element.className=this.class),this.element.style.cssText="position: absolute; z-index: 50; pointer-events: none; background-color: "+this.color),!i||i==document.body&&"static"==getComputedStyle(i).position)n=-pageXOffset,r=-pageYOffset;else {let e=i.getBoundingClientRect();n=e.left-i.scrollLeft,r=e.top-i.scrollTop;}this.element.style.left=e.left-n+"px",this.element.style.top=e.top-r+"px",this.element.style.width=e.right-e.left+"px",this.element.style.height=e.bottom-e.top+"px";}scheduleRemoval(e){clearTimeout(this.timeout),this.timeout=setTimeout((()=>this.setCursor(null)),e);}dragover(e){if(!this.editorView.editable)return;let t=this.editorView.posAtCoords({left:e.clientX,top:e.clientY}),n=t&&t.inside>=0&&this.editorView.state.doc.nodeAt(t.inside),r=n&&n.type.spec.disableDropCursor,i="function"==typeof r?r(this.editorView,t):r;if(t&&!i){let e=t.pos;if(this.editorView.dragging&&this.editorView.dragging.slice&&(e=Ua(this.editorView.state.doc,e,this.editorView.dragging.slice),null==e))return this.setCursor(null);this.setCursor(e),this.scheduleRemoval(5e3);}}dragend(){this.scheduleRemoval(20);}drop(){this.scheduleRemoval(20);}dragleave(e){e.target!=this.editorView.dom&&this.editorView.dom.contains(e.relatedTarget)||this.setCursor(null);}}const Km=Ah.create({name:"dropCursor",addOptions:()=>({color:"currentColor",width:1,class:void 0}),addProseMirrorPlugins(){return [Hm(this.options)]}});class qm extends al{constructor(e){super(e,e);}map(e,t){let n=e.resolve(t.map(this.head));return qm.valid(n)?new qm(n):al.near(n)}content(){return Os.empty}eq(e){return e instanceof qm&&e.head==this.head}toJSON(){return {type:"gapcursor",pos:this.head}}static fromJSON(e,t){if("number"!=typeof t.pos)throw new RangeError("Invalid input for GapCursor.fromJSON");return new qm(e.resolve(t.pos))}getBookmark(){return new Um(this.anchor)}static valid(e){let t=e.parent;if(t.isTextblock||!function(e){for(let t=e.depth;t>=0;t--){let n=e.index(t),r=e.node(t);if(0!=n)for(let e=r.child(n-1);;e=e.lastChild){if(0==e.childCount&&!e.inlineContent||e.isAtom||e.type.spec.isolating)return !0;if(e.inlineContent)return !1}else if(r.type.spec.isolating)return !0}return !0}(e)||!function(e){for(let t=e.depth;t>=0;t--){let n=e.indexAfter(t),r=e.node(t);if(n!=r.childCount)for(let e=r.child(n);;e=e.firstChild){if(0==e.childCount&&!e.inlineContent||e.isAtom||e.type.spec.isolating)return !0;if(e.inlineContent)return !1}else if(r.type.spec.isolating)return !0}return !0}(e))return !1;let n=t.type.spec.allowGapCursor;if(null!=n)return n;let r=t.contentMatchAt(e.index()).defaultType;return r&&r.isTextblock}static findGapCursorFrom(e,t,n=!1){e:for(;;){if(!n&&qm.valid(e))return e;let r=e.pos,i=null;for(let n=e.depth;;n--){let o=e.node(n);if(t>0?e.indexAfter(n)<o.childCount:e.index(n)>0){i=o.child(t>0?e.indexAfter(n):e.index(n)-1);break}if(0==n)return null;r+=t;let s=e.doc.resolve(r);if(qm.valid(s))return s}for(;;){let o=t>0?i.firstChild:i.lastChild;if(!o){if(i.isAtom&&!i.isText&&!pl.isSelectable(i)){e=e.doc.resolve(r+i.nodeSize*t),n=!1;continue e}break}i=o,r+=t;let s=e.doc.resolve(r);if(qm.valid(s))return s}return null}}}qm.prototype.visible=!1,qm.findFrom=qm.findGapCursorFrom,al.jsonID("gapcursor",qm);class Um{constructor(e){this.pos=e;}map(e){return new Um(e.map(this.pos))}resolve(e){let t=e.resolve(this.pos);return qm.valid(t)?new qm(t):al.near(t)}}const Wm=Wd({ArrowLeft:Gm("horiz",-1),ArrowRight:Gm("horiz",1),ArrowUp:Gm("vert",-1),ArrowDown:Gm("vert",1)});function Gm(e,t){const n="vert"==e?t>0?"down":"up":t>0?"right":"left";return function(e,r,i){let o=e.selection,s=t>0?o.$to:o.$from,a=o.empty;if(o instanceof dl){if(!i.endOfTextblock(n)||0==s.depth)return !1;a=!1,s=e.doc.resolve(t>0?s.after():s.before());}let l=qm.findGapCursorFrom(s,t,a);return !!l&&(r&&r(e.tr.setSelection(new qm(l))),!0)}}function Jm(e,t,n){if(!e||!e.editable)return !1;let r=e.state.doc.resolve(t);if(!qm.valid(r))return !1;let i=e.posAtCoords({left:n.clientX,top:n.clientY});return !(i&&i.inside>-1&&pl.isSelectable(e.state.doc.nodeAt(i.inside)))&&(e.dispatch(e.state.tr.setSelection(new qm(r))),!0)}function Zm(e,t){if("insertCompositionText"!=t.inputType||!(e.state.selection instanceof qm))return !1;let{$from:n}=e.state.selection,r=n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);if(!r)return !1;let i=Cs.empty;for(let e=r.length-1;e>=0;e--)i=Cs.from(r[e].createAndFill(null,i));let o=e.state.tr.replace(n.pos,n.pos,new Os(i,0,0));return o.setSelection(dl.near(o.doc.resolve(n.pos+1))),e.dispatch(o),!1}function Xm(e){if(!(e.selection instanceof qm))return null;let t=document.createElement("div");return t.className="ProseMirror-gapcursor",ld.create(e.doc,[od.widget(e.selection.head,t,{key:"gapcursor"})])}const Qm=Ah.create({name:"gapCursor",addProseMirrorPlugins:()=>[new Dl({props:{decorations:Xm,createSelectionBetween:(e,t,n)=>t.pos==n.pos&&qm.valid(n)?new qm(n):null,handleClick:Jm,handleKeyDown:Wm,handleDOMEvents:{beforeinput:Zm}}})],extendNodeSchema(e){var t;return {allowGapCursor:null!==(t=fh(ah(e,"allowGapCursor",{name:e.name,options:e.options,storage:e.storage})))&&void 0!==t?t:null}}}),Ym=xp.create({name:"hardBreak",addOptions:()=>({keepMarks:!0,HTMLAttributes:{}}),inline:!0,group:"inline",selectable:!1,parseHTML:()=>[{tag:"br"}],renderHTML({HTMLAttributes:e}){return ["br",dh(this.options.HTMLAttributes,e)]},renderText:()=>"\n",addCommands(){return {setHardBreak:()=>({commands:e,chain:t,state:n,editor:r})=>e.first([()=>e.exitCode(),()=>e.command((()=>{const{selection:e,storedMarks:i}=n;if(e.$from.parent.type.spec.isolating)return !1;const{keepMarks:o}=this.options,{splittableMarks:s}=r.extensionManager,a=i||e.$to.parentOffset&&e.$from.marks();return t().insertContent({type:this.name}).command((({tr:e,dispatch:t})=>{if(t&&a&&o){const t=a.filter((e=>s.includes(e.type.name)));e.ensureMarks(t);}return !0})).run()}))])}},addKeyboardShortcuts(){return {"Mod-Enter":()=>this.editor.commands.setHardBreak(),"Shift-Enter":()=>this.editor.commands.setHardBreak()}}}),eg=xp.create({name:"heading",addOptions:()=>({levels:[1,2,3,4,5,6],HTMLAttributes:{}}),content:"inline*",group:"block",defining:!0,addAttributes:()=>({level:{default:1,rendered:!1}}),parseHTML(){return this.options.levels.map((e=>({tag:`h${e}`,attrs:{level:e}})))},renderHTML({node:e,HTMLAttributes:t}){return [`h${this.options.levels.includes(e.attrs.level)?e.attrs.level:this.options.levels[0]}`,dh(this.options.HTMLAttributes,t),0]},addCommands(){return {setHeading:e=>({commands:t})=>!!this.options.levels.includes(e.level)&&t.setNode(this.name,e),toggleHeading:e=>({commands:t})=>!!this.options.levels.includes(e.level)&&t.toggleNode(this.name,"paragraph",e)}},addKeyboardShortcuts(){return this.options.levels.reduce(((e,t)=>({...e,[`Mod-Alt-${t}`]:()=>this.editor.commands.toggleHeading({level:t})})),{})},addInputRules(){return this.options.levels.map((e=>wp({find:new RegExp(`^(#{1,${e}})\\s$`),type:this.type,getAttributes:{level:e}})))}});var tg=function(){};tg.prototype.append=function(e){return e.length?(e=tg.from(e),!this.length&&e||e.length<200&&this.leafAppend(e)||this.length<200&&e.leafPrepend(this)||this.appendInner(e)):this},tg.prototype.prepend=function(e){return e.length?tg.from(e).append(this):this},tg.prototype.appendInner=function(e){return new rg(this,e)},tg.prototype.slice=function(e,t){return void 0===e&&(e=0),void 0===t&&(t=this.length),e>=t?tg.empty:this.sliceInner(Math.max(0,e),Math.min(this.length,t))},tg.prototype.get=function(e){if(!(e<0||e>=this.length))return this.getInner(e)},tg.prototype.forEach=function(e,t,n){void 0===t&&(t=0),void 0===n&&(n=this.length),t<=n?this.forEachInner(e,t,n,0):this.forEachInvertedInner(e,t,n,0);},tg.prototype.map=function(e,t,n){void 0===t&&(t=0),void 0===n&&(n=this.length);var r=[];return this.forEach((function(t,n){return r.push(e(t,n))}),t,n),r},tg.from=function(e){return e instanceof tg?e:e&&e.length?new ng(e):tg.empty};var ng=function(e){function t(t){e.call(this),this.values=t;}e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t;var n={length:{configurable:!0},depth:{configurable:!0}};return t.prototype.flatten=function(){return this.values},t.prototype.sliceInner=function(e,n){return 0==e&&n==this.length?this:new t(this.values.slice(e,n))},t.prototype.getInner=function(e){return this.values[e]},t.prototype.forEachInner=function(e,t,n,r){for(var i=t;i<n;i++)if(!1===e(this.values[i],r+i))return !1},t.prototype.forEachInvertedInner=function(e,t,n,r){for(var i=t-1;i>=n;i--)if(!1===e(this.values[i],r+i))return !1},t.prototype.leafAppend=function(e){if(this.length+e.length<=200)return new t(this.values.concat(e.flatten()))},t.prototype.leafPrepend=function(e){if(this.length+e.length<=200)return new t(e.flatten().concat(this.values))},n.length.get=function(){return this.values.length},n.depth.get=function(){return 0},Object.defineProperties(t.prototype,n),t}(tg);tg.empty=new ng([]);var rg=function(e){function t(t,n){e.call(this),this.left=t,this.right=n,this.length=t.length+n.length,this.depth=Math.max(t.depth,n.depth)+1;}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.flatten=function(){return this.left.flatten().concat(this.right.flatten())},t.prototype.getInner=function(e){return e<this.left.length?this.left.get(e):this.right.get(e-this.left.length)},t.prototype.forEachInner=function(e,t,n,r){var i=this.left.length;return !(t<i&&!1===this.left.forEachInner(e,t,Math.min(n,i),r))&&(!(n>i&&!1===this.right.forEachInner(e,Math.max(t-i,0),Math.min(this.length,n)-i,r+i))&&void 0)},t.prototype.forEachInvertedInner=function(e,t,n,r){var i=this.left.length;return !(t>i&&!1===this.right.forEachInvertedInner(e,t-i,Math.max(n,i)-i,r+i))&&(!(n<i&&!1===this.left.forEachInvertedInner(e,Math.min(t,i),n,r))&&void 0)},t.prototype.sliceInner=function(e,t){if(0==e&&t==this.length)return this;var n=this.left.length;return t<=n?this.left.slice(e,t):e>=n?this.right.slice(e-n,t-n):this.left.slice(e,n).append(this.right.slice(0,t-n))},t.prototype.leafAppend=function(e){var n=this.right.leafAppend(e);if(n)return new t(this.left,n)},t.prototype.leafPrepend=function(e){var n=this.left.leafPrepend(e);if(n)return new t(n,this.right)},t.prototype.appendInner=function(e){return this.left.depth>=Math.max(this.right.depth,e.depth)+1?new t(this.left,new t(this.right,e)):new t(this,e)},t}(tg),ig=tg;class og{constructor(e,t){this.items=e,this.eventCount=t;}popEvent(e,t){if(0==this.eventCount)return null;let n,r,i=this.items.length;for(;;i--){if(this.items.get(i-1).selection){--i;break}}t&&(n=this.remapping(i,this.items.length),r=n.maps.length);let o,s,a=e.tr,l=[],c=[];return this.items.forEach(((e,t)=>{if(!e.step)return n||(n=this.remapping(i,t+1),r=n.maps.length),r--,void c.push(e);if(n){c.push(new sg(e.map));let t,i=e.step.map(n.slice(r));i&&a.maybeStep(i).doc&&(t=a.mapping.maps[a.mapping.maps.length-1],l.push(new sg(t,void 0,void 0,l.length+c.length))),r--,t&&n.appendMap(t,r);}else a.maybeStep(e.step);return e.selection?(o=n?e.selection.map(n.slice(r)):e.selection,s=new og(this.items.slice(0,i).append(c.reverse().concat(l)),this.eventCount-1),!1):void 0}),this.items.length,0),{remaining:s,transform:a,selection:o}}addTransform(e,t,n,r){let i=[],o=this.eventCount,s=this.items,a=!r&&s.length?s.get(s.length-1):null;for(let n=0;n<e.steps.length;n++){let l,c=e.steps[n].invert(e.docs[n]),u=new sg(e.mapping.maps[n],c,t);(l=a&&a.merge(u))&&(u=l,n?i.pop():s=s.slice(0,s.length-1)),i.push(u),t&&(o++,t=void 0),r||(a=u);}let l=o-n.depth;return l>lg&&(s=function(e,t){let n;return e.forEach(((e,r)=>{if(e.selection&&0==t--)return n=r,!1})),e.slice(n)}(s,l),o-=l),new og(s.append(i),o)}remapping(e,t){let n=new Na;return this.items.forEach(((t,r)=>{let i=null!=t.mirrorOffset&&r-t.mirrorOffset>=e?n.maps.length-t.mirrorOffset:void 0;n.appendMap(t.map,i);}),e,t),n}addMaps(e){return 0==this.eventCount?this:new og(this.items.append(e.map((e=>new sg(e)))),this.eventCount)}rebased(e,t){if(!this.eventCount)return this;let n=[],r=Math.max(0,this.items.length-t),i=e.mapping,o=e.steps.length,s=this.eventCount;this.items.forEach((e=>{e.selection&&s--;}),r);let a=t;this.items.forEach((t=>{let r=i.getMirror(--a);if(null==r)return;o=Math.min(o,r);let l=i.maps[r];if(t.step){let o=e.steps[r].invert(e.docs[r]),c=t.selection&&t.selection.map(i.slice(a+1,r));c&&s++,n.push(new sg(l,o,c));}else n.push(new sg(l));}),r);let l=[];for(let e=t;e<o;e++)l.push(new sg(i.maps[e]));let c=this.items.slice(0,r).append(l).append(n),u=new og(c,s);return u.emptyItemCount()>500&&(u=u.compress(this.items.length-n.length)),u}emptyItemCount(){let e=0;return this.items.forEach((t=>{t.step||e++;})),e}compress(e=this.items.length){let t=this.remapping(0,e),n=t.maps.length,r=[],i=0;return this.items.forEach(((o,s)=>{if(s>=e)r.push(o),o.selection&&i++;else if(o.step){let e=o.step.map(t.slice(n)),s=e&&e.getMap();if(n--,s&&t.appendMap(s,n),e){let a=o.selection&&o.selection.map(t.slice(n));a&&i++;let l,c=new sg(s.invert(),e,a),u=r.length-1;(l=r.length&&r[u].merge(c))?r[u]=l:r.push(c);}}else o.map&&n--;}),this.items.length,0),new og(ig.from(r.reverse()),i)}}og.empty=new og(ig.empty,0);class sg{constructor(e,t,n,r){this.map=e,this.step=t,this.selection=n,this.mirrorOffset=r;}merge(e){if(this.step&&e.step&&!e.selection){let t=e.step.merge(this.step);if(t)return new sg(t.getMap().invert(),t,this.selection)}}}class ag{constructor(e,t,n,r){this.done=e,this.undone=t,this.prevRanges=n,this.prevTime=r;}}const lg=20;function cg(e){let t=[];return e.forEach(((e,n,r,i)=>t.push(r,i))),t}function ug(e,t){if(!e)return null;let n=[];for(let r=0;r<e.length;r+=2){let i=t.map(e[r],1),o=t.map(e[r+1],-1);i<=o&&n.push(i,o);}return n}function dg(e,t,n,r){let i=fg(t),o=mg.get(t).spec.config,s=(r?e.undone:e.done).popEvent(t,i);if(!s)return;let a=s.selection.resolve(s.transform.doc),l=(r?e.done:e.undone).addTransform(s.transform,t.selection.getBookmark(),o,i),c=new ag(r?l:s.remaining,r?s.remaining:l,null,0);n(s.transform.setSelection(a).setMeta(mg,{redo:r,historyState:c}).scrollIntoView());}let hg=!1,pg=null;function fg(e){let t=e.plugins;if(pg!=t){hg=!1,pg=t;for(let e=0;e<t.length;e++)if(t[e].spec.historyPreserveItems){hg=!0;break}}return hg}const mg=new Al("history"),gg=new Al("closeHistory");function vg(e={}){return e={depth:e.depth||100,newGroupDelay:e.newGroupDelay||500},new Dl({key:mg,state:{init:()=>new ag(og.empty,og.empty,null,0),apply:(t,n,r)=>function(e,t,n,r){let i,o=n.getMeta(mg);if(o)return o.historyState;n.getMeta(gg)&&(e=new ag(e.done,e.undone,null,0));let s=n.getMeta("appendedTransaction");if(0==n.steps.length)return e;if(s&&s.getMeta(mg))return s.getMeta(mg).redo?new ag(e.done.addTransform(n,void 0,r,fg(t)),e.undone,cg(n.mapping.maps[n.steps.length-1]),e.prevTime):new ag(e.done,e.undone.addTransform(n,void 0,r,fg(t)),null,e.prevTime);if(!1===n.getMeta("addToHistory")||s&&!1===s.getMeta("addToHistory"))return (i=n.getMeta("rebased"))?new ag(e.done.rebased(n,i),e.undone.rebased(n,i),ug(e.prevRanges,n.mapping),e.prevTime):new ag(e.done.addMaps(n.mapping.maps),e.undone.addMaps(n.mapping.maps),ug(e.prevRanges,n.mapping),e.prevTime);{let i=0==e.prevTime||!s&&(e.prevTime<(n.time||0)-r.newGroupDelay||!function(e,t){if(!t)return !1;if(!e.docChanged)return !0;let n=!1;return e.mapping.maps[0].forEach(((e,r)=>{for(let i=0;i<t.length;i+=2)e<=t[i+1]&&r>=t[i]&&(n=!0);})),n}(n,e.prevRanges)),o=s?ug(e.prevRanges,n.mapping):cg(n.mapping.maps[n.steps.length-1]);return new ag(e.done.addTransform(n,i?t.selection.getBookmark():void 0,r,fg(t)),og.empty,o,n.time)}}(n,r,t,e)},config:e,props:{handleDOMEvents:{beforeinput(e,t){let n=t.inputType,r="historyUndo"==n?yg:"historyRedo"==n?bg:null;return !!r&&(t.preventDefault(),r(e.state,e.dispatch))}}}})}const yg=(e,t)=>{let n=mg.getState(e);return !(!n||0==n.done.eventCount)&&(t&&dg(n,e,t,!1),!0)},bg=(e,t)=>{let n=mg.getState(e);return !(!n||0==n.undone.eventCount)&&(t&&dg(n,e,t,!0),!0)},wg=Ah.create({name:"history",addOptions:()=>({depth:100,newGroupDelay:500}),addCommands:()=>({undo:()=>({state:e,dispatch:t})=>yg(e,t),redo:()=>({state:e,dispatch:t})=>bg(e,t)}),addProseMirrorPlugins(){return [vg(this.options)]},addKeyboardShortcuts(){return {"Mod-z":()=>this.editor.commands.undo(),"Mod-y":()=>this.editor.commands.redo(),"Shift-Mod-z":()=>this.editor.commands.redo(),"Mod-я":()=>this.editor.commands.undo(),"Shift-Mod-я":()=>this.editor.commands.redo()}}}),kg=xp.create({name:"horizontalRule",addOptions:()=>({HTMLAttributes:{}}),group:"block",parseHTML:()=>[{tag:"hr"}],renderHTML({HTMLAttributes:e}){return ["hr",dh(this.options.HTMLAttributes,e)]},addCommands(){return {setHorizontalRule:()=>({chain:e})=>e().insertContent({type:this.name}).command((({tr:e,dispatch:t})=>{var n;if(t){const{$to:t}=e.selection,r=t.end();if(t.nodeAfter)e.setSelection(dl.create(e.doc,t.pos));else {const i=null===(n=t.parent.type.contentMatch.defaultType)||void 0===n?void 0:n.create();i&&(e.insert(r,i),e.setSelection(dl.create(e.doc,r)));}e.scrollIntoView();}return !0})).run()}},addInputRules(){return [bp({find:/^(?:---|—-|___\s|\*\*\*\s)$/,type:this.type})]}}),Cg=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,Eg=/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,xg=/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,Sg=/(?:^|\s)((?:_)((?:[^_]+))(?:_))/g,Dg=Ep.create({name:"italic",addOptions:()=>({HTMLAttributes:{}}),parseHTML:()=>[{tag:"em"},{tag:"i",getAttrs:e=>"normal"!==e.style.fontStyle&&null},{style:"font-style=italic"}],renderHTML({HTMLAttributes:e}){return ["em",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setItalic:()=>({commands:e})=>e.setMark(this.name),toggleItalic:()=>({commands:e})=>e.toggleMark(this.name),unsetItalic:()=>({commands:e})=>e.unsetMark(this.name)}},addKeyboardShortcuts(){return {"Mod-i":()=>this.editor.commands.toggleItalic(),"Mod-I":()=>this.editor.commands.toggleItalic()}},addInputRules(){return [yp({find:Cg,type:this.type}),yp({find:xg,type:this.type})]},addPasteRules(){return [Sp({find:Eg,type:this.type}),Sp({find:Sg,type:this.type})]}}),Mg=xp.create({name:"listItem",addOptions:()=>({HTMLAttributes:{}}),content:"paragraph block*",defining:!0,parseHTML:()=>[{tag:"li"}],renderHTML({HTMLAttributes:e}){return ["li",dh(this.options.HTMLAttributes,e),0]},addKeyboardShortcuts(){return {Enter:()=>this.editor.commands.splitListItem(this.name),Tab:()=>this.editor.commands.sinkListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)}}}),Og=/^(\d+)\.\s$/,Ag=xp.create({name:"orderedList",addOptions:()=>({itemTypeName:"listItem",HTMLAttributes:{}}),group:"block list",content(){return `${this.options.itemTypeName}+`},addAttributes:()=>({start:{default:1,parseHTML:e=>e.hasAttribute("start")?parseInt(e.getAttribute("start")||"",10):1}}),parseHTML:()=>[{tag:"ol"}],renderHTML({HTMLAttributes:e}){const{start:t,...n}=e;return 1===t?["ol",dh(this.options.HTMLAttributes,n),0]:["ol",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {toggleOrderedList:()=>({commands:e})=>e.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return {"Mod-Shift-7":()=>this.editor.commands.toggleOrderedList()}},addInputRules(){return [Cp({find:Og,type:this.type,getAttributes:e=>({start:+e[1]}),joinPredicate:(e,t)=>t.childCount+t.attrs.start===+e[1]})]}}),Ng=xp.create({name:"paragraph",priority:1e3,addOptions:()=>({HTMLAttributes:{}}),group:"block",content:"inline*",parseHTML:()=>[{tag:"p"}],renderHTML({HTMLAttributes:e}){return ["p",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setParagraph:()=>({commands:e})=>e.setNode(this.name)}},addKeyboardShortcuts(){return {"Mod-Alt-0":()=>this.editor.commands.setParagraph()}}}),_g=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,Tg=/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g,Lg=Ep.create({name:"strike",addOptions:()=>({HTMLAttributes:{}}),parseHTML:()=>[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:e=>!!e.includes("line-through")&&{}}],renderHTML({HTMLAttributes:e}){return ["s",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setStrike:()=>({commands:e})=>e.setMark(this.name),toggleStrike:()=>({commands:e})=>e.toggleMark(this.name),unsetStrike:()=>({commands:e})=>e.unsetMark(this.name)}},addKeyboardShortcuts(){return {"Mod-Shift-x":()=>this.editor.commands.toggleStrike()}},addInputRules(){return [yp({find:_g,type:this.type})]},addPasteRules(){return [Sp({find:Tg,type:this.type})]}}),Rg=xp.create({name:"text",group:"inline"}),Fg=Ah.create({name:"starterKit",addExtensions(){var e,t,n,r,i,o,s,a,l,c,u,d,h,p,f,m,g,v;const y=[];return !1!==this.options.blockquote&&y.push(Mm.configure(null===(e=this.options)||void 0===e?void 0:e.blockquote)),!1!==this.options.bold&&y.push(Tm.configure(null===(t=this.options)||void 0===t?void 0:t.bold)),!1!==this.options.bulletList&&y.push(Rm.configure(null===(n=this.options)||void 0===n?void 0:n.bulletList)),!1!==this.options.code&&y.push(Im.configure(null===(r=this.options)||void 0===r?void 0:r.code)),!1!==this.options.codeBlock&&y.push($m.configure(null===(i=this.options)||void 0===i?void 0:i.codeBlock)),!1!==this.options.document&&y.push(jm.configure(null===(o=this.options)||void 0===o?void 0:o.document)),!1!==this.options.dropcursor&&y.push(Km.configure(null===(s=this.options)||void 0===s?void 0:s.dropcursor)),!1!==this.options.gapcursor&&y.push(Qm.configure(null===(a=this.options)||void 0===a?void 0:a.gapcursor)),!1!==this.options.hardBreak&&y.push(Ym.configure(null===(l=this.options)||void 0===l?void 0:l.hardBreak)),!1!==this.options.heading&&y.push(eg.configure(null===(c=this.options)||void 0===c?void 0:c.heading)),!1!==this.options.history&&y.push(wg.configure(null===(u=this.options)||void 0===u?void 0:u.history)),!1!==this.options.horizontalRule&&y.push(kg.configure(null===(d=this.options)||void 0===d?void 0:d.horizontalRule)),!1!==this.options.italic&&y.push(Dg.configure(null===(h=this.options)||void 0===h?void 0:h.italic)),!1!==this.options.listItem&&y.push(Mg.configure(null===(p=this.options)||void 0===p?void 0:p.listItem)),!1!==this.options.orderedList&&y.push(Ag.configure(null===(f=this.options)||void 0===f?void 0:f.orderedList)),!1!==this.options.paragraph&&y.push(Ng.configure(null===(m=this.options)||void 0===m?void 0:m.paragraph)),!1!==this.options.strike&&y.push(Lg.configure(null===(g=this.options)||void 0===g?void 0:g.strike)),!1!==this.options.text&&y.push(Rg.configure(null===(v=this.options)||void 0===v?void 0:v.text)),y}}),Bg=kp({find:/--$/,replace:"—"}),Ig=kp({find:/\.\.\.$/,replace:"…"}),Pg=kp({find:/(?:^|[\s{[(<'"\u2018\u201C])(")$/,replace:"“"}),zg=kp({find:/"$/,replace:"”"}),$g=kp({find:/(?:^|[\s{[(<'"\u2018\u201C])(')$/,replace:"‘"}),jg=kp({find:/'$/,replace:"’"}),Hg=kp({find:/<-$/,replace:"←"}),Vg=kp({find:/->$/,replace:"→"}),Kg=kp({find:/\(c\)$/,replace:"©"}),qg=kp({find:/\(tm\)$/,replace:"™"}),Ug=kp({find:/\(r\)$/,replace:"®"}),Wg=kp({find:/1\/2$/,replace:"½"}),Gg=kp({find:/\+\/-$/,replace:"±"}),Jg=kp({find:/!=$/,replace:"≠"}),Zg=kp({find:/<<$/,replace:"«"}),Xg=kp({find:/>>$/,replace:"»"}),Qg=kp({find:/\d+\s?([*x])\s?\d+$/,replace:"×"}),Yg=kp({find:/\^2$/,replace:"²"}),ev=kp({find:/\^3$/,replace:"³"}),tv=kp({find:/1\/4$/,replace:"¼"}),nv=kp({find:/3\/4$/,replace:"¾"}),rv=Ah.create({name:"typography",addInputRules(){const e=[];return !1!==this.options.emDash&&e.push(Bg),!1!==this.options.ellipsis&&e.push(Ig),!1!==this.options.openDoubleQuote&&e.push(Pg),!1!==this.options.closeDoubleQuote&&e.push(zg),!1!==this.options.openSingleQuote&&e.push($g),!1!==this.options.closeSingleQuote&&e.push(jg),!1!==this.options.leftArrow&&e.push(Hg),!1!==this.options.rightArrow&&e.push(Vg),!1!==this.options.copyright&&e.push(Kg),!1!==this.options.trademark&&e.push(qg),!1!==this.options.registeredTrademark&&e.push(Ug),!1!==this.options.oneHalf&&e.push(Wg),!1!==this.options.plusMinus&&e.push(Gg),!1!==this.options.notEqual&&e.push(Jg),!1!==this.options.laquo&&e.push(Zg),!1!==this.options.raquo&&e.push(Xg),!1!==this.options.multiplication&&e.push(Qg),!1!==this.options.superscriptTwo&&e.push(Yg),!1!==this.options.superscriptThree&&e.push(ev),!1!==this.options.oneQuarter&&e.push(tv),!1!==this.options.threeQuarters&&e.push(nv),e}});function iv(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r);}return n}function ov(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?iv(Object(n),!0).forEach((function(t){cv(e,t,n[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):iv(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t));}));}return e}function sv(){
	/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
	sv=function(){return e};var e={},t=Object.prototype,n=t.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",s=r.toStringTag||"@@toStringTag";function a(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{a({},"");}catch(e){a=function(e,t,n){return e[t]=n};}function l(e,t,n,r){var i=t&&t.prototype instanceof d?t:d,o=Object.create(i.prototype),s=new E(r||[]);return o._invoke=function(e,t,n){var r="suspendedStart";return function(i,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw o;return S()}for(n.method=i,n.arg=o;;){var s=n.delegate;if(s){var a=w(s,n);if(a){if(a===u)continue;return a}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===r)throw r="completed",n.arg;n.dispatchException(n.arg);}else "return"===n.method&&n.abrupt("return",n.arg);r="executing";var l=c(e,t,n);if("normal"===l.type){if(r=n.done?"completed":"suspendedYield",l.arg===u)continue;return {value:l.arg,done:n.done}}"throw"===l.type&&(r="completed",n.method="throw",n.arg=l.arg);}}}(e,n,s),o}function c(e,t,n){try{return {type:"normal",arg:e.call(t,n)}}catch(e){return {type:"throw",arg:e}}}e.wrap=l;var u={};function d(){}function h(){}function p(){}var f={};a(f,i,(function(){return this}));var m=Object.getPrototypeOf,g=m&&m(m(x([])));g&&g!==t&&n.call(g,i)&&(f=g);var v=p.prototype=d.prototype=Object.create(f);function y(e){["next","throw","return"].forEach((function(t){a(e,t,(function(e){return this._invoke(t,e)}));}));}function b(e,t){function r(i,o,s,a){var l=c(e[i],e,o);if("throw"!==l.type){var u=l.arg,d=u.value;return d&&"object"==typeof d&&n.call(d,"__await")?t.resolve(d.__await).then((function(e){r("next",e,s,a);}),(function(e){r("throw",e,s,a);})):t.resolve(d).then((function(e){u.value=e,s(u);}),(function(e){return r("throw",e,s,a)}))}a(l.arg);}var i;this._invoke=function(e,n){function o(){return new t((function(t,i){r(e,n,t,i);}))}return i=i?i.then(o,o):o()};}function w(e,t){var n=e.iterator[t.method];if(void 0===n){if(t.delegate=null,"throw"===t.method){if(e.iterator.return&&(t.method="return",t.arg=void 0,w(e,t),"throw"===t.method))return u;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method");}return u}var r=c(n,e.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,u;var i=r.arg;return i?i.done?(t[e.resultName]=i.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,u):i:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,u)}function k(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t);}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t;}function E(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(k,this),this.reset(!0);}function x(e){if(e){var t=e[i];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,o=function t(){for(;++r<e.length;)if(n.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return o.next=o}}return {next:S}}function S(){return {value:void 0,done:!0}}return h.prototype=p,a(v,"constructor",p),a(p,"constructor",h),h.displayName=a(p,s,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return !!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,p):(e.__proto__=p,a(e,s,"GeneratorFunction")),e.prototype=Object.create(v),e},e.awrap=function(e){return {__await:e}},y(b.prototype),a(b.prototype,o,(function(){return this})),e.AsyncIterator=b,e.async=function(t,n,r,i,o){void 0===o&&(o=Promise);var s=new b(l(t,n,r,i),o);return e.isGeneratorFunction(n)?s:s.next().then((function(e){return e.done?e.value:s.next()}))},y(v),a(v,s,"Generator"),a(v,i,(function(){return this})),a(v,"toString",(function(){return "[object Generator]"})),e.keys=function(e){var t=[];for(var n in e)t.push(n);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},e.values=x,E.prototype={constructor:E,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(C),!e)for(var t in this)"t"===t.charAt(0)&&n.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0);},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(n,r){return s.type="throw",s.arg=e,t.next=n,r&&(t.method="next",t.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],s=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var a=n.call(o,"catchLoc"),l=n.call(o,"finallyLoc");if(a&&l){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else {if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===e||"continue"===e)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var s=o?o.completion:{};return s.type=e,s.arg=t,o?(this.method="next",this.next=o.finallyLoc,u):this.complete(s)},complete:function(e,t){if("throw"===e.type)throw e.arg;return "break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),u},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),C(n),u}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var i=r.arg;C(n);}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,n){return this.delegate={iterator:x(e),resultName:t,nextLoc:n},"next"===this.method&&(this.arg=void 0),u}},e}function av(e,t,n,r,i,o,s){try{var a=e[o](s),l=a.value;}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i);}function lv(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var o=e.apply(t,n);function s(e){av(o,r,i,s,a,"next",e);}function a(e){av(o,r,i,s,a,"throw",e);}s(void 0);}))}}function cv(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function uv(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,i,o=[],s=!0,a=!1;try{for(n=n.call(e);!(s=(r=n.next()).done)&&(o.push(r.value),!t||o.length!==t);s=!0);}catch(e){a=!0,i=e;}finally{try{s||null==n.return||n.return();}finally{if(a)throw i}}return o}(e,t)||hv(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function dv(e){return function(e){if(Array.isArray(e))return pv(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||hv(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function hv(e,t){if(e){if("string"==typeof e)return pv(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return "Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?pv(e,t):void 0}}function pv(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var fv=R,mv=ti,gv=/"/g,vv=E("".replace),yv=o,bv=function(e,t,n,r){var i=mv(fv(e)),o="<"+t;return ""!==n&&(o+=" "+n+'="'+vv(mv(r),gv,"&quot;")+'"'),o+">"+i+"</"+t+">"},wv=function(e){return yv((function(){var t=""[e]('"');return t!==t.toLowerCase()||t.split('"').length>3}))};function kv(e){this.j={},this.jr=[],this.jd=null,this.t=e;}Vr({target:"String",proto:!0,forced:wv("link")},{link:function(e){return bv(this,"a","href",e)}}),kv.prototype={accepts:function(){return !!this.t},tt:function(e,t){if(t&&t.j)return this.j[e]=t,t;var n=t,r=this.j[e];if(r)return n&&(r.t=n),r;r=Cv();var i=Dv(this,e);return i?(Object.assign(r.j,i.j),r.jr.append(i.jr),r.jr=i.jd,r.t=n||i.t):r.t=n,this.j[e]=r,r}};var Cv=function(){return new kv},Ev=function(e){return new kv(e)},xv=function(e,t,n){e.j[t]||(e.j[t]=n);},Sv=function(e,t,n){e.jr.push([t,n]);},Dv=function(e,t){var n=e.j[t];if(n)return n;for(var r=0;r<e.jr.length;r++){var i=e.jr[r][0],o=e.jr[r][1];if(i.test(t))return o}return e.jd},Mv=function(e,t,n){for(var r=0;r<t.length;r++)xv(e,t[r],n);},Ov=function(e,t){for(var n=0;n<t.length;n++){var r=t[n][0],i=t[n][1];xv(e,r,i);}},Av=function(e,t,n,r){for(var i,o=0,s=t.length;o<s&&(i=e.j[t[o]]);)e=i,o++;if(o>=s)return [];for(;o<s-1;)i=r(),xv(e,t[o],i),e=i,o++;xv(e,t[s-1],n);},Nv="DOMAIN",_v="TLD",Tv="NUM",Lv="AT",Rv="DOT",Fv="SLASH",Bv=Object.freeze({__proto__:null,DOMAIN:Nv,LOCALHOST:"LOCALHOST",TLD:_v,NUM:Tv,PROTOCOL:"PROTOCOL",MAILTO:"MAILTO",WS:"WS",NL:"NL",OPENBRACE:"OPENBRACE",OPENBRACKET:"OPENBRACKET",OPENANGLEBRACKET:"OPENANGLEBRACKET",OPENPAREN:"OPENPAREN",CLOSEBRACE:"CLOSEBRACE",CLOSEBRACKET:"CLOSEBRACKET",CLOSEANGLEBRACKET:"CLOSEANGLEBRACKET",CLOSEPAREN:"CLOSEPAREN",AMPERSAND:"AMPERSAND",APOSTROPHE:"APOSTROPHE",ASTERISK:"ASTERISK",AT:Lv,BACKSLASH:"BACKSLASH",BACKTICK:"BACKTICK",CARET:"CARET",COLON:"COLON",COMMA:"COMMA",DOLLAR:"DOLLAR",DOT:Rv,EQUALS:"EQUALS",EXCLAMATION:"EXCLAMATION",HYPHEN:"HYPHEN",PERCENT:"PERCENT",PIPE:"PIPE",PLUS:"PLUS",POUND:"POUND",QUERY:"QUERY",QUOTE:"QUOTE",SEMI:"SEMI",SLASH:Fv,TILDE:"TILDE",UNDERSCORE:"UNDERSCORE",SYM:"SYM"}),Iv="aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermögensberater-ctb vermögensberatung-pwb ελ ευ бг бел дети ею католик ком қаз мкд мон москва онлайн орг рус рф сайт срб укр გე հայ ישראל קום ابوظبي اتصالات ارامكو الاردن البحرين الجزائر السعودية العليان المغرب امارات ایران بارت بازار بھارت بيتك پاکستان ڀارت تونس سودان سورية شبكة عراق عرب عمان فلسطين قطر كاثوليك كوم مصر مليسيا موريتانيا موقع همراه कॉम नेट भारत भारतम् भारोत संगठन বাংলা ভারত ভাৰত ਭਾਰਤ ભારત ଭାରତ இந்தியா இலங்கை சிங்கப்பூர் భారత్ ಭಾರತ ഭാരതം ලංකා คอม ไทย ລາວ 닷넷 닷컴 삼성 한국 アマゾン グーグル クラウド コム ストア セール ファッション ポイント みんな 世界 中信 中国 中國 中文网 亚马逊 企业 佛山 信息 健康 八卦 公司 公益 台湾 台灣 商城 商店 商标 嘉里 嘉里大酒店 在线 大众汽车 大拿 天主教 娱乐 家電 广东 微博 慈善 我爱你 手机 招聘 政务 政府 新加坡 新闻 时尚 書籍 机构 淡马锡 游戏 澳門 点看 移动 组织机构 网址 网店 网站 网络 联通 诺基亚 谷歌 购物 通販 集团 電訊盈科 飞利浦 食品 餐厅 香格里拉 香港".split(" "),Pv=/(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,zv=/(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/,$v=/\uFE0F/,jv=/\d/,Hv=/\s/;function Vv(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=Cv(),n=Ev(Tv),r=Ev(Nv),i=Cv(),o=Ev("WS"),s=[[jv,r],[Pv,r],[zv,r],[$v,r]],a=function(){var e=Ev(Nv);return e.j={"-":i},e.jr=[].concat(s),e},l=function(e){var t=a();return t.t=e,t};Ov(t,[["'",Ev("APOSTROPHE")],["{",Ev("OPENBRACE")],["[",Ev("OPENBRACKET")],["<",Ev("OPENANGLEBRACKET")],["(",Ev("OPENPAREN")],["}",Ev("CLOSEBRACE")],["]",Ev("CLOSEBRACKET")],[">",Ev("CLOSEANGLEBRACKET")],[")",Ev("CLOSEPAREN")],["&",Ev("AMPERSAND")],["*",Ev("ASTERISK")],["@",Ev(Lv)],["`",Ev("BACKTICK")],["^",Ev("CARET")],[":",Ev("COLON")],[",",Ev("COMMA")],["$",Ev("DOLLAR")],[".",Ev(Rv)],["=",Ev("EQUALS")],["!",Ev("EXCLAMATION")],["-",Ev("HYPHEN")],["%",Ev("PERCENT")],["|",Ev("PIPE")],["+",Ev("PLUS")],["#",Ev("POUND")],["?",Ev("QUERY")],['"',Ev("QUOTE")],["/",Ev(Fv)],[";",Ev("SEMI")],["~",Ev("TILDE")],["_",Ev("UNDERSCORE")],["\\",Ev("BACKSLASH")]]),xv(t,"\n",Ev("NL")),Sv(t,Hv,o),xv(o,"\n",Cv()),Sv(o,Hv,o);for(var c=0;c<Iv.length;c++)Av(t,Iv[c],l(_v),a);var u=a(),d=a(),h=a(),p=a();Av(t,"file",u,a),Av(t,"ftp",d,a),Av(t,"http",h,a),Av(t,"mailto",p,a);var f=a(),m=Ev("PROTOCOL"),g=Ev("MAILTO");xv(d,"s",f),xv(d,":",m),xv(h,"s",f),xv(h,":",m),xv(u,":",m),xv(f,":",m),xv(p,":",g);for(var v=a(),y=0;y<e.length;y++)Av(t,e[y],v,a);return xv(v,":",m),Av(t,"localhost",l("LOCALHOST"),a),Sv(t,jv,n),Sv(t,Pv,r),Sv(t,zv,r),Sv(t,$v,r),Sv(n,jv,n),Sv(n,Pv,r),Sv(n,zv,r),Sv(n,$v,r),xv(n,"-",i),xv(r,"-",i),xv(i,"-",i),Sv(r,jv,r),Sv(r,Pv,r),Sv(r,zv,r),Sv(r,$v,r),Sv(i,jv,r),Sv(i,Pv,r),Sv(i,zv,r),Sv(i,$v,r),t.jd=Ev("SYM"),t}var Kv={defaultProtocol:"http",events:null,format:qv,formatHref:qv,nl2br:!1,tagName:"a",target:null,rel:null,validate:!0,truncate:0,className:null,attributes:null,ignoreTags:[]};function qv(e){return e}function Uv(){}function Wv(e,t){function n(t,n){this.t=e,this.v=t,this.tk=n;}return function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Object.create(e.prototype);for(var i in n)r[i]=n[i];r.constructor=t,t.prototype=r;}(Uv,n,t),n}Uv.prototype={t:"token",isLink:!1,toString:function(){return this.v},toHref:function(){return this.toString()},startIndex:function(){return this.tk[0].s},endIndex:function(){return this.tk[this.tk.length-1].e},toObject:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Kv.defaultProtocol;return {type:this.t,value:this.v,isLink:this.isLink,href:this.toHref(e),start:this.startIndex(),end:this.endIndex()}}};var Gv=Wv("email",{isLink:!0}),Jv=Wv("email",{isLink:!0,toHref:function(){return "mailto:"+this.toString()}}),Zv=Wv("text"),Xv=Wv("nl"),Qv=Wv("url",{isLink:!0,toHref:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Kv.defaultProtocol,t=this.tk,n=!1,r=!1,i=[],o=0;"PROTOCOL"===t[o].t;)n=!0,i.push(t[o].v),o++;for(;t[o].t===Fv;)r=!0,i.push(t[o].v),o++;for(;o<t.length;o++)i.push(t[o].v);return i=i.join(""),n||r||(i="".concat(e,"://").concat(i)),i},hasProtocol:function(){return "PROTOCOL"===this.tk[0].t}}),Yv=Object.freeze({__proto__:null,MultiToken:Uv,Base:Uv,createTokenClass:Wv,MailtoEmail:Gv,Email:Jv,Text:Zv,Nl:Xv,Url:Qv});function ey(){var e=Cv(),t=Cv(),n=Cv(),r=Cv(),i=Cv(),o=Cv(),s=Cv(),a=Ev(Qv),l=Cv(),c=Ev(Qv),u=Ev(Qv),d=Cv(),h=Cv(),p=Cv(),f=Cv(),m=Cv(),g=Ev(Qv),v=Ev(Qv),y=Ev(Qv),b=Ev(Qv),w=Cv(),k=Cv(),C=Cv(),E=Cv(),x=Cv(),S=Cv(),D=Ev(Jv),M=Cv(),O=Ev(Jv),A=Ev(Gv),N=Cv(),_=Cv(),T=Cv(),L=Cv(),R=Ev(Xv);xv(e,"NL",R),xv(e,"PROTOCOL",t),xv(e,"MAILTO",n),xv(t,Fv,r),xv(r,Fv,i),xv(e,_v,o),xv(e,Nv,o),xv(e,"LOCALHOST",a),xv(e,Tv,o),xv(i,_v,u),xv(i,Nv,u),xv(i,Tv,u),xv(i,"LOCALHOST",u),xv(o,Rv,s),xv(x,Rv,S),xv(s,_v,a),xv(s,Nv,o),xv(s,Tv,o),xv(s,"LOCALHOST",o),xv(S,_v,D),xv(S,Nv,x),xv(S,Tv,x),xv(S,"LOCALHOST",x),xv(a,Rv,s),xv(D,Rv,S),xv(a,"COLON",l),xv(a,Fv,u),xv(l,Tv,c),xv(c,Fv,u),xv(D,"COLON",M),xv(M,Tv,O);var F=["AMPERSAND","ASTERISK",Lv,"BACKSLASH","BACKTICK","CARET","DOLLAR",Nv,"EQUALS","HYPHEN","LOCALHOST",Tv,"PERCENT","PIPE","PLUS","POUND","PROTOCOL",Fv,"SYM","TILDE",_v,"UNDERSCORE"],B=["APOSTROPHE","CLOSEANGLEBRACKET","CLOSEBRACE","CLOSEBRACKET","CLOSEPAREN","COLON","COMMA",Rv,"EXCLAMATION","OPENANGLEBRACKET","OPENBRACE","OPENBRACKET","OPENPAREN","QUERY","QUOTE","SEMI"];xv(u,"OPENBRACE",h),xv(u,"OPENBRACKET",p),xv(u,"OPENANGLEBRACKET",f),xv(u,"OPENPAREN",m),xv(d,"OPENBRACE",h),xv(d,"OPENBRACKET",p),xv(d,"OPENANGLEBRACKET",f),xv(d,"OPENPAREN",m),xv(h,"CLOSEBRACE",u),xv(p,"CLOSEBRACKET",u),xv(f,"CLOSEANGLEBRACKET",u),xv(m,"CLOSEPAREN",u),xv(g,"CLOSEBRACE",u),xv(v,"CLOSEBRACKET",u),xv(y,"CLOSEANGLEBRACKET",u),xv(b,"CLOSEPAREN",u),xv(w,"CLOSEBRACE",u),xv(k,"CLOSEBRACKET",u),xv(C,"CLOSEANGLEBRACKET",u),xv(E,"CLOSEPAREN",u),Mv(h,F,g),Mv(p,F,v),Mv(f,F,y),Mv(m,F,b),Mv(h,B,w),Mv(p,B,k),Mv(f,B,C),Mv(m,B,E),Mv(g,F,g),Mv(v,F,v),Mv(y,F,y),Mv(b,F,b),Mv(g,B,g),Mv(v,B,v),Mv(y,B,y),Mv(b,B,b),Mv(w,F,g),Mv(k,F,v),Mv(C,F,y),Mv(E,F,b),Mv(w,B,w),Mv(k,B,k),Mv(C,B,C),Mv(E,B,E),Mv(u,F,u),Mv(d,F,u),Mv(u,B,d),Mv(d,B,d),xv(n,_v,A),xv(n,Nv,A),xv(n,Tv,A),xv(n,"LOCALHOST",A),Mv(A,F,A),Mv(A,B,N),Mv(N,F,A),Mv(N,B,N);var I=["AMPERSAND","APOSTROPHE","ASTERISK","BACKSLASH","BACKTICK","CARET","CLOSEBRACE","DOLLAR",Nv,"EQUALS","HYPHEN",Tv,"OPENBRACE","PERCENT","PIPE","PLUS","POUND","QUERY",Fv,"SYM","TILDE",_v,"UNDERSCORE"];return Mv(o,I,_),xv(o,Lv,T),Mv(a,I,_),xv(a,Lv,T),Mv(s,I,_),Mv(_,I,_),xv(_,Lv,T),xv(_,Rv,L),Mv(L,I,_),xv(T,_v,x),xv(T,Nv,x),xv(T,Tv,x),xv(T,"LOCALHOST",D),e}function ty(e,t,n){var r=n[0].s,i=n[n.length-1].e;return new e(t.substr(r,i-r),n)}var ny="undefined"!=typeof console&&console&&console.warn||function(){},ry={scanner:null,parser:null,pluginQueue:[],customProtocols:[],initialized:!1};function iy(e){if(ry.initialized&&ny('linkifyjs: already initialized - will not register custom protocol "'.concat(e,'" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')),!/^[a-z-]+$/.test(e))throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");ry.customProtocols.push(e);}function oy(e){return ry.initialized||function(){ry.scanner={start:Vv(ry.customProtocols),tokens:Bv},ry.parser={start:ey(),tokens:Yv};for(var e={createTokenClass:Wv},t=0;t<ry.pluginQueue.length;t++)ry.pluginQueue[t][1]({scanner:ry.scanner,parser:ry.parser,utils:e});ry.initialized=!0;}(),function(e,t,n){for(var r=n.length,i=0,o=[],s=[];i<r;){for(var a=e,l=null,c=null,u=0,d=null,h=-1;i<r&&!(l=Dv(a,n[i].t));)s.push(n[i++]);for(;i<r&&(c=l||Dv(a,n[i].t));)l=null,(a=c).accepts()?(h=0,d=a):h>=0&&h++,i++,u++;if(h<0)for(var p=i-u;p<i;p++)s.push(n[p]);else {s.length>0&&(o.push(ty(Zv,t,s)),s=[]),i-=h,u-=h;var f=d.t,m=n.slice(i-u,i);o.push(ty(f,t,m));}}return s.length>0&&o.push(ty(Zv,t,s)),o}(ry.parser.start,e,function(e,t){for(var n=function(e){for(var t=[],n=e.length,r=0;r<n;){var i=e.charCodeAt(r),o=void 0,s=i<55296||i>56319||r+1===n||(o=e.charCodeAt(r+1))<56320||o>57343?e[r]:e.slice(r,r+2);t.push(s),r+=s.length;}return t}(t.replace(/[A-Z]/g,(function(e){return e.toLowerCase()}))),r=n.length,i=[],o=0,s=0;s<r;){for(var a=e,l=null,c=0,u=null,d=-1,h=-1;s<r&&(l=Dv(a,n[s]));)(a=l).accepts()?(d=0,h=0,u=a):d>=0&&(d+=n[s].length,h++),c+=n[s].length,o+=n[s].length,s++;o-=d,s-=h,c-=d,i.push({t:u.t,v:t.substr(o-c,c),s:o-c,e:o});}return i}(ry.scanner.start,e))}function sy(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=oy(e),r=[],i=0;i<n.length;i++){var o=n[i];!o.isLink||t&&o.t!==t||r.push(o.toObject());}return r}function ay(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=oy(e);return 1===n.length&&n[0].isLink&&(!t||n[0].t===t)}function ly(e){return new Dl({key:new Al("autolink"),appendTransaction:(t,n,r)=>{const i=t.some((e=>e.docChanged))&&!n.doc.eq(r.doc),o=t.some((e=>e.getMeta("preventAutolink")));if(!i||o)return;const{tr:s}=r,a=function(e,t){const n=new ol(e);return t.forEach((e=>{e.steps.forEach((e=>{n.step(e);}));})),n}(n.doc,[...t]),{mapping:l}=a,c=function(e){const{mapping:t,steps:n}=e,r=[];return t.maps.forEach(((e,i)=>{const o=[];if(e.ranges.length)e.forEach(((e,t)=>{o.push({from:e,to:t});}));else {const{from:e,to:t}=n[i];if(void 0===e||void 0===t)return;o.push({from:e,to:t});}o.forEach((({from:e,to:n})=>{const o=t.slice(i).map(e,-1),s=t.slice(i).map(n),a=t.invert().map(o,-1),l=t.invert().map(s);r.push({oldRange:{from:a,to:l},newRange:{from:o,to:s}});}));})),fp(r)}(a);return c.forEach((({oldRange:t,newRange:i})=>{mp(t.from,t.to,n.doc).filter((t=>t.mark.type===e.type)).forEach((t=>{const i=mp(l.map(t.from),l.map(t.to),r.doc).filter((t=>t.mark.type===e.type));if(!i.length)return;const o=i[0],a=n.doc.textBetween(t.from,t.to,void 0," "),c=r.doc.textBetween(o.from,o.to,void 0," "),u=ay(a),d=ay(c);u&&!d&&s.removeMark(o.from,o.to,e.type);})),function(e,t,n){const r=[];return e.nodesBetween(t.from,t.to,((e,t)=>{n(e)&&r.push({node:e,pos:t});})),r}(r.doc,i,(e=>e.isTextblock)).forEach((t=>{sy(r.doc.textBetween(t.pos,t.pos+t.node.nodeSize,void 0," ")).filter((e=>e.isLink)).filter((t=>!e.validate||e.validate(t.value))).map((e=>({...e,from:t.pos+e.start+1,to:t.pos+e.end+1}))).filter((e=>{const t=i.from>=e.from&&i.from<=e.to,n=i.to>=e.from&&i.to<=e.to;return t||n})).forEach((t=>{s.addMark(t.from,t.to,e.type.create({href:t.href}));}));}));})),s.steps.length?s:void 0}})}const cy=Ep.create({name:"link",priority:1e3,keepOnSplit:!1,onCreate(){this.options.protocols.forEach(iy);},inclusive(){return this.options.autolink},addOptions:()=>({openOnClick:!0,linkOnPaste:!0,autolink:!0,protocols:[],HTMLAttributes:{target:"_blank",rel:"noopener noreferrer nofollow",class:null},validate:void 0}),addAttributes(){return {href:{default:null},target:{default:this.options.HTMLAttributes.target},class:{default:this.options.HTMLAttributes.class}}},parseHTML:()=>[{tag:'a[href]:not([href *= "javascript:" i])'}],renderHTML({HTMLAttributes:e}){return ["a",dh(this.options.HTMLAttributes,e),0]},addCommands(){return {setLink:e=>({chain:t})=>t().setMark(this.name,e).setMeta("preventAutolink",!0).run(),toggleLink:e=>({chain:t})=>t().toggleMark(this.name,e,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run(),unsetLink:()=>({chain:e})=>e().unsetMark(this.name,{extendEmptyMarkRange:!0}).setMeta("preventAutolink",!0).run()}},addPasteRules(){return [Sp({find:e=>sy(e).filter((e=>!this.options.validate||this.options.validate(e.value))).filter((e=>e.isLink)).map((e=>({text:e.value,index:e.start,data:e}))),type:this.type,getAttributes:e=>{var t;return {href:null===(t=e.data)||void 0===t?void 0:t.href}}})]},addProseMirrorPlugins(){const e=[];var t;return this.options.autolink&&e.push(ly({type:this.type,validate:this.options.validate})),this.options.openOnClick&&e.push((t={type:this.type},new Dl({key:new Al("handleClickLink"),props:{handleClick:(e,n,r)=>{var i;const o=hp(e.state,t.type.name);return !(!(null===(i=r.target)||void 0===i?void 0:i.closest("a"))||!o.href||(window.open(o.href,o.target),0))}}}))),this.options.linkOnPaste&&e.push(function(e){return new Dl({key:new Al("handlePasteLink"),props:{handlePaste:(t,n,r)=>{const{state:i}=t,{selection:o}=i,{empty:s}=o;if(s)return !1;let a="";r.content.forEach((e=>{a+=e.textContent;}));const l=sy(a).find((e=>e.isLink&&e.value===a));return !(!a||!l||(e.editor.commands.setMark(e.type,{href:l.href}),0))}}})}({editor:this.editor,type:this.type})),e}});var uy=[{value:"paper-link",label:"Normal link"},{value:"button",label:"Button primary"},{value:"button button-secondary",label:"Button secondary"},{value:"button button-tertiary",label:"Button tertiary"}],dy=cy.extend({defaultOptions:ov(ov({},cy.options),{},{openOnClick:!1,HTMLAttributes:{rel:null,class:null,title:null}}),addAttributes:function(){return ov(ov({},this.parent()),{},{class:{default:"paper-link"},title:{default:null}})},addProseMirrorPlugins:function(){return [new Dl({props:{handleClick:function(e,t){var n=Bh(e.state.doc.resolve(t),e.state.schema.marks.link);if(!n)return !1;var r=e.state.doc.resolve(n.from),i=e.state.doc.resolve(n.to),o=e.state.tr.setSelection(new dl(r,i));return e.dispatch(o),!0}}})]}});const hy=xp.create({name:"taskList",addOptions:()=>({itemTypeName:"taskItem",HTMLAttributes:{}}),group:"block list",content(){return `${this.options.itemTypeName}+`},parseHTML(){return [{tag:`ul[data-type="${this.name}"]`,priority:51}]},renderHTML({HTMLAttributes:e}){return ["ul",dh(this.options.HTMLAttributes,e,{"data-type":this.name}),0]},addCommands(){return {toggleTaskList:()=>({commands:e})=>e.toggleList(this.name,this.options.itemTypeName)}},addKeyboardShortcuts(){return {"Mod-Shift-9":()=>this.editor.commands.toggleTaskList()}}}),py=/^\s*(\[([( |x])?\])\s$/,fy=xp.create({name:"taskItem",addOptions:()=>({nested:!1,HTMLAttributes:{}}),content(){return this.options.nested?"paragraph block*":"paragraph+"},defining:!0,addAttributes:()=>({checked:{default:!1,keepOnSplit:!1,parseHTML:e=>"true"===e.getAttribute("data-checked"),renderHTML:e=>({"data-checked":e.checked})}}),parseHTML(){return [{tag:`li[data-type="${this.name}"]`,priority:51}]},renderHTML({node:e,HTMLAttributes:t}){return ["li",dh(this.options.HTMLAttributes,t,{"data-type":this.name}),["label",["input",{type:"checkbox",checked:e.attrs.checked?"checked":null}],["span"]],["div",0]]},addKeyboardShortcuts(){const e={Enter:()=>this.editor.commands.splitListItem(this.name),"Shift-Tab":()=>this.editor.commands.liftListItem(this.name)};return this.options.nested?{...e,Tab:()=>this.editor.commands.sinkListItem(this.name)}:e},addNodeView(){return ({node:e,HTMLAttributes:t,getPos:n,editor:r})=>{const i=document.createElement("li"),o=document.createElement("label"),s=document.createElement("span"),a=document.createElement("input"),l=document.createElement("div");return o.contentEditable="false",a.type="checkbox",a.addEventListener("change",(t=>{if(!r.isEditable&&!this.options.onReadOnlyChecked)return void(a.checked=!a.checked);const{checked:i}=t.target;r.isEditable&&"function"==typeof n&&r.chain().focus(void 0,{scrollIntoView:!1}).command((({tr:e})=>{const t=n(),r=e.doc.nodeAt(t);return e.setNodeMarkup(t,void 0,{...null==r?void 0:r.attrs,checked:i}),!0})).run(),!r.isEditable&&this.options.onReadOnlyChecked&&(this.options.onReadOnlyChecked(e,i)||(a.checked=!a.checked));})),Object.entries(this.options.HTMLAttributes).forEach((([e,t])=>{i.setAttribute(e,t);})),i.dataset.checked=e.attrs.checked,e.attrs.checked&&a.setAttribute("checked","checked"),o.append(a,s),i.append(o,l),Object.entries(t).forEach((([e,t])=>{i.setAttribute(e,t);})),{dom:i,contentDOM:l,update:e=>e.type===this.type&&(i.dataset.checked=e.attrs.checked,e.attrs.checked?a.setAttribute("checked","checked"):a.removeAttribute("checked"),!0)}}},addInputRules(){return [Cp({find:py,type:this.type,getAttributes:e=>({checked:"x"===e[e.length-1]})})]}});var my=M,gy=Array.isArray||function(e){return "Array"==my(e)},vy=TypeError,yy=st,by=Ct,wy=v,ky=function(e,t,n){var r=yy(t);r in e?by.f(e,r,wy(0,n)):e[r]=n;},Cy=E,Ey=o,xy=P,Sy=Qr,Dy=Qt,My=function(){},Oy=[],Ay=K("Reflect","construct"),Ny=/^\s*(?:class|function)\b/,_y=Cy(Ny.exec),Ty=!Ny.exec(My),Ly=function(e){if(!xy(e))return !1;try{return Ay(My,Oy,e),!0}catch(e){return !1}},Ry=function(e){if(!xy(e))return !1;switch(Sy(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return !1}try{return Ty||!!_y(Ny,Dy(e))}catch(e){return !0}};Ry.sham=!0;var Fy=!Ay||Ey((function(){var e;return Ly(Ly.call)||!Ly(Object)||!Ly((function(){e=!0;}))||e}))?Ry:Ly,By=gy,Iy=Fy,Py=$,zy=Je("species"),$y=Array,jy=function(e){var t;return By(e)&&(t=e.constructor,(Iy(t)&&(t===$y||By(t.prototype))||Py(t)&&null===(t=t[zy]))&&(t=void 0)),void 0===t?$y:t},Hy=function(e,t){return new(jy(e))(0===t?0:t)},Vy=o,Ky=Y,qy=Je("species"),Uy=function(e){return Ky>=51||!Vy((function(){var t=[];return (t.constructor={})[qy]=function(){return {foo:1}},1!==t[e](Boolean).foo}))},Wy=Vr,Gy=o,Jy=gy,Zy=$,Xy=Ne,Qy=tr,Yy=function(e){if(e>9007199254740991)throw vy("Maximum allowed index exceeded");return e},eb=ky,tb=Hy,nb=Uy,rb=Y,ib=Je("isConcatSpreadable"),ob=rb>=51||!Gy((function(){var e=[];return e[ib]=!1,e.concat()[0]!==e})),sb=nb("concat"),ab=function(e){if(!Zy(e))return !1;var t=e[ib];return void 0!==t?!!t:Jy(e)};Wy({target:"Array",proto:!0,arity:1,forced:!ob||!sb},{concat:function(e){var t,n,r,i,o,s=Xy(this),a=tb(s,0),l=0;for(t=-1,r=arguments.length;t<r;t++)if(ab(o=-1===t?s:arguments[t]))for(i=Qy(o),Yy(l+i),n=0;n<i;n++,l++)n in o&&eb(a,l,o[n]);else Yy(l+1),eb(a,l++,o);return a.length=l,a}});var lb=fe,cb=a,ub=E(E.bind),db=function(e,t){return lb(e),void 0===t?e:cb?ub(e,t):function(){return e.apply(t,arguments)}},hb=db,pb=T,fb=Ne,mb=tr,gb=Hy,vb=E([].push),yb=function(e){var t=1==e,n=2==e,r=3==e,i=4==e,o=6==e,s=7==e,a=5==e||o;return function(l,c,u,d){for(var h,p,f=fb(l),m=pb(f),g=hb(c,u),v=mb(m),y=0,b=d||gb,w=t?b(l,v):n||s?b(l,0):void 0;v>y;y++)if((a||y in m)&&(p=g(h=m[y],y,f),e))if(t)w[y]=p;else if(p)switch(e){case 3:return !0;case 5:return h;case 6:return y;case 2:vb(w,h);}else switch(e){case 4:return !1;case 7:vb(w,h);}return o?-1:r||i?i:w}},bb={forEach:yb(0),map:yb(1),filter:yb(2),some:yb(3),every:yb(4),find:yb(5),findIndex:yb(6),filterReject:yb(7)},wb=o,kb=function(e,t){var n=[][e];return !!n&&wb((function(){n.call(null,t||function(){return 1},1);}))},Cb=bb.forEach,Eb=kb("forEach")?[].forEach:function(e){return Cb(this,e,arguments.length>1?arguments[1]:void 0)};Vr({target:"Array",proto:!0,forced:[].forEach!=Eb},{forEach:Eb});var xb=Qr,Sb=qr?{}.toString:function(){return "[object "+xb(this)+"]"};qr||Hn(Object.prototype,"toString",Sb,{unsafe:!0});var Db=ut("span").classList,Mb=Db&&Db.constructor&&Db.constructor.prototype,Ob=r,Ab={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Nb=Mb===Object.prototype?void 0:Mb,_b=Eb,Tb=Pt,Lb=function(e){if(e&&e.forEach!==_b)try{Tb(e,"forEach",_b);}catch(t){e.forEach=_b;}};for(var Rb in Ab)Ab[Rb]&&Lb(Ob[Rb]&&Ob[Rb].prototype);let Fb,Bb;if(Lb(Nb),"undefined"!=typeof WeakMap){let e=new WeakMap;Fb=t=>e.get(t),Bb=(t,n)=>(e.set(t,n),n);}else {let e=[],t=10,n=0;Fb=t=>{for(let n=0;n<e.length;n+=2)if(e[n]==t)return e[n+1]},Bb=(r,i)=>(n==t&&(n=0),e[n++]=r,e[n++]=i);}class Ib{constructor(e,t,n,r){this.left=e,this.top=t,this.right=n,this.bottom=r;}}class Pb{constructor(e,t,n,r){this.width=e,this.height=t,this.map=n,this.problems=r;}findCell(e){for(let t=0;t<this.map.length;t++){let n=this.map[t];if(n!=e)continue;let r=t%this.width,i=t/this.width|0,o=r+1,s=i+1;for(let e=1;o<this.width&&this.map[t+e]==n;e++)o++;for(let e=1;s<this.height&&this.map[t+this.width*e]==n;e++)s++;return new Ib(r,i,o,s)}throw new RangeError("No cell with offset "+e+" found")}colCount(e){for(let t=0;t<this.map.length;t++)if(this.map[t]==e)return t%this.width;throw new RangeError("No cell with offset "+e+" found")}nextCell(e,t,n){let{left:r,right:i,top:o,bottom:s}=this.findCell(e);return "horiz"==t?(n<0?0==r:i==this.width)?null:this.map[o*this.width+(n<0?r-1:i)]:(n<0?0==o:s==this.height)?null:this.map[r+this.width*(n<0?o-1:s)]}rectBetween(e,t){let{left:n,right:r,top:i,bottom:o}=this.findCell(e),{left:s,right:a,top:l,bottom:c}=this.findCell(t);return new Ib(Math.min(n,s),Math.min(i,l),Math.max(r,a),Math.max(o,c))}cellsInRect(e){let t=[],n={};for(let r=e.top;r<e.bottom;r++)for(let i=e.left;i<e.right;i++){let o=r*this.width+i,s=this.map[o];n[s]||(n[s]=!0,i==e.left&&i&&this.map[o-1]==s||r==e.top&&r&&this.map[o-this.width]==s||t.push(s));}return t}positionAt(e,t,n){for(let r=0,i=0;;r++){let o=i+n.child(r).nodeSize;if(r==e){let n=t+e*this.width,r=(e+1)*this.width;for(;n<r&&this.map[n]<i;)n++;return n==r?o-1:this.map[n]}i=o;}}static get(e){return Fb(e)||Bb(e,function(e){if("table"!=e.type.spec.tableRole)throw new RangeError("Not a table node: "+e.type.name);let t=function(e){let t=-1,n=!1;for(let r=0;r<e.childCount;r++){let i=e.child(r),o=0;if(n)for(let t=0;t<r;t++){let n=e.child(t);for(let e=0;e<n.childCount;e++){let i=n.child(e);t+i.attrs.rowspan>r&&(o+=i.attrs.colspan);}}for(let e=0;e<i.childCount;e++){let t=i.child(e);o+=t.attrs.colspan,t.attrs.rowspan>1&&(n=!0);}-1==t?t=o:t!=o&&(t=Math.max(t,o));}return t}(e),n=e.childCount,r=[],i=0,o=null,s=[];for(let e=0,i=t*n;e<i;e++)r[e]=0;for(let a=0,l=0;a<n;a++){let c=e.child(a);l++;for(let e=0;;e++){for(;i<r.length&&0!=r[i];)i++;if(e==c.childCount)break;let u=c.child(e),{colspan:d,rowspan:h,colwidth:p}=u.attrs;for(let e=0;e<h;e++){if(e+a>=n){(o||(o=[])).push({type:"overlong_rowspan",pos:l,n:h-e});break}let c=i+e*t;for(let e=0;e<d;e++){0==r[c+e]?r[c+e]=l:(o||(o=[])).push({type:"collision",row:a,pos:l,n:d-e});let n=p&&p[e];if(n){let r=(c+e)%t*2,i=s[r];null==i||i!=n&&1==s[r+1]?(s[r]=n,s[r+1]=1):i==n&&s[r+1]++;}}}i+=d,l+=u.nodeSize;}let u=(a+1)*t,d=0;for(;i<u;)0==r[i++]&&d++;d&&(o||(o=[])).push({type:"missing",row:a,n:d}),l++;}let a=new Pb(t,n,r,o),l=!1;for(let e=0;!l&&e<s.length;e+=2)null!=s[e]&&s[e+1]<n&&(l=!0);l&&function(e,t,n){e.problems||(e.problems=[]);for(let r=0,i={};r<e.map.length;r++){let o=e.map[r];if(i[o])continue;i[o]=!0;let s=n.nodeAt(o),a=null;for(let n=0;n<s.attrs.colspan;n++){let i=t[2*((r+n)%e.width)];null==i||s.attrs.colwidth&&s.attrs.colwidth[n]==i||((a||(a=zb(s.attrs)))[n]=i);}a&&e.problems.unshift({type:"colwidth mismatch",pos:o,colwidth:a});}}(a,s,e);return a}(e))}}function zb(e){if(e.colwidth)return e.colwidth.slice();let t=[];for(let n=0;n<e.colspan;n++)t.push(0);return t}function $b(e){let t=e.cached.tableNodeTypes;if(!t){t=e.cached.tableNodeTypes={};for(let n in e.nodes){let r=e.nodes[n],i=r.spec.tableRole;i&&(t[i]=r);}}return t}const jb=new Al("selectingCells");function Hb(e){for(let t=e.depth-1;t>0;t--)if("row"==e.node(t).type.spec.tableRole)return e.node(0).resolve(e.before(t+1));return null}function Vb(e){let t=e.selection.$head;for(let e=t.depth;e>0;e--)if("row"==t.node(e).type.spec.tableRole)return !0;return !1}function Kb(e){let t=e.selection;return t.$anchorCell?t.$anchorCell.pos>t.$headCell.pos?t.$anchorCell:t.$headCell:t.node&&"cell"==t.node.type.spec.tableRole?t.$anchor:Hb(t.$head)||function(e){for(let t=e.nodeAfter,n=e.pos;t;t=t.firstChild,n++){let r=t.type.spec.tableRole;if("cell"==r||"header_cell"==r)return e.doc.resolve(n)}for(let t=e.nodeBefore,n=e.pos;t;t=t.lastChild,n--){let r=t.type.spec.tableRole;if("cell"==r||"header_cell"==r)return e.doc.resolve(n-t.nodeSize)}}(t.$head)}function qb(e){return "row"==e.parent.type.spec.tableRole&&e.nodeAfter}function Ub(e,t){return e.depth==t.depth&&e.pos>=t.start(-1)&&e.pos<=t.end(-1)}function Wb(e,t,n){let r=e.start(-1),i=Pb.get(e.node(-1)).nextCell(e.pos-r,t,n);return null==i?null:e.node(0).resolve(r+i)}function Gb(e,t,n){let r={};for(let t in e)r[t]=e[t];return r[t]=n,r}function Jb(e,t,n=1){let r=Gb(e,"colspan",e.colspan-n);return r.colwidth&&(r.colwidth=r.colwidth.slice(),r.colwidth.splice(t,n),r.colwidth.some((e=>e>0))||(r.colwidth=null)),r}function Zb(e,t,n=1){let r=Gb(e,"colspan",e.colspan+n);if(r.colwidth){r.colwidth=r.colwidth.slice();for(let e=0;e<n;e++)r.colwidth.splice(t,0,0);}return r}class Xb extends al{constructor(e,t=e){let n=e.node(-1),r=Pb.get(n),i=e.start(-1),o=r.rectBetween(e.pos-i,t.pos-i),s=e.node(0),a=r.cellsInRect(o).filter((e=>e!=t.pos-i));a.unshift(t.pos-i);let l=a.map((e=>{let t=n.nodeAt(e),r=e+i+1;return new ll(s.resolve(r),s.resolve(r+t.content.size))}));super(l[0].$from,l[0].$to,l),this.$anchorCell=e,this.$headCell=t;}map(e,t){let n=e.resolve(t.map(this.$anchorCell.pos)),r=e.resolve(t.map(this.$headCell.pos));if(qb(n)&&qb(r)&&Ub(n,r)){let e=this.$anchorCell.node(-1)!=n.node(-1);return e&&this.isRowSelection()?Xb.rowSelection(n,r):e&&this.isColSelection()?Xb.colSelection(n,r):new Xb(n,r)}return dl.between(n,r)}content(){let e=this.$anchorCell.node(-1),t=Pb.get(e),n=this.$anchorCell.start(-1),r=t.rectBetween(this.$anchorCell.pos-n,this.$headCell.pos-n),i={},o=[];for(let n=r.top;n<r.bottom;n++){let s=[];for(let o=n*t.width+r.left,a=r.left;a<r.right;a++,o++){let n=t.map[o];if(!i[n]){i[n]=!0;let o=t.findCell(n),a=e.nodeAt(n),l=r.left-o.left,c=o.right-r.right;if(l>0||c>0){let e=a.attrs;l>0&&(e=Jb(e,0,l)),c>0&&(e=Jb(e,e.colspan-c,c)),a=o.left<r.left?a.type.createAndFill(e):a.type.create(e,a.content);}if(o.top<r.top||o.bottom>r.bottom){let e=Gb(a.attrs,"rowspan",Math.min(o.bottom,r.bottom)-Math.max(o.top,r.top));a=o.top<r.top?a.type.createAndFill(e):a.type.create(e,a.content);}s.push(a);}}o.push(e.child(n).copy(Cs.from(s)));}const s=this.isColSelection()&&this.isRowSelection()?e:o;return new Os(Cs.from(s),1,1)}replace(e,t=Os.empty){let n=e.steps.length,r=this.ranges;for(let i=0;i<r.length;i++){let{$from:o,$to:s}=r[i],a=e.mapping.slice(n);e.replace(a.map(o.pos),a.map(s.pos),i?Os.empty:t);}let i=al.findFrom(e.doc.resolve(e.mapping.slice(n).map(this.to)),-1);i&&e.setSelection(i);}replaceWith(e,t){this.replace(e,new Os(Cs.from(t),0,0));}forEachCell(e){let t=this.$anchorCell.node(-1),n=Pb.get(t),r=this.$anchorCell.start(-1),i=n.cellsInRect(n.rectBetween(this.$anchorCell.pos-r,this.$headCell.pos-r));for(let n=0;n<i.length;n++)e(t.nodeAt(i[n]),r+i[n]);}isColSelection(){let e=this.$anchorCell.index(-1),t=this.$headCell.index(-1);if(Math.min(e,t)>0)return !1;let n=e+this.$anchorCell.nodeAfter.attrs.rowspan,r=t+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(n,r)==this.$headCell.node(-1).childCount}static colSelection(e,t=e){let n=Pb.get(e.node(-1)),r=e.start(-1),i=n.findCell(e.pos-r),o=n.findCell(t.pos-r),s=e.node(0);return i.top<=o.top?(i.top>0&&(e=s.resolve(r+n.map[i.left])),o.bottom<n.height&&(t=s.resolve(r+n.map[n.width*(n.height-1)+o.right-1]))):(o.top>0&&(t=s.resolve(r+n.map[o.left])),i.bottom<n.height&&(e=s.resolve(r+n.map[n.width*(n.height-1)+i.right-1]))),new Xb(e,t)}isRowSelection(){let e=Pb.get(this.$anchorCell.node(-1)),t=this.$anchorCell.start(-1),n=e.colCount(this.$anchorCell.pos-t),r=e.colCount(this.$headCell.pos-t);if(Math.min(n,r)>0)return !1;let i=n+this.$anchorCell.nodeAfter.attrs.colspan,o=r+this.$headCell.nodeAfter.attrs.colspan;return Math.max(i,o)==e.width}eq(e){return e instanceof Xb&&e.$anchorCell.pos==this.$anchorCell.pos&&e.$headCell.pos==this.$headCell.pos}static rowSelection(e,t=e){let n=Pb.get(e.node(-1)),r=e.start(-1),i=n.findCell(e.pos-r),o=n.findCell(t.pos-r),s=e.node(0);return i.left<=o.left?(i.left>0&&(e=s.resolve(r+n.map[i.top*n.width])),o.right<n.width&&(t=s.resolve(r+n.map[n.width*(o.top+1)-1]))):(o.left>0&&(t=s.resolve(r+n.map[o.top*n.width])),i.right<n.width&&(e=s.resolve(r+n.map[n.width*(i.top+1)-1]))),new Xb(e,t)}toJSON(){return {type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}}static fromJSON(e,t){return new Xb(e.resolve(t.anchor),e.resolve(t.head))}static create(e,t,n=t){return new Xb(e.resolve(t),e.resolve(n))}getBookmark(){return new Qb(this.$anchorCell.pos,this.$headCell.pos)}}Xb.prototype.visible=!1,al.jsonID("cell",Xb);class Qb{constructor(e,t){this.anchor=e,this.head=t;}map(e){return new Qb(e.map(this.anchor),e.map(this.head))}resolve(e){let t=e.resolve(this.anchor),n=e.resolve(this.head);return "row"==t.parent.type.spec.tableRole&&"row"==n.parent.type.spec.tableRole&&t.index()<t.parent.childCount&&n.index()<n.parent.childCount&&Ub(t,n)?new Xb(t,n):al.near(n,1)}}function Yb(e){if(!(e.selection instanceof Xb))return null;let t=[];return e.selection.forEachCell(((e,n)=>{t.push(od.node(n,n+e.nodeSize,{class:"selectedCell"}));})),ld.create(e.doc,t)}function ew(e){if(!e.size)return null;let{content:t,openStart:n,openEnd:r}=e;for(;1==t.childCount&&(n>0&&r>0||"table"==t.firstChild.type.spec.tableRole);)n--,r--,t=t.firstChild.content;let i=t.firstChild,o=i.type.spec.tableRole,s=i.type.schema,a=[];if("row"==o)for(let e=0;e<t.childCount;e++){let i=t.child(e).content,o=e?0:Math.max(0,n-1),l=e<t.childCount-1?0:Math.max(0,r-1);(o||l)&&(i=tw($b(s).row,new Os(i,o,l)).content),a.push(i);}else {if("cell"!=o&&"header_cell"!=o)return null;a.push(n||r?tw($b(s).row,new Os(t,n,r)).content:t);}return function(e,t){let n=[];for(let e=0;e<t.length;e++){let r=t[e];for(let t=r.childCount-1;t>=0;t--){let{rowspan:i,colspan:o}=r.child(t).attrs;for(let t=e;t<e+i;t++)n[t]=(n[t]||0)+o;}}let r=0;for(let e=0;e<n.length;e++)r=Math.max(r,n[e]);for(let i=0;i<n.length;i++)if(i>=t.length&&t.push(Cs.empty),n[i]<r){let o=$b(e).cell.createAndFill(),s=[];for(let e=n[i];e<r;e++)s.push(o);t[i]=t[i].append(Cs.from(s));}return {height:t.length,width:r,rows:t}}(s,a)}function tw(e,t){let n=e.createAndFill();return new ol(n).replace(0,n.content.size,t).doc}function nw(e,t,n,r,i,o,s,a){if(0==s||s==t.height)return !1;let l=!1;for(let c=i;c<o;c++){let i=s*t.width+c,o=t.map[i];if(t.map[i-t.width]==o){l=!0;let i=n.nodeAt(o),{top:u,left:d}=t.findCell(o);e.setNodeMarkup(e.mapping.slice(a).map(o+r),null,Gb(i.attrs,"rowspan",s-u)),e.insert(e.mapping.slice(a).map(t.positionAt(s,d,n)),i.type.createAndFill(Gb(i.attrs,"rowspan",u+i.attrs.rowspan-s))),c+=i.attrs.colspan-1;}}return l}function rw(e,t,n,r,i,o,s,a){if(0==s||s==t.width)return !1;let l=!1;for(let c=i;c<o;c++){let i=c*t.width+s,o=t.map[i];if(t.map[i-1]==o){l=!0;let i=n.nodeAt(o),u=t.colCount(o),d=e.mapping.slice(a).map(o+r);e.setNodeMarkup(d,null,Jb(i.attrs,s-u,i.attrs.colspan-(s-u))),e.insert(d+i.nodeSize,i.type.createAndFill(Jb(i.attrs,0,s-u))),c+=i.attrs.rowspan-1;}}return l}function iw(e,t,n,r,i){let o=n?e.doc.nodeAt(n-1):e.doc,s=Pb.get(o),{top:a,left:l}=r,c=l+i.width,u=a+i.height,d=e.tr,h=0;function p(){o=n?d.doc.nodeAt(n-1):d.doc,s=Pb.get(o),h=d.mapping.maps.length;}((function(e,t,n,r,i,o,s){let a,l,c=$b(e.doc.type.schema);if(i>t.width)for(let o=0,u=0;o<t.height;o++){let d=n.child(o);u+=d.nodeSize;let h,p=[];h=null==d.lastChild||d.lastChild.type==c.cell?a||(a=c.cell.createAndFill()):l||(l=c.header_cell.createAndFill());for(let e=t.width;e<i;e++)p.push(h);e.insert(e.mapping.slice(s).map(u-1+r),p);}if(o>t.height){let u=[];for(let e=0,r=(t.height-1)*t.width;e<Math.max(t.width,i);e++){let i=!(e>=t.width)&&n.nodeAt(t.map[r+e]).type==c.header_cell;u.push(i?l||(l=c.header_cell.createAndFill()):a||(a=c.cell.createAndFill()));}let d=c.row.create(null,Cs.from(u)),h=[];for(let e=t.height;e<o;e++)h.push(d);e.insert(e.mapping.slice(s).map(r+n.nodeSize-2),h);}return !(!a&&!l)}))(d,s,o,n,c,u,h)&&p(),nw(d,s,o,n,l,c,a,h)&&p(),nw(d,s,o,n,l,c,u,h)&&p(),rw(d,s,o,n,a,u,l,h)&&p(),rw(d,s,o,n,a,u,c,h)&&p();for(let e=a;e<u;e++){let t=s.positionAt(e,l,o),r=s.positionAt(e,c,o);d.replace(d.mapping.slice(h).map(t+n),d.mapping.slice(h).map(r+n),new Os(i.rows[e-a],0,0));}p(),d.setSelection(new Xb(d.doc.resolve(n+s.positionAt(a,l,o)),d.doc.resolve(n+s.positionAt(u-1,c-1,o)))),t(d);}const ow=Wd({ArrowLeft:aw("horiz",-1),ArrowRight:aw("horiz",1),ArrowUp:aw("vert",-1),ArrowDown:aw("vert",1),"Shift-ArrowLeft":lw("horiz",-1),"Shift-ArrowRight":lw("horiz",1),"Shift-ArrowUp":lw("vert",-1),"Shift-ArrowDown":lw("vert",1),Backspace:cw,"Mod-Backspace":cw,Delete:cw,"Mod-Delete":cw});function sw(e,t,n){return !n.eq(e.selection)&&(t&&t(e.tr.setSelection(n).scrollIntoView()),!0)}function aw(e,t){return (n,r,i)=>{let o=n.selection;if(o instanceof Xb)return sw(n,r,al.near(o.$headCell,t));if("horiz"!=e&&!o.empty)return !1;let s=pw(i,e,t);if(null==s)return !1;if("horiz"==e)return sw(n,r,al.near(n.doc.resolve(o.head+t),t));{let i,o=n.doc.resolve(s),a=Wb(o,e,t);return i=a?al.near(a,1):t<0?al.near(n.doc.resolve(o.before(-1)),-1):al.near(n.doc.resolve(o.after(-1)),1),sw(n,r,i)}}}function lw(e,t){return (n,r,i)=>{let o=n.selection;if(!(o instanceof Xb)){let r=pw(i,e,t);if(null==r)return !1;o=new Xb(n.doc.resolve(r));}let s=Wb(o.$headCell,e,t);return !!s&&sw(n,r,new Xb(o.$anchorCell,s))}}function cw(e,t){let n=e.selection;if(!(n instanceof Xb))return !1;if(t){let r=e.tr,i=$b(e.schema).cell.createAndFill().content;n.forEachCell(((e,t)=>{e.content.eq(i)||r.replace(r.mapping.map(t+1),r.mapping.map(t+e.nodeSize-1),new Os(i,0,0));})),r.docChanged&&t(r);}return !0}function uw(e,t){let n=Hb(e.state.doc.resolve(t));return !!n&&(e.dispatch(e.state.tr.setSelection(new Xb(n))),!0)}function dw(e,t,n){if(!Vb(e.state))return !1;let r=ew(n),i=e.state.selection;if(i instanceof Xb){r||(r={width:1,height:1,rows:[Cs.from(tw($b(e.state.schema).cell,n))]});let t=i.$anchorCell.node(-1),o=i.$anchorCell.start(-1),s=Pb.get(t).rectBetween(i.$anchorCell.pos-o,i.$headCell.pos-o);return r=function({width:e,height:t,rows:n},r,i){if(e!=r){let t=[],i=[];for(let e=0;e<n.length;e++){let o=n[e],s=[];for(let n=t[e]||0,i=0;n<r;i++){let a=o.child(i%o.childCount);n+a.attrs.colspan>r&&(a=a.type.create(Jb(a.attrs,a.attrs.colspan,n+a.attrs.colspan-r),a.content)),s.push(a),n+=a.attrs.colspan;for(let n=1;n<a.attrs.rowspan;n++)t[e+n]=(t[e+n]||0)+a.attrs.colspan;}i.push(Cs.from(s));}n=i,e=r;}if(t!=i){let e=[];for(let r=0,o=0;r<i;r++,o++){let s=[],a=n[o%t];for(let e=0;e<a.childCount;e++){let t=a.child(e);r+t.attrs.rowspan>i&&(t=t.type.create(Gb(t.attrs,"rowspan",Math.max(1,i-t.attrs.rowspan)),t.content)),s.push(t);}e.push(Cs.from(s));}n=e,t=i;}return {width:e,height:t,rows:n}}(r,s.right-s.left,s.bottom-s.top),iw(e.state,e.dispatch,o,s,r),!0}if(r){let t=Kb(e.state),n=t.start(-1);return iw(e.state,e.dispatch,n,Pb.get(t.node(-1)).findCell(t.pos-n),r),!0}return !1}function hw(e,t){if(t.ctrlKey||t.metaKey)return;let n,r=fw(e,t.target);if(t.shiftKey&&e.state.selection instanceof Xb)i(e.state.selection.$anchorCell,t),t.preventDefault();else if(t.shiftKey&&r&&null!=(n=Hb(e.state.selection.$anchor))&&mw(e,t).pos!=n.pos)i(n,t),t.preventDefault();else if(!r)return;function i(t,n){let r=mw(e,n),i=null==jb.getState(e.state);if(!r||!Ub(t,r)){if(!i)return;r=t;}let o=new Xb(t,r);if(i||!e.state.selection.eq(o)){let n=e.state.tr.setSelection(o);i&&n.setMeta(jb,t.pos),e.dispatch(n);}}function o(){e.root.removeEventListener("mouseup",o),e.root.removeEventListener("dragstart",o),e.root.removeEventListener("mousemove",s),null!=jb.getState(e.state)&&e.dispatch(e.state.tr.setMeta(jb,-1));}function s(n){let s,a=jb.getState(e.state);if(null!=a)s=e.state.doc.resolve(a);else if(fw(e,n.target)!=r&&(s=mw(e,t),!s))return o();s&&i(s,n);}e.root.addEventListener("mouseup",o),e.root.addEventListener("dragstart",o),e.root.addEventListener("mousemove",s);}function pw(e,t,n){if(!(e.state.selection instanceof dl))return null;let{$head:r}=e.state.selection;for(let i=r.depth-1;i>=0;i--){let o=r.node(i);if((n<0?r.index(i):r.indexAfter(i))!=(n<0?0:o.childCount))return null;if("cell"==o.type.spec.tableRole||"header_cell"==o.type.spec.tableRole){let o=r.before(i),s="vert"==t?n>0?"down":"up":n>0?"right":"left";return e.endOfTextblock(s)?o:null}}return null}function fw(e,t){for(;t&&t!=e.dom;t=t.parentNode)if("TD"==t.nodeName||"TH"==t.nodeName)return t}function mw(e,t){let n=e.posAtCoords({left:t.clientX,top:t.clientY});return n&&n?Hb(e.state.doc.resolve(n.pos)):null}const gw=new Al("fix-tables");function vw(e,t,n,r){let i=e.childCount,o=t.childCount;e:for(let s=0,a=0;s<o;s++){let o=t.child(s);for(let t=a,r=Math.min(i,s+3);t<r;t++)if(e.child(t)==o){a=t+1,n+=o.nodeSize;continue e}r(o,n),a<i&&e.child(a).sameMarkup(o)?vw(e.child(a),o,n+1,r):o.nodesBetween(0,o.content.size,r,n+1),n+=o.nodeSize;}}function yw(e,t){let n,r=(t,r)=>{"table"==t.type.spec.tableRole&&(n=function(e,t,n,r){let i=Pb.get(t);if(!i.problems)return r;r||(r=e.tr);let o,s,a=[];for(let e=0;e<i.height;e++)a.push(0);for(let e=0;e<i.problems.length;e++){let o=i.problems[e];if("collision"==o.type){let e=t.nodeAt(o.pos);for(let t=0;t<e.attrs.rowspan;t++)a[o.row+t]+=o.n;r.setNodeMarkup(r.mapping.map(n+1+o.pos),null,Jb(e.attrs,e.attrs.colspan-o.n,o.n));}else if("missing"==o.type)a[o.row]+=o.n;else if("overlong_rowspan"==o.type){let e=t.nodeAt(o.pos);r.setNodeMarkup(r.mapping.map(n+1+o.pos),null,Gb(e.attrs,"rowspan",e.attrs.rowspan-o.n));}else if("colwidth mismatch"==o.type){let e=t.nodeAt(o.pos);r.setNodeMarkup(r.mapping.map(n+1+o.pos),null,Gb(e.attrs,"colwidth",o.colwidth));}}for(let e=0;e<a.length;e++)a[e]&&(null==o&&(o=e),s=e);for(let l=0,c=n+1;l<i.height;l++){let n=t.child(l),i=c+n.nodeSize,u=a[l];if(u>0){let t="cell";n.firstChild&&(t=n.firstChild.type.spec.tableRole);let a=[];for(let n=0;n<u;n++)a.push($b(e.schema)[t].createAndFill());let d=0!=l&&o!=l-1||s!=l?i-1:c+1;r.insert(r.mapping.map(d),a);}c=i;}return r.setMeta(gw,{fixTables:!0})}(e,t,r,n));};return t?t.doc!=e.doc&&vw(t.doc,e.doc,0,r):e.doc.descendants(r),n}function bw(e){let t,n=e.selection,r=Kb(e),i=r.node(-1),o=r.start(-1),s=Pb.get(i);return t=n instanceof Xb?s.rectBetween(n.$anchorCell.pos-o,n.$headCell.pos-o):s.findCell(r.pos-o),t.tableStart=o,t.map=s,t.table=i,t}function ww(e,{map:t,tableStart:n,table:r},i){let o=i>0?-1:0;(function(e,t,n){let r=$b(t.type.schema).header_cell;for(let i=0;i<e.height;i++)if(t.nodeAt(e.map[n+i*e.width]).type!=r)return !1;return !0})(t,r,i+o)&&(o=0==i||i==t.width?null:0);for(let s=0;s<t.height;s++){let a=s*t.width+i;if(i>0&&i<t.width&&t.map[a-1]==t.map[a]){let o=t.map[a],l=r.nodeAt(o);e.setNodeMarkup(e.mapping.map(n+o),null,Zb(l.attrs,i-t.colCount(o))),s+=l.attrs.rowspan-1;}else {let l=null==o?$b(r.type.schema).cell:r.nodeAt(t.map[a+o]).type,c=t.positionAt(s,i,r);e.insert(e.mapping.map(n+c),l.createAndFill());}}return e}function kw(e,{map:t,table:n,tableStart:r},i){let o=e.mapping.maps.length;for(let s=0;s<t.height;){let a=s*t.width+i,l=t.map[a],c=n.nodeAt(l);if(i>0&&t.map[a-1]==l||i<t.width-1&&t.map[a+1]==l)e.setNodeMarkup(e.mapping.slice(o).map(r+l),null,Jb(c.attrs,i-t.colCount(l)));else {let t=e.mapping.slice(o).map(r+l);e.delete(t,t+c.nodeSize);}s+=c.attrs.rowspan;}}function Cw(e,{map:t,tableStart:n,table:r},i){let o=n;for(let e=0;e<i;e++)o+=r.child(e).nodeSize;let s=[],a=i>0?-1:0;(function(e,t,n){let r=$b(t.type.schema).header_cell;for(let i=0;i<e.width;i++)if(t.nodeAt(e.map[i+n*e.width]).type!=r)return !1;return !0})(t,r,i+a)&&(a=0==i||i==t.height?null:0);for(let o=0,l=t.width*i;o<t.width;o++,l++)if(i>0&&i<t.height&&t.map[l]==t.map[l-t.width]){let i=t.map[l],s=r.nodeAt(i).attrs;e.setNodeMarkup(n+i,null,Gb(s,"rowspan",s.rowspan+1)),o+=s.colspan-1;}else {let e=null==a?$b(r.type.schema).cell:r.nodeAt(t.map[l+a*t.width]).type;s.push(e.createAndFill());}return e.insert(o,$b(r.type.schema).row.create(null,s)),e}function Ew(e,{map:t,table:n,tableStart:r},i){let o=0;for(let e=0;e<i;e++)o+=n.child(e).nodeSize;let s=o+n.child(i).nodeSize,a=e.mapping.maps.length;e.delete(o+r,s+r);for(let o=0,s=i*t.width;o<t.width;o++,s++){let l=t.map[s];if(i>0&&l==t.map[s-t.width]){let t=n.nodeAt(l).attrs;e.setNodeMarkup(e.mapping.slice(a).map(l+r),null,Gb(t,"rowspan",t.rowspan-1)),o+=t.colspan-1;}else if(i<t.width&&l==t.map[s+t.width]){let s=n.nodeAt(l),c=s.type.create(Gb(s.attrs,"rowspan",s.attrs.rowspan-1),s.content),u=t.positionAt(i+1,o,n);e.insert(e.mapping.slice(a).map(r+u),c),o+=s.attrs.colspan-1;}}}function xw(e){let t=e.content;return 1==t.childCount&&t.firstChild.isTextblock&&0==t.firstChild.childCount}function Sw(e,t){let n=e.selection;if(!(n instanceof Xb)||n.$anchorCell.pos==n.$headCell.pos)return !1;let r=bw(e),{map:i}=r;if(function({width:e,height:t,map:n},r){let i=r.top*e+r.left,o=i,s=(r.bottom-1)*e+r.left,a=i+(r.right-r.left-1);for(let t=r.top;t<r.bottom;t++){if(r.left>0&&n[o]==n[o-1]||r.right<e&&n[a]==n[a+1])return !0;o+=e,a+=e;}for(let o=r.left;o<r.right;o++){if(r.top>0&&n[i]==n[i-e]||r.bottom<t&&n[s]==n[s+e])return !0;i++,s++;}return !1}(i,r))return !1;if(t){let n,o,s=e.tr,a={},l=Cs.empty;for(let e=r.top;e<r.bottom;e++)for(let t=r.left;t<r.right;t++){let c=i.map[e*i.width+t],u=r.table.nodeAt(c);if(!a[c])if(a[c]=!0,null==n)n=c,o=u;else {xw(u)||(l=l.append(u.content));let e=s.mapping.map(c+r.tableStart);s.delete(e,e+u.nodeSize);}}if(s.setNodeMarkup(n+r.tableStart,null,Gb(Zb(o.attrs,o.attrs.colspan,r.right-r.left-o.attrs.colspan),"rowspan",r.bottom-r.top)),l.size){let e=n+1+o.content.size,t=xw(o)?n+1:e;s.replaceWith(t+r.tableStart,e+r.tableStart,l);}s.setSelection(new Xb(s.doc.resolve(n+r.tableStart))),t(s);}return !0}function Dw(e,t){const n=$b(e.schema);return (r=({node:e})=>n[e.type.spec.tableRole],(e,t)=>{let n,i,o=e.selection;if(o instanceof Xb){if(o.$anchorCell.pos!=o.$headCell.pos)return !1;n=o.$anchorCell.nodeAfter,i=o.$anchorCell.pos;}else {if(n=function(e){for(let t=e.depth;t>0;t--){const n=e.node(t).type.spec.tableRole;if("cell"===n||"header_cell"===n)return e.node(t)}return null}(o.$from),!n)return !1;i=Hb(o.$from).pos;}if(1==n.attrs.colspan&&1==n.attrs.rowspan)return !1;if(t){let s=n.attrs,a=[],l=s.colwidth;s.rowspan>1&&(s=Gb(s,"rowspan",1)),s.colspan>1&&(s=Gb(s,"colspan",1));let c,u=bw(e),d=e.tr;for(let e=0;e<u.right-u.left;e++)a.push(l?Gb(s,"colwidth",l&&l[e]?[l[e]]:null):s);for(let e=u.top;e<u.bottom;e++){let t=u.map.positionAt(e,u.left,u.table);e==u.top&&(t+=n.nodeSize);for(let i=u.left,o=0;i<u.right;i++,o++)i==u.left&&e==u.top||d.insert(c=d.mapping.map(t+u.tableStart,1),r({node:n,row:e,col:i}).createAndFill(a[o]));}d.setNodeMarkup(i,r({node:n,row:u.top,col:u.left}),a[0]),o instanceof Xb&&d.setSelection(new Xb(d.doc.resolve(o.$anchorCell.pos),c&&d.doc.resolve(c))),t(d);}return !0})(e,t);var r;}function Mw(e,t,n){const r=t.map.cellsInRect({left:0,top:0,right:"row"==e?t.map.width:1,bottom:"column"==e?t.map.height:1});for(let e=0;e<r.length;e++){const i=t.table.nodeAt(r[e]);if(i&&i.type!==n.header_cell)return !1}return !0}function Ow(e,t){return (t=t||{useDeprecatedLogic:!1}).useDeprecatedLogic?function(e){return function(t,n){if(!Vb(t))return !1;if(n){let r=$b(t.schema),i=bw(t),o=t.tr,s=i.map.cellsInRect("column"==e?new Ib(i.left,0,i.right,i.map.height):"row"==e?new Ib(0,i.top,i.map.width,i.bottom):i),a=s.map((e=>i.table.nodeAt(e)));for(let e=0;e<s.length;e++)a[e].type==r.header_cell&&o.setNodeMarkup(i.tableStart+s[e],r.cell,a[e].attrs);if(0==o.steps.length)for(let e=0;e<s.length;e++)o.setNodeMarkup(i.tableStart+s[e],r.header_cell,a[e].attrs);n(o);}return !0}}(e):function(t,n){if(!Vb(t))return !1;if(n){let r=$b(t.schema),i=bw(t),o=t.tr,s=Mw("row",i,r),a=Mw("column",i,r),l=("column"===e?s:"row"===e&&a)?1:0,c="column"==e?new Ib(0,l,1,i.map.height):"row"==e?new Ib(l,0,i.map.width,1):i,u="column"==e?a?r.cell:r.header_cell:"row"==e?s?r.cell:r.header_cell:r.cell;i.map.cellsInRect(c).forEach((e=>{const t=e+i.tableStart,n=o.doc.nodeAt(t);n&&o.setNodeMarkup(t,u,n.attrs);})),n(o);}return !0}}Ow("row",{useDeprecatedLogic:!0}),Ow("column",{useDeprecatedLogic:!0});let Aw=Ow("cell",{useDeprecatedLogic:!0});function Nw(e){return function(t,n){if(!Vb(t))return !1;let r=function(e,t){if(t<0){let t=e.nodeBefore;if(t)return e.pos-t.nodeSize;for(let t=e.index(-1)-1,n=e.before();t>=0;t--){let r=e.node(-1).child(t);if(r.childCount)return n-1-r.lastChild.nodeSize;n-=r.nodeSize;}}else {if(e.index()<e.parent.childCount-1)return e.pos+e.nodeAfter.nodeSize;let t=e.node(-1);for(let n=e.indexAfter(-1),r=e.after();n<t.childCount;n++){let e=t.child(n);if(e.childCount)return r+1;r+=e.nodeSize;}}}(Kb(t),e);if(null!=r){if(n){let e=t.doc.resolve(r);n(t.tr.setSelection(dl.between(e,(i=e,i.node(0).resolve(i.pos+i.nodeAfter.nodeSize)))).scrollIntoView());}var i;return !0}}}class _w{constructor(e,t){this.node=e,this.cellMinWidth=t,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),Tw(e,this.colgroup,this.table,t),this.contentDOM=this.table.appendChild(document.createElement("tbody"));}update(e){return e.type==this.node.type&&(this.node=e,Tw(e,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(e){return "attributes"==e.type&&(e.target==this.table||this.colgroup.contains(e.target))}}function Tw(e,t,n,r,i,o){let s=0,a=!0,l=t.firstChild,c=e.firstChild;for(let e=0,n=0;e<c.childCount;e++){let{colspan:u,colwidth:d}=c.child(e).attrs;for(let e=0;e<u;e++,n++){let c=i==n?o:d&&d[e],u=c?c+"px":"";s+=c||r,c||(a=!1),l?(l.style.width!=u&&(l.style.width=u),l=l.nextSibling):t.appendChild(document.createElement("col")).style.width=u;}}for(;l;){let e=l.nextSibling;l.parentNode.removeChild(l),l=e;}a?(n.style.width=s+"px",n.style.minWidth=""):(n.style.width="",n.style.minWidth=s+"px");}const Lw=new Al("tableColumnResizing");function Rw({handleWidth:e=5,cellMinWidth:t=25,View:n=_w,lastColumnResizable:r=!0}={}){let i=new Dl({key:Lw,state:{init(e,r){return this.spec.props.nodeViews[$b(r.schema).table.name]=(e,r)=>new n(e,t,r),new Fw(-1,!1)},apply:(e,t)=>t.apply(e)},props:{attributes:e=>Lw.getState(e).activeHandle>-1?{class:"resize-cursor"}:null,handleDOMEvents:{mousemove(t,n){!function(e,t,n,r,i){let o=Lw.getState(e.state);if(!o.dragging){let r=function(e){for(;e&&"TD"!=e.nodeName&&"TH"!=e.nodeName;)e=e.classList.contains("ProseMirror")?null:e.parentNode;return e}(t.target),s=-1;if(r){let{left:i,right:o}=r.getBoundingClientRect();t.clientX-i<=n?s=Bw(e,t,"left"):o-t.clientX<=n&&(s=Bw(e,t,"right"));}if(s!=o.activeHandle){if(!i&&-1!==s){let t=e.state.doc.resolve(s),n=t.node(-1),r=Pb.get(n),i=t.start(-1);if(r.colCount(t.pos-i)+t.nodeAfter.attrs.colspan-1==r.width-1)return}Pw(e,s);}}}(t,n,e,0,r);},mouseleave(e){!function(e){let t=Lw.getState(e.state);t.activeHandle>-1&&!t.dragging&&Pw(e,-1);}(e);},mousedown(e,n){!function(e,t,n){let r=Lw.getState(e.state);if(-1==r.activeHandle||r.dragging)return !1;let i=e.state.doc.nodeAt(r.activeHandle),o=function(e,t,{colspan:n,colwidth:r}){let i=r&&r[r.length-1];if(i)return i;let o=e.domAtPos(t),s=o.node.childNodes[o.offset].offsetWidth,a=n;if(r)for(let e=0;e<n;e++)r[e]&&(s-=r[e],a--);return s/a}(e,r.activeHandle,i.attrs);function s(t){window.removeEventListener("mouseup",s),window.removeEventListener("mousemove",a);let r=Lw.getState(e.state);r.dragging&&(!function(e,t,n){let r=e.state.doc.resolve(t),i=r.node(-1),o=Pb.get(i),s=r.start(-1),a=o.colCount(r.pos-s)+r.nodeAfter.attrs.colspan-1,l=e.state.tr;for(let e=0;e<o.height;e++){let t=e*o.width+a;if(e&&o.map[t]==o.map[t-o.width])continue;let r=o.map[t],{attrs:c}=i.nodeAt(r),u=1==c.colspan?0:a-o.colCount(r);if(c.colwidth&&c.colwidth[u]==n)continue;let d=c.colwidth?c.colwidth.slice():zw(c.colspan);d[u]=n,l.setNodeMarkup(s+r,null,Gb(c,"colwidth",d));}l.docChanged&&e.dispatch(l);}(e,r.activeHandle,Iw(r.dragging,t,n)),e.dispatch(e.state.tr.setMeta(Lw,{setDragging:null})));}function a(t){if(!t.which)return s(t);let r=Lw.getState(e.state),i=Iw(r.dragging,t,n);!function(e,t,n,r){let i=e.state.doc.resolve(t),o=i.node(-1),s=i.start(-1),a=Pb.get(o).colCount(i.pos-s)+i.nodeAfter.attrs.colspan-1,l=e.domAtPos(i.start(-1)).node;for(;"TABLE"!=l.nodeName;)l=l.parentNode;Tw(o,l.firstChild,l,r,a,n);}(e,r.activeHandle,i,n);}e.dispatch(e.state.tr.setMeta(Lw,{setDragging:{startX:t.clientX,startWidth:o}})),window.addEventListener("mouseup",s),window.addEventListener("mousemove",a),t.preventDefault();}(e,n,t);}},decorations(e){let t=Lw.getState(e);if(t.activeHandle>-1)return function(e,t){let n=[],r=e.doc.resolve(t),i=r.node(-1),o=Pb.get(i),s=r.start(-1),a=o.colCount(r.pos-s)+r.nodeAfter.attrs.colspan;for(let e=0;e<o.height;e++){let t=a+e*o.width-1;if(!(a!=o.width&&o.map[t]==o.map[t+1]||0!=e&&o.map[t-1]==o.map[t-1-o.width])){let e=o.map[t],r=s+e+i.nodeAt(e).nodeSize-1,a=document.createElement("div");a.className="column-resize-handle",n.push(od.widget(r,a));}}return ld.create(e.doc,n)}(e,t.activeHandle)},nodeViews:{}}});return i}class Fw{constructor(e,t){this.activeHandle=e,this.dragging=t;}apply(e){let t=this,n=e.getMeta(Lw);if(n&&null!=n.setHandle)return new Fw(n.setHandle,null);if(n&&void 0!==n.setDragging)return new Fw(t.activeHandle,n.setDragging);if(t.activeHandle>-1&&e.docChanged){let n=e.mapping.map(t.activeHandle,-1);qb(e.doc.resolve(n))||(n=null),t=new Fw(n,t.dragging);}return t}}function Bw(e,t,n){let r=e.posAtCoords({left:t.clientX,top:t.clientY});if(!r)return -1;let{pos:i}=r,o=Hb(e.state.doc.resolve(i));if(!o)return -1;if("right"==n)return o.pos;let s=Pb.get(o.node(-1)),a=o.start(-1),l=s.map.indexOf(o.pos-a);return l%s.width==0?-1:a+s.map[l-1]}function Iw(e,t,n){let r=t.clientX-e.startX;return Math.max(n,e.startWidth+r)}function Pw(e,t){e.dispatch(e.state.tr.setMeta(Lw,{setHandle:t}));}function zw(e){let t=[];for(let n=0;n<e;n++)t.push(0);return t}function $w({allowTableNodeSelection:e=!1}={}){return new Dl({key:jb,state:{init:()=>null,apply(e,t){let n=e.getMeta(jb);if(null!=n)return -1==n?null:n;if(null==t||!e.docChanged)return t;let{deleted:r,pos:i}=e.mapping.mapResult(t);return r?null:i}},props:{decorations:Yb,handleDOMEvents:{mousedown:hw},createSelectionBetween(e){if(null!=jb.getState(e.state))return e.state.selection},handleTripleClick:uw,handleKeyDown:ow,handlePaste:dw},appendTransaction:(t,n,r)=>function(e,t,n){let r,i,o=(t||e).selection,s=(t||e).doc;if(o instanceof pl&&(i=o.node.type.spec.tableRole)){if("cell"==i||"header_cell"==i)r=Xb.create(s,o.from);else if("row"==i){let e=s.resolve(o.from+1);r=Xb.rowSelection(e,e);}else if(!n){let e=Pb.get(o.node),t=o.from+1,n=t+e.map[e.width*e.height-1];r=Xb.create(s,t+1,n);}}else o instanceof dl&&function({$from:e,$to:t}){if(e.pos==t.pos||e.pos<e.pos-6)return !1;let n=e.pos,r=t.pos,i=e.depth;for(;i>=0&&!(e.after(i+1)<e.end(i));i--,n++);for(let e=t.depth;e>=0&&!(t.before(e+1)>t.start(e));e--,r--);return n==r&&/row|table/.test(e.node(i).type.spec.tableRole)}(o)?r=dl.create(s,o.from):o instanceof dl&&function({$from:e,$to:t}){let n,r;for(let t=e.depth;t>0;t--){let r=e.node(t);if("cell"===r.type.spec.tableRole||"header_cell"===r.type.spec.tableRole){n=r;break}}for(let e=t.depth;e>0;e--){let n=t.node(e);if("cell"===n.type.spec.tableRole||"header_cell"===n.type.spec.tableRole){r=n;break}}return n!==r&&0===t.parentOffset}(o)&&(r=dl.create(s,o.$from.start(),o.$from.end()));return r&&(t||(t=e.tr)).setSelection(r),t}(r,yw(r,n),e)})}function jw(e,t,n,r,i,o){let s=0,a=!0,l=t.firstChild;const c=e.firstChild;for(let e=0,n=0;e<c.childCount;e+=1){const{colspan:u,colwidth:d}=c.child(e).attrs;for(let e=0;e<u;e+=1,n+=1){const c=i===n?o:d&&d[e],u=c?`${c}px`:"";s+=c||r,c||(a=!1),l?(l.style.width!==u&&(l.style.width=u),l=l.nextSibling):t.appendChild(document.createElement("col")).style.width=u;}}for(;l;){const e=l.nextSibling;l.parentNode.removeChild(l),l=e;}a?(n.style.width=`${s}px`,n.style.minWidth=""):(n.style.width="",n.style.minWidth=`${s}px`);}class Hw{constructor(e,t){this.node=e,this.cellMinWidth=t,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),jw(e,this.colgroup,this.table,t),this.contentDOM=this.table.appendChild(document.createElement("tbody"));}update(e){return e.type===this.node.type&&(this.node=e,jw(e,this.colgroup,this.table,this.cellMinWidth),!0)}ignoreMutation(e){return "attributes"===e.type&&(e.target===this.table||this.colgroup.contains(e.target))}}function Vw(e,t){return t?e.createChecked(null,t):e.createAndFill()}function Kw(e,t,n,r,i){const o=function(e){if(e.cached.tableNodeTypes)return e.cached.tableNodeTypes;const t={};return Object.keys(e.nodes).forEach((n=>{const r=e.nodes[n];r.spec.tableRole&&(t[r.spec.tableRole]=r);})),e.cached.tableNodeTypes=t,t}(e),s=[],a=[];for(let e=0;e<n;e+=1){const e=Vw(o.cell,i);if(e&&a.push(e),r){const e=Vw(o.header_cell,i);e&&s.push(e);}}const l=[];for(let e=0;e<t;e+=1)l.push(o.row.createChecked(null,r&&0===e?s:a));return o.table.createChecked(null,l)}const qw=({editor:e})=>{const{selection:t}=e.state;if(!(t instanceof Xb))return !1;let n=0;const r=Yh(t.ranges[0].$from,(e=>"table"===e.type.name));null==r||r.node.descendants((e=>{if("table"===e.type.name)return !1;["tableCell","tableHeader"].includes(e.type.name)&&(n+=1);}));return n===t.ranges.length&&(e.commands.deleteTable(),!0)},Uw=xp.create({name:"table",addOptions:()=>({HTMLAttributes:{},resizable:!1,handleWidth:5,cellMinWidth:25,View:Hw,lastColumnResizable:!0,allowTableNodeSelection:!1}),content:"tableRow+",tableRole:"table",isolating:!0,group:"block",parseHTML:()=>[{tag:"table"}],renderHTML({HTMLAttributes:e}){return ["table",dh(this.options.HTMLAttributes,e),["tbody",0]]},addCommands:()=>({insertTable:({rows:e=3,cols:t=3,withHeaderRow:n=!0}={})=>({tr:r,dispatch:i,editor:o})=>{const s=Kw(o.schema,e,t,n);if(i){const e=r.selection.anchor+1;r.replaceSelectionWith(s).scrollIntoView().setSelection(dl.near(r.doc.resolve(e)));}return !0},addColumnBefore:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e);t(ww(e.tr,n,n.left));}return !0}(e,t),addColumnAfter:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e);t(ww(e.tr,n,n.right));}return !0}(e,t),deleteColumn:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e),r=e.tr;if(0==n.left&&n.right==n.map.width)return !1;for(let e=n.right-1;kw(r,n,e),e!=n.left;e--)n.table=n.tableStart?r.doc.nodeAt(n.tableStart-1):r.doc,n.map=Pb.get(n.table);t(r);}return !0}(e,t),addRowBefore:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e);t(Cw(e.tr,n,n.top));}return !0}(e,t),addRowAfter:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e);t(Cw(e.tr,n,n.bottom));}return !0}(e,t),deleteRow:()=>({state:e,dispatch:t})=>function(e,t){if(!Vb(e))return !1;if(t){let n=bw(e),r=e.tr;if(0==n.top&&n.bottom==n.map.height)return !1;for(let e=n.bottom-1;Ew(r,n,e),e!=n.top;e--)n.table=n.tableStart?r.doc.nodeAt(n.tableStart-1):r.doc,n.map=Pb.get(n.table);t(r);}return !0}(e,t),deleteTable:()=>({state:e,dispatch:t})=>function(e,t){let n=e.selection.$anchor;for(let r=n.depth;r>0;r--)if("table"==n.node(r).type.spec.tableRole)return t&&t(e.tr.delete(n.before(r),n.after(r)).scrollIntoView()),!0;return !1}(e,t),mergeCells:()=>({state:e,dispatch:t})=>Sw(e,t),splitCell:()=>({state:e,dispatch:t})=>Dw(e,t),toggleHeaderColumn:()=>({state:e,dispatch:t})=>Ow("column")(e,t),toggleHeaderRow:()=>({state:e,dispatch:t})=>Ow("row")(e,t),toggleHeaderCell:()=>({state:e,dispatch:t})=>Aw(e,t),mergeOrSplit:()=>({state:e,dispatch:t})=>!!Sw(e,t)||Dw(e,t),setCellAttribute:(e,t)=>({state:n,dispatch:r})=>function(e,t){return function(n,r){if(!Vb(n))return !1;let i=Kb(n);if(i.nodeAfter.attrs[e]===t)return !1;if(r){let o=n.tr;n.selection instanceof Xb?n.selection.forEachCell(((n,r)=>{n.attrs[e]!==t&&o.setNodeMarkup(r,null,Gb(n.attrs,e,t));})):o.setNodeMarkup(i.pos,null,Gb(i.nodeAfter.attrs,e,t)),r(o);}return !0}}(e,t)(n,r),goToNextCell:()=>({state:e,dispatch:t})=>Nw(1)(e,t),goToPreviousCell:()=>({state:e,dispatch:t})=>Nw(-1)(e,t),fixTables:()=>({state:e,dispatch:t})=>(t&&yw(e),!0),setCellSelection:e=>({tr:t,dispatch:n})=>{if(n){const n=Xb.create(t.doc,e.anchorCell,e.headCell);t.setSelection(n);}return !0}}),addKeyboardShortcuts(){return {Tab:()=>!!this.editor.commands.goToNextCell()||!!this.editor.can().addRowAfter()&&this.editor.chain().addRowAfter().goToNextCell().run(),"Shift-Tab":()=>this.editor.commands.goToPreviousCell(),Backspace:qw,"Mod-Backspace":qw,Delete:qw,"Mod-Delete":qw}},addProseMirrorPlugins(){return [...this.options.resizable&&this.editor.isEditable?[Rw({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,View:this.options.View,lastColumnResizable:this.options.lastColumnResizable})]:[],$w({allowTableNodeSelection:this.options.allowTableNodeSelection})]},extendNodeSchema:e=>({tableRole:fh(ah(e,"tableRole",{name:e.name,options:e.options,storage:e.storage}))})});var Ww={},Gw={},Jw={};function Zw(e){this.content=e;}Zw.prototype={constructor:Zw,find:function(e){for(var t=0;t<this.content.length;t+=2)if(this.content[t]===e)return t;return -1},get:function(e){var t=this.find(e);return -1==t?void 0:this.content[t+1]},update:function(e,t,n){var r=n&&n!=e?this.remove(n):this,i=r.find(e),o=r.content.slice();return -1==i?o.push(n||e,t):(o[i+1]=t,n&&(o[i]=n)),new Zw(o)},remove:function(e){var t=this.find(e);if(-1==t)return this;var n=this.content.slice();return n.splice(t,2),new Zw(n)},addToStart:function(e,t){return new Zw([e,t].concat(this.remove(e).content))},addToEnd:function(e,t){var n=this.remove(e).content.slice();return n.push(e,t),new Zw(n)},addBefore:function(e,t,n){var r=this.remove(t),i=r.content.slice(),o=r.find(e);return i.splice(-1==o?i.length:o,0,t,n),new Zw(i)},forEach:function(e){for(var t=0;t<this.content.length;t+=2)e(this.content[t],this.content[t+1]);},prepend:function(e){return (e=Zw.from(e)).size?new Zw(e.content.concat(this.subtract(e).content)):this},append:function(e){return (e=Zw.from(e)).size?new Zw(this.subtract(e).content.concat(e.content)):this},subtract:function(e){var t=this;e=Zw.from(e);for(var n=0;n<e.content.length;n+=2)t=t.remove(e.content[n]);return t},get size(){return this.content.length>>1}},Zw.from=function(e){if(e instanceof Zw)return e;var t=[];if(e)for(var n in e)t.push(n,e[n]);return new Zw(t)};var Xw=Zw;function Qw(){return Qw="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=Yw(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(arguments.length<3?e:n):i.value}},Qw.apply(this,arguments)}function Yw(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=ak(e)););return e}function ek(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&sk(e,t);}function tk(e){var t=ok();return function(){var n,r=ak(e);if(t){var i=ak(this).constructor;n=Reflect.construct(r,arguments,i);}else n=r.apply(this,arguments);return nk(this,n)}}function nk(e,t){if(t&&("object"===dk(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function rk(e){var t="function"==typeof Map?new Map:void 0;return rk=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r);}function r(){return ik(e,arguments,ak(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),sk(r,e)},rk(e)}function ik(e,t,n){return ik=ok()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&sk(i,n.prototype),i},ik.apply(null,arguments)}function ok(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}function sk(e,t){return sk=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},sk(e,t)}function ak(e){return ak=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},ak(e)}function lk(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function ck(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function uk(e,t,n){return t&&ck(e.prototype,t),n&&ck(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}function dk(e){return dk="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},dk(e)}Object.defineProperty(Jw,"__esModule",{value:!0});var hk,pk=(hk=Xw)&&"object"===dk(hk)&&"default"in hk?hk:{default:hk};function fk(e,t,n){for(var r=0;;r++){if(r==e.childCount||r==t.childCount)return e.childCount==t.childCount?null:n;var i=e.child(r),o=t.child(r);if(i!=o){if(!i.sameMarkup(o))return n;if(i.isText&&i.text!=o.text){for(var s=0;i.text[s]==o.text[s];s++)n++;return n}if(i.content.size||o.content.size){var a=fk(i.content,o.content,n+1);if(null!=a)return a}n+=i.nodeSize;}else n+=i.nodeSize;}}function mk(e,t,n,r){for(var i=e.childCount,o=t.childCount;;){if(0==i||0==o)return i==o?null:{a:n,b:r};var s=e.child(--i),a=t.child(--o),l=s.nodeSize;if(s!=a){if(!s.sameMarkup(a))return {a:n,b:r};if(s.isText&&s.text!=a.text){for(var c=0,u=Math.min(s.text.length,a.text.length);c<u&&s.text[s.text.length-c-1]==a.text[a.text.length-c-1];)c++,n--,r--;return {a:n,b:r}}if(s.content.size||a.content.size){var d=mk(s.content,a.content,n-1,r-1);if(d)return d}n-=l,r-=l;}else n-=l,r-=l;}}var gk=function(){function e(t,n){if(lk(this,e),this.content=t,this.size=n||0,null==n)for(var r=0;r<t.length;r++)this.size+=t[r].nodeSize;}return uk(e,[{key:"nodesBetween",value:function(e,t,n){for(var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=arguments.length>4?arguments[4]:void 0,o=0,s=0;s<t;o++){var a=this.content[o],l=s+a.nodeSize;if(l>e&&!1!==n(a,r+s,i||null,o)&&a.content.size){var c=s+1;a.nodesBetween(Math.max(0,e-c),Math.min(a.content.size,t-c),n,r+c);}s=l;}}},{key:"descendants",value:function(e){this.nodesBetween(0,this.size,e);}},{key:"textBetween",value:function(e,t,n,r){var i="",o=!0;return this.nodesBetween(e,t,(function(s,a){s.isText?(i+=s.text.slice(Math.max(e,a)-a,t-a),o=!n):s.isLeaf?(r?i+="function"==typeof r?r(s):r:s.type.spec.leafText&&(i+=s.type.spec.leafText(s)),o=!n):!o&&s.isBlock&&(i+=n,o=!0);}),0),i}},{key:"append",value:function(t){if(!t.size)return this;if(!this.size)return t;var n=this.lastChild,r=t.firstChild,i=this.content.slice(),o=0;for(n.isText&&n.sameMarkup(r)&&(i[i.length-1]=n.withText(n.text+r.text),o=1);o<t.content.length;o++)i.push(t.content[o]);return new e(i,this.size+t.size)}},{key:"cut",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.size;if(0==t&&n==this.size)return this;var r=[],i=0;if(n>t)for(var o=0,s=0;s<n;o++){var a=this.content[o],l=s+a.nodeSize;l>t&&((s<t||l>n)&&(a=a.isText?a.cut(Math.max(0,t-s),Math.min(a.text.length,n-s)):a.cut(Math.max(0,t-s-1),Math.min(a.content.size,n-s-1))),r.push(a),i+=a.nodeSize),s=l;}return new e(r,i)}},{key:"cutByIndex",value:function(t,n){return t==n?e.empty:0==t&&n==this.content.length?this:new e(this.content.slice(t,n))}},{key:"replaceChild",value:function(t,n){var r=this.content[t];if(r==n)return this;var i=this.content.slice(),o=this.size+n.nodeSize-r.nodeSize;return i[t]=n,new e(i,o)}},{key:"addToStart",value:function(t){return new e([t].concat(this.content),this.size+t.nodeSize)}},{key:"addToEnd",value:function(t){return new e(this.content.concat(t),this.size+t.nodeSize)}},{key:"eq",value:function(e){if(this.content.length!=e.content.length)return !1;for(var t=0;t<this.content.length;t++)if(!this.content[t].eq(e.content[t]))return !1;return !0}},{key:"firstChild",get:function(){return this.content.length?this.content[0]:null}},{key:"lastChild",get:function(){return this.content.length?this.content[this.content.length-1]:null}},{key:"childCount",get:function(){return this.content.length}},{key:"child",value:function(e){var t=this.content[e];if(!t)throw new RangeError("Index "+e+" out of range for "+this);return t}},{key:"maybeChild",value:function(e){return this.content[e]||null}},{key:"forEach",value:function(e){for(var t=0,n=0;t<this.content.length;t++){var r=this.content[t];e(r,n,t),n+=r.nodeSize;}}},{key:"findDiffStart",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return fk(this,e,t)}},{key:"findDiffEnd",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.size,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.size;return mk(this,e,t,n)}},{key:"findIndex",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;if(0==e)return yk(0,e);if(e==this.size)return yk(this.content.length,e);if(e>this.size||e<0)throw new RangeError("Position ".concat(e," outside of fragment (").concat(this,")"));for(var n=0,r=0;;n++){var i=this.child(n),o=r+i.nodeSize;if(o>=e)return o==e||t>0?yk(n+1,o):yk(n,r);r=o;}}},{key:"toString",value:function(){return "<"+this.toStringInner()+">"}},{key:"toStringInner",value:function(){return this.content.join(", ")}},{key:"toJSON",value:function(){return this.content.length?this.content.map((function(e){return e.toJSON()})):null}}],[{key:"fromJSON",value:function(t,n){if(!n)return e.empty;if(!Array.isArray(n))throw new RangeError("Invalid input for Fragment.fromJSON");return new e(n.map(t.nodeFromJSON))}},{key:"fromArray",value:function(t){if(!t.length)return e.empty;for(var n,r=0,i=0;i<t.length;i++){var o=t[i];r+=o.nodeSize,i&&o.isText&&t[i-1].sameMarkup(o)?(n||(n=t.slice(0,i)),n[n.length-1]=o.withText(n[n.length-1].text+o.text)):n&&n.push(o);}return new e(n||t,r)}},{key:"from",value:function(t){if(!t)return e.empty;if(t instanceof e)return t;if(Array.isArray(t))return this.fromArray(t);if(t.attrs)return new e([t],t.nodeSize);throw new RangeError("Can not convert "+t+" to a Fragment"+(t.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}}]),e}();gk.empty=new gk([],0);var vk={index:0,offset:0};function yk(e,t){return vk.index=e,vk.offset=t,vk}function bk(e,t){if(e===t)return !0;if(!e||"object"!=dk(e)||!t||"object"!=dk(t))return !1;var n=Array.isArray(e);if(Array.isArray(t)!=n)return !1;if(n){if(e.length!=t.length)return !1;for(var r=0;r<e.length;r++)if(!bk(e[r],t[r]))return !1}else {for(var i in e)if(!(i in t)||!bk(e[i],t[i]))return !1;for(var o in t)if(!(o in e))return !1}return !0}var wk=function(){function e(t,n){lk(this,e),this.type=t,this.attrs=n;}return uk(e,[{key:"addToSet",value:function(e){for(var t,n=!1,r=0;r<e.length;r++){var i=e[r];if(this.eq(i))return e;if(this.type.excludes(i.type))t||(t=e.slice(0,r));else {if(i.type.excludes(this.type))return e;!n&&i.type.rank>this.type.rank&&(t||(t=e.slice(0,r)),t.push(this),n=!0),t&&t.push(i);}}return t||(t=e.slice()),n||t.push(this),t}},{key:"removeFromSet",value:function(e){for(var t=0;t<e.length;t++)if(this.eq(e[t]))return e.slice(0,t).concat(e.slice(t+1));return e}},{key:"isInSet",value:function(e){for(var t=0;t<e.length;t++)if(this.eq(e[t]))return !0;return !1}},{key:"eq",value:function(e){return this==e||this.type==e.type&&bk(this.attrs,e.attrs)}},{key:"toJSON",value:function(){var e={type:this.type.name};for(var t in this.attrs){e.attrs=this.attrs;break}return e}}],[{key:"fromJSON",value:function(e,t){if(!t)throw new RangeError("Invalid input for Mark.fromJSON");var n=e.marks[t.type];if(!n)throw new RangeError("There is no mark type ".concat(t.type," in this schema"));return n.create(t.attrs)}},{key:"sameSet",value:function(e,t){if(e==t)return !0;if(e.length!=t.length)return !1;for(var n=0;n<e.length;n++)if(!e[n].eq(t[n]))return !1;return !0}},{key:"setFrom",value:function(t){if(!t||Array.isArray(t)&&0==t.length)return e.none;if(t instanceof e)return [t];var n=t.slice();return n.sort((function(e,t){return e.type.rank-t.type.rank})),n}}]),e}();wk.none=[];var kk=function(e){ek(n,rk(Error));var t=tk(n);function n(){return lk(this,n),t.apply(this,arguments)}return uk(n)}(),Ck=function(){function e(t,n,r){lk(this,e),this.content=t,this.openStart=n,this.openEnd=r;}return uk(e,[{key:"size",get:function(){return this.content.size-this.openStart-this.openEnd}},{key:"insertAt",value:function(t,n){var r=xk(this.content,t+this.openStart,n);return r&&new e(r,this.openStart,this.openEnd)}},{key:"removeBetween",value:function(t,n){return new e(Ek(this.content,t+this.openStart,n+this.openStart),this.openStart,this.openEnd)}},{key:"eq",value:function(e){return this.content.eq(e.content)&&this.openStart==e.openStart&&this.openEnd==e.openEnd}},{key:"toString",value:function(){return this.content+"("+this.openStart+","+this.openEnd+")"}},{key:"toJSON",value:function(){if(!this.content.size)return null;var e={content:this.content.toJSON()};return this.openStart>0&&(e.openStart=this.openStart),this.openEnd>0&&(e.openEnd=this.openEnd),e}}],[{key:"fromJSON",value:function(t,n){if(!n)return e.empty;var r=n.openStart||0,i=n.openEnd||0;if("number"!=typeof r||"number"!=typeof i)throw new RangeError("Invalid input for Slice.fromJSON");return new e(gk.fromJSON(t,n.content),r,i)}},{key:"maxOpen",value:function(t){for(var n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=0,i=0,o=t.firstChild;o&&!o.isLeaf&&(n||!o.type.spec.isolating);o=o.firstChild)r++;for(var s=t.lastChild;s&&!s.isLeaf&&(n||!s.type.spec.isolating);s=s.lastChild)i++;return new e(t,r,i)}}]),e}();function Ek(e,t,n){var r=e.findIndex(t),i=r.index,o=r.offset,s=e.maybeChild(i),a=e.findIndex(n),l=a.index,c=a.offset;if(o==t||s.isText){if(c!=n&&!e.child(l).isText)throw new RangeError("Removing non-flat range");return e.cut(0,t).append(e.cut(n))}if(i!=l)throw new RangeError("Removing non-flat range");return e.replaceChild(i,s.copy(Ek(s.content,t-o-1,n-o-1)))}function xk(e,t,n,r){var i=e.findIndex(t),o=i.index,s=i.offset,a=e.maybeChild(o);if(s==t||a.isText)return r&&!r.canReplace(o,o,n)?null:e.cut(0,t).append(n).append(e.cut(t));var l=xk(a.content,t-s-1,n);return l&&e.replaceChild(o,a.copy(l))}function Sk(e,t,n){if(n.openStart>e.depth)throw new kk("Inserted content deeper than insertion position");if(e.depth-n.openStart!=t.depth-n.openEnd)throw new kk("Inconsistent open depths");return Dk(e,t,n,0)}function Dk(e,t,n,r){var i=e.index(r),o=e.node(r);if(i==t.index(r)&&r<e.depth-n.openStart){var s=Dk(e,t,n,r+1);return o.copy(o.content.replaceChild(i,s))}if(n.content.size){if(n.openStart||n.openEnd||e.depth!=r||t.depth!=r){var a=function(e,t){for(var n=t.depth-e.openStart,r=t.node(n).copy(e.content),i=n-1;i>=0;i--)r=t.node(i).copy(gk.from(r));return {start:r.resolveNoCache(e.openStart+n),end:r.resolveNoCache(r.content.size-e.openEnd-n)}}(n,e);return _k(o,Tk(e,a.start,a.end,t,r))}var l=e.parent,c=l.content;return _k(l,c.cut(0,e.parentOffset).append(n.content).append(c.cut(t.parentOffset)))}return _k(o,Lk(e,t,r))}function Mk(e,t){if(!t.type.compatibleContent(e.type))throw new kk("Cannot join "+t.type.name+" onto "+e.type.name)}function Ok(e,t,n){var r=e.node(n);return Mk(r,t.node(n)),r}function Ak(e,t){var n=t.length-1;n>=0&&e.isText&&e.sameMarkup(t[n])?t[n]=e.withText(t[n].text+e.text):t.push(e);}function Nk(e,t,n,r){var i=(t||e).node(n),o=0,s=t?t.index(n):i.childCount;e&&(o=e.index(n),e.depth>n?o++:e.textOffset&&(Ak(e.nodeAfter,r),o++));for(var a=o;a<s;a++)Ak(i.child(a),r);t&&t.depth==n&&t.textOffset&&Ak(t.nodeBefore,r);}function _k(e,t){if(!e.type.validContent(t))throw new kk("Invalid content for node "+e.type.name);return e.copy(t)}function Tk(e,t,n,r,i){var o=e.depth>i&&Ok(e,t,i+1),s=r.depth>i&&Ok(n,r,i+1),a=[];return Nk(null,e,i,a),o&&s&&t.index(i)==n.index(i)?(Mk(o,s),Ak(_k(o,Tk(e,t,n,r,i+1)),a)):(o&&Ak(_k(o,Lk(e,t,i+1)),a),Nk(t,n,i,a),s&&Ak(_k(s,Lk(n,r,i+1)),a)),Nk(r,null,i,a),new gk(a)}function Lk(e,t,n){var r=[];(Nk(null,e,n,r),e.depth>n)&&Ak(_k(Ok(e,t,n+1),Lk(e,t,n+1)),r);return Nk(t,null,n,r),new gk(r)}Ck.empty=new Ck(gk.empty,0,0);var Rk=function(){function e(t,n,r){lk(this,e),this.pos=t,this.path=n,this.parentOffset=r,this.depth=n.length/3-1;}return uk(e,[{key:"resolveDepth",value:function(e){return null==e?this.depth:e<0?this.depth+e:e}},{key:"parent",get:function(){return this.node(this.depth)}},{key:"doc",get:function(){return this.node(0)}},{key:"node",value:function(e){return this.path[3*this.resolveDepth(e)]}},{key:"index",value:function(e){return this.path[3*this.resolveDepth(e)+1]}},{key:"indexAfter",value:function(e){return e=this.resolveDepth(e),this.index(e)+(e!=this.depth||this.textOffset?1:0)}},{key:"start",value:function(e){return 0==(e=this.resolveDepth(e))?0:this.path[3*e-1]+1}},{key:"end",value:function(e){return e=this.resolveDepth(e),this.start(e)+this.node(e).content.size}},{key:"before",value:function(e){if(!(e=this.resolveDepth(e)))throw new RangeError("There is no position before the top-level node");return e==this.depth+1?this.pos:this.path[3*e-1]}},{key:"after",value:function(e){if(!(e=this.resolveDepth(e)))throw new RangeError("There is no position after the top-level node");return e==this.depth+1?this.pos:this.path[3*e-1]+this.path[3*e].nodeSize}},{key:"textOffset",get:function(){return this.pos-this.path[this.path.length-1]}},{key:"nodeAfter",get:function(){var e=this.parent,t=this.index(this.depth);if(t==e.childCount)return null;var n=this.pos-this.path[this.path.length-1],r=e.child(t);return n?e.child(t).cut(n):r}},{key:"nodeBefore",get:function(){var e=this.index(this.depth),t=this.pos-this.path[this.path.length-1];return t?this.parent.child(e).cut(0,t):0==e?null:this.parent.child(e-1)}},{key:"posAtIndex",value:function(e,t){t=this.resolveDepth(t);for(var n=this.path[3*t],r=0==t?0:this.path[3*t-1]+1,i=0;i<e;i++)r+=n.child(i).nodeSize;return r}},{key:"marks",value:function(){var e=this.parent,t=this.index();if(0==e.content.size)return wk.none;if(this.textOffset)return e.child(t).marks;var n=e.maybeChild(t-1),r=e.maybeChild(t);if(!n){var i=n;n=r,r=i;}for(var o=n.marks,s=0;s<o.length;s++)!1!==o[s].type.spec.inclusive||r&&o[s].isInSet(r.marks)||(o=o[s--].removeFromSet(o));return o}},{key:"marksAcross",value:function(e){var t=this.parent.maybeChild(this.index());if(!t||!t.isInline)return null;for(var n=t.marks,r=e.parent.maybeChild(e.index()),i=0;i<n.length;i++)!1!==n[i].type.spec.inclusive||r&&n[i].isInSet(r.marks)||(n=n[i--].removeFromSet(n));return n}},{key:"sharedDepth",value:function(e){for(var t=this.depth;t>0;t--)if(this.start(t)<=e&&this.end(t)>=e)return t;return 0}},{key:"blockRange",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this,t=arguments.length>1?arguments[1]:void 0;if(e.pos<this.pos)return e.blockRange(this);for(var n=this.depth-(this.parent.inlineContent||this.pos==e.pos?1:0);n>=0;n--)if(e.pos<=this.end(n)&&(!t||t(this.node(n))))return new Pk(this,e,n);return null}},{key:"sameParent",value:function(e){return this.pos-this.parentOffset==e.pos-e.parentOffset}},{key:"max",value:function(e){return e.pos>this.pos?e:this}},{key:"min",value:function(e){return e.pos<this.pos?e:this}},{key:"toString",value:function(){for(var e="",t=1;t<=this.depth;t++)e+=(e?"/":"")+this.node(t).type.name+"_"+this.index(t-1);return e+":"+this.parentOffset}}],[{key:"resolve",value:function(t,n){if(!(n>=0&&n<=t.content.size))throw new RangeError("Position "+n+" out of range");for(var r=[],i=0,o=n,s=t;;){var a=s.content.findIndex(o),l=a.index,c=a.offset,u=o-c;if(r.push(s,l,i+c),!u)break;if((s=s.child(l)).isText)break;o=u-1,i+=c+1;}return new e(n,r,o)}},{key:"resolveCached",value:function(t,n){for(var r=0;r<Fk.length;r++){var i=Fk[r];if(i.pos==n&&i.doc==t)return i}var o=Fk[Bk]=e.resolve(t,n);return Bk=(Bk+1)%Ik,o}}]),e}(),Fk=[],Bk=0,Ik=12,Pk=function(){function e(t,n,r){lk(this,e),this.$from=t,this.$to=n,this.depth=r;}return uk(e,[{key:"start",get:function(){return this.$from.before(this.depth+1)}},{key:"end",get:function(){return this.$to.after(this.depth+1)}},{key:"parent",get:function(){return this.$from.node(this.depth)}},{key:"startIndex",get:function(){return this.$from.index(this.depth)}},{key:"endIndex",get:function(){return this.$to.indexAfter(this.depth)}}]),e}(),zk=Object.create(null),$k=function(){function e(t,n,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:wk.none;lk(this,e),this.type=t,this.attrs=n,this.marks=i,this.content=r||gk.empty;}return uk(e,[{key:"nodeSize",get:function(){return this.isLeaf?1:2+this.content.size}},{key:"childCount",get:function(){return this.content.childCount}},{key:"child",value:function(e){return this.content.child(e)}},{key:"maybeChild",value:function(e){return this.content.maybeChild(e)}},{key:"forEach",value:function(e){this.content.forEach(e);}},{key:"nodesBetween",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.content.nodesBetween(e,t,n,r,this);}},{key:"descendants",value:function(e){this.nodesBetween(0,this.content.size,e);}},{key:"textContent",get:function(){return this.isLeaf&&this.type.spec.leafText?this.type.spec.leafText(this):this.textBetween(0,this.content.size,"")}},{key:"textBetween",value:function(e,t,n,r){return this.content.textBetween(e,t,n,r)}},{key:"firstChild",get:function(){return this.content.firstChild}},{key:"lastChild",get:function(){return this.content.lastChild}},{key:"eq",value:function(e){return this==e||this.sameMarkup(e)&&this.content.eq(e.content)}},{key:"sameMarkup",value:function(e){return this.hasMarkup(e.type,e.attrs,e.marks)}},{key:"hasMarkup",value:function(e,t,n){return this.type==e&&bk(this.attrs,t||e.defaultAttrs||zk)&&wk.sameSet(this.marks,n||wk.none)}},{key:"copy",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return t==this.content?this:new e(this.type,this.attrs,t,this.marks)}},{key:"mark",value:function(t){return t==this.marks?this:new e(this.type,this.attrs,this.content,t)}},{key:"cut",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.content.size;return 0==e&&t==this.content.size?this:this.copy(this.content.cut(e,t))}},{key:"slice",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.content.size,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e==t)return Ck.empty;var r=this.resolve(e),i=this.resolve(t),o=n?0:r.sharedDepth(t),s=r.start(o),a=r.node(o),l=a.content.cut(r.pos-s,i.pos-s);return new Ck(l,r.depth-o,i.depth-o)}},{key:"replace",value:function(e,t,n){return Sk(this.resolve(e),this.resolve(t),n)}},{key:"nodeAt",value:function(e){for(var t=this;;){var n=t.content.findIndex(e),r=n.index,i=n.offset;if(!(t=t.maybeChild(r)))return null;if(i==e||t.isText)return t;e-=i+1;}}},{key:"childAfter",value:function(e){var t=this.content.findIndex(e),n=t.index,r=t.offset;return {node:this.content.maybeChild(n),index:n,offset:r}}},{key:"childBefore",value:function(e){if(0==e)return {node:null,index:0,offset:0};var t=this.content.findIndex(e),n=t.index,r=t.offset;if(r<e)return {node:this.content.child(n),index:n,offset:r};var i=this.content.child(n-1);return {node:i,index:n-1,offset:r-i.nodeSize}}},{key:"resolve",value:function(e){return Rk.resolveCached(this,e)}},{key:"resolveNoCache",value:function(e){return Rk.resolve(this,e)}},{key:"rangeHasMark",value:function(e,t,n){var r=!1;return t>e&&this.nodesBetween(e,t,(function(e){return n.isInSet(e.marks)&&(r=!0),!r})),r}},{key:"isBlock",get:function(){return this.type.isBlock}},{key:"isTextblock",get:function(){return this.type.isTextblock}},{key:"inlineContent",get:function(){return this.type.inlineContent}},{key:"isInline",get:function(){return this.type.isInline}},{key:"isText",get:function(){return this.type.isText}},{key:"isLeaf",get:function(){return this.type.isLeaf}},{key:"isAtom",get:function(){return this.type.isAtom}},{key:"toString",value:function(){if(this.type.spec.toDebugString)return this.type.spec.toDebugString(this);var e=this.type.name;return this.content.size&&(e+="("+this.content.toStringInner()+")"),Hk(this.marks,e)}},{key:"contentMatchAt",value:function(e){var t=this.type.contentMatch.matchFragment(this.content,0,e);if(!t)throw new Error("Called contentMatchAt on a node with invalid content");return t}},{key:"canReplace",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:gk.empty,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:n.childCount,o=this.contentMatchAt(e).matchFragment(n,r,i),s=o&&o.matchFragment(this.content,t);if(!s||!s.validEnd)return !1;for(var a=r;a<i;a++)if(!this.type.allowsMarks(n.child(a).marks))return !1;return !0}},{key:"canReplaceWith",value:function(e,t,n,r){if(r&&!this.type.allowsMarks(r))return !1;var i=this.contentMatchAt(e).matchType(n),o=i&&i.matchFragment(this.content,t);return !!o&&o.validEnd}},{key:"canAppend",value:function(e){return e.content.size?this.canReplace(this.childCount,this.childCount,e.content):this.type.compatibleContent(e.type)}},{key:"check",value:function(){if(!this.type.validContent(this.content))throw new RangeError("Invalid content for node ".concat(this.type.name,": ").concat(this.content.toString().slice(0,50)));for(var e=wk.none,t=0;t<this.marks.length;t++)e=this.marks[t].addToSet(e);if(!wk.sameSet(e,this.marks))throw new RangeError("Invalid collection of marks for node ".concat(this.type.name,": ").concat(this.marks.map((function(e){return e.type.name}))));this.content.forEach((function(e){return e.check()}));}},{key:"toJSON",value:function(){var e={type:this.type.name};for(var t in this.attrs){e.attrs=this.attrs;break}return this.content.size&&(e.content=this.content.toJSON()),this.marks.length&&(e.marks=this.marks.map((function(e){return e.toJSON()}))),e}}],[{key:"fromJSON",value:function(e,t){if(!t)throw new RangeError("Invalid input for Node.fromJSON");var n=null;if(t.marks){if(!Array.isArray(t.marks))throw new RangeError("Invalid mark data for Node.fromJSON");n=t.marks.map(e.markFromJSON);}if("text"==t.type){if("string"!=typeof t.text)throw new RangeError("Invalid text node in JSON");return e.text(t.text,n)}var r=gk.fromJSON(e,t.content);return e.nodeType(t.type).create(t.attrs,r,n)}}]),e}();$k.prototype.text=void 0;var jk=function(e){ek(n,$k);var t=tk(n);function n(e,r,i,o){var s;if(lk(this,n),s=t.call(this,e,r,null,o),!i)throw new RangeError("Empty text nodes are not allowed");return s.text=i,s}return uk(n,[{key:"toString",value:function(){return this.type.spec.toDebugString?this.type.spec.toDebugString(this):Hk(this.marks,JSON.stringify(this.text))}},{key:"textContent",get:function(){return this.text}},{key:"textBetween",value:function(e,t){return this.text.slice(e,t)}},{key:"nodeSize",get:function(){return this.text.length}},{key:"mark",value:function(e){return e==this.marks?this:new n(this.type,this.attrs,this.text,e)}},{key:"withText",value:function(e){return e==this.text?this:new n(this.type,this.attrs,e,this.marks)}},{key:"cut",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.text.length;return 0==e&&t==this.text.length?this:this.withText(this.text.slice(e,t))}},{key:"eq",value:function(e){return this.sameMarkup(e)&&this.text==e.text}},{key:"toJSON",value:function(){var e=Qw(ak(n.prototype),"toJSON",this).call(this);return e.text=this.text,e}}]),n}();function Hk(e,t){for(var n=e.length-1;n>=0;n--)t=e[n].type.name+"("+t+")";return t}var Vk=function(){function e(t){lk(this,e),this.validEnd=t,this.next=[],this.wrapCache=[];}return uk(e,[{key:"matchType",value:function(e){for(var t=0;t<this.next.length;t++)if(this.next[t].type==e)return this.next[t].next;return null}},{key:"matchFragment",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.childCount,r=this,i=t;r&&i<n;i++)r=r.matchType(e.child(i).type);return r}},{key:"inlineContent",get:function(){return this.next.length&&this.next[0].type.isInline}},{key:"defaultType",get:function(){for(var e=0;e<this.next.length;e++){var t=this.next[e].type;if(!t.isText&&!t.hasRequiredAttrs())return t}return null}},{key:"compatible",value:function(e){for(var t=0;t<this.next.length;t++)for(var n=0;n<e.next.length;n++)if(this.next[t].type==e.next[n].type)return !0;return !1}},{key:"fillBefore",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[this];function i(o,s){var a=o.matchFragment(e,n);if(a&&(!t||a.validEnd))return gk.from(s.map((function(e){return e.createAndFill()})));for(var l=0;l<o.next.length;l++){var c=o.next[l],u=c.type,d=c.next;if(!u.isText&&!u.hasRequiredAttrs()&&-1==r.indexOf(d)){r.push(d);var h=i(d,s.concat(u));if(h)return h}}return null}return i(this,[])}},{key:"findWrapping",value:function(e){for(var t=0;t<this.wrapCache.length;t+=2)if(this.wrapCache[t]==e)return this.wrapCache[t+1];var n=this.computeWrapping(e);return this.wrapCache.push(e,n),n}},{key:"computeWrapping",value:function(e){for(var t=Object.create(null),n=[{match:this,type:null,via:null}];n.length;){var r=n.shift(),i=r.match;if(i.matchType(e)){for(var o=[],s=r;s.type;s=s.via)o.push(s.type);return o.reverse()}for(var a=0;a<i.next.length;a++){var l=i.next[a],c=l.type,u=l.next;c.isLeaf||c.hasRequiredAttrs()||c.name in t||r.type&&!u.validEnd||(n.push({match:c.contentMatch,type:c,via:r}),t[c.name]=!0);}}return null}},{key:"edgeCount",get:function(){return this.next.length}},{key:"edge",value:function(e){if(e>=this.next.length)throw new RangeError("There's no ".concat(e,"th edge in this content match"));return this.next[e]}},{key:"toString",value:function(){var e=[];return function t(n){e.push(n);for(var r=0;r<n.next.length;r++)-1==e.indexOf(n.next[r].next)&&t(n.next[r].next);}(this),e.map((function(t,n){for(var r=n+(t.validEnd?"*":" ")+" ",i=0;i<t.next.length;i++)r+=(i?", ":"")+t.next[i].type.name+"->"+e.indexOf(t.next[i].next);return r})).join("\n")}}],[{key:"parse",value:function(t,n){var r=new Kk(t,n);if(null==r.next)return e.empty;var i=qk(r);r.next&&r.err("Unexpected trailing text");var o=Qk(function(e){var t=[[]];return i(o(e,0),n()),t;function n(){return t.push([])-1}function r(e,n,r){var i={term:r,to:n};return t[e].push(i),i}function i(e,t){e.forEach((function(e){return e.to=t}));}function o(e,t){if("choice"==e.type)return e.exprs.reduce((function(e,n){return e.concat(o(n,t))}),[]);if("seq"!=e.type){if("star"==e.type){var s=n();return r(t,s),i(o(e.expr,s),s),[r(s)]}if("plus"==e.type){var a=n();return i(o(e.expr,t),a),i(o(e.expr,a),a),[r(a)]}if("opt"==e.type)return [r(t)].concat(o(e.expr,t));if("range"==e.type){for(var l=t,c=0;c<e.min;c++){var u=n();i(o(e.expr,l),u),l=u;}if(-1==e.max)i(o(e.expr,l),l);else for(var d=e.min;d<e.max;d++){var h=n();r(l,h),i(o(e.expr,l),h),l=h;}return [r(l)]}if("name"==e.type)return [r(t,void 0,e.value)];throw new Error("Unknown expr type")}for(var p=0;;p++){var f=o(e.exprs[p],t);if(p==e.exprs.length-1)return f;i(f,t=n());}}}(i));return function(e,t){for(var n=0,r=[e];n<r.length;n++){for(var i=r[n],o=!i.validEnd,s=[],a=0;a<i.next.length;a++){var l=i.next[a],c=l.type,u=l.next;s.push(c.name),!o||c.isText||c.hasRequiredAttrs()||(o=!1),-1==r.indexOf(u)&&r.push(u);}o&&t.err("Only non-generatable nodes ("+s.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)");}}(o,r),o}}]),e}();Vk.empty=new Vk(!0);var Kk=function(){function e(t,n){lk(this,e),this.string=t,this.nodeTypes=n,this.inline=null,this.pos=0,this.tokens=t.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&&this.tokens.pop(),""==this.tokens[0]&&this.tokens.shift();}return uk(e,[{key:"next",get:function(){return this.tokens[this.pos]}},{key:"eat",value:function(e){return this.next==e&&(this.pos++||!0)}},{key:"err",value:function(e){throw new SyntaxError(e+" (in content expression '"+this.string+"')")}}]),e}();function qk(e){var t=[];do{t.push(Uk(e));}while(e.eat("|"));return 1==t.length?t[0]:{type:"choice",exprs:t}}function Uk(e){var t=[];do{t.push(Wk(e));}while(e.next&&")"!=e.next&&"|"!=e.next);return 1==t.length?t[0]:{type:"seq",exprs:t}}function Wk(e){for(var t=function(e){if(e.eat("(")){var t=qk(e);return e.eat(")")||e.err("Missing closing paren"),t}if(!/\W/.test(e.next)){var n=function(e,t){var n=e.nodeTypes,r=n[t];if(r)return [r];var i=[];for(var o in n){var s=n[o];s.groups.indexOf(t)>-1&&i.push(s);}0==i.length&&e.err("No node type or group '"+t+"' found");return i}(e,e.next).map((function(t){return null==e.inline?e.inline=t.isInline:e.inline!=t.isInline&&e.err("Mixing inline and block content"),{type:"name",value:t}}));return e.pos++,1==n.length?n[0]:{type:"choice",exprs:n}}e.err("Unexpected token '"+e.next+"'");}(e);;)if(e.eat("+"))t={type:"plus",expr:t};else if(e.eat("*"))t={type:"star",expr:t};else if(e.eat("?"))t={type:"opt",expr:t};else {if(!e.eat("{"))break;t=Jk(e,t);}return t}function Gk(e){/\D/.test(e.next)&&e.err("Expected number, got '"+e.next+"'");var t=Number(e.next);return e.pos++,t}function Jk(e,t){var n=Gk(e),r=n;return e.eat(",")&&(r="}"!=e.next?Gk(e):-1),e.eat("}")||e.err("Unclosed braced range"),{type:"range",min:n,max:r,expr:t}}function Zk(e,t){return t-e}function Xk(e,t){var n=[];return function t(r){var i=e[r];if(1==i.length&&!i[0].term)return t(i[0].to);n.push(r);for(var o=0;o<i.length;o++){var s=i[o],a=s.term,l=s.to;a||-1!=n.indexOf(l)||t(l);}}(t),n.sort(Zk)}function Qk(e){var t=Object.create(null);return function n(r){var i=[];r.forEach((function(t){e[t].forEach((function(t){var n=t.term,r=t.to;if(n){for(var o,s=0;s<i.length;s++)i[s][0]==n&&(o=i[s][1]);Xk(e,r).forEach((function(e){o||i.push([n,o=[]]),-1==o.indexOf(e)&&o.push(e);}));}}));}));for(var o=t[r.join(",")]=new Vk(r.indexOf(e.length-1)>-1),s=0;s<i.length;s++){var a=i[s][1].sort(Zk);o.next.push({type:i[s][0],next:t[a.join(",")]||n(a)});}return o}(Xk(e,0))}function Yk(e){var t=Object.create(null);for(var n in e){var r=e[n];if(!r.hasDefault)return null;t[n]=r.default;}return t}function eC(e,t){var n=Object.create(null);for(var r in e){var i=t&&t[r];if(void 0===i){var o=e[r];if(!o.hasDefault)throw new RangeError("No value supplied for attribute "+r);i=o.default;}n[r]=i;}return n}function tC(e){var t=Object.create(null);if(e)for(var n in e)t[n]=new rC(e[n]);return t}var nC=function(){function e(t,n,r){lk(this,e),this.name=t,this.schema=n,this.spec=r,this.markSet=null,this.groups=r.group?r.group.split(" "):[],this.attrs=tC(r.attrs),this.defaultAttrs=Yk(this.attrs),this.contentMatch=null,this.inlineContent=null,this.isBlock=!(r.inline||"text"==t),this.isText="text"==t;}return uk(e,[{key:"isInline",get:function(){return !this.isBlock}},{key:"isTextblock",get:function(){return this.isBlock&&this.inlineContent}},{key:"isLeaf",get:function(){return this.contentMatch==Vk.empty}},{key:"isAtom",get:function(){return this.isLeaf||!!this.spec.atom}},{key:"whitespace",get:function(){return this.spec.whitespace||(this.spec.code?"pre":"normal")}},{key:"hasRequiredAttrs",value:function(){for(var e in this.attrs)if(this.attrs[e].isRequired)return !0;return !1}},{key:"compatibleContent",value:function(e){return this==e||this.contentMatch.compatible(e.contentMatch)}},{key:"computeAttrs",value:function(e){return !e&&this.defaultAttrs?this.defaultAttrs:eC(this.attrs,e)}},{key:"create",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;if(this.isText)throw new Error("NodeType.create can't construct text nodes");return new $k(this,this.computeAttrs(e),gk.from(t),wk.setFrom(n))}},{key:"createChecked",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;if(t=gk.from(t),!this.validContent(t))throw new RangeError("Invalid content for node "+this.name);return new $k(this,this.computeAttrs(e),t,wk.setFrom(n))}},{key:"createAndFill",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;if(e=this.computeAttrs(e),(t=gk.from(t)).size){var r=this.contentMatch.fillBefore(t);if(!r)return null;t=r.append(t);}var i=this.contentMatch.matchFragment(t),o=i&&i.fillBefore(gk.empty,!0);return o?new $k(this,e,t.append(o),wk.setFrom(n)):null}},{key:"validContent",value:function(e){var t=this.contentMatch.matchFragment(e);if(!t||!t.validEnd)return !1;for(var n=0;n<e.childCount;n++)if(!this.allowsMarks(e.child(n).marks))return !1;return !0}},{key:"allowsMarkType",value:function(e){return null==this.markSet||this.markSet.indexOf(e)>-1}},{key:"allowsMarks",value:function(e){if(null==this.markSet)return !0;for(var t=0;t<e.length;t++)if(!this.allowsMarkType(e[t].type))return !1;return !0}},{key:"allowedMarks",value:function(e){if(null==this.markSet)return e;for(var t,n=0;n<e.length;n++)this.allowsMarkType(e[n].type)?t&&t.push(e[n]):t||(t=e.slice(0,n));return t?t.length?t:wk.none:e}}],[{key:"compile",value:function(t,n){var r=Object.create(null);t.forEach((function(t,i){return r[t]=new e(t,n,i)}));var i=n.spec.topNode||"doc";if(!r[i])throw new RangeError("Schema is missing its top node type ('"+i+"')");if(!r.text)throw new RangeError("Every schema needs a 'text' type");for(var o in r.text.attrs)throw new RangeError("The text node type should not have attributes");return r}}]),e}(),rC=function(){function e(t){lk(this,e),this.hasDefault=Object.prototype.hasOwnProperty.call(t,"default"),this.default=t.default;}return uk(e,[{key:"isRequired",get:function(){return !this.hasDefault}}]),e}(),iC=function(){function e(t,n,r,i){lk(this,e),this.name=t,this.rank=n,this.schema=r,this.spec=i,this.attrs=tC(i.attrs),this.excluded=null;var o=Yk(this.attrs);this.instance=o?new wk(this,o):null;}return uk(e,[{key:"create",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return !e&&this.instance?this.instance:new wk(this,eC(this.attrs,e))}},{key:"removeFromSet",value:function(e){for(var t=0;t<e.length;t++)e[t].type==this&&(e=e.slice(0,t).concat(e.slice(t+1)),t--);return e}},{key:"isInSet",value:function(e){for(var t=0;t<e.length;t++)if(e[t].type==this)return e[t]}},{key:"excludes",value:function(e){return this.excluded.indexOf(e)>-1}}],[{key:"compile",value:function(t,n){var r=Object.create(null),i=0;return t.forEach((function(t,o){return r[t]=new e(t,i++,n,o)})),r}}]),e}(),oC=function(){function e(t){lk(this,e),this.cached=Object.create(null),this.spec={nodes:pk.default.from(t.nodes),marks:pk.default.from(t.marks||{}),topNode:t.topNode},this.nodes=nC.compile(this.spec.nodes,this),this.marks=iC.compile(this.spec.marks,this);var n=Object.create(null);for(var r in this.nodes){if(r in this.marks)throw new RangeError(r+" can not be both a node and a mark");var i=this.nodes[r],o=i.spec.content||"",s=i.spec.marks;i.contentMatch=n[o]||(n[o]=Vk.parse(o,this.nodes)),i.inlineContent=i.contentMatch.inlineContent,i.markSet="_"==s?null:s?sC(this,s.split(" ")):""!=s&&i.inlineContent?null:[];}for(var a in this.marks){var l=this.marks[a],c=l.spec.excludes;l.excluded=null==c?[l]:""==c?[]:sC(this,c.split(" "));}this.nodeFromJSON=this.nodeFromJSON.bind(this),this.markFromJSON=this.markFromJSON.bind(this),this.topNodeType=this.nodes[this.spec.topNode||"doc"],this.cached.wrappings=Object.create(null);}return uk(e,[{key:"node",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if("string"==typeof e)e=this.nodeType(e);else {if(!(e instanceof nC))throw new RangeError("Invalid node type: "+e);if(e.schema!=this)throw new RangeError("Node type from different schema used ("+e.name+")")}return e.createChecked(t,n,r)}},{key:"text",value:function(e,t){var n=this.nodes.text;return new jk(n,n.defaultAttrs,e,wk.setFrom(t))}},{key:"mark",value:function(e,t){return "string"==typeof e&&(e=this.marks[e]),e.create(t)}},{key:"nodeFromJSON",value:function(e){return $k.fromJSON(this,e)}},{key:"markFromJSON",value:function(e){return wk.fromJSON(this,e)}},{key:"nodeType",value:function(e){var t=this.nodes[e];if(!t)throw new RangeError("Unknown node type: "+e);return t}}]),e}();function sC(e,t){for(var n=[],r=0;r<t.length;r++){var i=t[r],o=e.marks[i],s=o;if(o)n.push(o);else for(var a in e.marks){var l=e.marks[a];("_"==i||l.spec.group&&l.spec.group.split(" ").indexOf(i)>-1)&&n.push(s=l);}if(!s)throw new SyntaxError("Unknown mark type: '"+t[r]+"'")}return n}var aC=function(){function e(t,n){var r=this;lk(this,e),this.schema=t,this.rules=n,this.tags=[],this.styles=[],n.forEach((function(e){e.tag?r.tags.push(e):e.style&&r.styles.push(e);})),this.normalizeLists=!this.tags.some((function(e){if(!/^(ul|ol)\b/.test(e.tag)||!e.node)return !1;var n=t.nodes[e.node];return n.contentMatch.matchType(n)}));}return uk(e,[{key:"parse",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new pC(this,t,!1);return n.addAll(e,t.from,t.to),n.finish()}},{key:"parseSlice",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new pC(this,t,!0);return n.addAll(e,t.from,t.to),Ck.maxOpen(n.finish())}},{key:"matchTag",value:function(e,t,n){for(var r=n?this.tags.indexOf(n)+1:0;r<this.tags.length;r++){var i=this.tags[r];if(fC(e,i.tag)&&(void 0===i.namespace||e.namespaceURI==i.namespace)&&(!i.context||t.matchesContext(i.context))){if(i.getAttrs){var o=i.getAttrs(e);if(!1===o)continue;i.attrs=o||void 0;}return i}}}},{key:"matchStyle",value:function(e,t,n,r){for(var i=r?this.styles.indexOf(r)+1:0;i<this.styles.length;i++){var o=this.styles[i],s=o.style;if(!(0!=s.indexOf(e)||o.context&&!n.matchesContext(o.context)||s.length>e.length&&(61!=s.charCodeAt(e.length)||s.slice(e.length+1)!=t))){if(o.getAttrs){var a=o.getAttrs(t);if(!1===a)continue;o.attrs=a||void 0;}return o}}}}],[{key:"schemaRules",value:function(e){var t=[];function n(e){for(var n=null==e.priority?50:e.priority,r=0;r<t.length;r++){var i=t[r];if((null==i.priority?50:i.priority)<n)break}t.splice(r,0,e);}var r=function(t){var r=e.marks[t].spec.parseDOM;r&&r.forEach((function(e){n(e=mC(e)),e.mark=t;}));};for(var i in e.marks)r(i);var o=function(t){var r=e.nodes[t].spec.parseDOM;r&&r.forEach((function(e){n(e=mC(e)),e.node=t;}));};for(var s in e.nodes)o(s);return t}},{key:"fromSchema",value:function(t){return t.cached.domParser||(t.cached.domParser=new e(t,e.schemaRules(t)))}}]),e}(),lC={address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},cC={head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},uC={ol:!0,ul:!0};function dC(e,t,n){return null!=t?(t?1:0)|("full"===t?2:0):e&&"pre"==e.whitespace?3:-5&n}var hC=function(){function e(t,n,r,i,o,s,a){lk(this,e),this.type=t,this.attrs=n,this.marks=r,this.pendingMarks=i,this.solid=o,this.options=a,this.content=[],this.activeMarks=wk.none,this.stashMarks=[],this.match=s||(4&a?null:t.contentMatch);}return uk(e,[{key:"findWrapping",value:function(e){if(!this.match){if(!this.type)return [];var t=this.type.contentMatch.fillBefore(gk.from(e));if(!t){var n,r=this.type.contentMatch;return (n=r.findWrapping(e.type))?(this.match=r,n):null}this.match=this.type.contentMatch.matchFragment(t);}return this.match.findWrapping(e.type)}},{key:"finish",value:function(e){if(!(1&this.options)){var t,n=this.content[this.content.length-1];if(n&&n.isText&&(t=/[ \t\r\n\u000c]+$/.exec(n.text))){var r=n;n.text.length==t[0].length?this.content.pop():this.content[this.content.length-1]=r.withText(r.text.slice(0,r.text.length-t[0].length));}}var i=gk.from(this.content);return !e&&this.match&&(i=i.append(this.match.fillBefore(gk.empty,!0))),this.type?this.type.create(this.attrs,i,this.marks):i}},{key:"popFromStashMark",value:function(e){for(var t=this.stashMarks.length-1;t>=0;t--)if(e.eq(this.stashMarks[t]))return this.stashMarks.splice(t,1)[0]}},{key:"applyPending",value:function(e){for(var t=0,n=this.pendingMarks;t<n.length;t++){var r=n[t];(this.type?this.type.allowsMarkType(r.type):gC(r.type,e))&&!r.isInSet(this.activeMarks)&&(this.activeMarks=r.addToSet(this.activeMarks),this.pendingMarks=r.removeFromSet(this.pendingMarks));}}},{key:"inlineContext",value:function(e){return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:e.parentNode&&!lC.hasOwnProperty(e.parentNode.nodeName.toLowerCase())}}]),e}(),pC=function(){function e(t,n,r){lk(this,e),this.parser=t,this.options=n,this.isOpen=r,this.open=0;var i,o=n.topNode,s=dC(null,n.preserveWhitespace,0)|(r?4:0);i=o?new hC(o.type,o.attrs,wk.none,wk.none,!0,n.topMatch||o.type.contentMatch,s):new hC(r?null:t.schema.topNodeType,null,wk.none,wk.none,!0,null,s),this.nodes=[i],this.find=n.findPositions,this.needsBlock=!1;}return uk(e,[{key:"top",get:function(){return this.nodes[this.open]}},{key:"addDOM",value:function(e){if(3==e.nodeType)this.addTextNode(e);else if(1==e.nodeType){var t=e.getAttribute("style"),n=t?this.readStyles(function(e){var t,n=/\s*([\w-]+)\s*:\s*([^;]+)/g,r=[];for(;t=n.exec(e);)r.push(t[1],t[2].trim());return r}(t)):null,r=this.top;if(null!=n)for(var i=0;i<n.length;i++)this.addPendingMark(n[i]);if(this.addElement(e),null!=n)for(var o=0;o<n.length;o++)this.removePendingMark(n[o],r);}}},{key:"addTextNode",value:function(e){var t=e.nodeValue,n=this.top;if(2&n.options||n.inlineContext(e)||/[^ \t\r\n\u000c]/.test(t)){if(1&n.options)t=2&n.options?t.replace(/\r\n?/g,"\n"):t.replace(/\r?\n|\r/g," ");else if(t=t.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(t)&&this.open==this.nodes.length-1){var r=n.content[n.content.length-1],i=e.previousSibling;(!r||i&&"BR"==i.nodeName||r.isText&&/[ \t\r\n\u000c]$/.test(r.text))&&(t=t.slice(1));}t&&this.insertNode(this.parser.schema.text(t)),this.findInText(e);}else this.findInside(e);}},{key:"addElement",value:function(e,t){var n,r=e.nodeName.toLowerCase();uC.hasOwnProperty(r)&&this.parser.normalizeLists&&function(e){for(var t=e.firstChild,n=null;t;t=t.nextSibling){var r=1==t.nodeType?t.nodeName.toLowerCase():null;r&&uC.hasOwnProperty(r)&&n?(n.appendChild(t),t=n):"li"==r?n=t:r&&(n=null);}}(e);var i=this.options.ruleFromNode&&this.options.ruleFromNode(e)||(n=this.parser.matchTag(e,this,t));if(i?i.ignore:cC.hasOwnProperty(r))this.findInside(e),this.ignoreFallback(e);else if(!i||i.skip||i.closeParent){i&&i.closeParent?this.open=Math.max(0,this.open-1):i&&i.skip.nodeType&&(e=i.skip);var o,s=this.top,a=this.needsBlock;if(lC.hasOwnProperty(r))o=!0,s.type||(this.needsBlock=!0);else if(!e.firstChild)return void this.leafFallback(e);this.addAll(e),o&&this.sync(s),this.needsBlock=a;}else this.addElementByRule(e,i,!1===i.consuming?n:void 0);}},{key:"leafFallback",value:function(e){"BR"==e.nodeName&&this.top.type&&this.top.type.inlineContent&&this.addTextNode(e.ownerDocument.createTextNode("\n"));}},{key:"ignoreFallback",value:function(e){"BR"!=e.nodeName||this.top.type&&this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"));}},{key:"readStyles",value:function(e){var t=wk.none;e:for(var n=0;n<e.length;n+=2)for(var r=void 0;;){var i=this.parser.matchStyle(e[n],e[n+1],this,r);if(!i)continue e;if(i.ignore)return null;if(t=this.parser.schema.marks[i.mark].create(i.attrs).addToSet(t),!1!==i.consuming)break;r=i;}return t}},{key:"addElementByRule",value:function(e,t,n){var r,i,o,s=this;t.node?(i=this.parser.schema.nodes[t.node]).isLeaf?this.insertNode(i.create(t.attrs))||this.leafFallback(e):r=this.enter(i,t.attrs||null,t.preserveWhitespace):(o=this.parser.schema.marks[t.mark].create(t.attrs),this.addPendingMark(o));var a=this.top;if(i&&i.isLeaf)this.findInside(e);else if(n)this.addElement(e,n);else if(t.getContent)this.findInside(e),t.getContent(e,this.parser.schema).forEach((function(e){return s.insertNode(e)}));else {var l=e;"string"==typeof t.contentElement?l=e.querySelector(t.contentElement):"function"==typeof t.contentElement?l=t.contentElement(e):t.contentElement&&(l=t.contentElement),this.findAround(e,l,!0),this.addAll(l);}r&&this.sync(a)&&this.open--,o&&this.removePendingMark(o,a);}},{key:"addAll",value:function(e,t,n){for(var r=t||0,i=t?e.childNodes[t]:e.firstChild,o=null==n?null:e.childNodes[n];i!=o;i=i.nextSibling,++r)this.findAtPoint(e,r),this.addDOM(i);this.findAtPoint(e,r);}},{key:"findPlace",value:function(e){for(var t,n,r=this.open;r>=0;r--){var i=this.nodes[r],o=i.findWrapping(e);if(o&&(!t||t.length>o.length)&&(t=o,n=i,!o.length))break;if(i.solid)break}if(!t)return !1;this.sync(n);for(var s=0;s<t.length;s++)this.enterInner(t[s],null,!1);return !0}},{key:"insertNode",value:function(e){if(e.isInline&&this.needsBlock&&!this.top.type){var t=this.textblockFromContext();t&&this.enterInner(t);}if(this.findPlace(e)){this.closeExtra();var n=this.top;n.applyPending(e.type),n.match&&(n.match=n.match.matchType(e.type));for(var r=n.activeMarks,i=0;i<e.marks.length;i++)n.type&&!n.type.allowsMarkType(e.marks[i].type)||(r=e.marks[i].addToSet(r));return n.content.push(e.mark(r)),!0}return !1}},{key:"enter",value:function(e,t,n){var r=this.findPlace(e.create(t));return r&&this.enterInner(e,t,!0,n),r}},{key:"enterInner",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0;this.closeExtra();var i=this.top;i.applyPending(e),i.match=i.match&&i.match.matchType(e);var o=dC(e,r,i.options);4&i.options&&0==i.content.length&&(o|=4),this.nodes.push(new hC(e,t,i.activeMarks,i.pendingMarks,n,null,o)),this.open++;}},{key:"closeExtra",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.nodes.length-1;if(t>this.open){for(;t>this.open;t--)this.nodes[t-1].content.push(this.nodes[t].finish(e));this.nodes.length=this.open+1;}}},{key:"finish",value:function(){return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}},{key:"sync",value:function(e){for(var t=this.open;t>=0;t--)if(this.nodes[t]==e)return this.open=t,!0;return !1}},{key:"currentPos",get:function(){this.closeExtra();for(var e=0,t=this.open;t>=0;t--){for(var n=this.nodes[t].content,r=n.length-1;r>=0;r--)e+=n[r].nodeSize;t&&e++;}return e}},{key:"findAtPoint",value:function(e,t){if(this.find)for(var n=0;n<this.find.length;n++)this.find[n].node==e&&this.find[n].offset==t&&(this.find[n].pos=this.currentPos);}},{key:"findInside",value:function(e){if(this.find)for(var t=0;t<this.find.length;t++)null==this.find[t].pos&&1==e.nodeType&&e.contains(this.find[t].node)&&(this.find[t].pos=this.currentPos);}},{key:"findAround",value:function(e,t,n){if(e!=t&&this.find)for(var r=0;r<this.find.length;r++){if(null==this.find[r].pos&&1==e.nodeType&&e.contains(this.find[r].node))t.compareDocumentPosition(this.find[r].node)&(n?2:4)&&(this.find[r].pos=this.currentPos);}}},{key:"findInText",value:function(e){if(this.find)for(var t=0;t<this.find.length;t++)this.find[t].node==e&&(this.find[t].pos=this.currentPos-(e.nodeValue.length-this.find[t].offset));}},{key:"matchesContext",value:function(e){var t=this;if(e.indexOf("|")>-1)return e.split(/\s*\|\s*/).some(this.matchesContext,this);var n=e.split("/"),r=this.options.context,i=!(this.isOpen||r&&r.parent.type!=this.nodes[0].type),o=-(r?r.depth+1:0)+(i?0:1);return function e(s,a){for(;s>=0;s--){var l=n[s];if(""==l){if(s==n.length-1||0==s)continue;for(;a>=o;a--)if(e(s-1,a))return !0;return !1}var c=a>0||0==a&&i?t.nodes[a].type:r&&a>=o?r.node(a-o).type:null;if(!c||c.name!=l&&-1==c.groups.indexOf(l))return !1;a--;}return !0}(n.length-1,this.open)}},{key:"textblockFromContext",value:function(){var e=this.options.context;if(e)for(var t=e.depth;t>=0;t--){var n=e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;if(n&&n.isTextblock&&n.defaultAttrs)return n}for(var r in this.parser.schema.nodes){var i=this.parser.schema.nodes[r];if(i.isTextblock&&i.defaultAttrs)return i}}},{key:"addPendingMark",value:function(e){var t=function(e,t){for(var n=0;n<t.length;n++)if(e.eq(t[n]))return t[n]}(e,this.top.pendingMarks);t&&this.top.stashMarks.push(t),this.top.pendingMarks=e.addToSet(this.top.pendingMarks);}},{key:"removePendingMark",value:function(e,t){for(var n=this.open;n>=0;n--){var r=this.nodes[n];if(r.pendingMarks.lastIndexOf(e)>-1)r.pendingMarks=e.removeFromSet(r.pendingMarks);else {r.activeMarks=e.removeFromSet(r.activeMarks);var i=r.popFromStashMark(e);i&&r.type&&r.type.allowsMarkType(i.type)&&(r.activeMarks=i.addToSet(r.activeMarks));}if(r==t)break}}}]),e}();function fC(e,t){return (e.matches||e.msMatchesSelector||e.webkitMatchesSelector||e.mozMatchesSelector).call(e,t)}function mC(e){var t={};for(var n in e)t[n]=e[n];return t}function gC(e,t){var n=t.schema.nodes,r=function(r){var i=n[r];if(!i.allowsMarkType(e))return "continue";var o=[];return function e(n){o.push(n);for(var r=0;r<n.edgeCount;r++){var i=n.edge(r),s=i.type,a=i.next;if(s==t)return !0;if(o.indexOf(a)<0&&e(a))return !0}}(i.contentMatch)?{v:!0}:void 0};for(var i in n){var o=r(i);if("continue"!==o&&"object"===dk(o))return o.v}}var vC=function(){function e(t,n){lk(this,e),this.nodes=t,this.marks=n;}return uk(e,[{key:"serializeFragment",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;r||(r=bC(n).createDocumentFragment());var i=r,o=[];return e.forEach((function(e){if(o.length||e.marks.length){for(var r=0,s=0;r<o.length&&s<e.marks.length;){var a=e.marks[s];if(t.marks[a.type.name]){if(!a.eq(o[r][0])||!1===a.type.spec.spanning)break;r++,s++;}else s++;}for(;r<o.length;)i=o.pop()[1];for(;s<e.marks.length;){var l=e.marks[s++],c=t.serializeMark(l,e.isInline,n);c&&(o.push([l,i]),i.appendChild(c.dom),i=c.contentDOM||c.dom);}}i.appendChild(t.serializeNodeInner(e,n));})),r}},{key:"serializeNodeInner",value:function(t,n){var r=e.renderSpec(bC(n),this.nodes[t.type.name](t)),i=r.dom,o=r.contentDOM;if(o){if(t.isLeaf)throw new RangeError("Content hole not allowed in a leaf node spec");this.serializeFragment(t.content,n,o);}return i}},{key:"serializeNode",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.serializeNodeInner(e,t),r=e.marks.length-1;r>=0;r--){var i=this.serializeMark(e.marks[r],e.isInline,t);i&&((i.contentDOM||i.dom).appendChild(n),n=i.dom);}return n}},{key:"serializeMark",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=this.marks[t.type.name];return i&&e.renderSpec(bC(r),i(t,n))}}],[{key:"renderSpec",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if("string"==typeof n)return {dom:t.createTextNode(n)};if(null!=n.nodeType)return {dom:n};if(n.dom&&null!=n.dom.nodeType)return n;var i,o=n[0],s=o.indexOf(" ");s>0&&(r=o.slice(0,s),o=o.slice(s+1));var a=r?t.createElementNS(r,o):t.createElement(o),l=n[1],c=1;if(l&&"object"==dk(l)&&null==l.nodeType&&!Array.isArray(l))for(var u in c=2,l)if(null!=l[u]){var d=u.indexOf(" ");d>0?a.setAttributeNS(u.slice(0,d),u.slice(d+1),l[u]):a.setAttribute(u,l[u]);}for(var h=c;h<n.length;h++){var p=n[h];if(0===p){if(h<n.length-1||h>c)throw new RangeError("Content hole must be the only child of its parent node");return {dom:a,contentDOM:a}}var f=e.renderSpec(t,p,r),m=f.dom,g=f.contentDOM;if(a.appendChild(m),g){if(i)throw new RangeError("Multiple content holes");i=g;}}return {dom:a,contentDOM:i}}},{key:"fromSchema",value:function(t){return t.cached.domSerializer||(t.cached.domSerializer=new e(this.nodesFromSchema(t),this.marksFromSchema(t)))}},{key:"nodesFromSchema",value:function(e){var t=yC(e.nodes);return t.text||(t.text=function(e){return e.text}),t}},{key:"marksFromSchema",value:function(e){return yC(e.marks)}}]),e}();function yC(e){var t={};for(var n in e){var r=e[n].spec.toDOM;r&&(t[n]=r);}return t}function bC(e){return e.document||window.document}Jw.ContentMatch=Vk,Jw.DOMParser=aC,Jw.DOMSerializer=vC,Jw.Fragment=gk,Jw.Mark=wk,Jw.MarkType=iC,Jw.Node=$k,Jw.NodeRange=Pk,Jw.NodeType=nC,Jw.ReplaceError=kk,Jw.ResolvedPos=Rk,Jw.Schema=oC,Jw.Slice=Ck;var wC={};function kC(e){return kC="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},kC(e)}function CC(){return CC="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=EC(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(arguments.length<3?e:n):i.value}},CC.apply(this,arguments)}function EC(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=OC(e)););return e}function xC(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&SC(e,t);}function SC(e,t){return SC=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},SC(e,t)}function DC(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var n,r=OC(e);if(t){var i=OC(this).constructor;n=Reflect.construct(r,arguments,i);}else n=r.apply(this,arguments);return MC(this,n)}}function MC(e,t){if(t&&("object"===kC(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function OC(e){return OC=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},OC(e)}function AC(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function NC(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function _C(e,t,n){return t&&NC(e.prototype,t),n&&NC(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}!function(e){function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},t(e)}function n(e){var t="function"==typeof Map?new Map:void 0;return n=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,i);}function i(){return r(e,arguments,c(this).constructor)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),o(i,e)},n(e)}function r(e,t,n){return r=l()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&o(i,n.prototype),i},r.apply(null,arguments)}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&o(e,t);}function o(e,t){return o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},o(e,t)}function s(e){var t=l();return function(){var n,r=c(e);if(t){var i=c(this).constructor;n=Reflect.construct(r,arguments,i);}else n=r.apply(this,arguments);return a(this,n)}}function a(e,n){if(n&&("object"===t(n)||"function"==typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}function c(e){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},c(e)}function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function d(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function h(e,t,n){return t&&d(e.prototype,t),n&&d(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}Object.defineProperty(e,"__esModule",{value:!0});var p=Jw,f=Math.pow(2,16);function m(e,t){return e+t*f}function g(e){return 65535&e}var v=function(){function e(t,n,r){u(this,e),this.pos=t,this.delInfo=n,this.recover=r;}return h(e,[{key:"deleted",get:function(){return (8&this.delInfo)>0}},{key:"deletedBefore",get:function(){return (5&this.delInfo)>0}},{key:"deletedAfter",get:function(){return (6&this.delInfo)>0}},{key:"deletedAcross",get:function(){return (4&this.delInfo)>0}}]),e}(),y=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(u(this,e),this.ranges=t,this.inverted=n,!t.length&&e.empty)return e.empty}return h(e,[{key:"recover",value:function(e){var t=0,n=g(e);if(!this.inverted)for(var r=0;r<n;r++)t+=this.ranges[3*r+2]-this.ranges[3*r+1];return this.ranges[3*n]+t+function(e){return (e-(65535&e))/f}(e)}},{key:"mapResult",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this._map(e,t,!1)}},{key:"map",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this._map(e,t,!0)}},{key:"_map",value:function(e,t,n){for(var r=0,i=this.inverted?2:1,o=this.inverted?1:2,s=0;s<this.ranges.length;s+=3){var a=this.ranges[s]-(this.inverted?r:0);if(a>e)break;var l=this.ranges[s+i],c=this.ranges[s+o],u=a+l;if(e<=u){var d=a+r+((l?e==a?-1:e==u?1:t:t)<0?0:c);if(n)return d;var h=e==(t<0?a:u)?null:m(s/3,e-a),p=e==a?2:e==u?1:4;return (t<0?e!=a:e!=u)&&(p|=8),new v(d,p,h)}r+=c-l;}return n?e+r:new v(e+r,0,null)}},{key:"touches",value:function(e,t){for(var n=0,r=g(t),i=this.inverted?2:1,o=this.inverted?1:2,s=0;s<this.ranges.length;s+=3){var a=this.ranges[s]-(this.inverted?n:0);if(a>e)break;var l=this.ranges[s+i];if(e<=a+l&&s==3*r)return !0;n+=this.ranges[s+o]-l;}return !1}},{key:"forEach",value:function(e){for(var t=this.inverted?2:1,n=this.inverted?1:2,r=0,i=0;r<this.ranges.length;r+=3){var o=this.ranges[r],s=o-(this.inverted?i:0),a=o+(this.inverted?0:i),l=this.ranges[r+t],c=this.ranges[r+n];e(s,s+l,a,a+c),i+=c-l;}}},{key:"invert",value:function(){return new e(this.ranges,!this.inverted)}},{key:"toString",value:function(){return (this.inverted?"-":"")+JSON.stringify(this.ranges)}}],[{key:"offset",value:function(t){return 0==t?e.empty:new e(t<0?[0,-t,0]:[0,0,t])}}]),e}();y.empty=new y([]);var b=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1?arguments[1]:void 0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.length;u(this,e),this.maps=t,this.mirror=n,this.from=r,this.to=i;}return h(e,[{key:"slice",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.maps.length;return new e(this.maps,this.mirror,t,n)}},{key:"copy",value:function(){return new e(this.maps.slice(),this.mirror&&this.mirror.slice(),this.from,this.to)}},{key:"appendMap",value:function(e,t){this.to=this.maps.push(e),null!=t&&this.setMirror(this.maps.length-1,t);}},{key:"appendMapping",value:function(e){for(var t=0,n=this.maps.length;t<e.maps.length;t++){var r=e.getMirror(t);this.appendMap(e.maps[t],null!=r&&r<t?n+r:void 0);}}},{key:"getMirror",value:function(e){if(this.mirror)for(var t=0;t<this.mirror.length;t++)if(this.mirror[t]==e)return this.mirror[t+(t%2?-1:1)]}},{key:"setMirror",value:function(e,t){this.mirror||(this.mirror=[]),this.mirror.push(e,t);}},{key:"appendMappingInverted",value:function(e){for(var t=e.maps.length-1,n=this.maps.length+e.maps.length;t>=0;t--){var r=e.getMirror(t);this.appendMap(e.maps[t].invert(),null!=r&&r>t?n-r-1:void 0);}}},{key:"invert",value:function(){var t=new e;return t.appendMappingInverted(this),t}},{key:"map",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(this.mirror)return this._map(e,t,!0);for(var n=this.from;n<this.to;n++)e=this.maps[n].map(e,t);return e}},{key:"mapResult",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this._map(e,t,!1)}},{key:"_map",value:function(e,t,n){for(var r=0,i=this.from;i<this.to;i++){var o=this.maps[i].mapResult(e,t);if(null!=o.recover){var s=this.getMirror(i);if(null!=s&&s>i&&s<this.to){i=s,e=this.maps[s].recover(o.recover);continue}}r|=o.delInfo,e=o.pos;}return n?e:new v(e,r,null)}}]),e}(),w=Object.create(null),k=function(){function e(){u(this,e);}return h(e,[{key:"getMap",value:function(){return y.empty}},{key:"merge",value:function(e){return null}}],[{key:"fromJSON",value:function(e,t){if(!t||!t.stepType)throw new RangeError("Invalid input for Step.fromJSON");var n=w[t.stepType];if(!n)throw new RangeError("No step type ".concat(t.stepType," defined"));return n.fromJSON(e,t)}},{key:"jsonID",value:function(e,t){if(e in w)throw new RangeError("Duplicate use of step JSON ID "+e);return w[e]=t,t.prototype.jsonID=e,t}}]),e}(),C=function(){function e(t,n){u(this,e),this.doc=t,this.failed=n;}return h(e,null,[{key:"ok",value:function(t){return new e(t,null)}},{key:"fail",value:function(t){return new e(null,t)}},{key:"fromReplace",value:function(t,n,r,i){try{return e.ok(t.replace(n,r,i))}catch(t){if(t instanceof p.ReplaceError)return e.fail(t.message);throw t}}}]),e}();function E(e,t,n){for(var r=[],i=0;i<e.childCount;i++){var o=e.child(i);o.content.size&&(o=o.copy(E(o.content,t,o))),o.isInline&&(o=t(o,n,i)),r.push(o);}return p.Fragment.fromArray(r)}var x=function(e){i(n,e);var t=s(n);function n(e,r,i){var o;return u(this,n),(o=t.call(this)).from=e,o.to=r,o.mark=i,o}return h(n,[{key:"apply",value:function(e){var t=this,n=e.slice(this.from,this.to),r=e.resolve(this.from),i=r.node(r.sharedDepth(this.to)),o=new p.Slice(E(n.content,(function(e,n){return e.isAtom&&n.type.allowsMarkType(t.mark.type)?e.mark(t.mark.addToSet(e.marks)):e}),i),n.openStart,n.openEnd);return C.fromReplace(e,this.from,this.to,o)}},{key:"invert",value:function(){return new S(this.from,this.to,this.mark)}},{key:"map",value:function(e){var t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deleted&&r.deleted||t.pos>=r.pos?null:new n(t.pos,r.pos,this.mark)}},{key:"merge",value:function(e){return e instanceof n&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new n(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}},{key:"toJSON",value:function(){return {stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for AddMarkStep.fromJSON");return new n(t.from,t.to,e.markFromJSON(t.mark))}}]),n}(k);k.jsonID("addMark",x);var S=function(e){i(n,e);var t=s(n);function n(e,r,i){var o;return u(this,n),(o=t.call(this)).from=e,o.to=r,o.mark=i,o}return h(n,[{key:"apply",value:function(e){var t=this,n=e.slice(this.from,this.to),r=new p.Slice(E(n.content,(function(e){return e.mark(t.mark.removeFromSet(e.marks))}),e),n.openStart,n.openEnd);return C.fromReplace(e,this.from,this.to,r)}},{key:"invert",value:function(){return new x(this.from,this.to,this.mark)}},{key:"map",value:function(e){var t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deleted&&r.deleted||t.pos>=r.pos?null:new n(t.pos,r.pos,this.mark)}},{key:"merge",value:function(e){return e instanceof n&&e.mark.eq(this.mark)&&this.from<=e.to&&this.to>=e.from?new n(Math.min(this.from,e.from),Math.max(this.to,e.to),this.mark):null}},{key:"toJSON",value:function(){return {stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");return new n(t.from,t.to,e.markFromJSON(t.mark))}}]),n}(k);k.jsonID("removeMark",S);var D=function(e){i(n,e);var t=s(n);function n(e,r,i){var o,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return u(this,n),(o=t.call(this)).from=e,o.to=r,o.slice=i,o.structure=s,o}return h(n,[{key:"apply",value:function(e){return this.structure&&O(e,this.from,this.to)?C.fail("Structure replace would overwrite content"):C.fromReplace(e,this.from,this.to,this.slice)}},{key:"getMap",value:function(){return new y([this.from,this.to-this.from,this.slice.size])}},{key:"invert",value:function(e){return new n(this.from,this.from+this.slice.size,e.slice(this.from,this.to))}},{key:"map",value:function(e){var t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1);return t.deletedAcross&&r.deletedAcross?null:new n(t.pos,Math.max(t.pos,r.pos),this.slice)}},{key:"merge",value:function(e){if(!(e instanceof n)||e.structure||this.structure)return null;if(this.from+this.slice.size!=e.from||this.slice.openEnd||e.slice.openStart){if(e.to!=this.from||this.slice.openStart||e.slice.openEnd)return null;var t=this.slice.size+e.slice.size==0?p.Slice.empty:new p.Slice(e.slice.content.append(this.slice.content),e.slice.openStart,this.slice.openEnd);return new n(e.from,this.to,t,this.structure)}var r=this.slice.size+e.slice.size==0?p.Slice.empty:new p.Slice(this.slice.content.append(e.slice.content),this.slice.openStart,e.slice.openEnd);return new n(this.from,this.to+(e.to-e.from),r,this.structure)}},{key:"toJSON",value:function(){var e={stepType:"replace",from:this.from,to:this.to};return this.slice.size&&(e.slice=this.slice.toJSON()),this.structure&&(e.structure=!0),e}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.from||"number"!=typeof t.to)throw new RangeError("Invalid input for ReplaceStep.fromJSON");return new n(t.from,t.to,p.Slice.fromJSON(e,t.slice),!!t.structure)}}]),n}(k);k.jsonID("replace",D);var M=function(e){i(n,e);var t=s(n);function n(e,r,i,o,s,a){var l,c=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return u(this,n),(l=t.call(this)).from=e,l.to=r,l.gapFrom=i,l.gapTo=o,l.slice=s,l.insert=a,l.structure=c,l}return h(n,[{key:"apply",value:function(e){if(this.structure&&(O(e,this.from,this.gapFrom)||O(e,this.gapTo,this.to)))return C.fail("Structure gap-replace would overwrite content");var t=e.slice(this.gapFrom,this.gapTo);if(t.openStart||t.openEnd)return C.fail("Gap is not a flat range");var n=this.slice.insertAt(this.insert,t.content);return n?C.fromReplace(e,this.from,this.to,n):C.fail("Content does not fit in gap")}},{key:"getMap",value:function(){return new y([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}},{key:"invert",value:function(e){var t=this.gapTo-this.gapFrom;return new n(this.from,this.from+this.slice.size+t,this.from+this.insert,this.from+this.insert+t,e.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}},{key:"map",value:function(e){var t=e.mapResult(this.from,1),r=e.mapResult(this.to,-1),i=e.map(this.gapFrom,-1),o=e.map(this.gapTo,1);return t.deletedAcross&&r.deletedAcross||i<t.pos||o>r.pos?null:new n(t.pos,r.pos,i,o,this.slice,this.insert,this.structure)}},{key:"toJSON",value:function(){var e={stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};return this.slice.size&&(e.slice=this.slice.toJSON()),this.structure&&(e.structure=!0),e}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.from||"number"!=typeof t.to||"number"!=typeof t.gapFrom||"number"!=typeof t.gapTo||"number"!=typeof t.insert)throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");return new n(t.from,t.to,t.gapFrom,t.gapTo,p.Slice.fromJSON(e,t.slice),t.insert,!!t.structure)}}]),n}(k);function O(e,t,n){for(var r=e.resolve(t),i=n-t,o=r.depth;i>0&&o>0&&r.indexAfter(o)==r.node(o).childCount;)o--,i--;if(i>0)for(var s=r.node(o).maybeChild(r.indexAfter(o));i>0;){if(!s||s.isLeaf)return !0;s=s.firstChild,i--;}return !1}function A(e,t,n){return (0==t||e.canReplace(t,e.childCount))&&(n==e.childCount||e.canReplace(0,n))}function N(e){return {type:e,attrs:null}}function _(e,t){var n=e.parent,r=e.startIndex,i=e.endIndex,o=n.contentMatchAt(r).findWrapping(t);if(!o)return null;var s=o.length?o[0]:t;return n.canReplaceWith(r,i,s)?o:null}function T(e,t){var n=e.parent,r=e.startIndex,i=e.endIndex,o=n.child(r),s=t.contentMatch.findWrapping(o.type);if(!s)return null;for(var a=(s.length?s[s.length-1]:t).contentMatch,l=r;a&&l<i;l++)a=a.matchType(n.child(l).type);return a&&a.validEnd?s:null}function L(e,t,n,r,i){if(!r.isTextblock)throw new RangeError("Type given to setBlockType should be a textblock");var o=e.steps.length;e.doc.nodesBetween(t,n,(function(t,n){if(t.isTextblock&&!t.hasMarkup(r,i)&&function(e,t,n){var r=e.resolve(t),i=r.index();return r.parent.canReplaceWith(i,i+1,n)}(e.doc,e.mapping.slice(o).map(n),r)){e.clearIncompatible(e.mapping.slice(o).map(n,1),r);var s=e.mapping.slice(o),a=s.map(n,1),l=s.map(n+t.nodeSize,1);return e.step(new M(a,l,a+1,l-1,new p.Slice(p.Fragment.from(r.create(i,null,t.marks)),0,0),1,!0)),!1}}));}function R(e,t,n,r,i){var o=e.doc.nodeAt(t);if(!o)throw new RangeError("No node at given position");n||(n=o.type);var s=n.create(r,null,i||o.marks);if(o.isLeaf)return e.replaceWith(t,t+o.nodeSize,s);if(!n.validContent(o.content))throw new RangeError("Invalid content for node type "+n.name);e.step(new M(t,t+o.nodeSize,t+1,t+o.nodeSize-1,new p.Slice(p.Fragment.from(s),0,0),1,!0));}function F(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,i=e.doc.resolve(t),o=p.Fragment.empty,s=p.Fragment.empty,a=i.depth,l=i.depth-n,c=n-1;a>l;a--,c--){o=p.Fragment.from(i.node(a).copy(o));var u=r&&r[c];s=p.Fragment.from(u?u.type.create(u.attrs,s):i.node(a).copy(s));}e.step(new D(t,t,new p.Slice(o.append(s),n,n),!0));}function B(e,t){return !(!e||!t||e.isLeaf||!e.canAppend(t))}function I(e,t,n){var r=new D(t-n,t+n,p.Slice.empty,!0);e.step(r);}function P(e,t,n){var r=e.resolve(t);if(r.parent.canReplaceWith(r.index(),r.index(),n))return t;if(0==r.parentOffset)for(var i=r.depth-1;i>=0;i--){var o=r.index(i);if(r.node(i).canReplaceWith(o,o,n))return r.before(i+1);if(o>0)return null}if(r.parentOffset==r.parent.content.size)for(var s=r.depth-1;s>=0;s--){var a=r.indexAfter(s);if(r.node(s).canReplaceWith(a,a,n))return r.after(s+1);if(a<r.node(s).childCount)return null}return null}function z(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p.Slice.empty;if(t==n&&!r.size)return null;var i=e.resolve(t),o=e.resolve(n);return $(i,o,r)?new D(t,n,r):new j(i,o,r).fit()}function $(e,t,n){return !n.openStart&&!n.openEnd&&e.start()==t.start()&&e.parent.canReplace(e.index(),t.index(),n.content)}k.jsonID("replaceAround",M);var j=function(){function e(t,n,r){u(this,e),this.$from=t,this.$to=n,this.unplaced=r,this.frontier=[],this.placed=p.Fragment.empty;for(var i=0;i<=t.depth;i++){var o=t.node(i);this.frontier.push({type:o.type,match:o.contentMatchAt(t.indexAfter(i))});}for(var s=t.depth;s>0;s--)this.placed=p.Fragment.from(t.node(s).copy(this.placed));}return h(e,[{key:"depth",get:function(){return this.frontier.length-1}},{key:"fit",value:function(){for(;this.unplaced.size;){var e=this.findFittable();e?this.placeNodes(e):this.openMore()||this.dropNode();}var t=this.mustMoveInline(),n=this.placed.size-this.depth-this.$from.depth,r=this.$from,i=this.close(t<0?this.$to:r.doc.resolve(t));if(!i)return null;for(var o=this.placed,s=r.depth,a=i.depth;s&&a&&1==o.childCount;)o=o.firstChild.content,s--,a--;var l=new p.Slice(o,s,a);return t>-1?new M(r.pos,t,this.$to.pos,this.$to.end(),l,n):l.size||r.pos!=this.$to.pos?new D(r.pos,i.pos,l):null}},{key:"findFittable",value:function(){for(var e=1;e<=2;e++)for(var t=this.unplaced.openStart;t>=0;t--)for(var n=null,r=(t?(n=K(this.unplaced.content,t-1).firstChild).content:this.unplaced.content).firstChild,i=this.depth;i>=0;i--){var o=this.frontier[i],s=o.type,a=o.match,l=void 0,c=null;if(1==e&&(r?a.matchType(r.type)||(c=a.fillBefore(p.Fragment.from(r),!1)):n&&s.compatibleContent(n.type)))return {sliceDepth:t,frontierDepth:i,parent:n,inject:c};if(2==e&&r&&(l=a.findWrapping(r.type)))return {sliceDepth:t,frontierDepth:i,parent:n,wrap:l};if(n&&a.matchType(n.type))break}}},{key:"openMore",value:function(){var e=this.unplaced,t=e.content,n=e.openStart,r=e.openEnd,i=K(t,n);return !(!i.childCount||i.firstChild.isLeaf)&&(this.unplaced=new p.Slice(t,n+1,Math.max(r,i.size+n>=t.size-r?n+1:0)),!0)}},{key:"dropNode",value:function(){var e=this.unplaced,t=e.content,n=e.openStart,r=e.openEnd,i=K(t,n);if(i.childCount<=1&&n>0){var o=t.size-n<=n+i.size;this.unplaced=new p.Slice(H(t,n-1,1),n-1,o?n-1:r);}else this.unplaced=new p.Slice(H(t,n,1),n,r);}},{key:"placeNodes",value:function(e){for(var t=e.sliceDepth,n=e.frontierDepth,r=e.parent,i=e.inject,o=e.wrap;this.depth>n;)this.closeFrontierNode();if(o)for(var s=0;s<o.length;s++)this.openFrontierNode(o[s]);var a=this.unplaced,l=r?r.content:a.content,c=a.openStart-t,u=0,d=[],h=this.frontier[n],f=h.match,m=h.type;if(i){for(s=0;s<i.childCount;s++)d.push(i.child(s));f=f.matchFragment(i);}for(var g=l.size+t-(a.content.size-a.openEnd);u<l.childCount;){var v=l.child(u),y=f.matchType(v.type);if(!y)break;(++u>1||0==c||v.content.size)&&(f=y,d.push(q(v.mark(m.allowedMarks(v.marks)),1==u?c:0,u==l.childCount?g:-1)));}var b=u==l.childCount;b||(g=-1),this.placed=V(this.placed,n,p.Fragment.from(d)),this.frontier[n].match=f,b&&g<0&&r&&r.type==this.frontier[this.depth].type&&this.frontier.length>1&&this.closeFrontierNode();for(var w=0,k=l;w<g;w++){var C=k.lastChild;this.frontier.push({type:C.type,match:C.contentMatchAt(C.childCount)}),k=C.content;}this.unplaced=b?0==t?p.Slice.empty:new p.Slice(H(a.content,t-1,1),t-1,g<0?a.openEnd:t-1):new p.Slice(H(a.content,t,u),a.openStart,a.openEnd);}},{key:"mustMoveInline",value:function(){if(!this.$to.parent.isTextblock)return -1;var e,t=this.frontier[this.depth];if(!t.type.isTextblock||!U(this.$to,this.$to.depth,t.type,t.match,!1)||this.$to.depth==this.depth&&(e=this.findCloseLevel(this.$to))&&e.depth==this.depth)return -1;for(var n=this.$to.depth,r=this.$to.after(n);n>1&&r==this.$to.end(--n);)++r;return r}},{key:"findCloseLevel",value:function(e){e:for(var t=Math.min(this.depth,e.depth);t>=0;t--){var n=this.frontier[t],r=n.match,i=n.type,o=t<e.depth&&e.end(t+1)==e.pos+(e.depth-(t+1)),s=U(e,t,i,r,o);if(s){for(var a=t-1;a>=0;a--){var l=this.frontier[a],c=l.match,u=U(e,a,l.type,c,!0);if(!u||u.childCount)continue e}return {depth:t,fit:s,move:o?e.doc.resolve(e.after(t+1)):e}}}}},{key:"close",value:function(e){var t=this.findCloseLevel(e);if(!t)return null;for(;this.depth>t.depth;)this.closeFrontierNode();t.fit.childCount&&(this.placed=V(this.placed,t.depth,t.fit)),e=t.move;for(var n=t.depth+1;n<=e.depth;n++){var r=e.node(n),i=r.type.contentMatch.fillBefore(r.content,!0,e.index(n));this.openFrontierNode(r.type,r.attrs,i);}return e}},{key:"openFrontierNode",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2?arguments[2]:void 0,r=this.frontier[this.depth];r.match=r.match.matchType(e),this.placed=V(this.placed,this.depth,p.Fragment.from(e.create(t,n))),this.frontier.push({type:e,match:e.contentMatch});}},{key:"closeFrontierNode",value:function(){var e=this.frontier.pop().match.fillBefore(p.Fragment.empty,!0);e.childCount&&(this.placed=V(this.placed,this.frontier.length,e));}}]),e}();function H(e,t,n){return 0==t?e.cutByIndex(n,e.childCount):e.replaceChild(0,e.firstChild.copy(H(e.firstChild.content,t-1,n)))}function V(e,t,n){return 0==t?e.append(n):e.replaceChild(e.childCount-1,e.lastChild.copy(V(e.lastChild.content,t-1,n)))}function K(e,t){for(var n=0;n<t;n++)e=e.firstChild.content;return e}function q(e,t,n){if(t<=0)return e;var r=e.content;return t>1&&(r=r.replaceChild(0,q(r.firstChild,t-1,1==r.childCount?n-1:0))),t>0&&(r=e.type.contentMatch.fillBefore(r).append(r),n<=0&&(r=r.append(e.type.contentMatch.matchFragment(r).fillBefore(p.Fragment.empty,!0)))),e.copy(r)}function U(e,t,n,r,i){var o=e.node(t),s=i?e.indexAfter(t):e.index(t);if(s==o.childCount&&!n.compatibleContent(o.type))return null;var a=r.fillBefore(o.content,!0,s);return a&&!function(e,t,n){for(var r=n;r<t.childCount;r++)if(!e.allowsMarks(t.child(r).marks))return !0;return !1}(n,o.content,s)?a:null}function W(e){return e.spec.defining||e.spec.definingForContent}function G(e,t,n,r,i){if(t<n){var o=e.firstChild;e=e.replaceChild(0,o.copy(G(o.content,t+1,n,r,o)));}if(t>r){var s=i.contentMatchAt(0),a=s.fillBefore(e).append(e);e=a.append(s.matchFragment(a).fillBefore(p.Fragment.empty,!0));}return e}function J(e,t){for(var n=[],r=Math.min(e.depth,t.depth);r>=0;r--){var i=e.start(r);if(i<e.pos-(e.depth-r)||t.end(r)>t.pos+(t.depth-r)||e.node(r).type.spec.isolating||t.node(r).type.spec.isolating)break;(i==t.start(r)||r==e.depth&&r==t.depth&&e.parent.inlineContent&&t.parent.inlineContent&&r&&t.start(r-1)==i-1)&&n.push(r);}return n}e.TransformError=function(e){i(n,e);var t=s(n);function n(){return u(this,n),t.apply(this,arguments)}return h(n)}(n(Error)),e.TransformError=function e(t){var n=Error.call(this,t);return n.__proto__=e.prototype,n},e.TransformError.prototype=Object.create(Error.prototype),e.TransformError.prototype.constructor=e.TransformError,e.TransformError.prototype.name="TransformError";var Z=function(){function t(e){u(this,t),this.doc=e,this.steps=[],this.docs=[],this.mapping=new b;}return h(t,[{key:"before",get:function(){return this.docs.length?this.docs[0]:this.doc}},{key:"step",value:function(t){var n=this.maybeStep(t);if(n.failed)throw new e.TransformError(n.failed);return this}},{key:"maybeStep",value:function(e){var t=e.apply(this.doc);return t.failed||this.addStep(e,t.doc),t}},{key:"docChanged",get:function(){return this.steps.length>0}},{key:"addStep",value:function(e,t){this.docs.push(this.doc),this.steps.push(e),this.mapping.appendMap(e.getMap()),this.doc=t;}},{key:"replace",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:p.Slice.empty,r=z(this.doc,e,t,n);return r&&this.step(r),this}},{key:"replaceWith",value:function(e,t,n){return this.replace(e,t,new p.Slice(p.Fragment.from(n),0,0))}},{key:"delete",value:function(e,t){return this.replace(e,t,p.Slice.empty)}},{key:"insert",value:function(e,t){return this.replaceWith(e,e,t)}},{key:"replaceRange",value:function(e,t,n){return function(e,t,n,r){if(!r.size)return e.deleteRange(t,n);var i=e.doc.resolve(t),o=e.doc.resolve(n);if($(i,o,r))return e.step(new D(t,n,r));var s=J(i,e.doc.resolve(n));0==s[s.length-1]&&s.pop();var a=-(i.depth+1);s.unshift(a);for(var l=i.depth,c=i.pos-1;l>0;l--,c--){var u=i.node(l).type.spec;if(u.defining||u.definingAsContext||u.isolating)break;s.indexOf(l)>-1?a=l:i.before(l)==c&&s.splice(1,0,-l);}for(var d=s.indexOf(a),h=[],f=r.openStart,m=r.content,g=0;;g++){var v=m.firstChild;if(h.push(v),g==r.openStart)break;m=v.content;}for(var y=f-1;y>=0;y--){var b=h[y].type,w=W(b);if(w&&i.node(d).type!=b)f=y;else if(w||!b.isTextblock)break}for(var k=r.openStart;k>=0;k--){var C=(k+f+1)%(r.openStart+1),E=h[C];if(E)for(var x=0;x<s.length;x++){var S=s[(x+d)%s.length],M=!0;S<0&&(M=!1,S=-S);var O=i.node(S-1),A=i.index(S-1);if(O.canReplaceWith(A,A,E.type,E.marks))return e.replace(i.before(S),M?o.after(S):n,new p.Slice(G(r.content,0,r.openStart,C),C,r.openEnd))}}for(var N=e.steps.length,_=s.length-1;_>=0&&(e.replace(t,n,r),!(e.steps.length>N));_--){var T=s[_];T<0||(t=i.before(T),n=o.after(T));}}(this,e,t,n),this}},{key:"replaceRangeWith",value:function(e,t,n){return function(e,t,n,r){if(!r.isInline&&t==n&&e.doc.resolve(t).parent.content.size){var i=P(e.doc,t,r.type);null!=i&&(t=n=i);}e.replaceRange(t,n,new p.Slice(p.Fragment.from(r),0,0));}(this,e,t,n),this}},{key:"deleteRange",value:function(e,t){return function(e,t,n){for(var r=e.doc.resolve(t),i=e.doc.resolve(n),o=J(r,i),s=0;s<o.length;s++){var a=o[s],l=s==o.length-1;if(l&&0==a||r.node(a).type.contentMatch.validEnd)return e.delete(r.start(a),i.end(a));if(a>0&&(l||r.node(a-1).canReplace(r.index(a-1),i.indexAfter(a-1))))return e.delete(r.before(a),i.after(a))}for(var c=1;c<=r.depth&&c<=i.depth;c++)if(t-r.start(c)==r.depth-c&&n>r.end(c)&&i.end(c)-n!=i.depth-c)return e.delete(r.before(c),n);e.delete(t,n);}(this,e,t),this}},{key:"lift",value:function(e,t){return function(e,t,n){for(var r=t.$from,i=t.$to,o=t.depth,s=r.before(o+1),a=i.after(o+1),l=s,c=a,u=p.Fragment.empty,d=0,h=o,f=!1;h>n;h--)f||r.index(h)>0?(f=!0,u=p.Fragment.from(r.node(h).copy(u)),d++):l--;for(var m=p.Fragment.empty,g=0,v=o,y=!1;v>n;v--)y||i.after(v+1)<i.end(v)?(y=!0,m=p.Fragment.from(i.node(v).copy(m)),g++):c++;e.step(new M(l,c,s,a,new p.Slice(u.append(m),d,g),u.size-d,!0));}(this,e,t),this}},{key:"join",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return I(this,e,t),this}},{key:"wrap",value:function(e,t){return function(e,t,n){for(var r=p.Fragment.empty,i=n.length-1;i>=0;i--){if(r.size){var o=n[i].type.contentMatch.matchFragment(r);if(!o||!o.validEnd)throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")}r=p.Fragment.from(n[i].type.create(n[i].attrs,r));}var s=t.start,a=t.end;e.step(new M(s,a,s,a,new p.Slice(r,0,0),n.length,!0));}(this,e,t),this}},{key:"setBlockType",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;return L(this,e,t,n,r),this}},{key:"setNodeMarkup",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];return R(this,e,t,n,r),this}},{key:"split",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0;return F(this,e,t,n),this}},{key:"addMark",value:function(e,t,n){return function(e,t,n,r){var i,o,s=[],a=[];e.doc.nodesBetween(t,n,(function(e,l,c){if(e.isInline){var u=e.marks;if(!r.isInSet(u)&&c.type.allowsMarkType(r.type)){for(var d=Math.max(l,t),h=Math.min(l+e.nodeSize,n),p=r.addToSet(u),f=0;f<u.length;f++)u[f].isInSet(p)||(i&&i.to==d&&i.mark.eq(u[f])?i.to=h:s.push(i=new S(d,h,u[f])));o&&o.to==d?o.to=h:a.push(o=new x(d,h,r));}}})),s.forEach((function(t){return e.step(t)})),a.forEach((function(t){return e.step(t)}));}(this,e,t,n),this}},{key:"removeMark",value:function(e,t,n){return function(e,t,n,r){var i=[],o=0;e.doc.nodesBetween(t,n,(function(e,s){if(e.isInline){o++;var a=null;if(r instanceof p.MarkType)for(var l,c=e.marks;l=r.isInSet(c);)(a||(a=[])).push(l),c=l.removeFromSet(c);else r?r.isInSet(e.marks)&&(a=[r]):a=e.marks;if(a&&a.length)for(var u=Math.min(s+e.nodeSize,n),d=0;d<a.length;d++){for(var h=a[d],f=void 0,m=0;m<i.length;m++){var g=i[m];g.step==o-1&&h.eq(i[m].style)&&(f=g);}f?(f.to=u,f.step=o):i.push({style:h,from:Math.max(s,t),to:u,step:o});}}})),i.forEach((function(t){return e.step(new S(t.from,t.to,t.style))}));}(this,e,t,n),this}},{key:"clearIncompatible",value:function(e,t,n){return function(e,t,n){for(var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.contentMatch,i=e.doc.nodeAt(t),o=[],s=t+1,a=0;a<i.childCount;a++){var l=i.child(a),c=s+l.nodeSize,u=r.matchType(l.type);if(u){r=u;for(var d=0;d<l.marks.length;d++)n.allowsMarkType(l.marks[d].type)||e.step(new S(s,c,l.marks[d]));}else o.push(new D(s,c,p.Slice.empty));s=c;}if(!r.validEnd){var h=r.fillBefore(p.Fragment.empty,!0);e.replace(s,s,new p.Slice(h,0,0));}for(var f=o.length-1;f>=0;f--)e.step(o[f]);}(this,e,t,n),this}}]),t}();e.AddMarkStep=x,e.MapResult=v,e.Mapping=b,e.RemoveMarkStep=S,e.ReplaceAroundStep=M,e.ReplaceStep=D,e.Step=k,e.StepMap=y,e.StepResult=C,e.Transform=Z,e.canJoin=function(e,t){var n=e.resolve(t),r=n.index();return B(n.nodeBefore,n.nodeAfter)&&n.parent.canReplace(r,r+1)},e.canSplit=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,i=e.resolve(t),o=i.depth-n,s=r&&r[r.length-1]||i.parent;if(o<0||i.parent.type.spec.isolating||!i.parent.canReplace(i.index(),i.parent.childCount)||!s.type.validContent(i.parent.content.cutByIndex(i.index(),i.parent.childCount)))return !1;for(var a=i.depth-1,l=n-2;a>o;a--,l--){var c=i.node(a),u=i.index(a);if(c.type.spec.isolating)return !1;var d=c.content.cutByIndex(u,c.childCount),h=r&&r[l]||c;if(h!=c&&(d=d.replaceChild(0,h.type.create(h.attrs))),!c.canReplace(u+1,c.childCount)||!h.type.validContent(d))return !1}var p=i.indexAfter(o),f=r&&r[0];return i.node(o).canReplaceWith(p,p,f?f.type:i.node(o+1).type)},e.dropPoint=function(e,t,n){var r=e.resolve(t);if(!n.content.size)return t;for(var i=n.content,o=0;o<n.openStart;o++)i=i.firstChild.content;for(var s=1;s<=(0==n.openStart&&n.size?2:1);s++)for(var a=r.depth;a>=0;a--){var l=a==r.depth?0:r.pos<=(r.start(a+1)+r.end(a+1))/2?-1:1,c=r.index(a)+(l>0?1:0),u=r.node(a),d=!1;if(1==s)d=u.canReplace(c,c,i);else {var h=u.contentMatchAt(c).findWrapping(i.firstChild.type);d=h&&u.canReplaceWith(c,c,h[0]);}if(d)return 0==l?r.pos:l<0?r.before(a+1):r.after(a+1)}return null},e.findWrapping=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e,i=_(e,t),o=i&&T(r,t);return o?i.map(N).concat({type:t,attrs:n}).concat(o.map(N)):null},e.insertPoint=P,e.joinPoint=function(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,r=e.resolve(t),i=r.depth;;i--){var o=void 0,s=void 0,a=r.index(i);if(i==r.depth?(o=r.nodeBefore,s=r.nodeAfter):n>0?(o=r.node(i+1),a++,s=r.node(i).maybeChild(a)):(o=r.node(i).maybeChild(a-1),s=r.node(i+1)),o&&!o.isTextblock&&B(o,s)&&r.node(i).canReplace(a,a+1))return t;if(0==i)break;t=n<0?r.before(i):r.after(i);}},e.liftTarget=function(e){for(var t=e.parent.content.cutByIndex(e.startIndex,e.endIndex),n=e.depth;;--n){var r=e.$from.node(n),i=e.$from.index(n),o=e.$to.indexAfter(n);if(n<e.depth&&r.canReplace(i,o,t))return n;if(0==n||r.type.spec.isolating||!A(r,i,o))break}return null},e.replaceStep=z;}(wC),Object.defineProperty(Gw,"__esModule",{value:!0});var TC=Jw,LC=wC,RC=Object.create(null),FC=function(){function e(t,n,r){AC(this,e),this.$anchor=t,this.$head=n,this.ranges=r||[new BC(t.min(n),t.max(n))];}return _C(e,[{key:"anchor",get:function(){return this.$anchor.pos}},{key:"head",get:function(){return this.$head.pos}},{key:"from",get:function(){return this.$from.pos}},{key:"to",get:function(){return this.$to.pos}},{key:"$from",get:function(){return this.ranges[0].$from}},{key:"$to",get:function(){return this.ranges[0].$to}},{key:"empty",get:function(){for(var e=this.ranges,t=0;t<e.length;t++)if(e[t].$from.pos!=e[t].$to.pos)return !1;return !0}},{key:"content",value:function(){return this.$from.doc.slice(this.from,this.to,!0)}},{key:"replace",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:TC.Slice.empty,n=t.content.lastChild,r=null,i=0;i<t.openEnd;i++)r=n,n=n.lastChild;for(var o=e.steps.length,s=this.ranges,a=0;a<s.length;a++){var l=s[a],c=l.$from,u=l.$to,d=e.mapping.slice(o);e.replaceRange(d.map(c.pos),d.map(u.pos),a?TC.Slice.empty:t),0==a&&UC(e,o,(n?n.isInline:r&&r.isTextblock)?-1:1);}}},{key:"replaceWith",value:function(e,t){for(var n=e.steps.length,r=this.ranges,i=0;i<r.length;i++){var o=r[i],s=o.$from,a=o.$to,l=e.mapping.slice(n),c=l.map(s.pos),u=l.map(a.pos);i?e.deleteRange(c,u):(e.replaceRangeWith(c,u,t),UC(e,n,t.isInline?-1:1));}}},{key:"getBookmark",value:function(){return zC.between(this.$anchor,this.$head).getBookmark()}}],[{key:"findFrom",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=e.parent.inlineContent?new zC(e):qC(e.node(0),e.parent,e.pos,e.index(),t,n);if(r)return r;for(var i=e.depth-1;i>=0;i--){var o=t<0?qC(e.node(0),e.node(i),e.before(i+1),e.index(i),t,n):qC(e.node(0),e.node(i),e.after(i+1),e.index(i)+1,t,n);if(o)return o}return null}},{key:"near",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.findFrom(e,t)||this.findFrom(e,-t)||new VC(e.node(0))}},{key:"atStart",value:function(e){return qC(e,e,0,0,1)||new VC(e)}},{key:"atEnd",value:function(e){return qC(e,e,e.content.size,e.childCount,-1)||new VC(e)}},{key:"fromJSON",value:function(e,t){if(!t||!t.type)throw new RangeError("Invalid input for Selection.fromJSON");var n=RC[t.type];if(!n)throw new RangeError("No selection type ".concat(t.type," defined"));return n.fromJSON(e,t)}},{key:"jsonID",value:function(e,t){if(e in RC)throw new RangeError("Duplicate use of selection JSON ID "+e);return RC[e]=t,t.prototype.jsonID=e,t}}]),e}();FC.prototype.visible=!0;var BC=_C((function e(t,n){AC(this,e),this.$from=t,this.$to=n;})),IC=!1;function PC(e){IC||e.parent.inlineContent||(IC=!0,console.warn("TextSelection endpoint not pointing into a node with inline content ("+e.parent.type.name+")"));}var zC=function(e){xC(n,FC);var t=DC(n);function n(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return AC(this,n),PC(e),PC(r),t.call(this,e,r)}return _C(n,[{key:"$cursor",get:function(){return this.$anchor.pos==this.$head.pos?this.$head:null}},{key:"map",value:function(e,t){var r=e.resolve(t.map(this.head));if(!r.parent.inlineContent)return FC.near(r);var i=e.resolve(t.map(this.anchor));return new n(i.parent.inlineContent?i:r,r)}},{key:"replace",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:TC.Slice.empty;if(CC(OC(n.prototype),"replace",this).call(this,e,t),t==TC.Slice.empty){var r=this.$from.marksAcross(this.$to);r&&e.ensureMarks(r);}}},{key:"eq",value:function(e){return e instanceof n&&e.anchor==this.anchor&&e.head==this.head}},{key:"getBookmark",value:function(){return new $C(this.anchor,this.head)}},{key:"toJSON",value:function(){return {type:"text",anchor:this.anchor,head:this.head}}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.anchor||"number"!=typeof t.head)throw new RangeError("Invalid input for TextSelection.fromJSON");return new n(e.resolve(t.anchor),e.resolve(t.head))}},{key:"create",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t,r=e.resolve(t);return new this(r,n==t?r:e.resolve(n))}},{key:"between",value:function(e,t,r){var i=e.pos-t.pos;if(r&&!i||(r=i>=0?1:-1),!t.parent.inlineContent){var o=FC.findFrom(t,r,!0)||FC.findFrom(t,-r,!0);if(!o)return FC.near(t,r);t=o.$head;}return e.parent.inlineContent||(0==i||(e=(FC.findFrom(e,-r,!0)||FC.findFrom(e,r,!0)).$anchor).pos<t.pos!=i<0)&&(e=t),new n(e,t)}}]),n}();FC.jsonID("text",zC);var $C=function(){function e(t,n){AC(this,e),this.anchor=t,this.head=n;}return _C(e,[{key:"map",value:function(t){return new e(t.map(this.anchor),t.map(this.head))}},{key:"resolve",value:function(e){return zC.between(e.resolve(this.anchor),e.resolve(this.head))}}]),e}(),jC=function(e){xC(n,FC);var t=DC(n);function n(e){var r;AC(this,n);var i=e.nodeAfter,o=e.node(0).resolve(e.pos+i.nodeSize);return (r=t.call(this,e,o)).node=i,r}return _C(n,[{key:"map",value:function(e,t){var r=t.mapResult(this.anchor),i=r.deleted,o=r.pos,s=e.resolve(o);return i?FC.near(s):new n(s)}},{key:"content",value:function(){return new TC.Slice(TC.Fragment.from(this.node),0,0)}},{key:"eq",value:function(e){return e instanceof n&&e.anchor==this.anchor}},{key:"toJSON",value:function(){return {type:"node",anchor:this.anchor}}},{key:"getBookmark",value:function(){return new HC(this.anchor)}}],[{key:"fromJSON",value:function(e,t){if("number"!=typeof t.anchor)throw new RangeError("Invalid input for NodeSelection.fromJSON");return new n(e.resolve(t.anchor))}},{key:"create",value:function(e,t){return new n(e.resolve(t))}},{key:"isSelectable",value:function(e){return !e.isText&&!1!==e.type.spec.selectable}}]),n}();jC.prototype.visible=!1,FC.jsonID("node",jC);var HC=function(){function e(t){AC(this,e),this.anchor=t;}return _C(e,[{key:"map",value:function(t){var n=t.mapResult(this.anchor),r=n.deleted,i=n.pos;return r?new $C(i,i):new e(i)}},{key:"resolve",value:function(e){var t=e.resolve(this.anchor),n=t.nodeAfter;return n&&jC.isSelectable(n)?new jC(t):FC.near(t)}}]),e}(),VC=function(e){xC(n,FC);var t=DC(n);function n(e){return AC(this,n),t.call(this,e.resolve(0),e.resolve(e.content.size))}return _C(n,[{key:"replace",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:TC.Slice.empty;if(t==TC.Slice.empty){e.delete(0,e.doc.content.size);var r=FC.atStart(e.doc);r.eq(e.selection)||e.setSelection(r);}else CC(OC(n.prototype),"replace",this).call(this,e,t);}},{key:"toJSON",value:function(){return {type:"all"}}},{key:"map",value:function(e){return new n(e)}},{key:"eq",value:function(e){return e instanceof n}},{key:"getBookmark",value:function(){return KC}}],[{key:"fromJSON",value:function(e){return new n(e)}}]),n}();FC.jsonID("all",VC);var KC={map:function(){return this},resolve:function(e){return new VC(e)}};function qC(e,t,n,r,i){var o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(t.inlineContent)return zC.create(e,n);for(var s=r-(i>0?0:1);i>0?s<t.childCount:s>=0;s+=i){var a=t.child(s);if(a.isAtom){if(!o&&jC.isSelectable(a))return jC.create(e,n-(i<0?a.nodeSize:0))}else {var l=qC(e,a,n+i,i<0?a.childCount:0,i,o);if(l)return l}n+=a.nodeSize*i;}return null}function UC(e,t,n){var r=e.steps.length-1;if(!(r<t)){var i,o=e.steps[r];if(o instanceof LC.ReplaceStep||o instanceof LC.ReplaceAroundStep)e.mapping.maps[r].forEach((function(e,t,n,r){null==i&&(i=r);})),e.setSelection(FC.near(e.doc.resolve(i),n));}}var WC=function(e){xC(n,LC.Transform);var t=DC(n);function n(e){var r;return AC(this,n),(r=t.call(this,e.doc)).curSelectionFor=0,r.updated=0,r.meta=Object.create(null),r.time=Date.now(),r.curSelection=e.selection,r.storedMarks=e.storedMarks,r}return _C(n,[{key:"selection",get:function(){return this.curSelectionFor<this.steps.length&&(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}},{key:"setSelection",value:function(e){if(e.$from.doc!=this.doc)throw new RangeError("Selection passed to setSelection must point at the current document");return this.curSelection=e,this.curSelectionFor=this.steps.length,this.updated=-3&(1|this.updated),this.storedMarks=null,this}},{key:"selectionSet",get:function(){return (1&this.updated)>0}},{key:"setStoredMarks",value:function(e){return this.storedMarks=e,this.updated|=2,this}},{key:"ensureMarks",value:function(e){return TC.Mark.sameSet(this.storedMarks||this.selection.$from.marks(),e)||this.setStoredMarks(e),this}},{key:"addStoredMark",value:function(e){return this.ensureMarks(e.addToSet(this.storedMarks||this.selection.$head.marks()))}},{key:"removeStoredMark",value:function(e){return this.ensureMarks(e.removeFromSet(this.storedMarks||this.selection.$head.marks()))}},{key:"storedMarksSet",get:function(){return (2&this.updated)>0}},{key:"addStep",value:function(e,t){CC(OC(n.prototype),"addStep",this).call(this,e,t),this.updated=-3&this.updated,this.storedMarks=null;}},{key:"setTime",value:function(e){return this.time=e,this}},{key:"replaceSelection",value:function(e){return this.selection.replace(this,e),this}},{key:"replaceSelectionWith",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=this.selection;return t&&(e=e.mark(this.storedMarks||(n.empty?n.$from.marks():n.$from.marksAcross(n.$to)||TC.Mark.none))),n.replaceWith(this,e),this}},{key:"deleteSelection",value:function(){return this.selection.replace(this),this}},{key:"insertText",value:function(e,t,n){var r=this.doc.type.schema;if(null==t)return e?this.replaceSelectionWith(r.text(e),!0):this.deleteSelection();if(null==n&&(n=t),n=null==n?t:n,!e)return this.deleteRange(t,n);var i=this.storedMarks;if(!i){var o=this.doc.resolve(t);i=n==t?o.marks():o.marksAcross(this.doc.resolve(n));}return this.replaceRangeWith(t,n,r.text(e,i)),this.selection.empty||this.setSelection(FC.near(this.selection.$to)),this}},{key:"setMeta",value:function(e,t){return this.meta["string"==typeof e?e:e.key]=t,this}},{key:"getMeta",value:function(e){return this.meta["string"==typeof e?e:e.key]}},{key:"isGeneric",get:function(){for(var e in this.meta)return !1;return !0}},{key:"scrollIntoView",value:function(){return this.updated|=4,this}},{key:"scrolledIntoView",get:function(){return (4&this.updated)>0}}]),n}();function GC(e,t){return t&&e?e.bind(t):e}var JC=_C((function e(t,n,r){AC(this,e),this.name=t,this.init=GC(n.init,r),this.apply=GC(n.apply,r);})),ZC=[new JC("doc",{init:function(e){return e.doc||e.schema.topNodeType.createAndFill()},apply:function(e){return e.doc}}),new JC("selection",{init:function(e,t){return e.selection||FC.atStart(t.doc)},apply:function(e){return e.selection}}),new JC("storedMarks",{init:function(e){return e.storedMarks||null},apply:function(e,t,n,r){return r.selection.$cursor?e.storedMarks:null}}),new JC("scrollToSelection",{init:function(){return 0},apply:function(e,t){return e.scrolledIntoView?t+1:t}})],XC=_C((function e(t,n){var r=this;AC(this,e),this.schema=t,this.plugins=[],this.pluginsByKey=Object.create(null),this.fields=ZC.slice(),n&&n.forEach((function(e){if(r.pluginsByKey[e.key])throw new RangeError("Adding different instances of a keyed plugin ("+e.key+")");r.plugins.push(e),r.pluginsByKey[e.key]=e,e.spec.state&&r.fields.push(new JC(e.key,e.spec.state,e));}));})),QC=function(){function e(t){AC(this,e),this.config=t;}return _C(e,[{key:"schema",get:function(){return this.config.schema}},{key:"plugins",get:function(){return this.config.plugins}},{key:"apply",value:function(e){return this.applyTransaction(e).state}},{key:"filterTransaction",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=0;n<this.config.plugins.length;n++)if(n!=t){var r=this.config.plugins[n];if(r.spec.filterTransaction&&!r.spec.filterTransaction.call(r,e,this))return !1}return !0}},{key:"applyTransaction",value:function(e){if(!this.filterTransaction(e))return {state:this,transactions:[]};for(var t=[e],n=this.applyInner(e),r=null;;){for(var i=!1,o=0;o<this.config.plugins.length;o++){var s=this.config.plugins[o];if(s.spec.appendTransaction){var a=r?r[o].n:0,l=r?r[o].state:this,c=a<t.length&&s.spec.appendTransaction.call(s,a?t.slice(a):t,l,n);if(c&&n.filterTransaction(c,o)){if(c.setMeta("appendedTransaction",e),!r){r=[];for(var u=0;u<this.config.plugins.length;u++)r.push(u<o?{state:n,n:t.length}:{state:this,n:0});}t.push(c),n=n.applyInner(c),i=!0;}r&&(r[o]={state:n,n:t.length});}}if(!i)return {state:n,transactions:t}}}},{key:"applyInner",value:function(t){if(!t.before.eq(this.doc))throw new RangeError("Applying a mismatched transaction");for(var n=new e(this.config),r=this.config.fields,i=0;i<r.length;i++){var o=r[i];n[o.name]=o.apply(t,this[o.name],this,n);}return n}},{key:"tr",get:function(){return new WC(this)}},{key:"reconfigure",value:function(t){for(var n=new XC(this.schema,t.plugins),r=n.fields,i=new e(n),o=0;o<r.length;o++){var s=r[o].name;i[s]=this.hasOwnProperty(s)?this[s]:r[o].init(t,i);}return i}},{key:"toJSON",value:function(e){var t={doc:this.doc.toJSON(),selection:this.selection.toJSON()};if(this.storedMarks&&(t.storedMarks=this.storedMarks.map((function(e){return e.toJSON()}))),e&&"object"==kC(e))for(var n in e){if("doc"==n||"selection"==n)throw new RangeError("The JSON fields `doc` and `selection` are reserved");var r=e[n],i=r.spec.state;i&&i.toJSON&&(t[n]=i.toJSON.call(r,this[r.key]));}return t}}],[{key:"create",value:function(t){for(var n=new XC(t.doc?t.doc.type.schema:t.schema,t.plugins),r=new e(n),i=0;i<n.fields.length;i++)r[n.fields[i].name]=n.fields[i].init(t,r);return r}},{key:"fromJSON",value:function(t,n,r){if(!n)throw new RangeError("Invalid input for EditorState.fromJSON");if(!t.schema)throw new RangeError("Required config field 'schema' missing");var i=new XC(t.schema,t.plugins),o=new e(i);return i.fields.forEach((function(e){if("doc"==e.name)o.doc=TC.Node.fromJSON(t.schema,n.doc);else if("selection"==e.name)o.selection=FC.fromJSON(o.doc,n.selection);else if("storedMarks"==e.name)n.storedMarks&&(o.storedMarks=n.storedMarks.map(t.schema.markFromJSON));else {if(r)for(var i in r){var s=r[i],a=s.spec.state;if(s.key==e.name&&a&&a.fromJSON&&Object.prototype.hasOwnProperty.call(n,i))return void(o[e.name]=a.fromJSON.call(s,t,n[i],o))}o[e.name]=e.init(t,o);}})),o}}]),e}();function YC(e,t,n){for(var r in e){var i=e[r];i instanceof Function?i=i.bind(t):"handleDOMEvents"==r&&(i=YC(i,t,{})),n[r]=i;}return n}var eE=function(){function e(t){AC(this,e),this.spec=t,this.props={},t.props&&YC(t.props,this,this.props),this.key=t.key?t.key.key:nE("plugin");}return _C(e,[{key:"getState",value:function(e){return e[this.key]}}]),e}(),tE=Object.create(null);function nE(e){return e in tE?e+"$"+ ++tE[e]:(tE[e]=0,e+"$")}var rE=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"key";AC(this,e),this.key=nE(t);}return _C(e,[{key:"get",value:function(e){return e.config.pluginsByKey[this.key]}},{key:"getState",value:function(e){return e[this.key]}}]),e}();Gw.AllSelection=VC,Gw.EditorState=QC,Gw.NodeSelection=jC,Gw.Plugin=eE,Gw.PluginKey=rE,Gw.Selection=FC,Gw.SelectionRange=BC,Gw.TextSelection=zC,Gw.Transaction=WC;var iE={},oE={};function sE(e){return sE="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},sE(e)}function aE(){return aE="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=lE(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(arguments.length<3?e:n):i.value}},aE.apply(this,arguments)}function lE(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=fE(e)););return e}function cE(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&uE(e,t);}function uE(e,t){return uE=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},uE(e,t)}function dE(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var n,r=fE(e);if(t){var i=fE(this).constructor;n=Reflect.construct(r,arguments,i);}else n=r.apply(this,arguments);return hE(this,n)}}function hE(e,t){if(t&&("object"===sE(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return pE(e)}function pE(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function fE(e){return fE=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},fE(e)}function mE(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function gE(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function vE(e,t,n){return t&&gE(e.prototype,t),n&&gE(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}Object.defineProperty(oE,"__esModule",{value:!0});var yE=Gw,bE=Jw,wE=wC,kE="undefined"!=typeof navigator?navigator:null,CE="undefined"!=typeof document?document:null,EE=kE&&kE.userAgent||"",xE=/Edge\/(\d+)/.exec(EE),SE=/MSIE \d/.exec(EE),DE=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(EE),ME=!!(SE||DE||xE),OE=SE?document.documentMode:DE?+DE[1]:xE?+xE[1]:0,AE=!ME&&/gecko\/(\d+)/i.test(EE);AE&&(/Firefox\/(\d+)/.exec(EE)||[0,0])[1];var NE=!ME&&/Chrome\/(\d+)/.exec(EE),_E=!!NE,TE=NE?+NE[1]:0,LE=!ME&&!!kE&&/Apple Computer/.test(kE.vendor),RE=LE&&(/Mobile\/\w+/.test(EE)||!!kE&&kE.maxTouchPoints>2),FE=RE||!!kE&&/Mac/.test(kE.platform),BE=/Android \d/.test(EE),IE=!!CE&&"webkitFontSmoothing"in CE.documentElement.style,PE=IE?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,zE=function(e){for(var t=0;;t++)if(!(e=e.previousSibling))return t},$E=function(e){var t=e.assignedSlot||e.parentNode;return t&&11==t.nodeType?t.host:t},jE=null,HE=function(e,t,n){var r=jE||(jE=document.createRange());return r.setEnd(e,null==n?e.nodeValue.length:n),r.setStart(e,t||0),r},VE=function(e,t,n,r){return n&&(qE(e,t,n,r,-1)||qE(e,t,n,r,1))},KE=/^(img|br|input|textarea|hr)$/i;function qE(e,t,n,r,i){for(;;){if(e==n&&t==r)return !0;if(t==(i<0?0:UE(e))){var o=e.parentNode;if(!o||1!=o.nodeType||GE(e)||KE.test(e.nodeName)||"false"==e.contentEditable)return !1;t=zE(e)+(i<0?0:1),e=o;}else {if(1!=e.nodeType)return !1;if("false"==(e=e.childNodes[t+(i<0?-1:0)]).contentEditable)return !1;t=i<0?UE(e):0;}}}function UE(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}function WE(e,t,n){for(var r=0==t,i=t==UE(e);r||i;){if(e==n)return !0;var o=zE(e);if(!(e=e.parentNode))return !1;r=r&&0==o,i=i&&o==UE(e);}}function GE(e){for(var t,n=e;n&&!(t=n.pmViewDesc);n=n.parentNode);return t&&t.node&&t.node.isBlock&&(t.dom==e||t.contentDOM==e)}var JE=function(e){var t=e.isCollapsed;return t&&_E&&e.rangeCount&&!e.getRangeAt(0).collapsed&&(t=!1),t};function ZE(e,t){var n=document.createEvent("Event");return n.initEvent("keydown",!0,!0),n.keyCode=e,n.key=n.code=t,n}function XE(e){return {left:0,right:e.documentElement.clientWidth,top:0,bottom:e.documentElement.clientHeight}}function QE(e,t){return "number"==typeof e?e:e[t]}function YE(e){var t=e.getBoundingClientRect(),n=t.width/e.offsetWidth||1,r=t.height/e.offsetHeight||1;return {left:t.left,right:t.left+e.clientWidth*n,top:t.top,bottom:t.top+e.clientHeight*r}}function ex(e,t,n){for(var r=e.someProp("scrollThreshold")||0,i=e.someProp("scrollMargin")||5,o=e.dom.ownerDocument,s=n||e.dom;s;s=$E(s))if(1==s.nodeType){var a=s,l=a==o.body,c=l?XE(o):YE(a),u=0,d=0;if(t.top<c.top+QE(r,"top")?d=-(c.top-t.top+QE(i,"top")):t.bottom>c.bottom-QE(r,"bottom")&&(d=t.bottom-c.bottom+QE(i,"bottom")),t.left<c.left+QE(r,"left")?u=-(c.left-t.left+QE(i,"left")):t.right>c.right-QE(r,"right")&&(u=t.right-c.right+QE(i,"right")),u||d)if(l)o.defaultView.scrollBy(u,d);else {var h=a.scrollLeft,p=a.scrollTop;d&&(a.scrollTop+=d),u&&(a.scrollLeft+=u);var f=a.scrollLeft-h,m=a.scrollTop-p;t={left:t.left-f,top:t.top-m,right:t.right-f,bottom:t.bottom-m};}if(l)break}}function tx(e){for(var t=[],n=e.ownerDocument,r=e;r&&(t.push({dom:r,top:r.scrollTop,left:r.scrollLeft}),e!=n);r=$E(r));return t}function nx(e,t){for(var n=0;n<e.length;n++){var r=e[n],i=r.dom,o=r.top,s=r.left;i.scrollTop!=o+t&&(i.scrollTop=o+t),i.scrollLeft!=s&&(i.scrollLeft=s);}}var rx=null;function ix(e,t){for(var n,r,i=2e8,o=0,s=t.top,a=t.top,l=e.firstChild,c=0;l;l=l.nextSibling,c++){var u=void 0;if(1==l.nodeType)u=l.getClientRects();else {if(3!=l.nodeType)continue;u=HE(l).getClientRects();}for(var d=0;d<u.length;d++){var h=u[d];if(h.top<=s&&h.bottom>=a){s=Math.max(h.bottom,s),a=Math.min(h.top,a);var p=h.left>t.left?h.left-t.left:h.right<t.left?t.left-h.right:0;if(p<i){n=l,i=p,r=p&&3==n.nodeType?{left:h.right<t.left?h.right:h.left,top:t.top}:t,1==l.nodeType&&p&&(o=c+(t.left>=(h.left+h.right)/2?1:0));continue}}!n&&(t.left>=h.right&&t.top>=h.top||t.left>=h.left&&t.top>=h.bottom)&&(o=c+1);}}return n&&3==n.nodeType?function(e,t){for(var n=e.nodeValue.length,r=document.createRange(),i=0;i<n;i++){r.setEnd(e,i+1),r.setStart(e,i);var o=lx(r,1);if(o.top!=o.bottom&&ox(t,o))return {node:e,offset:i+(t.left>=(o.left+o.right)/2?1:0)}}return {node:e,offset:0}}(n,r):!n||i&&1==n.nodeType?{node:e,offset:o}:ix(n,r)}function ox(e,t){return e.left>=t.left-1&&e.left<=t.right+1&&e.top>=t.top-1&&e.top<=t.bottom+1}function sx(e,t,n){var r=e.childNodes.length;if(r&&n.top<n.bottom)for(var i=Math.max(0,Math.min(r-1,Math.floor(r*(t.top-n.top)/(n.bottom-n.top))-2)),o=i;;){var s=e.childNodes[o];if(1==s.nodeType)for(var a=s.getClientRects(),l=0;l<a.length;l++){var c=a[l];if(ox(t,c))return sx(s,t,c)}if((o=(o+1)%r)==i)break}return e}function ax(e,t){var n,r=e.dom.ownerDocument,i=0;if(r.caretPositionFromPoint)try{var o=r.caretPositionFromPoint(t.left,t.top);o&&(n=o.offsetNode,i=o.offset);}catch(e){}if(!n&&r.caretRangeFromPoint){var s=r.caretRangeFromPoint(t.left,t.top);s&&(n=s.startContainer,i=s.startOffset);}var a,l=(e.root.elementFromPoint?e.root:r).elementFromPoint(t.left,t.top+1);if(!l||!e.dom.contains(1!=l.nodeType?l.parentNode:l)){var c=e.dom.getBoundingClientRect();if(!ox(t,c))return null;if(!(l=sx(e.dom,t,c)))return null}if(LE)for(var u=l;n&&u;u=$E(u))u.draggable&&(n=void 0);if(l=function(e,t){var n=e.parentNode;return n&&/^li$/i.test(n.nodeName)&&t.left<e.getBoundingClientRect().left?n:e}(l,t),n){if(AE&&1==n.nodeType&&(i=Math.min(i,n.childNodes.length))<n.childNodes.length){var d,h=n.childNodes[i];"IMG"==h.nodeName&&(d=h.getBoundingClientRect()).right<=t.left&&d.bottom>t.top&&i++;}n==e.dom&&i==n.childNodes.length-1&&1==n.lastChild.nodeType&&t.top>n.lastChild.getBoundingClientRect().bottom?a=e.state.doc.content.size:0!=i&&1==n.nodeType&&"BR"==n.childNodes[i-1].nodeName||(a=function(e,t,n,r){for(var i=-1,o=t;o!=e.dom;){var s=e.docView.nearestDesc(o,!0);if(!s)return null;if(s.node.isBlock&&s.parent){var a=s.dom.getBoundingClientRect();if(a.left>r.left||a.top>r.top)i=s.posBefore;else {if(!(a.right<r.left||a.bottom<r.top))break;i=s.posAfter;}}o=s.dom.parentNode;}return i>-1?i:e.docView.posFromDOM(t,n,1)}(e,n,i,t));}null==a&&(a=function(e,t,n){var r=ix(t,n),i=r.node,o=r.offset,s=-1;if(1==i.nodeType&&!i.firstChild){var a=i.getBoundingClientRect();s=a.left!=a.right&&n.left>(a.left+a.right)/2?1:-1;}return e.docView.posFromDOM(i,o,s)}(e,l,t));var p=e.docView.nearestDesc(l,!0);return {pos:a,inside:p?p.posAtStart-p.border:-1}}function lx(e,t){var n=e.getClientRects();return n.length?n[t<0?0:n.length-1]:e.getBoundingClientRect()}var cx=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;function ux(e,t,n){var r=e.docView.domFromPos(t,n<0?-1:1),i=r.node,o=r.offset,s=IE||AE;if(3==i.nodeType){if(!s||!cx.test(i.nodeValue)&&(n<0?o:o!=i.nodeValue.length)){var a=o,l=o,c=n<0?1:-1;return n<0&&!o?(l++,c=-1):n>=0&&o==i.nodeValue.length?(a--,c=1):n<0?a--:l++,dx(lx(HE(i,a,l),c),c<0)}var u=lx(HE(i,o,o),n);if(AE&&o&&/\s/.test(i.nodeValue[o-1])&&o<i.nodeValue.length){var d=lx(HE(i,o-1,o-1),-1);if(d.top==u.top){var h=lx(HE(i,o,o+1),-1);if(h.top!=u.top)return dx(h,h.left<d.left)}}return u}if(!e.state.doc.resolve(t).parent.inlineContent){if(o&&(n<0||o==UE(i))){var p=i.childNodes[o-1];if(1==p.nodeType)return hx(p.getBoundingClientRect(),!1)}if(o<UE(i)){var f=i.childNodes[o];if(1==f.nodeType)return hx(f.getBoundingClientRect(),!0)}return hx(i.getBoundingClientRect(),n>=0)}if(o&&(n<0||o==UE(i))){var m=i.childNodes[o-1],g=3==m.nodeType?HE(m,UE(m)-(s?0:1)):1!=m.nodeType||"BR"==m.nodeName&&m.nextSibling?null:m;if(g)return dx(lx(g,1),!1)}if(o<UE(i)){for(var v=i.childNodes[o];v.pmViewDesc&&v.pmViewDesc.ignoreForCoords;)v=v.nextSibling;var y=v?3==v.nodeType?HE(v,0,s?0:1):1==v.nodeType?v:null:null;if(y)return dx(lx(y,-1),!0)}return dx(lx(3==i.nodeType?HE(i):i,-n),n>=0)}function dx(e,t){if(0==e.width)return e;var n=t?e.left:e.right;return {top:e.top,bottom:e.bottom,left:n,right:n}}function hx(e,t){if(0==e.height)return e;var n=t?e.top:e.bottom;return {top:n,bottom:n,left:e.left,right:e.right}}function px(e,t,n){var r=e.state,i=e.root.activeElement;r!=t&&e.updateState(t),i!=e.dom&&e.focus();try{return n()}finally{r!=t&&e.updateState(r),i!=e.dom&&i&&i.focus();}}var fx=/[\u0590-\u08ac]/;var mx=null,gx=null,vx=!1;function yx(e,t,n){return mx==t&&gx==n?vx:(mx=t,gx=n,vx="up"==n||"down"==n?function(e,t,n){var r=t.selection,i="up"==n?r.$from:r.$to;return px(e,t,(function(){for(var t=e.docView.domFromPos(i.pos,"up"==n?-1:1).node;;){var r=e.docView.nearestDesc(t,!0);if(!r)break;if(r.node.isBlock){t=r.dom;break}t=r.dom.parentNode;}for(var o=ux(e,i.pos,1),s=t.firstChild;s;s=s.nextSibling){var a=void 0;if(1==s.nodeType)a=s.getClientRects();else {if(3!=s.nodeType)continue;a=HE(s,0,s.nodeValue.length).getClientRects();}for(var l=0;l<a.length;l++){var c=a[l];if(c.bottom>c.top+1&&("up"==n?o.top-c.top>2*(c.bottom-o.top):c.bottom-o.bottom>2*(o.bottom-c.top)))return !1}}return !0}))}(e,t,n):function(e,t,n){var r=t.selection.$head;if(!r.parent.isTextblock)return !1;var i=r.parentOffset,o=!i,s=i==r.parent.content.size,a=e.domSelection();return fx.test(r.parent.textContent)&&a.modify?px(e,t,(function(){var t=a.getRangeAt(0),i=a.focusNode,o=a.focusOffset,s=a.caretBidiLevel;a.modify("move",n,"character");var l=!(r.depth?e.docView.domAfterPos(r.before()):e.dom).contains(1==a.focusNode.nodeType?a.focusNode:a.focusNode.parentNode)||i==a.focusNode&&o==a.focusOffset;return a.removeAllRanges(),a.addRange(t),null!=s&&(a.caretBidiLevel=s),l})):"left"==n||"backward"==n?o:s}(e,t,n))}var bx=function(){function e(t,n,r,i){mE(this,e),this.parent=t,this.children=n,this.dom=r,this.contentDOM=i,this.dirty=0,r.pmViewDesc=this;}return vE(e,[{key:"matchesWidget",value:function(e){return !1}},{key:"matchesMark",value:function(e){return !1}},{key:"matchesNode",value:function(e,t,n){return !1}},{key:"matchesHack",value:function(e){return !1}},{key:"parseRule",value:function(){return null}},{key:"stopEvent",value:function(e){return !1}},{key:"size",get:function(){for(var e=0,t=0;t<this.children.length;t++)e+=this.children[t].size;return e}},{key:"border",get:function(){return 0}},{key:"destroy",value:function(){this.parent=void 0,this.dom.pmViewDesc==this&&(this.dom.pmViewDesc=void 0);for(var e=0;e<this.children.length;e++)this.children[e].destroy();}},{key:"posBeforeChild",value:function(e){for(var t=0,n=this.posAtStart;;t++){var r=this.children[t];if(r==e)return n;n+=r.size;}}},{key:"posBefore",get:function(){return this.parent.posBeforeChild(this)}},{key:"posAtStart",get:function(){return this.parent?this.parent.posBeforeChild(this)+this.border:0}},{key:"posAfter",get:function(){return this.posBefore+this.size}},{key:"posAtEnd",get:function(){return this.posAtStart+this.size-2*this.border}},{key:"localPosFromDOM",value:function(e,t,n){if(this.contentDOM&&this.contentDOM.contains(1==e.nodeType?e:e.parentNode)){if(n<0){var r,i;if(e==this.contentDOM)r=e.childNodes[t-1];else {for(;e.parentNode!=this.contentDOM;)e=e.parentNode;r=e.previousSibling;}for(;r&&(!(i=r.pmViewDesc)||i.parent!=this);)r=r.previousSibling;return r?this.posBeforeChild(i)+i.size:this.posAtStart}var o,s;if(e==this.contentDOM)o=e.childNodes[t];else {for(;e.parentNode!=this.contentDOM;)e=e.parentNode;o=e.nextSibling;}for(;o&&(!(s=o.pmViewDesc)||s.parent!=this);)o=o.nextSibling;return o?this.posBeforeChild(s):this.posAtEnd}var a;if(e==this.dom&&this.contentDOM)a=t>zE(this.contentDOM);else if(this.contentDOM&&this.contentDOM!=this.dom&&this.dom.contains(this.contentDOM))a=2&e.compareDocumentPosition(this.contentDOM);else if(this.dom.firstChild){if(0==t)for(var l=e;;l=l.parentNode){if(l==this.dom){a=!1;break}if(l.previousSibling)break}if(null==a&&t==e.childNodes.length)for(var c=e;;c=c.parentNode){if(c==this.dom){a=!0;break}if(c.nextSibling)break}}return (null==a?n>0:a)?this.posAtEnd:this.posAtStart}},{key:"nearestDesc",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!0,r=e;r;r=r.parentNode){var i=this.getDesc(r),o=void 0;if(i&&(!t||i.node)){if(!n||!(o=i.nodeDOM)||(1==o.nodeType?o.contains(1==e.nodeType?e:e.parentNode):o==e))return i;n=!1;}}}},{key:"getDesc",value:function(e){for(var t=e.pmViewDesc,n=t;n;n=n.parent)if(n==this)return t}},{key:"posFromDOM",value:function(e,t,n){for(var r=e;r;r=r.parentNode){var i=this.getDesc(r);if(i)return i.localPosFromDOM(e,t,n)}return -1}},{key:"descAt",value:function(e){for(var t=0,n=0;t<this.children.length;t++){var r=this.children[t],i=n+r.size;if(n==e&&i!=n){for(;!r.border&&r.children.length;)r=r.children[0];return r}if(e<i)return r.descAt(e-n-r.border);n=i;}}},{key:"domFromPos",value:function(e,t){if(!this.contentDOM)return {node:this.dom,offset:0};for(var n,r=0,i=0,o=0;r<this.children.length;r++){var s=this.children[r],a=o+s.size;if(a>e||s instanceof Dx){i=e-o;break}o=a;}if(i)return this.children[r].domFromPos(i-this.children[r].border,t);for(;r&&!(n=this.children[r-1]).size&&n instanceof wx&&n.side>=0;r--);if(t<=0){for(var l,c=!0;(l=r?this.children[r-1]:null)&&l.dom.parentNode!=this.contentDOM;r--,c=!1);return l&&t&&c&&!l.border&&!l.domAtom?l.domFromPos(l.size,t):{node:this.contentDOM,offset:l?zE(l.dom)+1:0}}for(var u,d=!0;(u=r<this.children.length?this.children[r]:null)&&u.dom.parentNode!=this.contentDOM;r++,d=!1);return u&&d&&!u.border&&!u.domAtom?u.domFromPos(0,t):{node:this.contentDOM,offset:u?zE(u.dom):this.contentDOM.childNodes.length}}},{key:"parseRange",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;if(0==this.children.length)return {node:this.contentDOM,from:e,to:t,fromOffset:0,toOffset:this.contentDOM.childNodes.length};for(var r=-1,i=-1,o=n,s=0;;s++){var a=this.children[s],l=o+a.size;if(-1==r&&e<=l){var c=o+a.border;if(e>=c&&t<=l-a.border&&a.node&&a.contentDOM&&this.contentDOM.contains(a.contentDOM))return a.parseRange(e,t,c);e=o;for(var u=s;u>0;u--){var d=this.children[u-1];if(d.size&&d.dom.parentNode==this.contentDOM&&!d.emptyChildAt(1)){r=zE(d.dom)+1;break}e-=d.size;}-1==r&&(r=0);}if(r>-1&&(l>t||s==this.children.length-1)){t=l;for(var h=s+1;h<this.children.length;h++){var p=this.children[h];if(p.size&&p.dom.parentNode==this.contentDOM&&!p.emptyChildAt(-1)){i=zE(p.dom);break}t+=p.size;}-1==i&&(i=this.contentDOM.childNodes.length);break}o=l;}return {node:this.contentDOM,from:e,to:t,fromOffset:r,toOffset:i}}},{key:"emptyChildAt",value:function(e){if(this.border||!this.contentDOM||!this.children.length)return !1;var t=this.children[e<0?0:this.children.length-1];return 0==t.size||t.emptyChildAt(e)}},{key:"domAfterPos",value:function(e){var t=this.domFromPos(e,0),n=t.node,r=t.offset;if(1!=n.nodeType||r==n.childNodes.length)throw new RangeError("No node after pos "+e);return n.childNodes[r]}},{key:"setSelection",value:function(e,t,n){for(var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=Math.min(e,t),o=Math.max(e,t),s=0,a=0;s<this.children.length;s++){var l=this.children[s],c=a+l.size;if(i>a&&o<c)return l.setSelection(e-a-l.border,t-a-l.border,n,r);a=c;}var u=this.domFromPos(e,e?-1:1),d=t==e?u:this.domFromPos(t,t?-1:1),h=n.getSelection(),p=!1;if((AE||LE)&&e==t){var f=u,m=f.node,g=f.offset;if(3==m.nodeType){if((p=!(!g||"\n"!=m.nodeValue[g-1]))&&g==m.nodeValue.length)for(var v,y=m;y;y=y.parentNode){if(v=y.nextSibling){"BR"==v.nodeName&&(u=d={node:v.parentNode,offset:zE(v)+1});break}var b=y.pmViewDesc;if(b&&b.node&&b.node.isBlock)break}}else {var w=m.childNodes[g-1];p=w&&("BR"==w.nodeName||"false"==w.contentEditable);}}if(AE&&h.focusNode&&h.focusNode!=d.node&&1==h.focusNode.nodeType){var k=h.focusNode.childNodes[h.focusOffset];k&&"false"==k.contentEditable&&(r=!0);}if(r||p&&LE||!VE(u.node,u.offset,h.anchorNode,h.anchorOffset)||!VE(d.node,d.offset,h.focusNode,h.focusOffset)){var C=!1;if((h.extend||e==t)&&!p){h.collapse(u.node,u.offset);try{e!=t&&h.extend(d.node,d.offset),C=!0;}catch(e){if(!(e instanceof DOMException))throw e}}if(!C){if(e>t){var E=u;u=d,d=E;}var x=document.createRange();x.setEnd(d.node,d.offset),x.setStart(u.node,u.offset),h.removeAllRanges(),h.addRange(x);}}}},{key:"ignoreMutation",value:function(e){return !this.contentDOM&&"selection"!=e.type}},{key:"contentLost",get:function(){return this.contentDOM&&this.contentDOM!=this.dom&&!this.dom.contains(this.contentDOM)}},{key:"markDirty",value:function(e,t){for(var n=0,r=0;r<this.children.length;r++){var i=this.children[r],o=n+i.size;if(n==o?e<=o&&t>=n:e<o&&t>n){var s=n+i.border,a=o-i.border;if(e>=s&&t<=a)return this.dirty=e==n||t==o?2:1,void(e!=s||t!=a||!i.contentLost&&i.dom.parentNode==this.contentDOM?i.markDirty(e-s,t-s):i.dirty=3);i.dirty=i.dom!=i.contentDOM||i.dom.parentNode!=this.contentDOM||i.children.length?3:2;}n=o;}this.dirty=2;}},{key:"markParentsDirty",value:function(){for(var e=1,t=this.parent;t;t=t.parent,e++){var n=1==e?2:1;t.dirty<n&&(t.dirty=n);}}},{key:"domAtom",get:function(){return !1}},{key:"ignoreForCoords",get:function(){return !1}}]),e}(),wx=function(e){cE(n,bx);var t=dE(n);function n(e,r,i,o){var s;mE(this,n);var a,l=r.type.toDOM;if("function"==typeof l&&(l=l(i,(function(){return a?a.parent?a.parent.posBeforeChild(a):void 0:o}))),!r.type.spec.raw){if(1!=l.nodeType){var c=document.createElement("span");c.appendChild(l),l=c;}l.contentEditable="false",l.classList.add("ProseMirror-widget");}return (s=t.call(this,e,[],l,null)).widget=r,s.widget=r,a=pE(s),s}return vE(n,[{key:"matchesWidget",value:function(e){return 0==this.dirty&&e.type.eq(this.widget.type)}},{key:"parseRule",value:function(){return {ignore:!0}}},{key:"stopEvent",value:function(e){var t=this.widget.spec.stopEvent;return !!t&&t(e)}},{key:"ignoreMutation",value:function(e){return "selection"!=e.type||this.widget.spec.ignoreSelection}},{key:"destroy",value:function(){this.widget.type.destroy(this.dom),aE(fE(n.prototype),"destroy",this).call(this);}},{key:"domAtom",get:function(){return !0}},{key:"side",get:function(){return this.widget.type.side}}]),n}(),kx=function(e){cE(n,bx);var t=dE(n);function n(e,r,i,o){var s;return mE(this,n),(s=t.call(this,e,[],r,null)).textDOM=i,s.text=o,s}return vE(n,[{key:"size",get:function(){return this.text.length}},{key:"localPosFromDOM",value:function(e,t){return e!=this.textDOM?this.posAtStart+(t?this.size:0):this.posAtStart+t}},{key:"domFromPos",value:function(e){return {node:this.textDOM,offset:e}}},{key:"ignoreMutation",value:function(e){return "characterData"===e.type&&e.target.nodeValue==e.oldValue}}]),n}(),Cx=function(e){cE(n,bx);var t=dE(n);function n(e,r,i,o){var s;return mE(this,n),(s=t.call(this,e,[],i,o)).mark=r,s}return vE(n,[{key:"parseRule",value:function(){return 3&this.dirty||this.mark.type.spec.reparseInView?null:{mark:this.mark.type.name,attrs:this.mark.attrs,contentElement:this.contentDOM||void 0}}},{key:"matchesMark",value:function(e){return 3!=this.dirty&&this.mark.eq(e)}},{key:"markDirty",value:function(e,t){if(aE(fE(n.prototype),"markDirty",this).call(this,e,t),0!=this.dirty){for(var r=this.parent;!r.node;)r=r.parent;r.dirty<this.dirty&&(r.dirty=this.dirty),this.dirty=0;}}},{key:"slice",value:function(e,t,r){var i=n.create(this.parent,this.mark,!0,r),o=this.children,s=this.size;t<s&&(o=zx(o,t,s,r)),e>0&&(o=zx(o,0,e,r));for(var a=0;a<o.length;a++)o[a].parent=i;return i.children=o,i}}],[{key:"create",value:function(e,t,r,i){var o=i.nodeViews[t.type.name],s=o&&o(t,i,r);return s&&s.dom||(s=bE.DOMSerializer.renderSpec(document,t.type.spec.toDOM(t,r))),new n(e,t,s.dom,s.contentDOM||s.dom)}}]),n}(),Ex=function(e){cE(n,bx);var t=dE(n);function n(e,r,i,o,s,a,l,c,u){var d;return mE(this,n),(d=t.call(this,e,[],s,a)).node=r,d.outerDeco=i,d.innerDeco=o,d.nodeDOM=l,a&&d.updateChildren(c,u),d}return vE(n,[{key:"parseRule",value:function(){var e=this;if(this.node.type.spec.reparseInView)return null;var t={node:this.node.type.name,attrs:this.node.attrs};if("pre"==this.node.type.whitespace&&(t.preserveWhitespace="full"),this.contentDOM)if(this.contentLost){for(var n=this.children.length-1;n>=0;n--){var r=this.children[n];if(this.dom.contains(r.dom.parentNode)){t.contentElement=r.dom.parentNode;break}}t.contentElement||(t.getContent=function(){return bE.Fragment.empty});}else t.contentElement=this.contentDOM;else t.getContent=function(){return e.node.content};return t}},{key:"matchesNode",value:function(e,t,n){return 0==this.dirty&&e.eq(this.node)&&Fx(t,this.outerDeco)&&n.eq(this.innerDeco)}},{key:"size",get:function(){return this.node.nodeSize}},{key:"border",get:function(){return this.node.isLeaf?0:1}},{key:"updateChildren",value:function(e,t){var n=this,r=this.node.inlineContent,i=t,o=e.composing?this.localCompositionInfo(e,t):null,s=o&&o.pos>-1?o:null,a=o&&o.pos<0,l=new Ix(this,s&&s.node);!function(e,t,n,r){var i=t.locals(e),o=0;if(0==i.length){for(var s=0;s<e.childCount;s++){var a=e.child(s);r(a,i,t.forChild(o,a),s),o+=a.nodeSize;}return}for(var l=0,c=[],u=null,d=0;;){if(l<i.length&&i[l].to==o){for(var h=i[l++],p=void 0;l<i.length&&i[l].to==o;)(p||(p=[h])).push(i[l++]);if(p){p.sort(Px);for(var f=0;f<p.length;f++)n(p[f],d,!!u);}else n(h,d,!!u);}var m=void 0,g=void 0;if(u)g=-1,m=u,u=null;else {if(!(d<e.childCount))break;g=d,m=e.child(d++);}for(var v=0;v<c.length;v++)c[v].to<=o&&c.splice(v--,1);for(;l<i.length&&i[l].from<=o&&i[l].to>o;)c.push(i[l++]);var y=o+m.nodeSize;if(m.isText){var b=y;l<i.length&&i[l].from<b&&(b=i[l].from);for(var w=0;w<c.length;w++)c[w].to<b&&(b=c[w].to);b<y&&(u=m.cut(b-o),m=m.cut(0,b-o),y=b,g=-1);}r(m,m.isInline&&!m.isLeaf?c.filter((function(e){return !e.inline})):c.slice(),t.forChild(o,m),g),o=y;}}(this.node,this.innerDeco,(function(t,o,s){t.spec.marks?l.syncToMarks(t.spec.marks,r,e):t.type.side>=0&&!s&&l.syncToMarks(o==n.node.childCount?bE.Mark.none:n.node.child(o).marks,r,e),l.placeWidget(t,e,i);}),(function(t,n,s,c){var u;l.syncToMarks(t.marks,r,e),l.findNodeMatch(t,n,s,c)||a&&e.state.selection.from>i&&e.state.selection.to<i+t.nodeSize&&(u=l.findIndexWithChild(o.node))>-1&&l.updateNodeAt(t,n,s,u,e)||l.updateNextNode(t,n,s,e,c)||l.addNode(t,n,s,e,i),i+=t.nodeSize;})),l.syncToMarks([],r,e),this.node.isTextblock&&l.addTextblockHacks(),l.destroyRest(),(l.changed||2==this.dirty)&&(s&&this.protectLocalComposition(e,s),Ox(this.contentDOM,this.children,e),RE&&function(e){if("UL"==e.nodeName||"OL"==e.nodeName){var t=e.style.cssText;e.style.cssText=t+"; list-style: square !important",window.getComputedStyle(e).listStyle,e.style.cssText=t;}}(this.dom));}},{key:"localCompositionInfo",value:function(e,t){var n=e.state.selection,r=n.from,i=n.to;if(!(e.state.selection instanceof yE.TextSelection)||r<t||i>t+this.node.content.size)return null;var o=e.domSelection(),s=function(e,t){for(;;){if(3==e.nodeType)return e;if(1==e.nodeType&&t>0){if(e.childNodes.length>t&&3==e.childNodes[t].nodeType)return e.childNodes[t];t=UE(e=e.childNodes[t-1]);}else {if(!(1==e.nodeType&&t<e.childNodes.length))return null;e=e.childNodes[t],t=0;}}}(o.focusNode,o.focusOffset);if(!s||!this.dom.contains(s.parentNode))return null;if(this.node.inlineContent){var a=s.nodeValue,l=function(e,t,n,r){for(var i=0,o=0;i<e.childCount&&o<=r;){var s=e.child(i++),a=o;if(o+=s.nodeSize,s.isText){for(var l=s.text;i<e.childCount;){var c=e.child(i++);if(o+=c.nodeSize,!c.isText)break;l+=c.text;}if(o>=n){var u=a<r?l.lastIndexOf(t,r-a-1):-1;if(u>=0&&u+t.length+a>=n)return a+u;if(n==r&&l.length>=r+t.length-a&&l.slice(r-a,r-a+t.length)==t)return r}}}return -1}(this.node.content,a,r-t,i-t);return l<0?null:{node:s,pos:l,text:a}}return {node:s,pos:-1,text:""}}},{key:"protectLocalComposition",value:function(e,t){var n=t.node,r=t.pos,i=t.text;if(!this.getDesc(n)){for(var o=n;o.parentNode!=this.contentDOM;o=o.parentNode){for(;o.previousSibling;)o.parentNode.removeChild(o.previousSibling);for(;o.nextSibling;)o.parentNode.removeChild(o.nextSibling);o.pmViewDesc&&(o.pmViewDesc=void 0);}var s=new kx(this,o,n,i);e.input.compositionNodes.push(s),this.children=zx(this.children,r,r+i.length,e,s);}}},{key:"update",value:function(e,t,n,r){return !(3==this.dirty||!e.sameMarkup(this.node))&&(this.updateInner(e,t,n,r),!0)}},{key:"updateInner",value:function(e,t,n,r){this.updateOuterDeco(t),this.node=e,this.innerDeco=n,this.contentDOM&&this.updateChildren(r,this.posAtStart),this.dirty=0;}},{key:"updateOuterDeco",value:function(e){if(!Fx(e,this.outerDeco)){var t=1!=this.nodeDOM.nodeType,n=this.dom;this.dom=Tx(this.dom,this.nodeDOM,_x(this.outerDeco,this.node,t),_x(e,this.node,t)),this.dom!=n&&(n.pmViewDesc=void 0,this.dom.pmViewDesc=this),this.outerDeco=e;}}},{key:"selectNode",value:function(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.add("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||(this.dom.draggable=!0);}},{key:"deselectNode",value:function(){1==this.nodeDOM.nodeType&&this.nodeDOM.classList.remove("ProseMirror-selectednode"),!this.contentDOM&&this.node.type.spec.draggable||this.dom.removeAttribute("draggable");}},{key:"domAtom",get:function(){return this.node.isAtom}}],[{key:"create",value:function(e,t,r,i,o,s){var a,l=o.nodeViews[t.type.name],c=l&&l(t,o,(function(){return a?a.parent?a.parent.posBeforeChild(a):void 0:s}),r,i),u=c&&c.dom,d=c&&c.contentDOM;if(t.isText)if(u){if(3!=u.nodeType)throw new RangeError("Text must be rendered as a DOM text node")}else u=document.createTextNode(t.text);else if(!u){var h=bE.DOMSerializer.renderSpec(document,t.type.spec.toDOM(t));u=h.dom,d=h.contentDOM;}d||t.isText||"BR"==u.nodeName||(u.hasAttribute("contenteditable")||(u.contentEditable="false"),t.type.spec.draggable&&(u.draggable=!0));var p=u;return u=Rx(u,r,t),c?a=new Mx(e,t,r,i,u,d||null,p,c,o,s+1):t.isText?new Sx(e,t,r,i,u,p,o):new n(e,t,r,i,u,d||null,p,o,s+1)}}]),n}();function xx(e,t,n,r,i){return Rx(r,t,e),new Ex(void 0,e,t,n,r,r,r,i,0)}var Sx=function(e){cE(n,Ex);var t=dE(n);function n(e,r,i,o,s,a,l){return mE(this,n),t.call(this,e,r,i,o,s,null,a,l,0)}return vE(n,[{key:"parseRule",value:function(){for(var e=this.nodeDOM.parentNode;e&&e!=this.dom&&!e.pmIsDeco;)e=e.parentNode;return {skip:e||!0}}},{key:"update",value:function(e,t,n,r){return !(3==this.dirty||0!=this.dirty&&!this.inParent()||!e.sameMarkup(this.node))&&(this.updateOuterDeco(t),0==this.dirty&&e.text==this.node.text||e.text==this.nodeDOM.nodeValue||(this.nodeDOM.nodeValue=e.text,r.trackWrites==this.nodeDOM&&(r.trackWrites=null)),this.node=e,this.dirty=0,!0)}},{key:"inParent",value:function(){for(var e=this.parent.contentDOM,t=this.nodeDOM;t;t=t.parentNode)if(t==e)return !0;return !1}},{key:"domFromPos",value:function(e){return {node:this.nodeDOM,offset:e}}},{key:"localPosFromDOM",value:function(e,t,r){return e==this.nodeDOM?this.posAtStart+Math.min(t,this.node.text.length):aE(fE(n.prototype),"localPosFromDOM",this).call(this,e,t,r)}},{key:"ignoreMutation",value:function(e){return "characterData"!=e.type&&"selection"!=e.type}},{key:"slice",value:function(e,t,r){var i=this.node.cut(e,t),o=document.createTextNode(i.text);return new n(this.parent,i,this.outerDeco,this.innerDeco,o,o,r)}},{key:"markDirty",value:function(e,t){aE(fE(n.prototype),"markDirty",this).call(this,e,t),this.dom==this.nodeDOM||0!=e&&t!=this.nodeDOM.nodeValue.length||(this.dirty=3);}},{key:"domAtom",get:function(){return !1}}]),n}(),Dx=function(e){cE(n,bx);var t=dE(n);function n(){return mE(this,n),t.apply(this,arguments)}return vE(n,[{key:"parseRule",value:function(){return {ignore:!0}}},{key:"matchesHack",value:function(e){return 0==this.dirty&&this.dom.nodeName==e}},{key:"domAtom",get:function(){return !0}},{key:"ignoreForCoords",get:function(){return "IMG"==this.dom.nodeName}}]),n}(),Mx=function(e){cE(n,Ex);var t=dE(n);function n(e,r,i,o,s,a,l,c,u,d){var h;return mE(this,n),(h=t.call(this,e,r,i,o,s,a,l,u,d)).spec=c,h}return vE(n,[{key:"update",value:function(e,t,r,i){if(3==this.dirty)return !1;if(this.spec.update){var o=this.spec.update(e,t,r);return o&&this.updateInner(e,t,r,i),o}return !(!this.contentDOM&&!e.isLeaf)&&aE(fE(n.prototype),"update",this).call(this,e,t,r,i)}},{key:"selectNode",value:function(){this.spec.selectNode?this.spec.selectNode():aE(fE(n.prototype),"selectNode",this).call(this);}},{key:"deselectNode",value:function(){this.spec.deselectNode?this.spec.deselectNode():aE(fE(n.prototype),"deselectNode",this).call(this);}},{key:"setSelection",value:function(e,t,r,i){this.spec.setSelection?this.spec.setSelection(e,t,r):aE(fE(n.prototype),"setSelection",this).call(this,e,t,r,i);}},{key:"destroy",value:function(){this.spec.destroy&&this.spec.destroy(),aE(fE(n.prototype),"destroy",this).call(this);}},{key:"stopEvent",value:function(e){return !!this.spec.stopEvent&&this.spec.stopEvent(e)}},{key:"ignoreMutation",value:function(e){return this.spec.ignoreMutation?this.spec.ignoreMutation(e):aE(fE(n.prototype),"ignoreMutation",this).call(this,e)}}]),n}();function Ox(e,t,n){for(var r=e.firstChild,i=!1,o=0;o<t.length;o++){var s=t[o],a=s.dom;if(a.parentNode==e){for(;a!=r;)r=Bx(r),i=!0;r=r.nextSibling;}else i=!0,e.insertBefore(a,r);if(s instanceof Cx){var l=r?r.previousSibling:e.lastChild;Ox(s.contentDOM,s.children,n),r=l?l.nextSibling:e.firstChild;}}for(;r;)r=Bx(r),i=!0;i&&n.trackWrites==e&&(n.trackWrites=null);}var Ax=function(e){e&&(this.nodeName=e);};Ax.prototype=Object.create(null);var Nx=[new Ax];function _x(e,t,n){if(0==e.length)return Nx;for(var r=n?Nx[0]:new Ax,i=[r],o=0;o<e.length;o++){var s=e[o].type.attrs;if(s)for(var a in s.nodeName&&i.push(r=new Ax(s.nodeName)),s){var l=s[a];null!=l&&(n&&1==i.length&&i.push(r=new Ax(t.isInline?"span":"div")),"class"==a?r.class=(r.class?r.class+" ":"")+l:"style"==a?r.style=(r.style?r.style+";":"")+l:"nodeName"!=a&&(r[a]=l));}}return i}function Tx(e,t,n,r){if(n==Nx&&r==Nx)return t;for(var i=t,o=0;o<r.length;o++){var s=r[o],a=n[o];if(o){var l=void 0;a&&a.nodeName==s.nodeName&&i!=e&&(l=i.parentNode)&&l.nodeName.toLowerCase()==s.nodeName||((l=document.createElement(s.nodeName)).pmIsDeco=!0,l.appendChild(i),a=Nx[0]),i=l;}Lx(i,a||Nx[0],s);}return i}function Lx(e,t,n){for(var r in t)"class"==r||"style"==r||"nodeName"==r||r in n||e.removeAttribute(r);for(var i in n)"class"!=i&&"style"!=i&&"nodeName"!=i&&n[i]!=t[i]&&e.setAttribute(i,n[i]);if(t.class!=n.class){for(var o=t.class?t.class.split(" ").filter(Boolean):[],s=n.class?n.class.split(" ").filter(Boolean):[],a=0;a<o.length;a++)-1==s.indexOf(o[a])&&e.classList.remove(o[a]);for(var l=0;l<s.length;l++)-1==o.indexOf(s[l])&&e.classList.add(s[l]);0==e.classList.length&&e.removeAttribute("class");}if(t.style!=n.style){if(t.style)for(var c,u=/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;c=u.exec(t.style);)e.style.removeProperty(c[1]);n.style&&(e.style.cssText+=n.style);}}function Rx(e,t,n){return Tx(e,e,Nx,_x(t,n,1!=e.nodeType))}function Fx(e,t){if(e.length!=t.length)return !1;for(var n=0;n<e.length;n++)if(!e[n].type.eq(t[n].type))return !1;return !0}function Bx(e){var t=e.nextSibling;return e.parentNode.removeChild(e),t}var Ix=function(){function e(t,n){mE(this,e),this.lock=n,this.index=0,this.stack=[],this.changed=!1,this.top=t,this.preMatch=function(e,t){var n=t,r=n.children.length,i=e.childCount,o=new Map,s=[];e:for(;i>0;){for(var a=void 0;;)if(r){var l=n.children[r-1];if(!(l instanceof Cx)){a=l,r--;break}n=l,r=l.children.length;}else {if(n==t)break e;r=n.parent.children.indexOf(n),n=n.parent;}var c=a.node;if(c){if(c!=e.child(i-1))break;--i,o.set(a,i),s.push(a);}}return {index:i,matched:o,matches:s.reverse()}}(t.node.content,t);}return vE(e,[{key:"destroyBetween",value:function(e,t){if(e!=t){for(var n=e;n<t;n++)this.top.children[n].destroy();this.top.children.splice(e,t-e),this.changed=!0;}}},{key:"destroyRest",value:function(){this.destroyBetween(this.index,this.top.children.length);}},{key:"syncToMarks",value:function(e,t,n){for(var r=0,i=this.stack.length>>1,o=Math.min(i,e.length);r<o&&(r==i-1?this.top:this.stack[r+1<<1]).matchesMark(e[r])&&!1!==e[r].type.spec.spanning;)r++;for(;r<i;)this.destroyRest(),this.top.dirty=0,this.index=this.stack.pop(),this.top=this.stack.pop(),i--;for(;i<e.length;){this.stack.push(this.top,this.index+1);for(var s=-1,a=this.index;a<Math.min(this.index+3,this.top.children.length);a++)if(this.top.children[a].matchesMark(e[i])){s=a;break}if(s>-1)s>this.index&&(this.changed=!0,this.destroyBetween(this.index,s)),this.top=this.top.children[this.index];else {var l=Cx.create(this.top,e[i],t,n);this.top.children.splice(this.index,0,l),this.top=l,this.changed=!0;}this.index=0,i++;}}},{key:"findNodeMatch",value:function(e,t,n,r){var i,o=-1;if(r>=this.preMatch.index&&(i=this.preMatch.matches[r-this.preMatch.index]).parent==this.top&&i.matchesNode(e,t,n))o=this.top.children.indexOf(i,this.index);else for(var s=this.index,a=Math.min(this.top.children.length,s+5);s<a;s++){var l=this.top.children[s];if(l.matchesNode(e,t,n)&&!this.preMatch.matched.has(l)){o=s;break}}return !(o<0)&&(this.destroyBetween(this.index,o),this.index++,!0)}},{key:"updateNodeAt",value:function(e,t,n,r,i){var o=this.top.children[r];return 3==o.dirty&&o.dom==o.contentDOM&&(o.dirty=2),!!o.update(e,t,n,i)&&(this.destroyBetween(this.index,r),this.index=r+1,!0)}},{key:"findIndexWithChild",value:function(e){for(;;){var t=e.parentNode;if(!t)return -1;if(t==this.top.contentDOM){var n=e.pmViewDesc;if(n)for(var r=this.index;r<this.top.children.length;r++)if(this.top.children[r]==n)return r;return -1}e=t;}}},{key:"updateNextNode",value:function(e,t,n,r,i){for(var o=this.index;o<this.top.children.length;o++){var s=this.top.children[o];if(s instanceof Ex){var a=this.preMatch.matched.get(s);if(null!=a&&a!=i)return !1;var l=s.dom;if(!(this.lock&&(l==this.lock||1==l.nodeType&&l.contains(this.lock.parentNode))&&!(e.isText&&s.node&&s.node.isText&&s.nodeDOM.nodeValue==e.text&&3!=s.dirty&&Fx(t,s.outerDeco)))&&s.update(e,t,n,r))return this.destroyBetween(this.index,o),s.dom!=l&&(this.changed=!0),this.index++,!0;break}}return !1}},{key:"addNode",value:function(e,t,n,r,i){this.top.children.splice(this.index++,0,Ex.create(this.top,e,t,n,r,i)),this.changed=!0;}},{key:"placeWidget",value:function(e,t,n){var r=this.index<this.top.children.length?this.top.children[this.index]:null;if(!r||!r.matchesWidget(e)||e!=r.widget&&r.widget.type.toDOM.parentNode){var i=new wx(this.top,e,t,n);this.top.children.splice(this.index++,0,i),this.changed=!0;}else this.index++;}},{key:"addTextblockHacks",value:function(){for(var e=this.top.children[this.index-1],t=this.top;e instanceof Cx;)e=(t=e).children[t.children.length-1];e&&e instanceof Sx&&!/\n$/.test(e.node.text)||((LE||_E)&&e&&"false"==e.dom.contentEditable&&this.addHackNode("IMG",t),this.addHackNode("BR",this.top));}},{key:"addHackNode",value:function(e,t){if(t==this.top&&this.index<t.children.length&&t.children[this.index].matchesHack(e))this.index++;else {var n=document.createElement(e);"IMG"==e&&(n.className="ProseMirror-separator",n.alt=""),"BR"==e&&(n.className="ProseMirror-trailingBreak");var r=new Dx(this.top,[],n,null);t!=this.top?t.children.push(r):t.children.splice(this.index++,0,r),this.changed=!0;}}}]),e}();function Px(e,t){return e.type.side-t.type.side}function zx(e,t,n,r,i){for(var o=[],s=0,a=0;s<e.length;s++){var l=e[s],c=a,u=a+=l.size;c>=n||u<=t?o.push(l):(c<t&&o.push(l.slice(0,t-c,r)),i&&(o.push(i),i=void 0),u>n&&o.push(l.slice(n-c,l.size,r)));}return o}function $x(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=e.domSelection(),r=e.state.doc;if(!n.focusNode)return null;var i=e.docView.nearestDesc(n.focusNode),o=i&&0==i.size,s=e.docView.posFromDOM(n.focusNode,n.focusOffset,1);if(s<0)return null;var a,l,c=r.resolve(s);if(JE(n)){for(a=c;i&&!i.node;)i=i.parent;var u=i.node;if(i&&u.isAtom&&yE.NodeSelection.isSelectable(u)&&i.parent&&(!u.isInline||!WE(n.focusNode,n.focusOffset,i.dom))){var d=i.posBefore;l=new yE.NodeSelection(s==d?c:r.resolve(d));}}else {var h=e.docView.posFromDOM(n.anchorNode,n.anchorOffset,1);if(h<0)return null;a=r.resolve(h);}if(!l){var p="pointer"==t||e.state.selection.head<c.pos&&!o?1:-1;l=Xx(e,a,c,p);}return l}function jx(e){return e.editable?e.hasFocus():Yx(e)&&document.activeElement&&document.activeElement.contains(e.dom)}function Hx(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.state.selection;if(Jx(e,n),jx(e)){if(!t&&e.input.mouseDown&&e.input.mouseDown.allowDefault&&_E){var r=e.domSelection(),i=e.domObserver.currentSelection;if(r.anchorNode&&i.anchorNode&&VE(r.anchorNode,r.anchorOffset,i.anchorNode,i.anchorOffset))return e.input.mouseDown.delayedSelectionSync=!0,void e.domObserver.setCurSelection()}if(e.domObserver.disconnectSelection(),e.cursorWrapper)Gx(e);else {var o,s,a=n.anchor,l=n.head;!Vx||n instanceof yE.TextSelection||(n.$from.parent.inlineContent||(o=Kx(e,n.from)),n.empty||n.$from.parent.inlineContent||(s=Kx(e,n.to))),e.docView.setSelection(a,l,e.root,t),Vx&&(o&&Ux(o),s&&Ux(s)),n.visible?e.dom.classList.remove("ProseMirror-hideselection"):(e.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&&Wx(e));}e.domObserver.setCurSelection(),e.domObserver.connectSelection();}}var Vx=LE||_E&&TE<63;function Kx(e,t){var n=e.docView.domFromPos(t,0),r=n.node,i=n.offset,o=i<r.childNodes.length?r.childNodes[i]:null,s=i?r.childNodes[i-1]:null;if(LE&&o&&"false"==o.contentEditable)return qx(o);if(!(o&&"false"!=o.contentEditable||s&&"false"!=s.contentEditable)){if(o)return qx(o);if(s)return qx(s)}}function qx(e){return e.contentEditable="true",LE&&e.draggable&&(e.draggable=!1,e.wasDraggable=!0),e}function Ux(e){e.contentEditable="false",e.wasDraggable&&(e.draggable=!0,e.wasDraggable=null);}function Wx(e){var t=e.dom.ownerDocument;t.removeEventListener("selectionchange",e.input.hideSelectionGuard);var n=e.domSelection(),r=n.anchorNode,i=n.anchorOffset;t.addEventListener("selectionchange",e.input.hideSelectionGuard=function(){n.anchorNode==r&&n.anchorOffset==i||(t.removeEventListener("selectionchange",e.input.hideSelectionGuard),setTimeout((function(){jx(e)&&!e.state.selection.visible||e.dom.classList.remove("ProseMirror-hideselection");}),20));});}function Gx(e){var t=e.domSelection(),n=document.createRange(),r=e.cursorWrapper.dom,i="IMG"==r.nodeName;i?n.setEnd(r.parentNode,zE(r)+1):n.setEnd(r,0),n.collapse(!1),t.removeAllRanges(),t.addRange(n),!i&&!e.state.selection.visible&&ME&&OE<=11&&(r.disabled=!0,r.disabled=!1);}function Jx(e,t){if(t instanceof yE.NodeSelection){var n=e.docView.descAt(t.from);n!=e.lastSelectedViewDesc&&(Zx(e),n&&n.selectNode(),e.lastSelectedViewDesc=n);}else Zx(e);}function Zx(e){e.lastSelectedViewDesc&&(e.lastSelectedViewDesc.parent&&e.lastSelectedViewDesc.deselectNode(),e.lastSelectedViewDesc=void 0);}function Xx(e,t,n,r){return e.someProp("createSelectionBetween",(function(r){return r(e,t,n)}))||yE.TextSelection.between(t,n,r)}function Qx(e){return (!e.editable||e.root.activeElement==e.dom)&&Yx(e)}function Yx(e){var t=e.domSelection();if(!t.anchorNode)return !1;try{return e.dom.contains(3==t.anchorNode.nodeType?t.anchorNode.parentNode:t.anchorNode)&&(e.editable||e.dom.contains(3==t.focusNode.nodeType?t.focusNode.parentNode:t.focusNode))}catch(e){return !1}}function eS(e,t){var n=e.selection,r=n.$anchor,i=n.$head,o=t>0?r.max(i):r.min(i),s=o.parent.inlineContent?o.depth?e.doc.resolve(t>0?o.after():o.before()):null:o;return s&&yE.Selection.findFrom(s,t)}function tS(e,t){return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()),!0}function nS(e,t,n){var r=e.state.selection;if(!(r instanceof yE.TextSelection)){if(r instanceof yE.NodeSelection&&r.node.isInline)return tS(e,new yE.TextSelection(t>0?r.$to:r.$from));var i=eS(e.state,t);return !!i&&tS(e,i)}if(!r.empty||n.indexOf("s")>-1)return !1;if(e.endOfTextblock(t>0?"right":"left")){var o=eS(e.state,t);return !!(o&&o instanceof yE.NodeSelection)&&tS(e,o)}if(!(FE&&n.indexOf("m")>-1)){var s,a=r.$head,l=a.textOffset?null:t<0?a.nodeBefore:a.nodeAfter;if(!l||l.isText)return !1;var c=t<0?a.pos-l.nodeSize:a.pos;return !!(l.isAtom||(s=e.docView.descAt(c))&&!s.contentDOM)&&(yE.NodeSelection.isSelectable(l)?tS(e,new yE.NodeSelection(t<0?e.state.doc.resolve(a.pos-l.nodeSize):a)):!!IE&&tS(e,new yE.TextSelection(e.state.doc.resolve(t<0?c:c+l.nodeSize))))}}function rS(e){return 3==e.nodeType?e.nodeValue.length:e.childNodes.length}function iS(e){var t=e.pmViewDesc;return t&&0==t.size&&(e.nextSibling||"BR"!=e.nodeName)}function oS(e){var t=e.domSelection(),n=t.focusNode,r=t.focusOffset;if(n){var i,o,s=!1;for(AE&&1==n.nodeType&&r<rS(n)&&iS(n.childNodes[r])&&(s=!0);;)if(r>0){if(1!=n.nodeType)break;var a=n.childNodes[r-1];if(iS(a))i=n,o=--r;else {if(3!=a.nodeType)break;r=(n=a).nodeValue.length;}}else {if(aS(n))break;for(var l=n.previousSibling;l&&iS(l);)i=n.parentNode,o=zE(l),l=l.previousSibling;if(l)r=rS(n=l);else {if((n=n.parentNode)==e.dom)break;r=0;}}s?lS(e,t,n,r):i&&lS(e,t,i,o);}}function sS(e){var t=e.domSelection(),n=t.focusNode,r=t.focusOffset;if(n){for(var i,o,s=rS(n);;)if(r<s){if(1!=n.nodeType)break;if(!iS(n.childNodes[r]))break;i=n,o=++r;}else {if(aS(n))break;for(var a=n.nextSibling;a&&iS(a);)i=a.parentNode,o=zE(a)+1,a=a.nextSibling;if(a)r=0,s=rS(n=a);else {if((n=n.parentNode)==e.dom)break;r=s=0;}}i&&lS(e,t,i,o);}}function aS(e){var t=e.pmViewDesc;return t&&t.node&&t.node.isBlock}function lS(e,t,n,r){if(JE(t)){var i=document.createRange();i.setEnd(n,r),i.setStart(n,r),t.removeAllRanges(),t.addRange(i);}else t.extend&&t.extend(n,r);e.domObserver.setCurSelection();var o=e.state;setTimeout((function(){e.state==o&&Hx(e);}),50);}function cS(e,t,n){var r=e.state.selection;if(r instanceof yE.TextSelection&&!r.empty||n.indexOf("s")>-1)return !1;if(FE&&n.indexOf("m")>-1)return !1;var i=r.$from,o=r.$to;if(!i.parent.inlineContent||e.endOfTextblock(t<0?"up":"down")){var s=eS(e.state,t);if(s&&s instanceof yE.NodeSelection)return tS(e,s)}if(!i.parent.inlineContent){var a=t<0?i:o,l=r instanceof yE.AllSelection?yE.Selection.near(a,t):yE.Selection.findFrom(a,t);return !!l&&tS(e,l)}return !1}function uS(e,t){if(!(e.state.selection instanceof yE.TextSelection))return !0;var n=e.state.selection,r=n.$head,i=n.$anchor,o=n.empty;if(!r.sameParent(i))return !0;if(!o)return !1;if(e.endOfTextblock(t>0?"forward":"backward"))return !0;var s=!r.textOffset&&(t<0?r.nodeBefore:r.nodeAfter);if(s&&!s.isText){var a=e.state.tr;return t<0?a.delete(r.pos-s.nodeSize,r.pos):a.delete(r.pos,r.pos+s.nodeSize),e.dispatch(a),!0}return !1}function dS(e,t,n){e.domObserver.stop(),t.contentEditable=n,e.domObserver.start();}function hS(e,t){var n=t.keyCode,r=function(e){var t="";return e.ctrlKey&&(t+="c"),e.metaKey&&(t+="m"),e.altKey&&(t+="a"),e.shiftKey&&(t+="s"),t}(t);return 8==n||FE&&72==n&&"c"==r?uS(e,-1)||oS(e):46==n||FE&&68==n&&"c"==r?uS(e,1)||sS(e):13==n||27==n||(37==n||FE&&66==n&&"c"==r?nS(e,-1,r)||oS(e):39==n||FE&&70==n&&"c"==r?nS(e,1,r)||sS(e):38==n||FE&&80==n&&"c"==r?cS(e,-1,r)||oS(e):40==n||FE&&78==n&&"c"==r?function(e){if(!LE||e.state.selection.$head.parentOffset>0)return !1;var t=e.domSelection(),n=t.focusNode,r=t.focusOffset;if(n&&1==n.nodeType&&0==r&&n.firstChild&&"false"==n.firstChild.contentEditable){var i=n.firstChild;dS(e,i,"true"),setTimeout((function(){return dS(e,i,"false")}),20);}return !1}(e)||cS(e,1,r)||sS(e):r==(FE?"m":"c")&&(66==n||73==n||89==n||90==n))}function pS(e,t){for(var n=[],r=t.content,i=t.openStart,o=t.openEnd;i>1&&o>1&&1==r.childCount&&1==r.firstChild.childCount;){i--,o--;var s=r.firstChild;n.push(s.type.name,s.attrs!=s.type.defaultAttrs?s.attrs:null),r=s.content;}var a=e.someProp("clipboardSerializer")||bE.DOMSerializer.fromSchema(e.state.schema),l=ES(),c=l.createElement("div");c.appendChild(a.serializeFragment(r,{document:l}));for(var u,d=c.firstChild,h=0;d&&1==d.nodeType&&(u=kS[d.nodeName.toLowerCase()]);){for(var p=u.length-1;p>=0;p--){for(var f=l.createElement(u[p]);c.firstChild;)f.appendChild(c.firstChild);c.appendChild(f),h++;}d=c.firstChild;}return d&&1==d.nodeType&&d.setAttribute("data-pm-slice","".concat(i," ").concat(o).concat(h?" -".concat(h):""," ").concat(JSON.stringify(n))),{dom:c,text:e.someProp("clipboardTextSerializer",(function(e){return e(t)}))||t.content.textBetween(0,t.content.size,"\n\n")}}function fS(e,t,n,r,i){var o,s,a=i.parent.type.spec.code;if(!n&&!t)return null;var l=t&&(r||a||!n);if(l){if(e.someProp("transformPastedText",(function(e){t=e(t,a||r);})),a)return t?new bE.Slice(bE.Fragment.from(e.state.schema.text(t.replace(/\r\n?/g,"\n"))),0,0):bE.Slice.empty;var c=e.someProp("clipboardTextParser",(function(e){return e(t,i,r)}));if(c)s=c;else {var u=i.marks(),d=e.state.schema,h=bE.DOMSerializer.fromSchema(d);o=document.createElement("div"),t.split(/(?:\r\n?|\n)+/).forEach((function(e){var t=o.appendChild(document.createElement("p"));e&&t.appendChild(h.serializeNode(d.text(e,u)));}));}}else e.someProp("transformPastedHTML",(function(e){n=e(n);})),o=function(e){var t=/^(\s*<meta [^>]*>)*/.exec(e);t&&(e=e.slice(t[0].length));var n,r=ES().createElement("div"),i=/<([a-z][^>\s]+)/i.exec(e);(n=i&&kS[i[1].toLowerCase()])&&(e=n.map((function(e){return "<"+e+">"})).join("")+e+n.map((function(e){return "</"+e+">"})).reverse().join(""));if(r.innerHTML=e,n)for(var o=0;o<n.length;o++)r=r.querySelector(n[o])||r;return r}(n),IE&&function(e){for(var t=e.querySelectorAll(_E?"span:not([class]):not([style])":"span.Apple-converted-space"),n=0;n<t.length;n++){var r=t[n];1==r.childNodes.length&&" "==r.textContent&&r.parentNode&&r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "),r);}}(o);var p=o&&o.querySelector("[data-pm-slice]"),f=p&&/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(p.getAttribute("data-pm-slice")||"");if(f&&f[3])for(var m=+f[3];m>0&&o.firstChild;m--)o=o.firstChild;if(!s){var g=e.someProp("clipboardParser")||e.someProp("domParser")||bE.DOMParser.fromSchema(e.state.schema);s=g.parseSlice(o,{preserveWhitespace:!(!l&&!f),context:i,ruleFromNode:function(e){return "BR"!=e.nodeName||e.nextSibling||!e.parentNode||mS.test(e.parentNode.nodeName)?null:{ignore:!0}}});}if(f)s=function(e,t){if(!e.size)return e;var n,r=e.content.firstChild.type.schema;try{n=JSON.parse(t);}catch(t){return e}for(var i=e.content,o=e.openStart,s=e.openEnd,a=n.length-2;a>=0;a-=2){var l=r.nodes[n[a]];if(!l||l.hasRequiredAttrs())break;i=bE.Fragment.from(l.create(n[a+1],i)),o++,s++;}return new bE.Slice(i,o,s)}(wS(s,+f[1],+f[2]),f[4]);else if(s=bE.Slice.maxOpen(function(e,t){if(e.childCount<2)return e;for(var n=function(n){var r=t.node(n).contentMatchAt(t.index(n)),i=void 0,o=[];if(e.forEach((function(e){if(o){var t,n=r.findWrapping(e.type);if(!n)return o=null;if(t=o.length&&i.length&&vS(n,i,e,o[o.length-1],0))o[o.length-1]=t;else {o.length&&(o[o.length-1]=yS(o[o.length-1],i.length));var s=gS(e,n);o.push(s),r=r.matchType(s.type),i=n;}}})),o)return {v:bE.Fragment.from(o)}},r=t.depth;r>=0;r--){var i=n(r);if("object"===sE(i))return i.v}return e}(s.content,i),!0),s.openStart||s.openEnd){for(var v=0,y=0,b=s.content.firstChild;v<s.openStart&&!b.type.spec.isolating;v++,b=b.firstChild);for(var w=s.content.lastChild;y<s.openEnd&&!w.type.spec.isolating;y++,w=w.lastChild);s=wS(s,v,y);}return e.someProp("transformPasted",(function(e){s=e(s);})),s}var mS=/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;function gS(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=t.length-1;r>=n;r--)e=t[r].create(null,bE.Fragment.from(e));return e}function vS(e,t,n,r,i){if(i<e.length&&i<t.length&&e[i]==t[i]){var o=vS(e,t,n,r.lastChild,i+1);if(o)return r.copy(r.content.replaceChild(r.childCount-1,o));if(r.contentMatchAt(r.childCount).matchType(i==e.length-1?n.type:e[i+1]))return r.copy(r.content.append(bE.Fragment.from(gS(n,e,i+1))))}}function yS(e,t){if(0==t)return e;var n=e.content.replaceChild(e.childCount-1,yS(e.lastChild,t-1)),r=e.contentMatchAt(e.childCount).fillBefore(bE.Fragment.empty,!0);return e.copy(n.append(r))}function bS(e,t,n,r,i,o){var s=t<0?e.firstChild:e.lastChild,a=s.content;return i<r-1&&(a=bS(a,t,n,r,i+1,o)),i>=n&&(a=t<0?s.contentMatchAt(0).fillBefore(a,e.childCount>1||o<=i).append(a):a.append(s.contentMatchAt(s.childCount).fillBefore(bE.Fragment.empty,!0))),e.replaceChild(t<0?0:e.childCount-1,s.copy(a))}function wS(e,t,n){return t<e.openStart&&(e=new bE.Slice(bS(e.content,-1,t,e.openStart,0,e.openEnd),t,e.openEnd)),n<e.openEnd&&(e=new bE.Slice(bS(e.content,1,n,e.openEnd,0,0),e.openStart,n)),e}var kS={thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]},CS=null;function ES(){return CS||(CS=document.implementation.createHTMLDocument("title"))}var xS={},SS={},DS=vE((function e(){mE(this,e),this.shiftKey=!1,this.mouseDown=null,this.lastKeyCode=null,this.lastKeyCodeTime=0,this.lastClick={time:0,x:0,y:0,type:""},this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastIOSEnter=0,this.lastIOSEnterFallbackTimeout=-1,this.lastAndroidDelete=0,this.composing=!1,this.composingTimeout=-1,this.compositionNodes=[],this.compositionEndedAt=-2e8,this.domChangeCount=0,this.eventHandlers=Object.create(null),this.hideSelectionGuard=null;}));function MS(e,t){e.input.lastSelectionOrigin=t,e.input.lastSelectionTime=Date.now();}function OS(e){e.someProp("handleDOMEvents",(function(t){for(var n in t)e.input.eventHandlers[n]||e.dom.addEventListener(n,e.input.eventHandlers[n]=function(t){return AS(e,t)});}));}function AS(e,t){return e.someProp("handleDOMEvents",(function(n){var r=n[t.type];return !!r&&(r(e,t)||t.defaultPrevented)}))}function NS(e){return {left:e.clientX,top:e.clientY}}function _S(e,t,n,r,i){if(-1==r)return !1;for(var o=e.state.doc.resolve(r),s=function(r){if(e.someProp(t,(function(t){return r>o.depth?t(e,n,o.nodeAfter,o.before(r),i,!0):t(e,n,o.node(r),o.before(r),i,!1)})))return {v:!0}},a=o.depth+1;a>0;a--){var l=s(a);if("object"===sE(l))return l.v}return !1}function TS(e,t,n){e.focused||e.focus();var r=e.state.tr.setSelection(t);"pointer"==n&&r.setMeta("pointer",!0),e.dispatch(r);}function LS(e,t,n,r,i){return _S(e,"handleClickOn",t,n,r)||e.someProp("handleClick",(function(n){return n(e,t,r)}))||(i?function(e,t){if(-1==t)return !1;var n,r,i=e.state.selection;i instanceof yE.NodeSelection&&(n=i.node);for(var o=e.state.doc.resolve(t),s=o.depth+1;s>0;s--){var a=s>o.depth?o.nodeAfter:o.node(s);if(yE.NodeSelection.isSelectable(a)){r=n&&i.$from.depth>0&&s>=i.$from.depth&&o.before(i.$from.depth+1)==i.$from.pos?o.before(i.$from.depth):o.before(s);break}}return null!=r&&(TS(e,yE.NodeSelection.create(e.state.doc,r),"pointer"),!0)}(e,n):function(e,t){if(-1==t)return !1;var n=e.state.doc.resolve(t),r=n.nodeAfter;return !!(r&&r.isAtom&&yE.NodeSelection.isSelectable(r))&&(TS(e,new yE.NodeSelection(n),"pointer"),!0)}(e,n))}function RS(e,t,n,r){return _S(e,"handleDoubleClickOn",t,n,r)||e.someProp("handleDoubleClick",(function(n){return n(e,t,r)}))}function FS(e,t,n,r){return _S(e,"handleTripleClickOn",t,n,r)||e.someProp("handleTripleClick",(function(n){return n(e,t,r)}))||function(e,t,n){if(0!=n.button)return !1;var r=e.state.doc;if(-1==t)return !!r.inlineContent&&(TS(e,yE.TextSelection.create(r,0,r.content.size),"pointer"),!0);for(var i=r.resolve(t),o=i.depth+1;o>0;o--){var s=o>i.depth?i.nodeAfter:i.node(o),a=i.before(o);if(s.inlineContent)TS(e,yE.TextSelection.create(r,a+1,a+1+s.content.size),"pointer");else {if(!yE.NodeSelection.isSelectable(s))continue;TS(e,yE.NodeSelection.create(r,a),"pointer");}return !0}}(e,n,r)}function BS(e){return VS(e)}SS.keydown=function(e,t){var n=t;if(e.input.shiftKey=16==n.keyCode||n.shiftKey,!zS(e,n)&&(e.input.lastKeyCode=n.keyCode,e.input.lastKeyCodeTime=Date.now(),!BE||!_E||13!=n.keyCode))if(229!=n.keyCode&&e.domObserver.forceFlush(),!RE||13!=n.keyCode||n.ctrlKey||n.altKey||n.metaKey)e.someProp("handleKeyDown",(function(t){return t(e,n)}))||hS(e,n)?n.preventDefault():MS(e,"key");else {var r=Date.now();e.input.lastIOSEnter=r,e.input.lastIOSEnterFallbackTimeout=setTimeout((function(){e.input.lastIOSEnter==r&&(e.someProp("handleKeyDown",(function(t){return t(e,ZE(13,"Enter"))})),e.input.lastIOSEnter=0);}),200);}},SS.keyup=function(e,t){16==t.keyCode&&(e.input.shiftKey=!1);},SS.keypress=function(e,t){var n=t;if(!(zS(e,n)||!n.charCode||n.ctrlKey&&!n.altKey||FE&&n.metaKey))if(e.someProp("handleKeyPress",(function(t){return t(e,n)})))n.preventDefault();else {var r=e.state.selection;if(!(r instanceof yE.TextSelection&&r.$from.sameParent(r.$to))){var i=String.fromCharCode(n.charCode);e.someProp("handleTextInput",(function(t){return t(e,r.$from.pos,r.$to.pos,i)}))||e.dispatch(e.state.tr.insertText(i).scrollIntoView()),n.preventDefault();}}};var IS=FE?"metaKey":"ctrlKey";xS.mousedown=function(e,t){var n=t;e.input.shiftKey=n.shiftKey;var r=BS(e),i=Date.now(),o="singleClick";i-e.input.lastClick.time<500&&function(e,t){var n=t.x-e.clientX,r=t.y-e.clientY;return n*n+r*r<100}(n,e.input.lastClick)&&!n[IS]&&("singleClick"==e.input.lastClick.type?o="doubleClick":"doubleClick"==e.input.lastClick.type&&(o="tripleClick")),e.input.lastClick={time:i,x:n.clientX,y:n.clientY,type:o};var s=e.posAtCoords(NS(n));s&&("singleClick"==o?(e.input.mouseDown&&e.input.mouseDown.done(),e.input.mouseDown=new PS(e,s,n,!!r)):("doubleClick"==o?RS:FS)(e,s.pos,s.inside,n)?n.preventDefault():MS(e,"pointer"));};var PS=function(){function e(t,n,r,i){var o,s,a=this;if(mE(this,e),this.view=t,this.pos=n,this.event=r,this.flushed=i,this.delayedSelectionSync=!1,this.mightDrag=null,this.startDoc=t.state.doc,this.selectNode=!!r[IS],this.allowDefault=r.shiftKey,n.inside>-1)o=t.state.doc.nodeAt(n.inside),s=n.inside;else {var l=t.state.doc.resolve(n.pos);o=l.parent,s=l.depth?l.before():0;}var c=i?null:r.target,u=c?t.docView.nearestDesc(c,!0):null;this.target=u?u.dom:null;var d=t.state.selection;(0==r.button&&o.type.spec.draggable&&!1!==o.type.spec.selectable||d instanceof yE.NodeSelection&&d.from<=s&&d.to>s)&&(this.mightDrag={node:o,pos:s,addAttr:!(!this.target||this.target.draggable),setUneditable:!(!this.target||!AE||this.target.hasAttribute("contentEditable"))}),this.target&&this.mightDrag&&(this.mightDrag.addAttr||this.mightDrag.setUneditable)&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&(this.target.draggable=!0),this.mightDrag.setUneditable&&setTimeout((function(){a.view.input.mouseDown==a&&a.target.setAttribute("contentEditable","false");}),20),this.view.domObserver.start()),t.root.addEventListener("mouseup",this.up=this.up.bind(this)),t.root.addEventListener("mousemove",this.move=this.move.bind(this)),MS(t,"pointer");}return vE(e,[{key:"done",value:function(){var e=this;this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&&this.target&&(this.view.domObserver.stop(),this.mightDrag.addAttr&&this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&&this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&&setTimeout((function(){return Hx(e.view)})),this.view.input.mouseDown=null;}},{key:"up",value:function(e){if(this.done(),this.view.dom.contains(e.target)){var t=this.pos;this.view.state.doc!=this.startDoc&&(t=this.view.posAtCoords(NS(e))),this.allowDefault||!t?MS(this.view,"pointer"):LS(this.view,t.pos,t.inside,e,this.selectNode)?e.preventDefault():0==e.button&&(this.flushed||LE&&this.mightDrag&&!this.mightDrag.node.isAtom||_E&&!(this.view.state.selection instanceof yE.TextSelection)&&Math.min(Math.abs(t.pos-this.view.state.selection.from),Math.abs(t.pos-this.view.state.selection.to))<=2)?(TS(this.view,yE.Selection.near(this.view.state.doc.resolve(t.pos)),"pointer"),e.preventDefault()):MS(this.view,"pointer");}}},{key:"move",value:function(e){!this.allowDefault&&(Math.abs(this.event.x-e.clientX)>4||Math.abs(this.event.y-e.clientY)>4)&&(this.allowDefault=!0),MS(this.view,"pointer"),0==e.buttons&&this.done();}}]),e}();function zS(e,t){return !!e.composing||!!(LE&&Math.abs(t.timeStamp-e.input.compositionEndedAt)<500)&&(e.input.compositionEndedAt=-2e8,!0)}xS.touchdown=function(e){BS(e),MS(e,"pointer");},xS.contextmenu=function(e){return BS(e)};var $S=BE?5e3:-1;function jS(e,t){clearTimeout(e.input.composingTimeout),t>-1&&(e.input.composingTimeout=setTimeout((function(){return VS(e)}),t));}function HS(e){var t;for(e.composing&&(e.input.composing=!1,e.input.compositionEndedAt=((t=document.createEvent("Event")).initEvent("event",!0,!0),t.timeStamp));e.input.compositionNodes.length>0;)e.input.compositionNodes.pop().markParentsDirty();}function VS(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!(BE&&e.domObserver.flushingSoon>=0)){if(e.domObserver.forceFlush(),HS(e),t||e.docView&&e.docView.dirty){var n=$x(e);return n&&!n.eq(e.state.selection)?e.dispatch(e.state.tr.setSelection(n)):e.updateState(e.state),!0}return !1}}SS.compositionstart=SS.compositionupdate=function(e){if(!e.composing){e.domObserver.flush();var t=e.state,n=t.selection.$from;if(t.selection.empty&&(t.storedMarks||!n.textOffset&&n.parentOffset&&n.nodeBefore.marks.some((function(e){return !1===e.type.spec.inclusive}))))e.markCursor=e.state.storedMarks||n.marks(),VS(e,!0),e.markCursor=null;else if(VS(e),AE&&t.selection.empty&&n.parentOffset&&!n.textOffset&&n.nodeBefore.marks.length)for(var r=e.domSelection(),i=r.focusNode,o=r.focusOffset;i&&1==i.nodeType&&0!=o;){var s=o<0?i.lastChild:i.childNodes[o-1];if(!s)break;if(3==s.nodeType){r.collapse(s,s.nodeValue.length);break}i=s,o=-1;}e.input.composing=!0;}jS(e,$S);},SS.compositionend=function(e,t){e.composing&&(e.input.composing=!1,e.input.compositionEndedAt=t.timeStamp,jS(e,20));};var KS=ME&&OE<15||RE&&PE<604;function qS(e,t,n,r){var i=fS(e,t,n,e.input.shiftKey,e.state.selection.$from);if(e.someProp("handlePaste",(function(t){return t(e,r,i||bE.Slice.empty)})))return !0;if(!i)return !1;var o=function(e){return 0==e.openStart&&0==e.openEnd&&1==e.content.childCount?e.content.firstChild:null}(i),s=o?e.state.tr.replaceSelectionWith(o,e.input.shiftKey):e.state.tr.replaceSelection(i);return e.dispatch(s.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}xS.copy=SS.cut=function(e,t){var n=t,r=e.state.selection,i="cut"==n.type;if(!r.empty){var o=KS?null:n.clipboardData,s=pS(e,r.content()),a=s.dom,l=s.text;o?(n.preventDefault(),o.clearData(),o.setData("text/html",a.innerHTML),o.setData("text/plain",l)):function(e,t){if(e.dom.parentNode){var n=e.dom.parentNode.appendChild(document.createElement("div"));n.appendChild(t),n.style.cssText="position: fixed; left: -10000px; top: 10px";var r=getSelection(),i=document.createRange();i.selectNodeContents(t),e.dom.blur(),r.removeAllRanges(),r.addRange(i),setTimeout((function(){n.parentNode&&n.parentNode.removeChild(n),e.focus();}),50);}}(e,a),i&&e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"));}},SS.paste=function(e,t){var n=t;if(!e.composing||BE){var r=KS?null:n.clipboardData;r&&qS(e,r.getData("text/plain"),r.getData("text/html"),n)?n.preventDefault():function(e,t){if(e.dom.parentNode){var n=e.input.shiftKey||e.state.selection.$from.parent.type.spec.code,r=e.dom.parentNode.appendChild(document.createElement(n?"textarea":"div"));n||(r.contentEditable="true"),r.style.cssText="position: fixed; left: -10000px; top: 10px",r.focus(),setTimeout((function(){e.focus(),r.parentNode&&r.parentNode.removeChild(r),n?qS(e,r.value,null,t):qS(e,r.textContent,r.innerHTML,t);}),50);}}(e,n);}};var US=vE((function e(t,n){mE(this,e),this.slice=t,this.move=n;})),WS=FE?"altKey":"ctrlKey";for(var GS in xS.dragstart=function(e,t){var n=t,r=e.input.mouseDown;if(r&&r.done(),n.dataTransfer){var i=e.state.selection,o=i.empty?null:e.posAtCoords(NS(n));if(o&&o.pos>=i.from&&o.pos<=(i instanceof yE.NodeSelection?i.to-1:i.to));else if(r&&r.mightDrag)e.dispatch(e.state.tr.setSelection(yE.NodeSelection.create(e.state.doc,r.mightDrag.pos)));else if(n.target&&1==n.target.nodeType){var s=e.docView.nearestDesc(n.target,!0);s&&s.node.type.spec.draggable&&s!=e.docView&&e.dispatch(e.state.tr.setSelection(yE.NodeSelection.create(e.state.doc,s.posBefore)));}var a=e.state.selection.content(),l=pS(e,a),c=l.dom,u=l.text;n.dataTransfer.clearData(),n.dataTransfer.setData(KS?"Text":"text/html",c.innerHTML),n.dataTransfer.effectAllowed="copyMove",KS||n.dataTransfer.setData("text/plain",u),e.dragging=new US(a,!n[WS]);}},xS.dragend=function(e){var t=e.dragging;window.setTimeout((function(){e.dragging==t&&(e.dragging=null);}),50);},SS.dragover=SS.dragenter=function(e,t){return t.preventDefault()},SS.drop=function(e,t){var n=t,r=e.dragging;if(e.dragging=null,n.dataTransfer){var i=e.posAtCoords(NS(n));if(i){var o=e.state.doc.resolve(i.pos);if(o){var s=r&&r.slice;s?e.someProp("transformPasted",(function(e){s=e(s);})):s=fS(e,n.dataTransfer.getData(KS?"Text":"text/plain"),KS?null:n.dataTransfer.getData("text/html"),!1,o);var a=!(!r||n[WS]);if(e.someProp("handleDrop",(function(t){return t(e,n,s||bE.Slice.empty,a)})))n.preventDefault();else if(s){n.preventDefault();var l=s?wE.dropPoint(e.state.doc,o.pos,s):o.pos;null==l&&(l=o.pos);var c=e.state.tr;a&&c.deleteSelection();var u=c.mapping.map(l),d=0==s.openStart&&0==s.openEnd&&1==s.content.childCount,h=c.doc;if(d?c.replaceRangeWith(u,u,s.content.firstChild):c.replaceRange(u,u,s),!c.doc.eq(h)){var p=c.doc.resolve(u);if(d&&yE.NodeSelection.isSelectable(s.content.firstChild)&&p.nodeAfter&&p.nodeAfter.sameMarkup(s.content.firstChild))c.setSelection(new yE.NodeSelection(p));else {var f=c.mapping.map(l);c.mapping.maps[c.mapping.maps.length-1].forEach((function(e,t,n,r){return f=r})),c.setSelection(Xx(e,p,c.doc.resolve(f)));}e.focus(),e.dispatch(c.setMeta("uiEvent","drop"));}}}}}},xS.focus=function(e){e.focused||(e.domObserver.stop(),e.dom.classList.add("ProseMirror-focused"),e.domObserver.start(),e.focused=!0,setTimeout((function(){e.docView&&e.hasFocus()&&!e.domObserver.currentSelection.eq(e.domSelection())&&Hx(e);}),20));},xS.blur=function(e,t){var n=t;e.focused&&(e.domObserver.stop(),e.dom.classList.remove("ProseMirror-focused"),e.domObserver.start(),n.relatedTarget&&e.dom.contains(n.relatedTarget)&&e.domObserver.currentSelection.clear(),e.focused=!1);},xS.beforeinput=function(e,t){if(_E&&BE&&"deleteContentBackward"==t.inputType){e.domObserver.flushSoon();var n=e.input.domChangeCount;setTimeout((function(){if(e.input.domChangeCount==n&&(e.dom.blur(),e.focus(),!e.someProp("handleKeyDown",(function(t){return t(e,ZE(8,"Backspace"))})))){var t=e.state.selection.$cursor;t&&t.pos>0&&e.dispatch(e.state.tr.delete(t.pos-1,t.pos).scrollIntoView());}}),50);}},SS)xS[GS]=SS[GS];function JS(e,t){if(e==t)return !0;for(var n in e)if(e[n]!==t[n])return !1;for(var r in t)if(!(r in e))return !1;return !0}var ZS=function(){function e(t,n){mE(this,e),this.toDOM=t,this.spec=n||tD,this.side=this.spec.side||0;}return vE(e,[{key:"map",value:function(e,t,n,r){var i=e.mapResult(t.from+r,this.side<0?-1:1),o=i.pos;return i.deleted?null:new YS(o-n,o-n,this)}},{key:"valid",value:function(){return !0}},{key:"eq",value:function(t){return this==t||t instanceof e&&(this.spec.key&&this.spec.key==t.spec.key||this.toDOM==t.toDOM&&JS(this.spec,t.spec))}},{key:"destroy",value:function(e){this.spec.destroy&&this.spec.destroy(e);}}]),e}(),XS=function(){function e(t,n){mE(this,e),this.attrs=t,this.spec=n||tD;}return vE(e,[{key:"map",value:function(e,t,n,r){var i=e.map(t.from+r,this.spec.inclusiveStart?-1:1)-n,o=e.map(t.to+r,this.spec.inclusiveEnd?1:-1)-n;return i>=o?null:new YS(i,o,this)}},{key:"valid",value:function(e,t){return t.from<t.to}},{key:"eq",value:function(t){return this==t||t instanceof e&&JS(this.attrs,t.attrs)&&JS(this.spec,t.spec)}},{key:"destroy",value:function(){}}],[{key:"is",value:function(t){return t.type instanceof e}}]),e}(),QS=function(){function e(t,n){mE(this,e),this.attrs=t,this.spec=n||tD;}return vE(e,[{key:"map",value:function(e,t,n,r){var i=e.mapResult(t.from+r,1);if(i.deleted)return null;var o=e.mapResult(t.to+r,-1);return o.deleted||o.pos<=i.pos?null:new YS(i.pos-n,o.pos-n,this)}},{key:"valid",value:function(e,t){var n,r=e.content.findIndex(t.from),i=r.index,o=r.offset;return o==t.from&&!(n=e.child(i)).isText&&o+n.nodeSize==t.to}},{key:"eq",value:function(t){return this==t||t instanceof e&&JS(this.attrs,t.attrs)&&JS(this.spec,t.spec)}},{key:"destroy",value:function(){}}]),e}(),YS=function(){function e(t,n,r){mE(this,e),this.from=t,this.to=n,this.type=r;}return vE(e,[{key:"copy",value:function(t,n){return new e(t,n,this.type)}},{key:"eq",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.type.eq(e.type)&&this.from+t==e.from&&this.to+t==e.to}},{key:"map",value:function(e,t,n){return this.type.map(e,this,t,n)}},{key:"spec",get:function(){return this.type.spec}},{key:"inline",get:function(){return this.type instanceof XS}}],[{key:"widget",value:function(t,n,r){return new e(t,t,new ZS(n,r))}},{key:"inline",value:function(t,n,r,i){return new e(t,n,new XS(r,i))}},{key:"node",value:function(t,n,r,i){return new e(t,n,new QS(r,i))}}]),e}(),eD=[],tD={},nD=function(){function e(t,n){mE(this,e),this.local=t.length?t:eD,this.children=n.length?n:eD;}return vE(e,[{key:"find",value:function(e,t,n){var r=[];return this.findInner(null==e?0:e,null==t?1e9:t,r,0,n),r}},{key:"findInner",value:function(e,t,n,r,i){for(var o=0;o<this.local.length;o++){var s=this.local[o];s.from<=t&&s.to>=e&&(!i||i(s.spec))&&n.push(s.copy(s.from+r,s.to+r));}for(var a=0;a<this.children.length;a+=3)if(this.children[a]<t&&this.children[a+1]>e){var l=this.children[a]+1;this.children[a+2].findInner(e-l,t-l,n,r+l,i);}}},{key:"map",value:function(e,t,n){return this==rD||0==e.maps.length?this:this.mapInner(e,t,0,0,n||tD)}},{key:"mapInner",value:function(t,n,r,i,o){for(var s,a=0;a<this.local.length;a++){var l=this.local[a].map(t,r,i);l&&l.type.valid(n,l)?(s||(s=[])).push(l):o.onRemove&&o.onRemove(this.local[a].spec);}return this.children.length?oD(this.children,s||[],t,n,r,i,o):s?new e(s.sort(uD),eD):rD}},{key:"add",value:function(t,n){return n.length?this==rD?e.create(t,n):this.addInner(t,n,0):this}},{key:"addInner",value:function(t,n,r){var i,o=this,s=0;t.forEach((function(e,t){var a,l=t+r;if(a=aD(n,e,l)){for(i||(i=o.children.slice());s<i.length&&i[s]<t;)s+=3;i[s]==t?i[s+2]=i[s+2].addInner(e,a,l+1):i.splice(s,0,t,t+e.nodeSize,cD(a,e,l+1,tD)),s+=3;}}));for(var a=sD(s?lD(n):n,-r),l=0;l<a.length;l++)a[l].type.valid(t,a[l])||a.splice(l--,1);return new e(a.length?this.local.concat(a).sort(uD):this.local,i||this.children)}},{key:"remove",value:function(e){return 0==e.length||this==rD?this:this.removeInner(e,0)}},{key:"removeInner",value:function(t,n){for(var r=this.children,i=this.local,o=0;o<r.length;o+=3){for(var s,a=void 0,l=r[o]+n,c=r[o+1]+n,u=0;u<t.length;u++)(s=t[u])&&s.from>l&&s.to<c&&(t[u]=null,(a||(a=[])).push(s));if(a){r==this.children&&(r=this.children.slice());var d=r[o+2].removeInner(a,l+1);d!=rD?r[o+2]=d:(r.splice(o,3),o-=3);}}if(i.length)for(var h,p=0;p<t.length;p++)if(h=t[p])for(var f=0;f<i.length;f++)i[f].eq(h,n)&&(i==this.local&&(i=this.local.slice()),i.splice(f--,1));return r==this.children&&i==this.local?this:i.length||r.length?new e(i,r):rD}},{key:"forChild",value:function(t,n){if(this==rD)return this;if(n.isLeaf)return e.empty;for(var r,i,o=0;o<this.children.length;o+=3)if(this.children[o]>=t){this.children[o]==t&&(r=this.children[o+2]);break}for(var s=t+1,a=s+n.content.size,l=0;l<this.local.length;l++){var c=this.local[l];if(c.from<a&&c.to>s&&c.type instanceof XS){var u=Math.max(s,c.from)-s,d=Math.min(a,c.to)-s;u<d&&(i||(i=[])).push(c.copy(u,d));}}if(i){var h=new e(i.sort(uD),eD);return r?new iD([h,r]):h}return r||rD}},{key:"eq",value:function(t){if(this==t)return !0;if(!(t instanceof e)||this.local.length!=t.local.length||this.children.length!=t.children.length)return !1;for(var n=0;n<this.local.length;n++)if(!this.local[n].eq(t.local[n]))return !1;for(var r=0;r<this.children.length;r+=3)if(this.children[r]!=t.children[r]||this.children[r+1]!=t.children[r+1]||!this.children[r+2].eq(t.children[r+2]))return !1;return !0}},{key:"locals",value:function(e){return dD(this.localsInner(e))}},{key:"localsInner",value:function(e){if(this==rD)return eD;if(e.inlineContent||!this.local.some(XS.is))return this.local;for(var t=[],n=0;n<this.local.length;n++)this.local[n].type instanceof XS||t.push(this.local[n]);return t}}],[{key:"create",value:function(e,t){return t.length?cD(t,e,0,tD):rD}}]),e}();nD.empty=new nD([],[]),nD.removeOverlap=dD;var rD=nD.empty,iD=function(){function e(t){mE(this,e),this.members=t;}return vE(e,[{key:"map",value:function(t,n){var r=this.members.map((function(e){return e.map(t,n,tD)}));return e.from(r)}},{key:"forChild",value:function(t,n){if(n.isLeaf)return nD.empty;for(var r=[],i=0;i<this.members.length;i++){var o=this.members[i].forChild(t,n);o!=rD&&(o instanceof e?r=r.concat(o.members):r.push(o));}return e.from(r)}},{key:"eq",value:function(t){if(!(t instanceof e)||t.members.length!=this.members.length)return !1;for(var n=0;n<this.members.length;n++)if(!this.members[n].eq(t.members[n]))return !1;return !0}},{key:"locals",value:function(e){for(var t,n=!0,r=0;r<this.members.length;r++){var i=this.members[r].localsInner(e);if(i.length)if(t){n&&(t=t.slice(),n=!1);for(var o=0;o<i.length;o++)t.push(i[o]);}else t=i;}return t?dD(n?t:t.sort(uD)):eD}}],[{key:"from",value:function(t){switch(t.length){case 0:return rD;case 1:return t[0];default:return new e(t)}}}]),e}();function oD(e,t,n,r,i,o,s){for(var a=e.slice(),l=function(e,t,n,r){for(var s=0;s<a.length;s+=3){var l=a[s+1],c=void 0;if(!(l<0||e>l+o)){var u=a[s]+o;t>=u?a[s+1]=e<=u?-2:-1:n>=i&&(c=r-n-(t-e))&&(a[s]+=c,a[s+1]+=c);}}},c=0;c<n.maps.length;c++)n.maps[c].forEach(l);for(var u=!1,d=0;d<a.length;d+=3)if(a[d+1]<0){if(-2==a[d+1]){u=!0,a[d+1]=-1;continue}var h=n.map(e[d]+o),p=h-i;if(p<0||p>=r.content.size){u=!0;continue}var f=n.map(e[d+1]+o,-1)-i,m=r.content.findIndex(p),g=m.index,v=m.offset,y=r.maybeChild(g);if(y&&v==p&&v+y.nodeSize==f){var b=a[d+2].mapInner(n,y,h+1,e[d]+o+1,s);b!=rD?(a[d]=p,a[d+1]=f,a[d+2]=b):(a[d+1]=-2,u=!0);}else u=!0;}if(u){var w=function(e,t,n,r,i,o,s){function a(e,t){for(var o=0;o<e.local.length;o++){var l=e.local[o].map(r,i,t);l?n.push(l):s.onRemove&&s.onRemove(e.local[o].spec);}for(var c=0;c<e.children.length;c+=3)a(e.children[c+2],e.children[c]+t+1);}for(var l=0;l<e.length;l+=3)-1==e[l+1]&&a(e[l+2],t[l]+o+1);return n}(a,e,t,n,i,o,s),k=cD(w,r,0,s);t=k.local;for(var C=0;C<a.length;C+=3)a[C+1]<0&&(a.splice(C,3),C-=3);for(var E=0,x=0;E<k.children.length;E+=3){for(var S=k.children[E];x<a.length&&a[x]<S;)x+=3;a.splice(x,0,k.children[E],k.children[E+1],k.children[E+2]);}}return new nD(t.sort(uD),a)}function sD(e,t){if(!t||!e.length)return e;for(var n=[],r=0;r<e.length;r++){var i=e[r];n.push(new YS(i.from+t,i.to+t,i.type));}return n}function aD(e,t,n){if(t.isLeaf)return null;for(var r,i=n+t.nodeSize,o=null,s=0;s<e.length;s++)(r=e[s])&&r.from>n&&r.to<i&&((o||(o=[])).push(r),e[s]=null);return o}function lD(e){for(var t=[],n=0;n<e.length;n++)null!=e[n]&&t.push(e[n]);return t}function cD(e,t,n,r){var i=[],o=!1;t.forEach((function(t,s){var a=aD(e,t,s+n);if(a){o=!0;var l=cD(a,t,n+s+1,r);l!=rD&&i.push(s,s+t.nodeSize,l);}}));for(var s=sD(o?lD(e):e,-n).sort(uD),a=0;a<s.length;a++)s[a].type.valid(t,s[a])||(r.onRemove&&r.onRemove(s[a].spec),s.splice(a--,1));return s.length||i.length?new nD(s,i):rD}function uD(e,t){return e.from-t.from||e.to-t.to}function dD(e){for(var t=e,n=0;n<t.length-1;n++){var r=t[n];if(r.from!=r.to)for(var i=n+1;i<t.length;i++){var o=t[i];if(o.from!=r.from){o.from<r.to&&(t==e&&(t=e.slice()),t[n]=r.copy(r.from,o.from),hD(t,i,r.copy(o.from,r.to)));break}o.to!=r.to&&(t==e&&(t=e.slice()),t[i]=o.copy(o.from,r.to),hD(t,i+1,o.copy(r.to,o.to)));}}return t}function hD(e,t,n){for(;t<e.length&&uD(n,e[t])>0;)t++;e.splice(t,0,n);}function pD(e){var t=[];return e.someProp("decorations",(function(n){var r=n(e.state);r&&r!=rD&&t.push(r);})),e.cursorWrapper&&t.push(nD.create(e.state.doc,[e.cursorWrapper.deco])),iD.from(t)}var fD={childList:!0,characterData:!0,characterDataOldValue:!0,attributes:!0,attributeOldValue:!0,subtree:!0},mD=ME&&OE<=11,gD=function(){function e(){mE(this,e),this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0;}return vE(e,[{key:"set",value:function(e){this.anchorNode=e.anchorNode,this.anchorOffset=e.anchorOffset,this.focusNode=e.focusNode,this.focusOffset=e.focusOffset;}},{key:"clear",value:function(){this.anchorNode=this.focusNode=null;}},{key:"eq",value:function(e){return e.anchorNode==this.anchorNode&&e.anchorOffset==this.anchorOffset&&e.focusNode==this.focusNode&&e.focusOffset==this.focusOffset}}]),e}(),vD=function(){function e(t,n){var r=this;mE(this,e),this.view=t,this.handleDOMChange=n,this.queue=[],this.flushingSoon=-1,this.observer=null,this.currentSelection=new gD,this.onCharData=null,this.suppressingSelectionUpdates=!1,this.observer=window.MutationObserver&&new window.MutationObserver((function(e){for(var t=0;t<e.length;t++)r.queue.push(e[t]);ME&&OE<=11&&e.some((function(e){return "childList"==e.type&&e.removedNodes.length||"characterData"==e.type&&e.oldValue.length>e.target.nodeValue.length}))?r.flushSoon():r.flush();})),mD&&(this.onCharData=function(e){r.queue.push({target:e.target,type:"characterData",oldValue:e.prevValue}),r.flushSoon();}),this.onSelectionChange=this.onSelectionChange.bind(this);}return vE(e,[{key:"flushSoon",value:function(){var e=this;this.flushingSoon<0&&(this.flushingSoon=window.setTimeout((function(){e.flushingSoon=-1,e.flush();}),20));}},{key:"forceFlush",value:function(){this.flushingSoon>-1&&(window.clearTimeout(this.flushingSoon),this.flushingSoon=-1,this.flush());}},{key:"start",value:function(){this.observer&&this.observer.observe(this.view.dom,fD),this.onCharData&&this.view.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.connectSelection();}},{key:"stop",value:function(){var e=this;if(this.observer){var t=this.observer.takeRecords();if(t.length){for(var n=0;n<t.length;n++)this.queue.push(t[n]);window.setTimeout((function(){return e.flush()}),20);}this.observer.disconnect();}this.onCharData&&this.view.dom.removeEventListener("DOMCharacterDataModified",this.onCharData),this.disconnectSelection();}},{key:"connectSelection",value:function(){this.view.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange);}},{key:"disconnectSelection",value:function(){this.view.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange);}},{key:"suppressSelectionUpdates",value:function(){var e=this;this.suppressingSelectionUpdates=!0,setTimeout((function(){return e.suppressingSelectionUpdates=!1}),50);}},{key:"onSelectionChange",value:function(){if(Qx(this.view)){if(this.suppressingSelectionUpdates)return Hx(this.view);if(ME&&OE<=11&&!this.view.state.selection.empty){var e=this.view.domSelection();if(e.focusNode&&VE(e.focusNode,e.focusOffset,e.anchorNode,e.anchorOffset))return this.flushSoon()}this.flush();}}},{key:"setCurSelection",value:function(){this.currentSelection.set(this.view.domSelection());}},{key:"ignoreSelectionChange",value:function(e){if(0==e.rangeCount)return !0;var t=e.getRangeAt(0).commonAncestorContainer,n=this.view.docView.nearestDesc(t);return n&&n.ignoreMutation({type:"selection",target:3==t.nodeType?t.parentNode:t})?(this.setCurSelection(),!0):void 0}},{key:"flush",value:function(){if(this.view.docView&&!(this.flushingSoon>-1)){var e=this.observer?this.observer.takeRecords():[];this.queue.length&&(e=this.queue.concat(e),this.queue.length=0);var t=this.view.domSelection(),n=!this.suppressingSelectionUpdates&&!this.currentSelection.eq(t)&&Qx(this.view)&&!this.ignoreSelectionChange(t),r=-1,i=-1,o=!1,s=[];if(this.view.editable)for(var a=0;a<e.length;a++){var l=this.registerMutation(e[a],s);l&&(r=r<0?l.from:Math.min(l.from,r),i=i<0?l.to:Math.max(l.to,i),l.typeOver&&(o=!0));}if(AE&&s.length>1){var c=s.filter((function(e){return "BR"==e.nodeName}));if(2==c.length){var u=c[0],d=c[1];u.parentNode&&u.parentNode.parentNode==d.parentNode?d.remove():u.remove();}}(r>-1||n)&&(r>-1&&(this.view.docView.markDirty(r,i),function(e){if(yD)return;yD=!0,"normal"==getComputedStyle(e.dom).whiteSpace&&console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");}(this.view)),this.handleDOMChange(r,i,o,s),this.view.docView&&this.view.docView.dirty?this.view.updateState(this.view.state):this.currentSelection.eq(t)||Hx(this.view),this.currentSelection.set(t));}}},{key:"registerMutation",value:function(e,t){if(t.indexOf(e.target)>-1)return null;var n=this.view.docView.nearestDesc(e.target);if("attributes"==e.type&&(n==this.view.docView||"contenteditable"==e.attributeName||"style"==e.attributeName&&!e.oldValue&&!e.target.getAttribute("style")))return null;if(!n||n.ignoreMutation(e))return null;if("childList"==e.type){for(var r=0;r<e.addedNodes.length;r++)t.push(e.addedNodes[r]);if(n.contentDOM&&n.contentDOM!=n.dom&&!n.contentDOM.contains(e.target))return {from:n.posBefore,to:n.posAfter};var i=e.previousSibling,o=e.nextSibling;if(ME&&OE<=11&&e.addedNodes.length)for(var s=0;s<e.addedNodes.length;s++){var a=e.addedNodes[s],l=a.previousSibling,c=a.nextSibling;(!l||Array.prototype.indexOf.call(e.addedNodes,l)<0)&&(i=l),(!c||Array.prototype.indexOf.call(e.addedNodes,c)<0)&&(o=c);}var u=i&&i.parentNode==e.target?zE(i)+1:0,d=n.localPosFromDOM(e.target,u,-1),h=o&&o.parentNode==e.target?zE(o):e.target.childNodes.length;return {from:d,to:n.localPosFromDOM(e.target,h,1)}}return "attributes"==e.type?{from:n.posAtStart-n.border,to:n.posAtEnd+n.border}:{from:n.posAtStart,to:n.posAtEnd,typeOver:e.target.nodeValue==e.oldValue}}}]),e}(),yD=!1;function bD(e){var t=e.pmViewDesc;if(t)return t.parseRule();if("BR"==e.nodeName&&e.parentNode){if(LE&&/^(ul|ol)$/i.test(e.parentNode.nodeName)){var n=document.createElement("div");return n.appendChild(document.createElement("li")),{skip:n}}if(e.parentNode.lastChild==e||LE&&/^(tr|table)$/i.test(e.parentNode.nodeName))return {ignore:!0}}else if("IMG"==e.nodeName&&e.getAttribute("mark-placeholder"))return {ignore:!0};return null}function wD(e,t,n,r,i){if(t<0){var o=e.input.lastSelectionTime>Date.now()-50?e.input.lastSelectionOrigin:null,s=$x(e,o);if(s&&!e.state.selection.eq(s)){var a=e.state.tr.setSelection(s);"pointer"==o?a.setMeta("pointer",!0):"key"==o&&a.scrollIntoView(),e.dispatch(a);}}else {var l=e.state.doc.resolve(t),c=l.sharedDepth(n);t=l.before(c+1),n=e.state.doc.resolve(n).after(c+1);var u=e.state.selection,d=function(e,t,n){var r,i=e.docView.parseRange(t,n),o=i.node,s=i.fromOffset,a=i.toOffset,l=i.from,c=i.to,u=e.domSelection(),d=u.anchorNode;if(d&&e.dom.contains(1==d.nodeType?d:d.parentNode)&&(r=[{node:d,offset:u.anchorOffset}],JE(u)||r.push({node:u.focusNode,offset:u.focusOffset})),_E&&8===e.input.lastKeyCode)for(var h=a;h>s;h--){var p=o.childNodes[h-1],f=p.pmViewDesc;if("BR"==p.nodeName&&!f){a=h;break}if(!f||f.size)break}var m=e.state.doc,g=e.someProp("domParser")||bE.DOMParser.fromSchema(e.state.schema),v=m.resolve(l),y=null,b=g.parse(o,{topNode:v.parent,topMatch:v.parent.contentMatchAt(v.index()),topOpen:!0,from:s,to:a,preserveWhitespace:"pre"!=v.parent.type.whitespace||"full",findPositions:r,ruleFromNode:bD,context:v});if(r&&null!=r[0].pos){var w=r[0].pos,k=r[1]&&r[1].pos;null==k&&(k=w),y={anchor:w+l,head:k+l};}return {doc:b,sel:y,from:l,to:c}}(e,t,n);if(_E&&e.cursorWrapper&&d.sel&&d.sel.anchor==e.cursorWrapper.deco.from){var h=e.cursorWrapper.deco.type.toDOM.nextSibling,p=h&&h.nodeValue?h.nodeValue.length:1;d.sel={anchor:d.sel.anchor+p,head:d.sel.anchor+p};}var f,m,g=e.state.doc,v=g.slice(d.from,d.to);8===e.input.lastKeyCode&&Date.now()-100<e.input.lastKeyCodeTime?(f=e.state.selection.to,m="end"):(f=e.state.selection.from,m="start"),e.input.lastKeyCode=null;var y=function(e,t,n,r,i){var o=e.findDiffStart(t,n);if(null==o)return null;var s=e.findDiffEnd(t,n+e.size,n+t.size),a=s.a,l=s.b;if("end"==i){r-=a+Math.max(0,o-Math.min(a,l))-o;}if(a<o&&e.size<t.size){l=(o-=r<=o&&r>=a?o-r:0)+(l-a),a=o;}else if(l<o){a=(o-=r<=o&&r>=l?o-r:0)+(a-l),l=o;}return {start:o,endA:a,endB:l}}(v.content,d.doc.content,d.from,f,m);if((RE&&e.input.lastIOSEnter>Date.now()-225||BE)&&i.some((function(e){return "DIV"==e.nodeName||"P"==e.nodeName}))&&(!y||y.endA>=y.endB)&&e.someProp("handleKeyDown",(function(t){return t(e,ZE(13,"Enter"))})))e.input.lastIOSEnter=0;else {if(!y){if(!(r&&u instanceof yE.TextSelection&&!u.empty&&u.$head.sameParent(u.$anchor))||e.composing||d.sel&&d.sel.anchor!=d.sel.head){if(d.sel){var b=kD(e,e.state.doc,d.sel);b&&!b.eq(e.state.selection)&&e.dispatch(e.state.tr.setSelection(b));}return}y={start:u.from,endA:u.to,endB:u.to};}e.input.domChangeCount++,e.state.selection.from<e.state.selection.to&&y.start==y.endB&&e.state.selection instanceof yE.TextSelection&&(y.start>e.state.selection.from&&y.start<=e.state.selection.from+2&&e.state.selection.from>=d.from?y.start=e.state.selection.from:y.endA<e.state.selection.to&&y.endA>=e.state.selection.to-2&&e.state.selection.to<=d.to&&(y.endB+=e.state.selection.to-y.endA,y.endA=e.state.selection.to)),ME&&OE<=11&&y.endB==y.start+1&&y.endA==y.start&&y.start>d.from&&"  "==d.doc.textBetween(y.start-d.from-1,y.start-d.from+1)&&(y.start--,y.endA--,y.endB--);var w,k=d.doc.resolveNoCache(y.start-d.from),C=d.doc.resolveNoCache(y.endB-d.from),E=g.resolve(y.start),x=k.sameParent(C)&&k.parent.inlineContent&&E.end()>=y.endA;if((RE&&e.input.lastIOSEnter>Date.now()-225&&(!x||i.some((function(e){return "DIV"==e.nodeName||"P"==e.nodeName})))||!x&&k.pos<d.doc.content.size&&(w=yE.Selection.findFrom(d.doc.resolve(k.pos+1),1,!0))&&w.head==C.pos)&&e.someProp("handleKeyDown",(function(t){return t(e,ZE(13,"Enter"))})))e.input.lastIOSEnter=0;else if(e.state.selection.anchor>y.start&&function(e,t,n,r,i){if(!r.parent.isTextblock||n-t<=i.pos-r.pos||CD(r,!0,!1)<i.pos)return !1;var o=e.resolve(t);if(o.parentOffset<o.parent.content.size||!o.parent.isTextblock)return !1;var s=e.resolve(CD(o,!0,!0));return !(!s.parent.isTextblock||s.pos>n||CD(s,!0,!1)<n)&&r.parent.content.cut(r.parentOffset).eq(s.parent.content)}(g,y.start,y.endA,k,C)&&e.someProp("handleKeyDown",(function(t){return t(e,ZE(8,"Backspace"))})))BE&&_E&&e.domObserver.suppressSelectionUpdates();else {_E&&BE&&y.endB==y.start&&(e.input.lastAndroidDelete=Date.now()),BE&&!x&&k.start()!=C.start()&&0==C.parentOffset&&k.depth==C.depth&&d.sel&&d.sel.anchor==d.sel.head&&d.sel.head==y.endA&&(y.endB-=2,C=d.doc.resolveNoCache(y.endB-d.from),setTimeout((function(){e.someProp("handleKeyDown",(function(t){return t(e,ZE(13,"Enter"))}));}),20));var S,D,M,O=y.start,A=y.endA;if(x)if(k.pos==C.pos)ME&&OE<=11&&0==k.parentOffset&&(e.domObserver.suppressSelectionUpdates(),setTimeout((function(){return Hx(e)}),20)),S=e.state.tr.delete(O,A),D=g.resolve(y.start).marksAcross(g.resolve(y.endA));else if(y.endA==y.endB&&(M=function(e,t){for(var n,r,i,o=e.firstChild.marks,s=t.firstChild.marks,a=o,l=s,c=0;c<s.length;c++)a=s[c].removeFromSet(a);for(var u=0;u<o.length;u++)l=o[u].removeFromSet(l);if(1==a.length&&0==l.length)r=a[0],n="add",i=function(e){return e.mark(r.addToSet(e.marks))};else {if(0!=a.length||1!=l.length)return null;r=l[0],n="remove",i=function(e){return e.mark(r.removeFromSet(e.marks))};}for(var d=[],h=0;h<t.childCount;h++)d.push(i(t.child(h)));if(bE.Fragment.from(d).eq(e))return {mark:r,type:n}}(k.parent.content.cut(k.parentOffset,C.parentOffset),E.parent.content.cut(E.parentOffset,y.endA-E.start()))))S=e.state.tr,"add"==M.type?S.addMark(O,A,M.mark):S.removeMark(O,A,M.mark);else if(k.parent.child(k.index()).isText&&k.index()==C.index()-(C.textOffset?0:1)){var N=k.parent.textBetween(k.parentOffset,C.parentOffset);if(e.someProp("handleTextInput",(function(t){return t(e,O,A,N)})))return;S=e.state.tr.insertText(N,O,A);}if(S||(S=e.state.tr.replace(O,A,d.doc.slice(y.start-d.from,y.endB-d.from))),d.sel){var _=kD(e,S.doc,d.sel);_&&!(_E&&BE&&e.composing&&_.empty&&(y.start!=y.endB||e.input.lastAndroidDelete<Date.now()-100)&&(_.head==O||_.head==S.mapping.map(A)-1)||ME&&_.empty&&_.head==O)&&S.setSelection(_);}D&&S.ensureMarks(D),e.dispatch(S.scrollIntoView());}}}}function kD(e,t,n){return Math.max(n.anchor,n.head)>t.content.size?null:Xx(e,t.resolve(n.anchor),t.resolve(n.head))}function CD(e,t,n){for(var r=e.depth,i=t?e.end():e.pos;r>0&&(t||e.indexAfter(r)==e.node(r).childCount);)r--,i++,t=!1;if(n)for(var o=e.node(r).maybeChild(e.indexAfter(r));o&&!o.isLeaf;)o=o.firstChild,i++;return i}var ED=pS,xD=fS,SD=VS,DD=function(){function e(t,n){var r=this;mE(this,e),this._root=null,this.focused=!1,this.trackWrites=null,this.mounted=!1,this.markCursor=null,this.cursorWrapper=null,this.lastSelectedViewDesc=void 0,this.input=new DS,this.prevDirectPlugins=[],this.pluginViews=[],this.dragging=null,this._props=n,this.state=n.state,this.directPlugins=n.plugins||[],this.directPlugins.forEach(_D),this.dispatch=this.dispatch.bind(this),this.dom=t&&t.mount||document.createElement("div"),t&&(t.appendChild?t.appendChild(this.dom):"function"==typeof t?t(this.dom):t.mount&&(this.mounted=!0)),this.editable=AD(this),OD(this),this.nodeViews=ND(this),this.docView=xx(this.state.doc,MD(this),pD(this),this.dom,this),this.domObserver=new vD(this,(function(e,t,n,i){return wD(r,e,t,n,i)})),this.domObserver.start(),function(e){var t=function(t){var n=xS[t];e.dom.addEventListener(t,e.input.eventHandlers[t]=function(t){!function(e,t){if(!t.bubbles)return !0;if(t.defaultPrevented)return !1;for(var n=t.target;n!=e.dom;n=n.parentNode)if(!n||11==n.nodeType||n.pmViewDesc&&n.pmViewDesc.stopEvent(t))return !1;return !0}(e,t)||AS(e,t)||!e.editable&&t.type in SS||n(e,t);});};for(var n in xS)t(n);LE&&e.dom.addEventListener("input",(function(){return null})),OS(e);}(this),this.updatePluginViews();}return vE(e,[{key:"composing",get:function(){return this.input.composing}},{key:"props",get:function(){if(this._props.state!=this.state){var e=this._props;for(var t in this._props={},e)this._props[t]=e[t];this._props.state=this.state;}return this._props}},{key:"update",value:function(e){e.handleDOMEvents!=this._props.handleDOMEvents&&OS(this),this._props=e,e.plugins&&(e.plugins.forEach(_D),this.directPlugins=e.plugins),this.updateStateInner(e.state,!0);}},{key:"setProps",value:function(e){var t={};for(var n in this._props)t[n]=this._props[n];for(var r in t.state=this.state,e)t[r]=e[r];this.update(t);}},{key:"updateState",value:function(e){this.updateStateInner(e,this.state.plugins!=e.plugins);}},{key:"updateStateInner",value:function(e,t){var n=this,r=this.state,i=!1,o=!1;if(e.storedMarks&&this.composing&&(HS(this),o=!0),this.state=e,t){var s=ND(this);((function(e,t){var n=0,r=0;for(var i in e){if(e[i]!=t[i])return !0;n++;}for(var o in t)r++;return n!=r}))(s,this.nodeViews)&&(this.nodeViews=s,i=!0),OS(this);}this.editable=AD(this),OD(this);var a=pD(this),l=MD(this),c=t?"reset":e.scrollToSelection>r.scrollToSelection?"to selection":"preserve",u=i||!this.docView.matchesNode(e.doc,l,a);!u&&e.selection.eq(r.selection)||(o=!0);var d,h,p,f,m,g,v,y,b,w,k,C="preserve"==c&&o&&null==this.dom.style.overflowAnchor&&function(e){for(var t,n,r=e.dom.getBoundingClientRect(),i=Math.max(0,r.top),o=(r.left+r.right)/2,s=i+1;s<Math.min(innerHeight,r.bottom);s+=5){var a=e.root.elementFromPoint(o,s);if(a&&a!=e.dom&&e.dom.contains(a)){var l=a.getBoundingClientRect();if(l.top>=i-20){t=a,n=l.top;break}}}return {refDOM:t,refTop:n,stack:tx(e.dom)}}(this);if(o){this.domObserver.stop();var E=u&&(ME||_E)&&!this.composing&&!r.selection.empty&&!e.selection.empty&&(f=r.selection,m=e.selection,g=Math.min(f.$anchor.sharedDepth(f.head),m.$anchor.sharedDepth(m.head)),f.$anchor.start(g)!=m.$anchor.start(g));if(u){var x=_E?this.trackWrites=this.domSelection().focusNode:null;!i&&this.docView.update(e.doc,l,a,this)||(this.docView.updateOuterDeco([]),this.docView.destroy(),this.docView=xx(e.doc,l,a,this.dom,this)),x&&!this.trackWrites&&(E=!0);}E||!(this.input.mouseDown&&this.domObserver.currentSelection.eq(this.domSelection())&&(d=this,h=d.docView.domFromPos(d.state.selection.anchor,0),p=d.domSelection(),VE(h.node,h.offset,p.anchorNode,p.anchorOffset)))?Hx(this,E):(Jx(this,e.selection),this.domObserver.setCurSelection()),this.domObserver.start();}if(this.updatePluginViews(r),"reset"==c)this.dom.scrollTop=0;else if("to selection"==c){var S=this.domSelection().focusNode;if(this.someProp("handleScrollToSelection",(function(e){return e(n)})));else if(e.selection instanceof yE.NodeSelection){var D=this.docView.domAfterPos(e.selection.from);1==D.nodeType&&ex(this,D.getBoundingClientRect(),S);}else ex(this,this.coordsAtPos(e.selection.head,1),S);}else C&&(y=(v=C).refDOM,b=v.refTop,w=v.stack,k=y?y.getBoundingClientRect().top:0,nx(w,0==k?0:k-b));}},{key:"destroyPluginViews",value:function(){for(var e;e=this.pluginViews.pop();)e.destroy&&e.destroy();}},{key:"updatePluginViews",value:function(e){if(e&&e.plugins==this.state.plugins&&this.directPlugins==this.prevDirectPlugins)for(var t=0;t<this.pluginViews.length;t++){var n=this.pluginViews[t];n.update&&n.update(this,e);}else {this.prevDirectPlugins=this.directPlugins,this.destroyPluginViews();for(var r=0;r<this.directPlugins.length;r++){var i=this.directPlugins[r];i.spec.view&&this.pluginViews.push(i.spec.view(this));}for(var o=0;o<this.state.plugins.length;o++){var s=this.state.plugins[o];s.spec.view&&this.pluginViews.push(s.spec.view(this));}}}},{key:"someProp",value:function(e,t){var n,r=this._props&&this._props[e];if(null!=r&&(n=t?t(r):r))return n;for(var i=0;i<this.directPlugins.length;i++){var o=this.directPlugins[i].props[e];if(null!=o&&(n=t?t(o):o))return n}var s=this.state.plugins;if(s)for(var a=0;a<s.length;a++){var l=s[a].props[e];if(null!=l&&(n=t?t(l):l))return n}}},{key:"hasFocus",value:function(){return this.root.activeElement==this.dom}},{key:"focus",value:function(){this.domObserver.stop(),this.editable&&function(e){if(e.setActive)return e.setActive();if(rx)return e.focus(rx);var t=tx(e);e.focus(null==rx?{get preventScroll(){return rx={preventScroll:!0},!0}}:void 0),rx||(rx=!1,nx(t,0));}(this.dom),Hx(this),this.domObserver.start();}},{key:"root",get:function(){var e=this,t=this._root;if(null==t)for(var n=function(t){if(9==t.nodeType||11==t.nodeType&&t.host)return t.getSelection||(Object.getPrototypeOf(t).getSelection=function(){return t.ownerDocument.getSelection()}),{v:e._root=t}},r=this.dom.parentNode;r;r=r.parentNode){var i=n(r);if("object"===sE(i))return i.v}return t||document}},{key:"posAtCoords",value:function(e){return ax(this,e)}},{key:"coordsAtPos",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return ux(this,e,t)}},{key:"domAtPos",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.docView.domFromPos(e,t)}},{key:"nodeDOM",value:function(e){var t=this.docView.descAt(e);return t?t.nodeDOM:null}},{key:"posAtDOM",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,r=this.docView.posFromDOM(e,t,n);if(null==r)throw new RangeError("DOM position not inside the editor");return r}},{key:"endOfTextblock",value:function(e,t){return yx(this,t||this.state,e)}},{key:"destroy",value:function(){this.docView&&(!function(e){for(var t in e.domObserver.stop(),e.input.eventHandlers)e.dom.removeEventListener(t,e.input.eventHandlers[t]);clearTimeout(e.input.composingTimeout),clearTimeout(e.input.lastIOSEnterFallbackTimeout);}(this),this.destroyPluginViews(),this.mounted?(this.docView.update(this.state.doc,[],pD(this),this),this.dom.textContent=""):this.dom.parentNode&&this.dom.parentNode.removeChild(this.dom),this.docView.destroy(),this.docView=null);}},{key:"isDestroyed",get:function(){return null==this.docView}},{key:"dispatchEvent",value:function(e){return function(e,t){AS(e,t)||!xS[t.type]||!e.editable&&t.type in SS||xS[t.type](e,t);}(this,e)}},{key:"dispatch",value:function(e){var t=this._props.dispatchTransaction;t?t.call(this,e):this.updateState(this.state.apply(e));}},{key:"domSelection",value:function(){return this.root.getSelection()}}]),e}();function MD(e){var t=Object.create(null);return t.class="ProseMirror",t.contenteditable=String(e.editable),t.translate="no",e.someProp("attributes",(function(n){if("function"==typeof n&&(n=n(e.state)),n)for(var r in n)"class"==r&&(t.class+=" "+n[r]),"style"==r?t.style=(t.style?t.style+";":"")+n[r]:t[r]||"contenteditable"==r||"nodeName"==r||(t[r]=String(n[r]));})),[YS.node(0,e.state.doc.content.size,t)]}function OD(e){if(e.markCursor){var t=document.createElement("img");t.className="ProseMirror-separator",t.setAttribute("mark-placeholder","true"),t.setAttribute("alt",""),e.cursorWrapper={dom:t,deco:YS.widget(e.state.selection.head,t,{raw:!0,marks:e.markCursor})};}else e.cursorWrapper=null;}function AD(e){return !e.someProp("editable",(function(t){return !1===t(e.state)}))}function ND(e){var t=Object.create(null);function n(e){for(var n in e)Object.prototype.hasOwnProperty.call(t,n)||(t[n]=e[n]);}return e.someProp("nodeViews",n),e.someProp("markViews",n),t}function _D(e){if(e.spec.state||e.spec.filterTransaction||e.spec.appendTransaction)throw new RangeError("Plugins passed directly to the view must not have a state component")}oE.Decoration=YS,oE.DecorationSet=nD,oE.EditorView=DD,oE.__endComposition=SD,oE.__parseFromClipboard=xD,oE.__serializeForClipboard=ED;var TD={},LD={};Object.defineProperty(LD,"__esModule",{value:!0});for(var RD={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},FD={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},BD="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent),ID="undefined"!=typeof navigator&&/Apple Computer/.test(navigator.vendor),PD="undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent),zD="undefined"!=typeof navigator&&/Mac/.test(navigator.platform),$D="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),jD=BD&&(zD||+BD[1]<57)||PD&&zD,HD=0;HD<10;HD++)RD[48+HD]=RD[96+HD]=String(HD);for(HD=1;HD<=24;HD++)RD[HD+111]="F"+HD;for(HD=65;HD<=90;HD++)RD[HD]=String.fromCharCode(HD+32),FD[HD]=String.fromCharCode(HD);for(var VD in RD)FD.hasOwnProperty(VD)||(FD[VD]=RD[VD]);LD.base=RD,LD.keyName=function(e){var t=!(jD&&(e.ctrlKey||e.altKey||e.metaKey)||(ID||$D)&&e.shiftKey&&e.key&&1==e.key.length||"Unidentified"==e.key)&&e.key||(e.shiftKey?FD:RD)[e.keyCode]||e.key||"Unidentified";return "Esc"==t&&(t="Escape"),"Del"==t&&(t="Delete"),"Left"==t&&(t="ArrowLeft"),"Up"==t&&(t="ArrowUp"),"Right"==t&&(t="ArrowRight"),"Down"==t&&(t="ArrowDown"),t},LD.shift=FD,Object.defineProperty(TD,"__esModule",{value:!0});var KD=LD,qD=Gw,UD="undefined"!=typeof navigator&&/Mac|iP(hone|[oa]d)/.test(navigator.platform);function WD(e){var t,n,r,i,o=e.split(/-(?!$)/),s=o[o.length-1];"Space"==s&&(s=" ");for(var a=0;a<o.length-1;a++){var l=o[a];if(/^(cmd|meta|m)$/i.test(l))i=!0;else if(/^a(lt)?$/i.test(l))t=!0;else if(/^(c|ctrl|control)$/i.test(l))n=!0;else if(/^s(hift)?$/i.test(l))r=!0;else {if(!/^mod$/i.test(l))throw new Error("Unrecognized modifier name: "+l);UD?i=!0:n=!0;}}return t&&(s="Alt-"+s),n&&(s="Ctrl-"+s),i&&(s="Meta-"+s),r&&(s="Shift-"+s),s}function GD(e,t,n){return t.altKey&&(e="Alt-"+e),t.ctrlKey&&(e="Ctrl-"+e),t.metaKey&&(e="Meta-"+e),!1!==n&&t.shiftKey&&(e="Shift-"+e),e}function JD(e){var t=function(e){var t=Object.create(null);for(var n in e)t[WD(n)]=e[n];return t}(e);return function(e,n){var r,i=KD.keyName(n),o=1==i.length&&" "!=i,s=t[GD(i,n,!o)];if(s&&s(e.state,e.dispatch,e))return !0;if(o&&(n.shiftKey||n.altKey||n.metaKey||i.charCodeAt(0)>127)&&(r=KD.base[n.keyCode])&&r!=i){var a=t[GD(r,n,!0)];if(a&&a(e.state,e.dispatch,e))return !0}else if(o&&n.shiftKey){var l=t[GD(i,n,!0)];if(l&&l(e.state,e.dispatch,e))return !0}return !1}}TD.keydownHandler=JD,TD.keymap=function(e){return new qD.Plugin({props:{handleKeyDown:JD(e)}})},Object.defineProperty(iE,"__esModule",{value:!0});var ZD,XD,QD=Gw,YD=oE,eM=Jw,tM=wC,nM=TD;if("undefined"!=typeof WeakMap){var rM=new WeakMap;ZD=function(e){return rM.get(e)},XD=function(e,t){return rM.set(e,t),t};}else {var iM=[],oM=0;ZD=function(e){for(var t=0;t<iM.length;t+=2)if(iM[t]==e)return iM[t+1]},XD=function(e,t){return 10==oM&&(oM=0),iM[oM++]=e,iM[oM++]=t};}var sM=function(e,t,n,r){this.left=e,this.top=t,this.right=n,this.bottom=r;},aM=function(e,t,n,r){this.width=e,this.height=t,this.map=n,this.problems=r;};function lM(e){if(e.colwidth)return e.colwidth.slice();for(var t=[],n=0;n<e.colspan;n++)t.push(0);return t}aM.prototype.findCell=function(e){for(var t=this,n=0;n<this.map.length;n++){var r=t.map[n];if(r==e){for(var i=n%t.width,o=n/t.width|0,s=i+1,a=o+1,l=1;s<this.width&&this.map[n+l]==r;l++)s++;for(var c=1;a<this.height&&this.map[n+this.width*c]==r;c++)a++;return new sM(i,o,s,a)}}throw new RangeError("No cell with offset "+e+" found")},aM.prototype.colCount=function(e){for(var t=0;t<this.map.length;t++)if(this.map[t]==e)return t%this.width;throw new RangeError("No cell with offset "+e+" found")},aM.prototype.nextCell=function(e,t,n){var r=this.findCell(e),i=r.left,o=r.right,s=r.top,a=r.bottom;return "horiz"==t?(n<0?0==i:o==this.width)?null:this.map[s*this.width+(n<0?i-1:o)]:(n<0?0==s:a==this.height)?null:this.map[i+this.width*(n<0?s-1:a)]},aM.prototype.rectBetween=function(e,t){var n=this.findCell(e),r=n.left,i=n.right,o=n.top,s=n.bottom,a=this.findCell(t),l=a.left,c=a.right,u=a.top,d=a.bottom;return new sM(Math.min(r,l),Math.min(o,u),Math.max(i,c),Math.max(s,d))},aM.prototype.cellsInRect=function(e){for(var t=this,n=[],r={},i=e.top;i<e.bottom;i++)for(var o=e.left;o<e.right;o++){var s=i*t.width+o,a=t.map[s];r[a]||(r[a]=!0,o==e.left&&o&&t.map[s-1]==a||i==e.top&&i&&t.map[s-t.width]==a||n.push(a));}return n},aM.prototype.positionAt=function(e,t,n){for(var r=this,i=0,o=0;;i++){var s=o+n.child(i).nodeSize;if(i==e){for(var a=t+e*r.width,l=(e+1)*r.width;a<l&&this.map[a]<o;)a++;return a==l?s-1:r.map[a]}o=s;}},aM.get=function(e){return ZD(e)||XD(e,function(e){if("table"!=e.type.spec.tableRole)throw new RangeError("Not a table node: "+e.type.name);for(var t=function(e){for(var t=-1,n=!1,r=0;r<e.childCount;r++){var i=e.child(r),o=0;if(n)for(var s=0;s<r;s++)for(var a=e.child(s),l=0;l<a.childCount;l++){var c=a.child(l);s+c.attrs.rowspan>r&&(o+=c.attrs.colspan);}for(var u=0;u<i.childCount;u++){var d=i.child(u);o+=d.attrs.colspan,d.attrs.rowspan>1&&(n=!0);}-1==t?t=o:t!=o&&(t=Math.max(t,o));}return t}(e),n=e.childCount,r=[],i=0,o=null,s=[],a=0,l=t*n;a<l;a++)r[a]=0;for(var c=0,u=0;c<n;c++){var d=e.child(c);u++;for(var h=0;;h++){for(;i<r.length&&0!=r[i];)i++;if(h==d.childCount)break;for(var p=d.child(h),f=p.attrs,m=f.colspan,g=f.rowspan,v=f.colwidth,y=0;y<g;y++){if(y+c>=n){(o||(o=[])).push({type:"overlong_rowspan",pos:u,n:g-y});break}for(var b=i+y*t,w=0;w<m;w++){0==r[b+w]?r[b+w]=u:(o||(o=[])).push({type:"collision",row:c,pos:u,n:m-w});var k=v&&v[w];if(k){var C=(b+w)%t*2,E=s[C];null==E||E!=k&&1==s[C+1]?(s[C]=k,s[C+1]=1):E==k&&s[C+1]++;}}}i+=m,u+=p.nodeSize;}for(var x=(c+1)*t,S=0;i<x;)0==r[i++]&&S++;S&&(o||(o=[])).push({type:"missing",row:c,n:S}),u++;}for(var D=new aM(t,n,r,o),M=!1,O=0;!M&&O<s.length;O+=2)null!=s[O]&&s[O+1]<n&&(M=!0);M&&function(e,t,n){e.problems||(e.problems=[]);for(var r=0,i={};r<e.map.length;r++){var o=e.map[r];if(!i[o]){i[o]=!0;for(var s=n.nodeAt(o),a=null,l=0;l<s.attrs.colspan;l++){var c=t[2*((r+l)%e.width)];null==c||s.attrs.colwidth&&s.attrs.colwidth[l]==c||((a||(a=lM(s.attrs)))[l]=c);}a&&e.problems.unshift({type:"colwidth mismatch",pos:o,colwidth:a});}}}(D,s,e);return D}(e))};var cM=new QD.PluginKey("selectingCells");function uM(e){for(var t=e.depth-1;t>0;t--)if("row"==e.node(t).type.spec.tableRole)return e.node(0).resolve(e.before(t+1));return null}function dM(e){for(var t=e.selection.$head,n=t.depth;n>0;n--)if("row"==t.node(n).type.spec.tableRole)return !0;return !1}function hM(e){var t=e.selection;return t.$anchorCell?t.$anchorCell.pos>t.$headCell.pos?t.$anchorCell:t.$headCell:t.node&&"cell"==t.node.type.spec.tableRole?t.$anchor:uM(t.$head)||function(e){for(var t=e.nodeAfter,n=e.pos;t;t=t.firstChild,n++){var r=t.type.spec.tableRole;if("cell"==r||"header_cell"==r)return e.doc.resolve(n)}for(var i=e.nodeBefore,o=e.pos;i;i=i.lastChild,o--){var s=i.type.spec.tableRole;if("cell"==s||"header_cell"==s)return e.doc.resolve(o-i.nodeSize)}}(t.$head)}function pM(e){return "row"==e.parent.type.spec.tableRole&&e.nodeAfter}function fM(e){return e.node(0).resolve(e.pos+e.nodeAfter.nodeSize)}function mM(e,t){return e.depth==t.depth&&e.pos>=t.start(-1)&&e.pos<=t.end(-1)}function gM(e,t,n){var r=e.start(-1),i=aM.get(e.node(-1)).nextCell(e.pos-r,t,n);return null==i?null:e.node(0).resolve(r+i)}function vM(e,t,n){var r={};for(var i in e)r[i]=e[i];return r[t]=n,r}function yM(e,t,n){void 0===n&&(n=1);var r=vM(e,"colspan",e.colspan-n);return r.colwidth&&(r.colwidth=r.colwidth.slice(),r.colwidth.splice(t,n),r.colwidth.some((function(e){return e>0}))||(r.colwidth=null)),r}function bM(e,t,n){void 0===n&&(n=1);var r=vM(e,"colspan",e.colspan+n);if(r.colwidth){r.colwidth=r.colwidth.slice();for(var i=0;i<n;i++)r.colwidth.splice(t,0,0);}return r}var wM=function(e){function t(t,n){void 0===n&&(n=t);var r=t.node(-1),i=aM.get(r),o=t.start(-1),s=i.rectBetween(t.pos-o,n.pos-o),a=t.node(0),l=i.cellsInRect(s).filter((function(e){return e!=n.pos-o}));l.unshift(n.pos-o);var c=l.map((function(e){var t=r.nodeAt(e),n=e+o+1;return new QD.SelectionRange(a.resolve(n),a.resolve(n+t.content.size))}));e.call(this,c[0].$from,c[0].$to,c),this.$anchorCell=t,this.$headCell=n;}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.map=function(e,n){var r=e.resolve(n.map(this.$anchorCell.pos)),i=e.resolve(n.map(this.$headCell.pos));if(pM(r)&&pM(i)&&mM(r,i)){var o=this.$anchorCell.node(-1)!=r.node(-1);return o&&this.isRowSelection()?t.rowSelection(r,i):o&&this.isColSelection()?t.colSelection(r,i):new t(r,i)}return QD.TextSelection.between(r,i)},t.prototype.content=function(){for(var e=this.$anchorCell.node(-1),t=aM.get(e),n=this.$anchorCell.start(-1),r=t.rectBetween(this.$anchorCell.pos-n,this.$headCell.pos-n),i={},o=[],s=r.top;s<r.bottom;s++){for(var a=[],l=s*t.width+r.left,c=r.left;c<r.right;c++,l++){var u=t.map[l];if(!i[u]){i[u]=!0;var d=t.findCell(u),h=e.nodeAt(u),p=r.left-d.left,f=d.right-r.right;if(p>0||f>0){var m=h.attrs;p>0&&(m=yM(m,0,p)),f>0&&(m=yM(m,m.colspan-f,f)),h=d.left<r.left?h.type.createAndFill(m):h.type.create(m,h.content);}if(d.top<r.top||d.bottom>r.bottom){var g=vM(h.attrs,"rowspan",Math.min(d.bottom,r.bottom)-Math.max(d.top,r.top));h=d.top<r.top?h.type.createAndFill(g):h.type.create(g,h.content);}a.push(h);}}o.push(e.child(s).copy(eM.Fragment.from(a)));}var v=this.isColSelection()&&this.isRowSelection()?e:o;return new eM.Slice(eM.Fragment.from(v),1,1)},t.prototype.replace=function(t,n){void 0===n&&(n=eM.Slice.empty);for(var r=t.steps.length,i=this.ranges,o=0;o<i.length;o++){var s=i[o],a=s.$from,l=s.$to,c=t.mapping.slice(r);t.replace(c.map(a.pos),c.map(l.pos),o?eM.Slice.empty:n);}var u=e.findFrom(t.doc.resolve(t.mapping.slice(r).map(this.to)),-1);u&&t.setSelection(u);},t.prototype.replaceWith=function(e,t){this.replace(e,new eM.Slice(eM.Fragment.from(t),0,0));},t.prototype.forEachCell=function(e){for(var t=this.$anchorCell.node(-1),n=aM.get(t),r=this.$anchorCell.start(-1),i=n.cellsInRect(n.rectBetween(this.$anchorCell.pos-r,this.$headCell.pos-r)),o=0;o<i.length;o++)e(t.nodeAt(i[o]),r+i[o]);},t.prototype.isColSelection=function(){var e=this.$anchorCell.index(-1),t=this.$headCell.index(-1);if(Math.min(e,t)>0)return !1;var n=e+this.$anchorCell.nodeAfter.attrs.rowspan,r=t+this.$headCell.nodeAfter.attrs.rowspan;return Math.max(n,r)==this.$headCell.node(-1).childCount},t.colSelection=function(e,n){void 0===n&&(n=e);var r=aM.get(e.node(-1)),i=e.start(-1),o=r.findCell(e.pos-i),s=r.findCell(n.pos-i),a=e.node(0);return o.top<=s.top?(o.top>0&&(e=a.resolve(i+r.map[o.left])),s.bottom<r.height&&(n=a.resolve(i+r.map[r.width*(r.height-1)+s.right-1]))):(s.top>0&&(n=a.resolve(i+r.map[s.left])),o.bottom<r.height&&(e=a.resolve(i+r.map[r.width*(r.height-1)+o.right-1]))),new t(e,n)},t.prototype.isRowSelection=function(){var e=aM.get(this.$anchorCell.node(-1)),t=this.$anchorCell.start(-1),n=e.colCount(this.$anchorCell.pos-t),r=e.colCount(this.$headCell.pos-t);if(Math.min(n,r)>0)return !1;var i=n+this.$anchorCell.nodeAfter.attrs.colspan,o=r+this.$headCell.nodeAfter.attrs.colspan;return Math.max(i,o)==e.width},t.prototype.eq=function(e){return e instanceof t&&e.$anchorCell.pos==this.$anchorCell.pos&&e.$headCell.pos==this.$headCell.pos},t.rowSelection=function(e,n){void 0===n&&(n=e);var r=aM.get(e.node(-1)),i=e.start(-1),o=r.findCell(e.pos-i),s=r.findCell(n.pos-i),a=e.node(0);return o.left<=s.left?(o.left>0&&(e=a.resolve(i+r.map[o.top*r.width])),s.right<r.width&&(n=a.resolve(i+r.map[r.width*(s.top+1)-1]))):(s.left>0&&(n=a.resolve(i+r.map[s.top*r.width])),o.right<r.width&&(e=a.resolve(i+r.map[r.width*(o.top+1)-1]))),new t(e,n)},t.prototype.toJSON=function(){return {type:"cell",anchor:this.$anchorCell.pos,head:this.$headCell.pos}},t.fromJSON=function(e,n){return new t(e.resolve(n.anchor),e.resolve(n.head))},t.create=function(e,n,r){return void 0===r&&(r=n),new t(e.resolve(n),e.resolve(r))},t.prototype.getBookmark=function(){return new kM(this.$anchorCell.pos,this.$headCell.pos)},t}(QD.Selection);wM.prototype.visible=!1,QD.Selection.jsonID("cell",wM);var kM=function(e,t){this.anchor=e,this.head=t;};function CM(e){if(!(e.selection instanceof wM))return null;var t=[];return e.selection.forEachCell((function(e,n){t.push(YD.Decoration.node(n,n+e.nodeSize,{class:"selectedCell"}));})),YD.DecorationSet.create(e.doc,t)}function EM(e,t){var n=e.getAttribute("data-colwidth"),r=n&&/^\d+(,\d+)*$/.test(n)?n.split(",").map((function(e){return Number(e)})):null,i=Number(e.getAttribute("colspan")||1),o={colspan:i,rowspan:Number(e.getAttribute("rowspan")||1),colwidth:r&&r.length==i?r:null};for(var s in t){var a=t[s].getFromDOM,l=a&&a(e);null!=l&&(o[s]=l);}return o}function xM(e,t){var n={};for(var r in 1!=e.attrs.colspan&&(n.colspan=e.attrs.colspan),1!=e.attrs.rowspan&&(n.rowspan=e.attrs.rowspan),e.attrs.colwidth&&(n["data-colwidth"]=e.attrs.colwidth.join(",")),t){var i=t[r].setDOMAttr;i&&i(e.attrs[r],n);}return n}function SM(e){var t=e.cached.tableNodeTypes;if(!t)for(var n in t=e.cached.tableNodeTypes={},e.nodes){var r=e.nodes[n],i=r.spec.tableRole;i&&(t[i]=r);}return t}function DM(e){if(!e.size)return null;for(var t=e.content,n=e.openStart,r=e.openEnd;1==t.childCount&&(n>0&&r>0||"table"==t.firstChild.type.spec.tableRole);)n--,r--,t=t.firstChild.content;var i=t.firstChild,o=i.type.spec.tableRole,s=i.type.schema,a=[];if("row"==o)for(var l=0;l<t.childCount;l++){var c=t.child(l).content,u=l?0:Math.max(0,n-1),d=l<t.childCount-1?0:Math.max(0,r-1);(u||d)&&(c=MM(SM(s).row,new eM.Slice(c,u,d)).content),a.push(c);}else {if("cell"!=o&&"header_cell"!=o)return null;a.push(n||r?MM(SM(s).row,new eM.Slice(t,n,r)).content:t);}return function(e,t){for(var n=[],r=0;r<t.length;r++)for(var i=t[r],o=i.childCount-1;o>=0;o--)for(var s=i.child(o).attrs,a=s.rowspan,l=s.colspan,c=r;c<r+a;c++)n[c]=(n[c]||0)+l;for(var u=0,d=0;d<n.length;d++)u=Math.max(u,n[d]);for(var h=0;h<n.length;h++)if(h>=t.length&&t.push(eM.Fragment.empty),n[h]<u){for(var p=SM(e).cell.createAndFill(),f=[],m=n[h];m<u;m++)f.push(p);t[h]=t[h].append(eM.Fragment.from(f));}return {height:t.length,width:u,rows:t}}(s,a)}function MM(e,t){var n=e.createAndFill();return new tM.Transform(n).replace(0,n.content.size,t).doc}function OM(e,t,n){var r=e.width,i=e.height,o=e.rows;if(r!=t){for(var s=[],a=[],l=0;l<o.length;l++){for(var c=o[l],u=[],d=s[l]||0,h=0;d<t;h++){var p=c.child(h%c.childCount);d+p.attrs.colspan>t&&(p=p.type.create(yM(p.attrs,p.attrs.colspan,d+p.attrs.colspan-t),p.content)),u.push(p),d+=p.attrs.colspan;for(var f=1;f<p.attrs.rowspan;f++)s[l+f]=(s[l+f]||0)+p.attrs.colspan;}a.push(eM.Fragment.from(u));}o=a,r=t;}if(i!=n){for(var m=[],g=0,v=0;g<n;g++,v++){for(var y=[],b=o[v%i],w=0;w<b.childCount;w++){var k=b.child(w);g+k.attrs.rowspan>n&&(k=k.type.create(vM(k.attrs,"rowspan",n-k.attrs.rowspan),k.content)),y.push(k);}m.push(eM.Fragment.from(y));}o=m,i=n;}return {width:r,height:i,rows:o}}function AM(e,t,n,r,i,o,s,a){if(0==s||s==t.height)return !1;for(var l=!1,c=i;c<o;c++){var u=s*t.width+c,d=t.map[u];if(t.map[u-t.width]==d){l=!0;var h=n.nodeAt(d),p=t.findCell(d),f=p.top,m=p.left;e.setNodeMarkup(e.mapping.slice(a).map(d+r),null,vM(h.attrs,"rowspan",s-f)),e.insert(e.mapping.slice(a).map(t.positionAt(s,m,n)),h.type.createAndFill(vM(h.attrs,"rowspan",f+h.attrs.rowspan-s))),c+=h.attrs.colspan-1;}}return l}function NM(e,t,n,r,i,o,s,a){if(0==s||s==t.width)return !1;for(var l=!1,c=i;c<o;c++){var u=c*t.width+s,d=t.map[u];if(t.map[u-1]==d){l=!0;var h=n.nodeAt(d),p=t.colCount(d),f=e.mapping.slice(a).map(d+r);e.setNodeMarkup(f,null,yM(h.attrs,s-p,h.attrs.colspan-(s-p))),e.insert(f+h.nodeSize,h.type.createAndFill(yM(h.attrs,0,s-p))),c+=h.attrs.rowspan-1;}}return l}function _M(e,t,n,r,i){var o=n?e.doc.nodeAt(n-1):e.doc,s=aM.get(o),a=r.top,l=r.left,c=l+i.width,u=a+i.height,d=e.tr,h=0;function p(){o=n?d.doc.nodeAt(n-1):d.doc,s=aM.get(o),h=d.mapping.maps.length;}((function(e,t,n,r,i,o,s){var a,l,c=SM(e.doc.type.schema);if(i>t.width)for(var u=0,d=0;u<t.height;u++){var h=n.child(u);d+=h.nodeSize;var p=[],f=void 0;f=null==h.lastChild||h.lastChild.type==c.cell?a||(a=c.cell.createAndFill()):l||(l=c.header_cell.createAndFill());for(var m=t.width;m<i;m++)p.push(f);e.insert(e.mapping.slice(s).map(d-1+r),p);}if(o>t.height){for(var g=[],v=0,y=(t.height-1)*t.width;v<Math.max(t.width,i);v++){var b=!(v>=t.width)&&n.nodeAt(t.map[y+v]).type==c.header_cell;g.push(b?l||(l=c.header_cell.createAndFill()):a||(a=c.cell.createAndFill()));}for(var w=c.row.create(null,eM.Fragment.from(g)),k=[],C=t.height;C<o;C++)k.push(w);e.insert(e.mapping.slice(s).map(r+n.nodeSize-2),k);}return !(!a&&!l)}))(d,s,o,n,c,u,h)&&p(),AM(d,s,o,n,l,c,a,h)&&p(),AM(d,s,o,n,l,c,u,h)&&p(),NM(d,s,o,n,a,u,l,h)&&p(),NM(d,s,o,n,a,u,c,h)&&p();for(var f=a;f<u;f++){var m=s.positionAt(f,l,o),g=s.positionAt(f,c,o);d.replace(d.mapping.slice(h).map(m+n),d.mapping.slice(h).map(g+n),new eM.Slice(i.rows[f-a],0,0));}p(),d.setSelection(new wM(d.doc.resolve(n+s.positionAt(a,l,o)),d.doc.resolve(n+s.positionAt(u-1,c-1,o)))),t(d);}kM.prototype.map=function(e){return new kM(e.map(this.anchor),e.map(this.head))},kM.prototype.resolve=function(e){var t=e.resolve(this.anchor),n=e.resolve(this.head);return "row"==t.parent.type.spec.tableRole&&"row"==n.parent.type.spec.tableRole&&t.index()<t.parent.childCount&&n.index()<n.parent.childCount&&mM(t,n)?new wM(t,n):QD.Selection.near(n,1)};var TM=nM.keydownHandler({ArrowLeft:RM("horiz",-1),ArrowRight:RM("horiz",1),ArrowUp:RM("vert",-1),ArrowDown:RM("vert",1),"Shift-ArrowLeft":FM("horiz",-1),"Shift-ArrowRight":FM("horiz",1),"Shift-ArrowUp":FM("vert",-1),"Shift-ArrowDown":FM("vert",1),Backspace:BM,"Mod-Backspace":BM,Delete:BM,"Mod-Delete":BM});function LM(e,t,n){return !n.eq(e.selection)&&(t&&t(e.tr.setSelection(n).scrollIntoView()),!0)}function RM(e,t){return function(n,r,i){var o=n.selection;if(o instanceof wM)return LM(n,r,QD.Selection.near(o.$headCell,t));if("horiz"!=e&&!o.empty)return !1;var s=$M(i,e,t);if(null==s)return !1;if("horiz"==e)return LM(n,r,QD.Selection.near(n.doc.resolve(o.head+t),t));var a,l=n.doc.resolve(s),c=gM(l,e,t);return a=c?QD.Selection.near(c,1):t<0?QD.Selection.near(n.doc.resolve(l.before(-1)),-1):QD.Selection.near(n.doc.resolve(l.after(-1)),1),LM(n,r,a)}}function FM(e,t){return function(n,r,i){var o=n.selection;if(!(o instanceof wM)){var s=$M(i,e,t);if(null==s)return !1;o=new wM(n.doc.resolve(s));}var a=gM(o.$headCell,e,t);return !!a&&LM(n,r,new wM(o.$anchorCell,a))}}function BM(e,t){var n=e.selection;if(!(n instanceof wM))return !1;if(t){var r=e.tr,i=SM(e.schema).cell.createAndFill().content;n.forEachCell((function(e,t){e.content.eq(i)||r.replace(r.mapping.map(t+1),r.mapping.map(t+e.nodeSize-1),new eM.Slice(i,0,0));})),r.docChanged&&t(r);}return !0}function IM(e,t){var n=uM(e.state.doc.resolve(t));return !!n&&(e.dispatch(e.state.tr.setSelection(new wM(n))),!0)}function PM(e,t,n){if(!dM(e.state))return !1;var r=DM(n),i=e.state.selection;if(i instanceof wM){r||(r={width:1,height:1,rows:[eM.Fragment.from(MM(SM(e.state.schema).cell,n))]});var o=i.$anchorCell.node(-1),s=i.$anchorCell.start(-1),a=aM.get(o).rectBetween(i.$anchorCell.pos-s,i.$headCell.pos-s);return r=OM(r,a.right-a.left,a.bottom-a.top),_M(e.state,e.dispatch,s,a,r),!0}if(r){var l=hM(e.state),c=l.start(-1);return _M(e.state,e.dispatch,c,aM.get(l.node(-1)).findCell(l.pos-c),r),!0}return !1}function zM(e,t){if(!t.ctrlKey&&!t.metaKey){var n,r=jM(e,t.target);if(t.shiftKey&&e.state.selection instanceof wM)i(e.state.selection.$anchorCell,t),t.preventDefault();else if(t.shiftKey&&r&&null!=(n=uM(e.state.selection.$anchor))&&HM(e,t).pos!=n.pos)i(n,t),t.preventDefault();else if(!r)return;e.root.addEventListener("mouseup",o),e.root.addEventListener("dragstart",o),e.root.addEventListener("mousemove",s);}function i(t,n){var r=HM(e,n),i=null==cM.getState(e.state);if(!r||!mM(t,r)){if(!i)return;r=t;}var o=new wM(t,r);if(i||!e.state.selection.eq(o)){var s=e.state.tr.setSelection(o);i&&s.setMeta(cM,t.pos),e.dispatch(s);}}function o(){e.root.removeEventListener("mouseup",o),e.root.removeEventListener("dragstart",o),e.root.removeEventListener("mousemove",s),null!=cM.getState(e.state)&&e.dispatch(e.state.tr.setMeta(cM,-1));}function s(n){var s,a=cM.getState(e.state);if(null!=a)s=e.state.doc.resolve(a);else if(jM(e,n.target)!=r&&!(s=HM(e,t)))return o();s&&i(s,n);}}function $M(e,t,n){if(!(e.state.selection instanceof QD.TextSelection))return null;for(var r=e.state.selection.$head,i=r.depth-1;i>=0;i--){var o=r.node(i);if((n<0?r.index(i):r.indexAfter(i))!=(n<0?0:o.childCount))return null;if("cell"==o.type.spec.tableRole||"header_cell"==o.type.spec.tableRole){var s=r.before(i),a="vert"==t?n>0?"down":"up":n>0?"right":"left";return e.endOfTextblock(a)?s:null}}return null}function jM(e,t){for(;t&&t!=e.dom;t=t.parentNode)if("TD"==t.nodeName||"TH"==t.nodeName)return t}function HM(e,t){var n=e.posAtCoords({left:t.clientX,top:t.clientY});return n&&n?uM(e.state.doc.resolve(n.pos)):null}var VM=new QD.PluginKey("fix-tables");function KM(e,t,n,r){var i=e.childCount,o=t.childCount;e:for(var s=0,a=0;s<o;s++){for(var l=t.child(s),c=a,u=Math.min(i,s+3);c<u;c++)if(e.child(c)==l){a=c+1,n+=l.nodeSize;continue e}r(l,n),a<i&&e.child(a).sameMarkup(l)?KM(e.child(a),l,n+1,r):l.nodesBetween(0,l.content.size,r,n+1),n+=l.nodeSize;}}function qM(e,t){var n,r=function(t,r){"table"==t.type.spec.tableRole&&(n=function(e,t,n,r){var i=aM.get(t);if(!i.problems)return r;r||(r=e.tr);for(var o,s,a=[],l=0;l<i.height;l++)a.push(0);for(var c=0;c<i.problems.length;c++){var u=i.problems[c];if("collision"==u.type){for(var d=t.nodeAt(u.pos),h=0;h<d.attrs.rowspan;h++)a[u.row+h]+=u.n;r.setNodeMarkup(r.mapping.map(n+1+u.pos),null,yM(d.attrs,d.attrs.colspan-u.n,u.n));}else if("missing"==u.type)a[u.row]+=u.n;else if("overlong_rowspan"==u.type){var p=t.nodeAt(u.pos);r.setNodeMarkup(r.mapping.map(n+1+u.pos),null,vM(p.attrs,"rowspan",p.attrs.rowspan-u.n));}else if("colwidth mismatch"==u.type){var f=t.nodeAt(u.pos);r.setNodeMarkup(r.mapping.map(n+1+u.pos),null,vM(f.attrs,"colwidth",u.colwidth));}}for(var m=0;m<a.length;m++)a[m]&&(null==o&&(o=m),s=m);for(var g=0,v=n+1;g<i.height;g++){var y=t.child(g),b=v+y.nodeSize,w=a[g];if(w>0){var k="cell";y.firstChild&&(k=y.firstChild.type.spec.tableRole);for(var C=[],E=0;E<w;E++)C.push(SM(e.schema)[k].createAndFill());var x=0!=g&&o!=g-1||s!=g?b-1:v+1;r.insert(r.mapping.map(x),C);}v=b;}return r.setMeta(VM,{fixTables:!0})}(e,t,r,n));};return t?t.doc!=e.doc&&KM(t.doc,e.doc,0,r):e.doc.descendants(r),n}function UM(e){var t,n=e.selection,r=hM(e),i=r.node(-1),o=r.start(-1),s=aM.get(i);return (t=n instanceof wM?s.rectBetween(n.$anchorCell.pos-o,n.$headCell.pos-o):s.findCell(r.pos-o)).tableStart=o,t.map=s,t.table=i,t}function WM(e,t,n){var r=t.map,i=t.tableStart,o=t.table,s=n>0?-1:0;(function(e,t,n){for(var r=SM(t.type.schema).header_cell,i=0;i<e.height;i++)if(t.nodeAt(e.map[n+i*e.width]).type!=r)return !1;return !0})(r,o,n+s)&&(s=0==n||n==r.width?null:0);for(var a=0;a<r.height;a++){var l=a*r.width+n;if(n>0&&n<r.width&&r.map[l-1]==r.map[l]){var c=r.map[l],u=o.nodeAt(c);e.setNodeMarkup(e.mapping.map(i+c),null,bM(u.attrs,n-r.colCount(c))),a+=u.attrs.rowspan-1;}else {var d=null==s?SM(o.type.schema).cell:o.nodeAt(r.map[l+s]).type,h=r.positionAt(a,n,o);e.insert(e.mapping.map(i+h),d.createAndFill());}}return e}function GM(e,t,n){for(var r=t.map,i=t.table,o=t.tableStart,s=e.mapping.maps.length,a=0;a<r.height;){var l=a*r.width+n,c=r.map[l],u=i.nodeAt(c);if(n>0&&r.map[l-1]==c||n<r.width-1&&r.map[l+1]==c)e.setNodeMarkup(e.mapping.slice(s).map(o+c),null,yM(u.attrs,n-r.colCount(c)));else {var d=e.mapping.slice(s).map(o+c);e.delete(d,d+u.nodeSize);}a+=u.attrs.rowspan;}}function JM(e,t,n){for(var r=t.map,i=t.tableStart,o=t.table,s=i,a=0;a<n;a++)s+=o.child(a).nodeSize;var l=[],c=n>0?-1:0;(function(e,t,n){for(var r=SM(t.type.schema).header_cell,i=0;i<e.width;i++)if(t.nodeAt(e.map[i+n*e.width]).type!=r)return !1;return !0})(r,o,n+c)&&(c=0==n||n==r.height?null:0);for(var u=0,d=r.width*n;u<r.width;u++,d++)if(n>0&&n<r.height&&r.map[d]==r.map[d-r.width]){var h=r.map[d],p=o.nodeAt(h).attrs;e.setNodeMarkup(i+h,null,vM(p,"rowspan",p.rowspan+1)),u+=p.colspan-1;}else {var f=null==c?SM(o.type.schema).cell:o.nodeAt(r.map[d+c*r.width]).type;l.push(f.createAndFill());}return e.insert(s,SM(o.type.schema).row.create(null,l)),e}function ZM(e,t,n){for(var r=t.map,i=t.table,o=t.tableStart,s=0,a=0;a<n;a++)s+=i.child(a).nodeSize;var l=s+i.child(n).nodeSize,c=e.mapping.maps.length;e.delete(s+o,l+o);for(var u=0,d=n*r.width;u<r.width;u++,d++){var h=r.map[d];if(n>0&&h==r.map[d-r.width]){var p=i.nodeAt(h).attrs;e.setNodeMarkup(e.mapping.slice(c).map(h+o),null,vM(p,"rowspan",p.rowspan-1)),u+=p.colspan-1;}else if(n<r.width&&h==r.map[d+r.width]){var f=i.nodeAt(h),m=f.type.create(vM(f.attrs,"rowspan",f.attrs.rowspan-1),f.content),g=r.positionAt(n+1,u,i);e.insert(e.mapping.slice(c).map(o+g),m),u+=f.attrs.colspan-1;}}}function XM(e){var t=e.content;return 1==t.childCount&&t.firstChild.isTextblock&&0==t.firstChild.childCount}function QM(e){return function(t,n){var r,i,o=t.selection;if(o instanceof wM){if(o.$anchorCell.pos!=o.$headCell.pos)return !1;r=o.$anchorCell.nodeAfter,i=o.$anchorCell.pos;}else {if(!(r=function(e){for(var t=e.depth;t>0;t--){var n=e.node(t).type.spec.tableRole;if("cell"===n||"header_cell"===n)return e.node(t)}return null}(o.$from)))return !1;i=uM(o.$from).pos;}if(1==r.attrs.colspan&&1==r.attrs.rowspan)return !1;if(n){var s=r.attrs,a=[],l=s.colwidth;s.rowspan>1&&(s=vM(s,"rowspan",1)),s.colspan>1&&(s=vM(s,"colspan",1));for(var c,u=UM(t),d=t.tr,h=0;h<u.right-u.left;h++)a.push(l?vM(s,"colwidth",l&&l[h]?[l[h]]:null):s);for(var p=u.top;p<u.bottom;p++){var f=u.map.positionAt(p,u.left,u.table);p==u.top&&(f+=r.nodeSize);for(var m=u.left,g=0;m<u.right;m++,g++)m==u.left&&p==u.top||d.insert(c=d.mapping.map(f+u.tableStart,1),e({node:r,row:p,col:m}).createAndFill(a[g]));}d.setNodeMarkup(i,e({node:r,row:u.top,col:u.left}),a[0]),o instanceof wM&&d.setSelection(new wM(d.doc.resolve(o.$anchorCell.pos),c&&d.doc.resolve(c))),n(d);}return !0}}function YM(e,t,n){for(var r=t.map.cellsInRect({left:0,top:0,right:"row"==e?t.map.width:1,bottom:"column"==e?t.map.height:1}),i=0;i<r.length;i++){var o=t.table.nodeAt(r[i]);if(o&&o.type!==n.header_cell)return !1}return !0}function eO(e,t){return (t=t||{useDeprecatedLogic:!1}).useDeprecatedLogic?function(e){return function(t,n){if(!dM(t))return !1;if(n){for(var r=SM(t.schema),i=UM(t),o=t.tr,s=i.map.cellsInRect("column"==e?new sM(i.left,0,i.right,i.map.height):"row"==e?new sM(0,i.top,i.map.width,i.bottom):i),a=s.map((function(e){return i.table.nodeAt(e)})),l=0;l<s.length;l++)a[l].type==r.header_cell&&o.setNodeMarkup(i.tableStart+s[l],r.cell,a[l].attrs);if(0==o.steps.length)for(var c=0;c<s.length;c++)o.setNodeMarkup(i.tableStart+s[c],r.header_cell,a[c].attrs);n(o);}return !0}}(e):function(t,n){if(!dM(t))return !1;if(n){var r=SM(t.schema),i=UM(t),o=t.tr,s=YM("row",i,r),a=YM("column",i,r),l=("column"===e?s:"row"===e&&a)?1:0,c="column"==e?new sM(0,l,1,i.map.height):"row"==e?new sM(l,0,i.map.width,1):i,u="column"==e?a?r.cell:r.header_cell:"row"==e?s?r.cell:r.header_cell:r.cell;i.map.cellsInRect(c).forEach((function(e){var t=e+i.tableStart,n=o.doc.nodeAt(t);n&&o.setNodeMarkup(t,u,n.attrs);})),n(o);}return !0}}var tO=eO("row",{useDeprecatedLogic:!0}),nO=eO("column",{useDeprecatedLogic:!0}),rO=eO("cell",{useDeprecatedLogic:!0});var iO=function(e,t){this.node=e,this.cellMinWidth=t,this.dom=document.createElement("div"),this.dom.className="tableWrapper",this.table=this.dom.appendChild(document.createElement("table")),this.colgroup=this.table.appendChild(document.createElement("colgroup")),oO(e,this.colgroup,this.table,t),this.contentDOM=this.table.appendChild(document.createElement("tbody"));};function oO(e,t,n,r,i,o){for(var s=0,a=!0,l=t.firstChild,c=e.firstChild,u=0,d=0;u<c.childCount;u++)for(var h=c.child(u).attrs,p=h.colspan,f=h.colwidth,m=0;m<p;m++,d++){var g=i==d?o:f&&f[m],v=g?g+"px":"";s+=g||r,g||(a=!1),l?(l.style.width!=v&&(l.style.width=v),l=l.nextSibling):t.appendChild(document.createElement("col")).style.width=v;}for(;l;){var y=l.nextSibling;l.parentNode.removeChild(l),l=y;}a?(n.style.width=s+"px",n.style.minWidth=""):(n.style.width="",n.style.minWidth=s+"px");}iO.prototype.update=function(e){return e.type==this.node.type&&(this.node=e,oO(e,this.colgroup,this.table,this.cellMinWidth),!0)},iO.prototype.ignoreMutation=function(e){return "attributes"==e.type&&(e.target==this.table||this.colgroup.contains(e.target))};var sO=new QD.PluginKey("tableColumnResizing");var aO=function(e,t){this.activeHandle=e,this.dragging=t;};function lO(e,t,n){var r=e.posAtCoords({left:t.clientX,top:t.clientY}).pos,i=uM(e.state.doc.resolve(r));if(!i)return -1;if("right"==n)return i.pos;var o=aM.get(i.node(-1)),s=i.start(-1),a=o.map.indexOf(i.pos-s);return a%o.width==0?-1:s+o.map[a-1]}function cO(e,t,n){var r=t.clientX-e.startX;return Math.max(n,e.startWidth+r)}function uO(e,t){e.dispatch(e.state.tr.setMeta(sO,{setHandle:t}));}function dO(e){for(var t=[],n=0;n<e;n++)t.push(0);return t}aO.prototype.apply=function(e){var t=this,n=e.getMeta(sO);if(n&&null!=n.setHandle)return new aO(n.setHandle,null);if(n&&void 0!==n.setDragging)return new aO(t.activeHandle,n.setDragging);if(t.activeHandle>-1&&e.docChanged){var r=e.mapping.map(t.activeHandle,-1);pM(e.doc.resolve(r))||(r=null),t=new aO(r,t.dragging);}return t},iE.tableEditing=function(e){void 0===e&&(e={});var t=e.allowTableNodeSelection;return void 0===t&&(t=!1),new QD.Plugin({key:cM,state:{init:function(){return null},apply:function(e,t){var n=e.getMeta(cM);if(null!=n)return -1==n?null:n;if(null==t||!e.docChanged)return t;var r=e.mapping.mapResult(t),i=r.deleted,o=r.pos;return i?null:o}},props:{decorations:CM,handleDOMEvents:{mousedown:zM},createSelectionBetween:function(e){if(null!=cM.getState(e.state))return e.state.selection},handleTripleClick:IM,handleKeyDown:TM,handlePaste:PM},appendTransaction:function(e,n,r){return function(e,t,n){var r,i,o=(t||e).selection,s=(t||e).doc;if(o instanceof QD.NodeSelection&&(i=o.node.type.spec.tableRole)){if("cell"==i||"header_cell"==i)r=wM.create(s,o.from);else if("row"==i){var a=s.resolve(o.from+1);r=wM.rowSelection(a,a);}else if(!n){var l=aM.get(o.node),c=o.from+1,u=c+l.map[l.width*l.height-1];r=wM.create(s,c+1,u);}}else o instanceof QD.TextSelection&&function(e){var t=e.$from,n=e.$to;if(t.pos==n.pos||t.pos<t.pos-6)return !1;for(var r=t.pos,i=n.pos,o=t.depth;o>=0&&!(t.after(o+1)<t.end(o));o--,r++);for(var s=n.depth;s>=0&&!(n.before(s+1)>n.start(s));s--,i--);return r==i&&/row|table/.test(t.node(o).type.spec.tableRole)}(o)?r=QD.TextSelection.create(s,o.from):o instanceof QD.TextSelection&&function(e){for(var t,n,r=e.$from,i=e.$to,o=r.depth;o>0;o--){var s=r.node(o);if("cell"===s.type.spec.tableRole||"header_cell"===s.type.spec.tableRole){t=s;break}}for(var a=i.depth;a>0;a--){var l=i.node(a);if("cell"===l.type.spec.tableRole||"header_cell"===l.type.spec.tableRole){n=l;break}}return t!==n&&0===i.parentOffset}(o)&&(r=QD.TextSelection.create(s,o.$from.start(),o.$from.end()));return r&&(t||(t=e.tr)).setSelection(r),t}(r,qM(r,n),t)}})},iE.fixTables=qM,iE.handlePaste=PM,iE.fixTablesKey=VM,iE.tableEditingKey=cM,iE.cellAround=uM,iE.isInTable=dM,iE.selectionCell=hM,iE.moveCellForward=fM,iE.inSameTable=mM,iE.findCell=function(e){return aM.get(e.node(-1)).findCell(e.pos-e.start(-1))},iE.colCount=function(e){return aM.get(e.node(-1)).colCount(e.pos-e.start(-1))},iE.nextCell=gM,iE.tableNodes=function(e){var t=e.cellAttributes||{},n={colspan:{default:1},rowspan:{default:1},colwidth:{default:null}};for(var r in t)n[r]={default:t[r].default};return {table:{content:"table_row+",tableRole:"table",isolating:!0,group:e.tableGroup,parseDOM:[{tag:"table"}],toDOM:function(){return ["table",["tbody",0]]}},table_row:{content:"(table_cell | table_header)*",tableRole:"row",parseDOM:[{tag:"tr"}],toDOM:function(){return ["tr",0]}},table_cell:{content:e.cellContent,attrs:n,tableRole:"cell",isolating:!0,parseDOM:[{tag:"td",getAttrs:function(e){return EM(e,t)}}],toDOM:function(e){return ["td",xM(e,t),0]}},table_header:{content:e.cellContent,attrs:n,tableRole:"header_cell",isolating:!0,parseDOM:[{tag:"th",getAttrs:function(e){return EM(e,t)}}],toDOM:function(e){return ["th",xM(e,t),0]}}}},iE.CellSelection=wM,iE.TableMap=aM,iE.columnResizing=function(e){void 0===e&&(e={});var t=e.handleWidth;void 0===t&&(t=5);var n=e.cellMinWidth;void 0===n&&(n=25);var r=e.View;void 0===r&&(r=iO);var i=e.lastColumnResizable;void 0===i&&(i=!0);var o=new QD.Plugin({key:sO,state:{init:function(e,t){return this.spec.props.nodeViews[SM(t.schema).table.name]=function(e,t){return new r(e,n,t)},new aO(-1,!1)},apply:function(e,t){return t.apply(e)}},props:{attributes:function(e){return sO.getState(e).activeHandle>-1?{class:"resize-cursor"}:null},handleDOMEvents:{mousemove:function(e,n){!function(e,t,n,r,i){var o=sO.getState(e.state);if(!o.dragging){var s=function(e){for(;e&&"TD"!=e.nodeName&&"TH"!=e.nodeName;)e=e.classList.contains("ProseMirror")?null:e.parentNode;return e}(t.target),a=-1;if(s){var l=s.getBoundingClientRect(),c=l.left,u=l.right;t.clientX-c<=n?a=lO(e,t,"left"):u-t.clientX<=n&&(a=lO(e,t,"right"));}if(a!=o.activeHandle){if(!i&&-1!==a){var d=e.state.doc.resolve(a),h=d.node(-1),p=aM.get(h),f=d.start(-1);if(p.colCount(d.pos-f)+d.nodeAfter.attrs.colspan-1==p.width-1)return}uO(e,a);}}}(e,n,t,0,i);},mouseleave:function(e){!function(e){var t=sO.getState(e.state);t.activeHandle>-1&&!t.dragging&&uO(e,-1);}(e);},mousedown:function(e,t){!function(e,t,n){var r=sO.getState(e.state);if(-1==r.activeHandle||r.dragging)return !1;var i=e.state.doc.nodeAt(r.activeHandle),o=function(e,t,n){var r=n.colspan,i=n.colwidth,o=i&&i[i.length-1];if(o)return o;var s=e.domAtPos(t),a=s.node.childNodes[s.offset].offsetWidth,l=r;if(i)for(var c=0;c<r;c++)i[c]&&(a-=i[c],l--);return a/l}(e,r.activeHandle,i.attrs);function s(t){window.removeEventListener("mouseup",s),window.removeEventListener("mousemove",a);var r=sO.getState(e.state);r.dragging&&(!function(e,t,n){for(var r=e.state.doc.resolve(t),i=r.node(-1),o=aM.get(i),s=r.start(-1),a=o.colCount(r.pos-s)+r.nodeAfter.attrs.colspan-1,l=e.state.tr,c=0;c<o.height;c++){var u=c*o.width+a;if(!c||o.map[u]!=o.map[u-o.width]){var d=o.map[u],h=i.nodeAt(d).attrs,p=1==h.colspan?0:a-o.colCount(d);if(!h.colwidth||h.colwidth[p]!=n){var f=h.colwidth?h.colwidth.slice():dO(h.colspan);f[p]=n,l.setNodeMarkup(s+d,null,vM(h,"colwidth",f));}}}l.docChanged&&e.dispatch(l);}(e,r.activeHandle,cO(r.dragging,t,n)),e.dispatch(e.state.tr.setMeta(sO,{setDragging:null})));}function a(t){if(!t.which)return s(t);var r=sO.getState(e.state),i=cO(r.dragging,t,n);!function(e,t,n,r){var i=e.state.doc.resolve(t),o=i.node(-1),s=i.start(-1),a=aM.get(o).colCount(i.pos-s)+i.nodeAfter.attrs.colspan-1,l=e.domAtPos(i.start(-1)).node;for(;"TABLE"!=l.nodeName;)l=l.parentNode;oO(o,l.firstChild,l,r,a,n);}(e,r.activeHandle,i,n);}e.dispatch(e.state.tr.setMeta(sO,{setDragging:{startX:t.clientX,startWidth:o}})),window.addEventListener("mouseup",s),window.addEventListener("mousemove",a),t.preventDefault();}(e,t,n);}},decorations:function(e){var t=sO.getState(e);if(t.activeHandle>-1)return function(e,t){for(var n=[],r=e.doc.resolve(t),i=r.node(-1),o=aM.get(i),s=r.start(-1),a=o.colCount(r.pos-s)+r.nodeAfter.attrs.colspan,l=0;l<o.height;l++){var c=a+l*o.width-1;if(!(a!=o.width&&o.map[c]==o.map[c+1]||0!=l&&o.map[c-1]==o.map[c-1-o.width])){var u=o.map[c],d=s+u+i.nodeAt(u).nodeSize-1,h=document.createElement("div");h.className="column-resize-handle",n.push(YD.Decoration.widget(d,h));}}return YD.DecorationSet.create(e.doc,n)}(e,t.activeHandle)},nodeViews:{}}});return o},iE.columnResizingPluginKey=sO,iE.updateColumnsOnResize=oO,iE.__pastedCells=DM,iE.__insertCells=_M,iE.__clipCells=OM,iE.addColumn=WM,iE.addColumnBefore=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e);t(WM(e.tr,n,n.left));}return !0},iE.addColumnAfter=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e);t(WM(e.tr,n,n.right));}return !0},iE.removeColumn=GM,iE.deleteColumn=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e),r=e.tr;if(0==n.left&&n.right==n.map.width)return !1;for(var i=n.right-1;GM(r,n,i),i!=n.left;i--)n.table=n.tableStart?r.doc.nodeAt(n.tableStart-1):r.doc,n.map=aM.get(n.table);t(r);}return !0},iE.addRow=JM,iE.addRowBefore=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e);t(JM(e.tr,n,n.top));}return !0},iE.addRowAfter=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e);t(JM(e.tr,n,n.bottom));}return !0},iE.removeRow=ZM,iE.deleteRow=function(e,t){if(!dM(e))return !1;if(t){var n=UM(e),r=e.tr;if(0==n.top&&n.bottom==n.map.height)return !1;for(var i=n.bottom-1;ZM(r,n,i),i!=n.top;i--)n.table=n.tableStart?r.doc.nodeAt(n.tableStart-1):r.doc,n.map=aM.get(n.table);t(r);}return !0},iE.mergeCells=function(e,t){var n=e.selection;if(!(n instanceof wM)||n.$anchorCell.pos==n.$headCell.pos)return !1;var r=UM(e),i=r.map;if(function(e,t){for(var n=e.width,r=e.height,i=e.map,o=t.top*n+t.left,s=o,a=(t.bottom-1)*n+t.left,l=o+(t.right-t.left-1),c=t.top;c<t.bottom;c++){if(t.left>0&&i[s]==i[s-1]||t.right<n&&i[l]==i[l+1])return !0;s+=n,l+=n;}for(var u=t.left;u<t.right;u++){if(t.top>0&&i[o]==i[o-n]||t.bottom<r&&i[a]==i[a+n])return !0;o++,a++;}return !1}(i,r))return !1;if(t){for(var o,s,a=e.tr,l={},c=eM.Fragment.empty,u=r.top;u<r.bottom;u++)for(var d=r.left;d<r.right;d++){var h=i.map[u*i.width+d],p=r.table.nodeAt(h);if(!l[h])if(l[h]=!0,null==o)o=h,s=p;else {XM(p)||(c=c.append(p.content));var f=a.mapping.map(h+r.tableStart);a.delete(f,f+p.nodeSize);}}if(a.setNodeMarkup(o+r.tableStart,null,vM(bM(s.attrs,s.attrs.colspan,r.right-r.left-s.attrs.colspan),"rowspan",r.bottom-r.top)),c.size){var m=o+1+s.content.size,g=XM(s)?o+1:m;a.replaceWith(g+r.tableStart,m+r.tableStart,c);}a.setSelection(new wM(a.doc.resolve(o+r.tableStart))),t(a);}return !0},iE.splitCell=function(e,t){var n=SM(e.schema);return QM((function(e){var t=e.node;return n[t.type.spec.tableRole]}))(e,t)},iE.splitCellWithType=QM,iE.setCellAttr=function(e,t){return function(n,r){if(!dM(n))return !1;var i=hM(n);if(i.nodeAfter.attrs[e]===t)return !1;if(r){var o=n.tr;n.selection instanceof wM?n.selection.forEachCell((function(n,r){n.attrs[e]!==t&&o.setNodeMarkup(r,null,vM(n.attrs,e,t));})):o.setNodeMarkup(i.pos,null,vM(i.nodeAfter.attrs,e,t)),r(o);}return !0}},iE.toggleHeader=eO,iE.toggleHeaderRow=tO,iE.toggleHeaderColumn=nO,iE.toggleHeaderCell=rO,iE.goToNextCell=function(e){return function(t,n){if(!dM(t))return !1;var r=function(e,t){if(t<0){var n=e.nodeBefore;if(n)return e.pos-n.nodeSize;for(var r=e.index(-1)-1,i=e.before();r>=0;r--){var o=e.node(-1).child(r);if(o.childCount)return i-1-o.lastChild.nodeSize;i-=o.nodeSize;}}else {if(e.index()<e.parent.childCount-1)return e.pos+e.nodeAfter.nodeSize;for(var s=e.node(-1),a=e.indexAfter(-1),l=e.after();a<s.childCount;a++){var c=s.child(a);if(c.childCount)return l+1;l+=c.nodeSize;}}}(hM(t),e);if(null!=r){if(n){var i=t.doc.resolve(r);n(t.tr.setSelection(QD.TextSelection.between(i,fM(i))).scrollIntoView());}return !0}}},iE.deleteTable=function(e,t){for(var n=e.selection.$anchor,r=n.depth;r>0;r--){if("table"==n.node(r).type.spec.tableRole)return t&&t(e.tr.delete(n.before(r),n.after(r)).scrollIntoView()),!0}return !1},Object.defineProperty(Ww,"__esModule",{value:!0});var hO=Gw,pO=Jw,fO=iE,mO=function(e,t){return function(n){Array.isArray(e)||(e=[e]);for(var r=0,i=e.length;r<i;r++){var o=jO(e[r])(n.selection);if(o){var s=xO(o.pos,t)(n);if(s!==n)return s}}return n}},gO=function(e){return function(t){if(kO(t.selection)){var n=t.selection,r=n.$from,i=n.$to;if(e instanceof pO.Fragment&&r.parent.canReplace(r.index(),r.indexAfter(),e)||r.parent.canReplaceWith(r.index(),r.indexAfter(),e.type))return EO(t.replaceWith(r.pos,i.pos,e).setSelection(new hO.NodeSelection(t.doc.resolve(r.pos))))}return t}},vO=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return function(n){var r=hO.Selection.findFrom(n.doc.resolve(e),t,!0);return r?n.setSelection(r):n}},yO=function(e){return e.type&&e.type.spec.selectable},bO=function(e,t,n){return function(e){return yO(e)&&e.type.isLeaf}(e)?n.setSelection(new hO.NodeSelection(n.doc.resolve(t))):vO(t)(n)},wO=function(e,t,n){return function(r){var i="number"==typeof t,o=r.selection.$from,s=i?r.doc.resolve(t):kO(r.selection)?r.doc.resolve(o.pos+1):o,a=s.parent;if(kO(r.selection)&&n&&r!==(r=gO(e)(r)))return r;if(AO(a)&&r!==(r=mO(a.type,e)(r))){var l=yO(e)?s.before(s.depth):s.pos;return bO(e,l,r)}if(OO(s,e)){r.insert(s.pos,e);var c=i?s.pos:yO(e)?r.selection.$anchor.pos-1:r.selection.$anchor.pos;return EO(bO(e,c,r))}for(var u=s.depth;u>0;u--){var d=s.after(u),h=r.doc.resolve(d);if(OO(h,e))return r.insert(d,e),EO(bO(e,d,r))}return r}},kO=function(e){return e instanceof hO.NodeSelection},CO=function(e,t){return Array.isArray(e)&&e.indexOf(t.type)>-1||t.type===e},EO=function(e){return Object.assign(Object.create(e),e).setTime(Date.now())},xO=function(e,t){return function(n){var r=n.doc.nodeAt(e),i=n.doc.resolve(e);if(SO(i,t)){var o=(n=n.replaceWith(e,e+r.nodeSize,t)).selection.$from.pos-1;return n=vO(Math.max(o,0),-1)(n),n=vO(n.selection.$from.start())(n),EO(n)}return n}},SO=function(e,t){var n=e.node(e.depth);return n&&n.type.validContent(t instanceof pO.Fragment?t:pO.Fragment.from(t))},DO=function(e){return function(t){var n=t.doc.nodeAt(e);return EO(t.delete(e,e+n.nodeSize))}},MO=function(e){if(e.cached.tableNodeTypes)return e.cached.tableNodeTypes;var t={};return Object.keys(e.nodes).forEach((function(n){var r=e.nodes[n];r.spec.tableRole&&(t[r.spec.tableRole]=r);})),e.cached.tableNodeTypes=t,t},OO=function(e,t){var n=e.index();return t instanceof pO.Fragment?e.parent.canReplace(n,n,t):t instanceof pO.Node&&e.parent.canReplaceWith(n,n,t.type)},AO=function(e){return !e||"paragraph"===e.type.name&&2===e.nodeSize},NO=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t?e.createChecked(null,t):e.createAndFill()},_O=function(e){return function(t){for(var n=fO.TableMap.get(t.$anchorCell.node(-1)),r=t.$anchorCell.start(-1),i=n.cellsInRect(e),o=n.cellsInRect(n.rectBetween(t.$anchorCell.pos-r,t.$headCell.pos-r)),s=0,a=i.length;s<a;s++)if(-1===o.indexOf(i[s]))return !1;return !0}},TO=function(e){return e[0].map((function(t,n){return e.map((function(e){return e[n]}))}))},LO=function(e){for(var t=fO.TableMap.get(e),n=[],r=0;r<t.height;r++){for(var i=[],o={},s=0;s<t.width;s++){var a=t.map[r*t.width+s],l=e.nodeAt(a),c=t.findCell(a);o[a]||c.top!==r?i.push(null):(o[a]=!0,i.push(l));}n.push(i);}return n},RO=function(e,t){for(var n=[],r=fO.TableMap.get(e),i=0;i<r.height;i++){for(var o=e.child(i),s=[],a=0;a<r.width;a++)if(t[i][a]){var l=r.map[i*r.width+a],c=t[i][a],u=e.nodeAt(l).type.createChecked(Object.assign({},c.attrs),c.content,c.marks);s.push(u);}n.push(o.type.createChecked(o.attrs,s,o.marks));}return e.type.createChecked(e.attrs,n,e.marks)},FO=function(e,t,n,r){var i=t[0]>n[0]?-1:1,o=e.splice(t[0],t.length),s=o.length%2==0?1:0,a=void 0;return a=-1===r&&1===i?n[0]-1:1===r&&-1===i?n[n.length-1]-s+1:-1===i?n[0]:n[n.length-1]-s,e.splice.apply(e,[a,0].concat(o)),e},BO=function(e,t,n,r){var i="Target position is invalid, you can't move the "+r+" "+e+" to "+t+", the target can't be split. You could use tryToFit option.";if(1===(e>t?-1:1)){if(-1!==n.slice(0,n.length-1).indexOf(t))throw new Error(i)}else if(-1!==n.slice(1).indexOf(t))throw new Error(i);return !0},IO=function(e){return function(t){var n=t.$from;return PO(n,e)}},PO=function(e,t){for(var n=e.depth;n>0;n--){var r=e.node(n);if(t(r))return {pos:n>0?e.before(n):0,start:e.start(n),depth:n,node:r}}},zO=function(e,t){return function(n){var r=IO(e)(n);if(r)return VO(r.pos,t)}},$O=function(e){return function(t){return !!IO(e)(t)}},jO=function(e){return function(t){return IO((function(t){return CO(e,t)}))(t)}},HO=function(e){var t=e.$from.nodeBefore,n=hO.Selection.findFrom(e.$from,-1);if(n&&t){var r=jO(t.type)(n);return r?r.pos:n.$from.pos}},VO=function(e,t){var n=t(e),r=n.node.childNodes[n.offset];return n.node.nodeType===Node.TEXT_NODE?n.node.parentNode:r&&r.nodeType!==Node.TEXT_NODE?r:n.node},KO=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!e)throw new Error('Invalid "node" parameter');var n=[];return e.descendants((function(e,r){if(n.push({node:e,pos:r}),!t)return !1})),n},qO=function(e,t,n){if(!e)throw new Error('Invalid "node" parameter');if(!t)throw new Error('Invalid "predicate" parameter');return KO(e,n).filter((function(e){return t(e.node)}))},UO=function(e,t,n){return qO(e,(function(e){return e.type===t}),n)};var WO=function(e){return IO((function(e){return e.type.spec.tableRole&&"table"===e.type.spec.tableRole}))(e)},GO=function(e){return e instanceof fO.CellSelection},JO=function(e){if(GO(e)){var t=fO.TableMap.get(e.$anchorCell.node(-1));return _O({left:0,right:t.width,top:0,bottom:t.height})(e)}return !1},ZO=function(e){return function(t){var n=WO(t);if(n){var r=fO.TableMap.get(n.node);return (Array.isArray(e)?e:Array.from([e])).reduce((function(e,t){if(t>=0&&t<=r.width-1){var i=r.cellsInRect({left:t,right:t+1,top:0,bottom:r.height});return e.concat(i.map((function(e){var t=n.node.nodeAt(e),r=e+n.start;return {pos:r,start:r+1,node:t}})))}}),[])}}},XO=function(e){return function(t){var n=WO(t);if(n){var r=fO.TableMap.get(n.node);return (Array.isArray(e)?e:Array.from([e])).reduce((function(e,t){if(t>=0&&t<=r.height-1){var i=r.cellsInRect({left:0,right:r.width,top:t,bottom:t+1});return e.concat(i.map((function(e){var t=n.node.nodeAt(e),r=e+n.start;return {pos:r,start:r+1,node:t}})))}}),[])}}},QO=function(e){return function(t,n){return function(r){var i=WO(r.selection),o="row"===e;if(i){var s=fO.TableMap.get(i.node);if(t>=0&&t<(o?s.height:s.width)){var a=o?0:t,l=o?t:0,c=o?s.width:t+1,u=o?t+1:s.height;if(n){var d=sA(r.selection.$from);if(!d)return r;var h=s.findCell(d.pos-i.start);o?(l=Math.min(l,h.top),u=Math.max(u,h.bottom)):(a=Math.min(a,h.left),c=Math.max(c,h.right));}var p=s.cellsInRect({left:a,top:l,right:o?c:a+1,bottom:o?l+1:u}),f=u-l==1?p:s.cellsInRect({left:o?a:c-1,top:o?u-1:l,right:c,bottom:u}),m=i.start+p[0],g=i.start+f[f.length-1],v=r.doc.resolve(m),y=r.doc.resolve(g);return EO(r.setSelection(new fO.CellSelection(y,v)))}}return r}}},YO=QO("column"),eA=QO("row"),tA=function(e){return function(t){var n=WO(t.selection);if(n){var r=fO.TableMap.get(n.node);if(e>=0&&e<=r.height){for(var i=n.node,o=MO(i.type.schema),s=n.start,a=0;a<e+1;a++)s+=i.child(a).nodeSize;var l=i.child(e),c=[],u=0;if(l.forEach((function(e){1===e.attrs.rowspan&&(u+=e.attrs.colspan,c.push(o[e.type.spec.tableRole].createAndFill(e.attrs,e.marks)));})),u<r.width){for(var d=[],h=function(n){var r=lA(n,(function(t,r){var i=t.node.attrs.rowspan;return i>1&&n+i>e}))(t);d.push.apply(d,function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(r));},p=e;p>=0;p--)h(p);d.length&&d.forEach((function(e){t=oA(e,{rowspan:e.node.attrs.rowspan+1})(t);}));}return wO(o.row.create(l.attrs,c),s)(t)}}return t}},nA=function(e){return function(t){var n=WO(t.selection);if(n){var r=fO.TableMap.get(n.node);if(0===e&&1===r.width)return iA(t);if(e>=0&&e<=r.width)return fO.removeColumn(t,{map:r,tableStart:n.start,table:n.node},e),EO(t)}return t}},rA=function(e){return function(t){var n=WO(t.selection);if(n){var r=fO.TableMap.get(n.node);if(0===e&&1===r.height)return iA(t);if(e>=0&&e<=r.height)return fO.removeRow(t,{map:r,tableStart:n.start,table:n.node},e),EO(t)}return t}},iA=function(e){for(var t=e.selection.$from,n=t.depth;n>0;n--){if("table"===t.node(n).type.spec.tableRole)return EO(e.delete(t.before(n),t.after(n)))}return e},oA=function(e,t){return function(n){return e?(n.setNodeMarkup(e.pos,null,Object.assign({},e.node.attrs,t)),EO(n)):n}},sA=function(e){return PO(e,(function(e){return e.type.spec.tableRole&&/cell/i.test(e.type.spec.tableRole)}))},aA=function(e){var t=sA(e);if(t){var n=function(e){return PO(e,(function(e){return e.type.spec.tableRole&&/table/i.test(e.type.spec.tableRole)}))}(e),r=fO.TableMap.get(n.node),i=t.pos-n.start;return r.rectBetween(i,i)}},lA=function(e,t){return function(n){var r=[],i=XO(e)(n.selection);if(i)for(var o=i.length-1;o>=0;o--)t(i[o],n)&&r.push(i[o]);return r}},cA=function(e){return function(t){for(var n=e,r=e,i=function(e){var i=ZO(e)(t.selection);i&&i.forEach((function(t){var i=t.node.attrs.colspan+e-1;i>=n&&(n=e),i>r&&(r=i);}));},o=e;o>=0;o--)i(o);var s=function(e){var n=ZO(e)(t.selection);n&&n.forEach((function(t){var n=t.node.attrs.colspan+e-1;t.node.attrs.colspan>1&&n>r&&(r=n);}));};for(o=e;o<=r;o++)s(o);var a=[];for(o=n;o<=r;o++){var l=ZO(o)(t.selection);l&&l.length&&a.push(o);}n=a[0],r=a[a.length-1];for(var c=ZO(n)(t.selection),u=XO(0)(t.selection),d=t.doc.resolve(c[c.length-1].pos),h=void 0,p=r;p>=n;p--){var f=ZO(p)(t.selection);if(f&&f.length){for(var m=u.length-1;m>=0;m--)if(u[m].pos===f[0].pos){h=f[0];break}if(h)break}}return {$anchor:d,$head:t.doc.resolve(h.pos),indexes:a}}},uA=function(e){return function(t){for(var n=e,r=e,i=function(e){XO(e)(t.selection).forEach((function(t){var i=t.node.attrs.rowspan+e-1;i>=n&&(n=e),i>r&&(r=i);}));},o=e;o>=0;o--)i(o);var s=function(e){XO(e)(t.selection).forEach((function(t){var n=t.node.attrs.rowspan+e-1;t.node.attrs.rowspan>1&&n>r&&(r=n);}));};for(o=e;o<=r;o++)s(o);var a=[];for(o=n;o<=r;o++){var l=XO(o)(t.selection);l&&l.length&&a.push(o);}n=a[0],r=a[a.length-1];for(var c=XO(n)(t.selection),u=ZO(0)(t.selection),d=t.doc.resolve(c[c.length-1].pos),h=void 0,p=r;p>=n;p--){var f=XO(p)(t.selection);if(f&&f.length){for(var m=u.length-1;m>=0;m--)if(u[m].pos===f[0].pos){h=f[0];break}if(h)break}}return {$anchor:d,$head:t.doc.resolve(h.pos),indexes:a}}};Ww.isNodeSelection=kO,Ww.canInsert=OO,Ww.convertTableNodeToArrayOfRows=LO,Ww.convertArrayOfRowsToTableNode=RO;var dA=Ww.findParentNode=IO;Ww.findParentNodeClosestToPos=PO,Ww.findParentDomRef=zO,Ww.hasParentNode=$O,Ww.findParentNodeOfType=jO,Ww.findParentNodeOfTypeClosestToPos=function(e,t){return PO(e,(function(e){return CO(t,e)}))},Ww.hasParentNodeOfType=function(e){return function(t){return $O((function(t){return CO(e,t)}))(t)}},Ww.findParentDomRefOfType=function(e,t){return function(n){return zO((function(t){return CO(e,t)}),t)(n)}},Ww.findSelectedNodeOfType=function(e){return function(t){if(kO(t)){var n=t.node,r=t.$from;if(CO(e,n))return {node:n,pos:r.pos,depth:r.depth}}}},Ww.findPositionOfNodeBefore=HO,Ww.findDomRefAtPos=VO,Ww.flatten=KO,Ww.findChildren=qO,Ww.findTextNodes=function(e,t){return qO(e,(function(e){return e.isText}),t)},Ww.findInlineNodes=function(e,t){return qO(e,(function(e){return e.isInline}),t)},Ww.findBlockNodes=function(e,t){return qO(e,(function(e){return e.isBlock}),t)},Ww.findChildrenByAttr=function(e,t,n){return qO(e,(function(e){return !!t(e.attrs)}),n)},Ww.findChildrenByType=UO,Ww.findChildrenByMark=function(e,t,n){return qO(e,(function(e){return t.isInSet(e.marks)}),n)},Ww.contains=function(e,t){return !!UO(e,t).length},Ww.findTable=WO;var hA=Ww.isCellSelection=GO;Ww.getSelectionRect=function(e){if(GO(e)){var t=e.$anchorCell.start(-1);return fO.TableMap.get(e.$anchorCell.node(-1)).rectBetween(e.$anchorCell.pos-t,e.$headCell.pos-t)}};var pA=Ww.isColumnSelected=function(e){return function(t){if(GO(t)){var n=fO.TableMap.get(t.$anchorCell.node(-1));return _O({left:e,right:e+1,top:0,bottom:n.height})(t)}return !1}},fA=Ww.isRowSelected=function(e){return function(t){if(GO(t)){var n=fO.TableMap.get(t.$anchorCell.node(-1));return _O({left:0,right:n.width,top:e,bottom:e+1})(t)}return !1}},mA=Ww.isTableSelected=JO,gA=Ww.getCellsInColumn=ZO,vA=Ww.getCellsInRow=XO;Ww.getCellsInTable=function(e){var t=WO(e);if(t){var n=fO.TableMap.get(t.node);return n.cellsInRect({left:0,right:n.width,top:0,bottom:n.height}).map((function(e){var n=t.node.nodeAt(e),r=e+t.start;return {pos:r,start:r+1,node:n}}))}};var yA=Ww.selectColumn=YO,bA=Ww.selectRow=eA,wA=Ww.selectTable=function(e){var t=WO(e.selection);if(t){var n=fO.TableMap.get(t.node).map;if(n&&n.length){var r=t.start+n[0],i=t.start+n[n.length-1],o=e.doc.resolve(r),s=e.doc.resolve(i);return EO(e.setSelection(new fO.CellSelection(s,o)))}}return e};Ww.emptyCell=function(e,t){return function(n){if(e){var r=MO(t).cell.createAndFill().content;if(!e.node.content.eq(r))return n.replaceWith(e.pos+1,e.pos+e.node.nodeSize,r),EO(n)}return n}},Ww.addColumnAt=function(e){return function(t){var n=WO(t.selection);if(n){var r=fO.TableMap.get(n.node);if(e>=0&&e<=r.width)return EO(fO.addColumn(t,{map:r,tableStart:n.start,table:n.node},e))}return t}},Ww.moveRow=function(e,t,n){return function(r){var i=Object.assign({tryToFit:!1,direction:0},n),o=WO(r.selection);if(!o)return r;var s=uA(e)(r).indexes,a=uA(t)(r).indexes;if(s.indexOf(t)>-1)return r;!i.tryToFit&&a.length>1&&BO(e,t,a,"row");var l=function(e,t,n,r){var i=LO(e.node);return i=FO(i,t,n,r),RO(e.node,i)}(o,s,a,i.direction);return EO(r).replaceWith(o.pos,o.pos+o.node.nodeSize,l)}},Ww.moveColumn=function(e,t,n){return function(r){var i=Object.assign({tryToFit:!1,direction:0},n),o=WO(r.selection);if(!o)return r;var s=cA(e)(r).indexes,a=cA(t)(r).indexes;if(s.indexOf(t)>-1)return r;!i.tryToFit&&a.length>1&&BO(e,t,a,"column");var l=function(e,t,n,r){var i=TO(LO(e.node));return i=FO(i,t,n,r),i=TO(i),RO(e.node,i)}(o,s,a,i.direction);return EO(r).replaceWith(o.pos,o.pos+o.node.nodeSize,l)}},Ww.addRowAt=function(e,t){return function(n){var r=WO(n.selection);if(r){var i=fO.TableMap.get(r.node),o=e-1;if(t&&o>=0)return EO(tA(o)(n));if(e>=0&&e<=i.height)return EO(fO.addRow(n,{map:i,tableStart:r.start,table:r.node},e))}return n}},Ww.cloneRowAt=tA,Ww.removeColumnAt=nA,Ww.removeRowAt=rA,Ww.removeTable=iA,Ww.removeSelectedColumns=function(e){var t=e.selection;if(JO(t))return iA(e);if(GO(t)){var n=WO(t);if(n){var r=fO.TableMap.get(n.node),i=r.rectBetween(t.$anchorCell.pos-n.start,t.$headCell.pos-n.start);if(0==i.left&&i.right==r.width)return !1;for(var o=Object.assign({},i,{map:r,table:n.node,tableStart:n.start}),s=o.right-1;fO.removeColumn(e,o,s),s!==o.left;s--)o.table=o.tableStart?e.doc.nodeAt(o.tableStart-1):e.doc,o.map=fO.TableMap.get(o.table);return EO(e)}}return e},Ww.removeSelectedRows=function(e){var t=e.selection;if(JO(t))return iA(e);if(GO(t)){var n=WO(t);if(n){var r=fO.TableMap.get(n.node),i=r.rectBetween(t.$anchorCell.pos-n.start,t.$headCell.pos-n.start);if(0==i.top&&i.bottom==r.height)return !1;for(var o=Object.assign({},i,{map:r,table:n.node,tableStart:n.start}),s=o.bottom-1;fO.removeRow(e,o,s),s!==o.top;s--)o.table=o.tableStart?e.doc.nodeAt(o.tableStart-1):e.doc,o.map=fO.TableMap.get(o.table);return EO(e)}}return e},Ww.removeColumnClosestToPos=function(e){return function(t){var n=aA(e);return n?nA(n.left)(vO(e.pos)(t)):t}},Ww.removeRowClosestToPos=function(e){return function(t){var n=aA(e);return n?rA(n.top)(vO(e.pos)(t)):t}},Ww.forEachCellInColumn=function(e,t,n){return function(r){var i=ZO(e)(r.selection);if(i){for(var o=i.length-1;o>=0;o--)r=t(i[o],r);if(n){var s=r.doc.resolve(r.mapping.map(i[i.length-1].pos));r.setSelection(hO.Selection.near(s));}return EO(r)}return r}},Ww.forEachCellInRow=function(e,t,n){return function(r){var i=XO(e)(r.selection);if(i){for(var o=i.length-1;o>=0;o--)r=t(i[o],r);if(n){var s=r.doc.resolve(r.mapping.map(i[i.length-1].pos));r.setSelection(hO.Selection.near(s));}}return r}},Ww.setCellAttrs=oA,Ww.createTable=function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=MO(e),s=o.cell,a=o.header_cell,l=o.row,c=o.table,u=[],d=[],h=0;h<n;h++)u.push(NO(s,i)),r&&d.push(NO(a,i));for(var p=[],f=0;f<t;f++)p.push(l.createChecked(null,r&&0===f?d:u));return c.createChecked(null,p)},Ww.findCellClosestToPos=sA,Ww.findCellRectClosestToPos=aA,Ww.getSelectionRangeInColumn=cA,Ww.getSelectionRangeInRow=uA,Ww.removeParentNodeOfType=function(e){return function(t){var n=jO(e)(t.selection);return n?DO(n.pos)(t):t}},Ww.replaceParentNodeOfType=mO,Ww.removeSelectedNode=function(e){if(kO(e.selection)){var t=e.selection.$from.pos,n=e.selection.$to.pos;return EO(e.delete(t,n))}return e},Ww.replaceSelectedNode=gO,Ww.setTextSelection=vO,Ww.safeInsert=wO,Ww.setParentNodeMarkup=function(e,t,n,r){return function(i){var o=jO(e)(i.selection);return o?EO(i.setNodeMarkup(o.pos,t,Object.assign({},o.node.attrs,n),r)):i}},Ww.selectParentNodeOfType=function(e){return function(t){if(!kO(t.selection)){var n=jO(e)(t.selection);if(n)return EO(t.setSelection(hO.NodeSelection.create(t.doc,n.pos)))}return t}},Ww.removeNodeBefore=function(e){var t=HO(e.selection);return "number"==typeof t?DO(t)(e):e};var kA=Uw.extend({defaultOptions:ov(ov({},Uw.options),{},{HTMLAttributes:{role:"none"}}),addAttributes:function(){return {role:{default:"none"},class:{default:"paper-table"}}},addProseMirrorPlugins:function(){var e=this,t=this.options.resizable&&this.editor.isEditable;return [].concat(dv(t?[Rw({handleWidth:this.options.handleWidth,cellMinWidth:this.options.cellMinWidth,View:this.options.View,lastColumnResizable:this.options.lastColumnResizable})]:[]),[$w({allowTableNodeSelection:this.options.allowTableNodeSelection}),new Dl({props:{decorations:function(t){var n=t.doc,r=t.selection,i=[],o=gA(0)(r);return o&&o.forEach((function(n,o){var s=n.pos;0===o&&i.push(od.widget(s+1,(function(){var n="grip-table";mA(r)&&(n+=" selected");var i=document.createElement("a");return i.className=n,i.addEventListener("mousedown",(function(n){n.preventDefault(),n.stopImmediatePropagation(),e.editor.view.dispatch(wA(t.tr));})),i})));})),ld.create(n,i)}}})])}});var CA=xp.create({name:"tableRow",addOptions:()=>({HTMLAttributes:{}}),content:"(tableCell | tableHeader)*",tableRole:"row",parseHTML:()=>[{tag:"tr"}],renderHTML({HTMLAttributes:e}){return ["tr",dh(this.options.HTMLAttributes,e),0]}}).extend({addProseMirrorPlugins:function(){var e=this;return [new Dl({props:{decorations:function(t){var n=t.doc,r=t.selection,i=[],o=gA(0)(r);return o&&o.forEach((function(n,s){var a=n.pos;i.push(od.widget(a+1,(function(){var n="grip-row";fA(s)(r)&&(n+=" selected"),0===s&&(n+=" first"),s===o.length-1&&(n+=" last");var i=document.createElement("a");return i.className=n,i.addEventListener("mousedown",(function(n){n.preventDefault(),n.stopImmediatePropagation(),e.editor.view.dispatch(bA(s)(t.tr));})),i})));})),ld.create(n,i)}}})]}});var EA=xp.create({name:"tableHeader",addOptions:()=>({HTMLAttributes:{}}),content:"block+",addAttributes:()=>({colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:e=>{const t=e.getAttribute("colwidth");return t?[parseInt(t,10)]:null}}}),tableRole:"header_cell",isolating:!0,parseHTML:()=>[{tag:"th"}],renderHTML({HTMLAttributes:e}){return ["th",dh(this.options.HTMLAttributes,e),0]}}).extend({addProseMirrorPlugins:function(){var e=this;return [new Dl({props:{decorations:function(t){var n=t.doc,r=t.selection,i=[],o=vA(0)(r);return o&&o.forEach((function(n,s){var a=n.pos;i.push(od.widget(a+1,(function(){var n="grip-column";pA(s)(r)&&(n+=" selected"),0===s?n+=" first":s===o.length-1&&(n+=" last");var i=document.createElement("a");return i.className=n,i.addEventListener("mousedown",(function(n){n.preventDefault(),n.stopImmediatePropagation(),e.editor.view.dispatch(yA(s)(t.tr));})),i})));})),ld.create(n,i)}}})]}});const xA=xp.create({name:"tableCell",addOptions:()=>({HTMLAttributes:{}}),content:"block+",addAttributes:()=>({colspan:{default:1},rowspan:{default:1},colwidth:{default:null,parseHTML:e=>{const t=e.getAttribute("colwidth");return t?[parseInt(t,10)]:null}}}),tableRole:"cell",isolating:!0,parseHTML:()=>[{tag:"td"}],renderHTML({HTMLAttributes:e}){return ["td",dh(this.options.HTMLAttributes,e),0]}}),SA=Ah.create({name:"placeholder",addOptions:()=>({emptyEditorClass:"is-editor-empty",emptyNodeClass:"is-empty",placeholder:"Write something …",showOnlyWhenEditable:!0,showOnlyCurrent:!0,includeChildren:!1}),addProseMirrorPlugins(){return [new Dl({props:{decorations:({doc:e,selection:t})=>{const n=this.editor.isEditable||!this.options.showOnlyWhenEditable,{anchor:r}=t,i=[];return n?(e.descendants(((e,t)=>{const n=r>=t&&r<=t+e.nodeSize,o=!e.isLeaf&&!e.childCount;if((n||!this.options.showOnlyCurrent)&&o){const r=[this.options.emptyNodeClass];this.editor.isEmpty&&r.push(this.options.emptyEditorClass);const o=od.node(t,t+e.nodeSize,{class:r.join(" "),"data-placeholder":"function"==typeof this.options.placeholder?this.options.placeholder({editor:this.editor,node:e,pos:t,hasAnchor:n}):this.options.placeholder});i.push(o);}return this.options.includeChildren})),ld.create(e,i)):null}}})]}});var DA=E([].slice),MA=TypeError,OA=r,AA=ho,NA=P,_A=DA,TA=function(e,t){if(e<t)throw MA("Not enough arguments");return e},LA=/MSIE .\./.test(U),RA=OA.Function,FA=function(e){return LA?function(t,n){var r=TA(arguments.length,1)>2,i=NA(t)?t:RA(t),o=r?_A(arguments,2):void 0;return e(r?function(){AA(i,this,o);}:i,n)}:e},BA={setTimeout:FA(OA.setTimeout),setInterval:FA(OA.setInterval)},IA=BA.setInterval;Vr({global:!0,bind:!0,forced:r.setInterval!==IA},{setInterval:IA});var PA=BA.setTimeout;Vr({global:!0,bind:!0,forced:r.setTimeout!==PA},{setTimeout:PA});var zA=s,$A=qt.EXISTS,jA=E,HA=Ct.f,VA=Function.prototype,KA=jA(VA.toString),qA=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,UA=jA(qA.exec);zA&&!$A&&HA(VA,"name",{configurable:!0,get:function(){try{return UA(qA,KA(this))[1]}catch(e){return ""}}});var WA=Vr,GA=T,JA=I,ZA=kb,XA=E([].join),QA=GA!=Object,YA=ZA("join",",");WA({target:"Array",proto:!0,forced:QA||!YA},{join:function(e){return XA(JA(this),void 0===e?",":e)}});var eN=/^\/(\w+)?$/;function tN(e,t,n,r,i){if(e.composing)return !1;var o=e.state,s=o.doc.resolve(t);if(s.parent.type.spec.code)return !1;var a=s.parent.textBetween(Math.max(0,s.parentOffset-500),s.parentOffset,null,"￼"),l=r.exec(a);return !!i(o,l,l?t-l[0].length:t,n)}function nN(e){e.options.editorProps.showBlockMenu=!1;}function rN(e){e.options.editorProps.showBlockMenu=!0;}var iN=SA.extend({defaultOptions:ov(ov({},SA.options),{},{placeholder:"Write something great..."}),addProseMirrorPlugins:function(){return function(e,t){var n=document.createElement("button");n.className="block-menu-trigger",n.type="button";var r=document.createTextNode("+");return n.appendChild(r),[new Dl({props:{handleClick:function(){return nN(e),!1},handleKeyDown:function(t,n){if("Backspace"===n.key&&setTimeout((function(){var n=t.state.selection.$from.pos;return tN(t,n,n,eN,(function(t,n){return n?(rN(e),console.log(n)):nN(e),null}))})),"Enter"===n.key||"ArrowUp"===n.key||"ArrowDown"===n.key||"Tab"===n.key){var r=t.state.selection.$from.pos;return tN(t,r,r,eN,(function(e,t){return !!t||null}))}return !1},decorations:function(r){var i=dA((function(e){return "paragraph"===e.type.name}))(r.selection);if(i){var o=[],s=i&&0===i.node.content.size,a=1===r.selection.$from.depth,l=[t.emptyNodeClass];return e.isEmpty&&l.push(t.emptyEditorClass),a?(s&&(o.push(od.widget(i.pos,(function(){return n.addEventListener("click",(function(){rN(e);})),n}))),o.push(od.node(i.pos,i.pos+i.node.nodeSize,{class:l.join(" "),"data-placeholder":t.placeholder}))),ld.create(r.doc,o)):void 0}}}})]}(this.editor,this.options)}});Vr({target:"Array",stat:!0},{isArray:gy});var oN=Je,sN=Li,aN=Ct.f,lN=oN("unscopables"),cN=Array.prototype;null==cN[lN]&&aN(cN,lN,{configurable:!0,value:sN(null)});var uN=sr.includes,dN=function(e){cN[lN][e]=!0;};Vr({target:"Array",proto:!0,forced:o((function(){return !Array(1).includes()}))},{includes:function(e){return uN(this,e,arguments.length>1?arguments[1]:void 0)}}),dN("includes");var hN=$,pN=M,fN=Je("match"),mN=function(e){var t;return hN(e)&&(void 0!==(t=e[fN])?!!t:"RegExp"==pN(e))},gN=TypeError,vN=Je("match"),yN=Vr,bN=function(e){if(mN(e))throw gN("The method doesn't accept regular expressions");return e},wN=R,kN=ti,CN=function(e){var t=/./;try{"/./"[e](t);}catch(n){try{return t[vN]=!1,"/./"[e](t)}catch(e){}}return !1},EN=E("".indexOf);yN({target:"String",proto:!0,forced:!CN("includes")},{includes:function(e){return !!~EN(kN(wN(this)),kN(bN(e)),arguments.length>1?arguments[1]:void 0)}});var xN=bb.filter;Vr({target:"Array",proto:!0,forced:!Uy("filter")},{filter:function(e){return xN(this,e,arguments.length>1?arguments[1]:void 0)}});var SN=bb.map;Vr({target:"Array",proto:!0,forced:!Uy("map")},{map:function(e){return SN(this,e,arguments.length>1?arguments[1]:void 0)}});var DN=s,MN=E,ON=di,AN=I,NN=MN(d.f),_N=MN([].push),TN=function(e){return function(t){for(var n,r=AN(t),i=ON(r),o=i.length,s=0,a=[];o>s;)n=i[s++],DN&&!NN(r,n)||_N(a,e?[n,r[n]]:r[n]);return a}},LN={entries:TN(!0),values:TN(!1)}.entries;function RN(e){var t=e.types,n=e.node;return Array.isArray(t)&&t.includes(n.type)||n.type===t}Vr({target:"Object",stat:!0},{entries:function(e){return LN(e)}});var FN=Ah.create({name:"trailingNode",addOptions:function(){return {node:"paragraph",notAfter:["paragraph"]}},addProseMirrorPlugins:function(){var e=this,t=new Al(this.name),n=Object.entries(this.editor.schema.nodes).map((function(e){return uv(e,2)[1]})).filter((function(t){return e.options.notAfter.includes(t.name)}));return [new Dl({key:t,appendTransaction:function(n,r,i){var o=i.doc,s=i.tr,a=i.schema,l=t.getState(i),c=o.content.size,u=a.nodes[e.options.node];if(l)return s.insert(c,u.create())},state:{init:function(e,t){return !RN({node:t.tr.doc.lastChild,types:n})},apply:function(e,t){return e.docChanged?!RN({node:e.doc.lastChild,types:n}):t}}})]}});const BN=/(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,IN=xp.create({name:"image",addOptions:()=>({inline:!1,allowBase64:!1,HTMLAttributes:{}}),inline(){return this.options.inline},group(){return this.options.inline?"inline":"block"},draggable:!0,addAttributes:()=>({src:{default:null},alt:{default:null},title:{default:null}}),parseHTML(){return [{tag:this.options.allowBase64?"img[src]":'img[src]:not([src^="data:"])'}]},renderHTML({HTMLAttributes:e}){return ["img",dh(this.options.HTMLAttributes,e)]},addCommands(){return {setImage:e=>({commands:t})=>t.insertContent({type:this.name,attrs:e})}},addInputRules(){return [bp({find:BN,type:this.type,getAttributes:e=>{const[,,t,n,r]=e;return {src:n,alt:t,title:r}}})]}});var PN=IN.extend({addAttributes:function(){var e;return ov(ov({},null===(e=this.parent)||void 0===e?void 0:e.call(this)),{},{"data-href":{default:null}})},addCommands:function(){var e=this;return {setImage:function(t){return function(n){var r,i,o,s=n.tr,a=n.commands;return "image"===(null===(r=s.selection)||void 0===r||null===(i=r.node)||void 0===i||null===(o=i.type)||void 0===o?void 0:o.name)?a.updateAttributes("image",t):a.insertContent({type:e.name,attrs:t})}}}},addNodeView:function(){return function(e){var t=e.node,n=document.createElement("div");n.className="wysiwyg-image-wrapper";var r=document.createElement("img");return r.src=t.attrs.src,n.append(r),{dom:n,contentDOM:r}}},renderHTML:function(e){e.node;var t=e.HTMLAttributes,n=["img",dh(this.options.HTMLAttributes,t)];return t["data-href"]?["a",{href:t["data-href"],class:"image-link"},n]:n}}),zN=u,$N=Mt,jN=ge,HN=Mt,VN=function(e,t,n){var r,i;$N(e);try{if(!(r=jN(e,"return"))){if("throw"===t)throw n;return n}r=zN(r,e);}catch(e){i=!0,r=e;}if("throw"===t)throw n;if(i)throw r;return $N(r),n},KN={},qN=KN,UN=Je("iterator"),WN=Array.prototype,GN=Qr,JN=ge,ZN=KN,XN=Je("iterator"),QN=function(e){if(null!=e)return JN(e,XN)||JN(e,"@@iterator")||ZN[GN(e)]},YN=u,e_=fe,t_=Mt,n_=ue,r_=QN,i_=TypeError,o_=db,s_=u,a_=Ne,l_=function(e,t,n,r){try{return r?t(HN(n)[0],n[1]):t(n)}catch(t){VN(e,"throw",t);}},c_=function(e){return void 0!==e&&(qN.Array===e||WN[UN]===e)},u_=Fy,d_=tr,h_=ky,p_=function(e,t){var n=arguments.length<2?r_(e):t;if(e_(n))return t_(YN(n,e));throw i_(n_(e)+" is not iterable")},f_=QN,m_=Array,g_=Je("iterator"),v_=!1;try{var y_=0,b_={next:function(){return {done:!!y_++}},return:function(){v_=!0;}};b_[g_]=function(){return this},Array.from(b_,(function(){throw 2}));}catch(zR){}var w_=function(e){var t=a_(e),n=u_(this),r=arguments.length,i=r>1?arguments[1]:void 0,o=void 0!==i;o&&(i=o_(i,r>2?arguments[2]:void 0));var s,a,l,c,u,d,h=f_(t),p=0;if(!h||this===m_&&c_(h))for(s=d_(t),a=n?new this(s):m_(s);s>p;p++)d=o?i(t[p],p):t[p],h_(a,p,d);else for(u=(c=p_(t,h)).next,a=n?new this:[];!(l=s_(u,c)).done;p++)d=o?l_(c,i,[l.value,p],!0):l.value,h_(a,p,d);return a.length=p,a},k_=function(e,t){if(!t&&!v_)return !1;var n=!1;try{var r={};r[g_]=function(){return {next:function(){return {done:n=!0}}}},e(r);}catch(e){}return n};Vr({target:"Array",stat:!0,forced:!k_((function(e){Array.from(e);}))},{from:w_});var C_,E_,x_,S_=!o((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),D_=Le,M_=P,O_=Ne,A_=S_,N_=an("IE_PROTO"),__=Object,T_=__.prototype,L_=A_?__.getPrototypeOf:function(e){var t=O_(e);if(D_(t,N_))return t[N_];var n=t.constructor;return M_(n)&&t instanceof n?n.prototype:t instanceof __?T_:null},R_=o,F_=P,B_=L_,I_=Hn,P_=Je("iterator"),z_=!1;[].keys&&("next"in(x_=[].keys())?(E_=B_(B_(x_)))!==Object.prototype&&(C_=E_):z_=!0);var $_=null==C_||R_((function(){var e={};return C_[P_].call(e)!==e}));$_&&(C_={}),F_(C_[P_])||I_(C_,P_,(function(){return this}));var j_={IteratorPrototype:C_,BUGGY_SAFARI_ITERATORS:z_},H_=Ct.f,V_=Le,K_=Je("toStringTag"),q_=function(e,t,n){e&&!n&&(e=e.prototype),e&&!V_(e,K_)&&H_(e,K_,{configurable:!0,value:t});},U_=j_.IteratorPrototype,W_=Li,G_=v,J_=q_,Z_=KN,X_=function(){return this},Q_=P,Y_=String,eT=TypeError,tT=E,nT=Mt,rT=function(e){if("object"==typeof e||Q_(e))return e;throw eT("Can't set "+Y_(e)+" as a prototype")},iT=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=tT(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array;}catch(e){}return function(n,r){return nT(n),rT(r),t?e(n,r):n.__proto__=r,n}}():void 0),oT=Vr,sT=u,aT=P,lT=function(e,t,n,r){var i=t+" Iterator";return e.prototype=W_(U_,{next:G_(+!r,n)}),J_(e,i,!1),Z_[i]=X_,e},cT=L_,uT=iT,dT=q_,hT=Pt,pT=Hn,fT=KN,mT=qt.PROPER,gT=qt.CONFIGURABLE,vT=j_.IteratorPrototype,yT=j_.BUGGY_SAFARI_ITERATORS,bT=Je("iterator"),wT=function(){return this},kT=No.charAt,CT=ti,ET=Sn,xT=function(e,t,n,r,i,o,s){lT(n,t,r);var a,l,c,u=function(e){if(e===i&&m)return m;if(!yT&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},d=t+" Iterator",h=!1,p=e.prototype,f=p[bT]||p["@@iterator"]||i&&p[i],m=!yT&&f||u(i),g="Array"==t&&p.entries||f;if(g&&(a=cT(g.call(new e)))!==Object.prototype&&a.next&&(cT(a)!==vT&&(uT?uT(a,vT):aT(a[bT])||pT(a,bT,wT)),dT(a,d,!0)),mT&&"values"==i&&f&&"values"!==f.name&&(gT?hT(p,"name","values"):(h=!0,m=function(){return sT(f,this)})),i)if(l={values:u("values"),keys:o?m:u("keys"),entries:u("entries")},s)for(c in l)(yT||h||!(c in p))&&pT(p,c,l[c]);else oT({target:t,proto:!0,forced:yT||h},l);return p[bT]!==m&&pT(p,bT,m,{name:i}),fT[t]=m,l},ST=ET.set,DT=ET.getterFor("String Iterator");xT(String,"String",(function(e){ST(this,{type:"String Iterator",string:CT(e),index:0});}),(function(){var e,t=DT(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=kT(n,r),t.index+=e.length,{value:e,done:!1})}));var MT=Vr,OT=sr.indexOf,AT=kb,NT=E([].indexOf),_T=!!NT&&1/NT([1],1,-0)<0,TT=AT("indexOf");MT({target:"Array",proto:!0,forced:_T||!TT},{indexOf:function(e){var t=arguments.length>1?arguments[1]:void 0;return _T?NT(this,e,t)||0:OT(this,e,t)}});var LT={uploadImage:function(){var t=lv(sv().mark((function t(n,r){var i,o,s;return sv().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(null!=r&&r.uploadUrl){t.next=2;break}return t.abrupt("return",null);case 2:return (i=new FormData).append("images",n),o={"Content-Type":"multipart/form-data"},t.next=7,e.post(r.uploadUrl,i,{headers:o});case 7:if(0!==(s=t.sent).data.length){t.next=10;break}return t.abrupt("return",alert("Unable to upload file"));case 10:return t.abrupt("return",s.data[0]);case 11:case"end":return t.stop()}}),t)})));return function(e,n){return t.apply(this,arguments)}}()},RT=LT.uploadImage;function FT(e,t=[]){return e.map((e=>{const n=[...t,...e.properties?e.properties.className:[]];return e.children?FT(e.children,n):{text:e.value,classes:n}})).flat()}function BT(e){return e.value||e.children||[]}function IT({doc:e,name:t,lowlight:n,defaultLanguage:r}){const i=[];return pp(e,(e=>e.type.name===t)).forEach((e=>{let t=e.pos+1;const o=e.node.attrs.language||r,s=n.listLanguages();FT(o&&s.includes(o)?BT(n.highlight(o,e.node.textContent)):BT(n.highlightAuto(e.node.textContent))).forEach((e=>{const n=t+e.text.length;if(e.classes.length){const r=od.inline(t,n,{class:e.classes.join(" ")});i.push(r);}t=n;}));})),ld.create(e,i)}function PT({name:e,lowlight:t,defaultLanguage:n}){if(!["highlight","highlightAuto","listLanguages"].every((e=>"function"==typeof t[e])))throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");const r=new Dl({key:new Al("lowlight"),state:{init:(r,{doc:i})=>IT({doc:i,name:e,lowlight:t,defaultLanguage:n}),apply:(r,i,o,s)=>{const a=o.selection.$head.parent.type.name,l=s.selection.$head.parent.type.name,c=pp(o.doc,(t=>t.type.name===e)),u=pp(s.doc,(t=>t.type.name===e));return r.docChanged&&([a,l].includes(e)||u.length!==c.length||r.steps.some((e=>void 0!==e.from&&void 0!==e.to&&c.some((t=>t.pos>=e.from&&t.pos+t.node.nodeSize<=e.to)))))?IT({doc:r.doc,name:e,lowlight:t,defaultLanguage:n}):i.map(r.mapping,r.doc)}},props:{decorations:e=>r.getState(e)}});return r}const zT=$m.extend({addOptions(){var e;return {...null===(e=this.parent)||void 0===e?void 0:e.call(this),lowlight:{},defaultLanguage:null}},addProseMirrorPlugins(){var e;return [...(null===(e=this.parent)||void 0===e?void 0:e.call(this))||[],PT({name:this.name,lowlight:this.options.lowlight,defaultLanguage:this.options.defaultLanguage})]}});const $T=["a","abbr","address","article","aside","audio","b","blockquote","body","button","canvas","caption","cite","code","dd","del","details","dfn","div","dl","dt","em","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","html","i","iframe","img","input","ins","kbd","label","legend","li","main","mark","menu","nav","object","ol","p","q","quote","samp","section","span","strong","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","ul","var","video"],jT=["any-hover","any-pointer","aspect-ratio","color","color-gamut","color-index","device-aspect-ratio","device-height","device-width","display-mode","forced-colors","grid","height","hover","inverted-colors","monochrome","orientation","overflow-block","overflow-inline","pointer","prefers-color-scheme","prefers-contrast","prefers-reduced-motion","prefers-reduced-transparency","resolution","scan","scripting","update","width","min-width","max-width","min-height","max-height"],HT=["active","any-link","blank","checked","current","default","defined","dir","disabled","drop","empty","enabled","first","first-child","first-of-type","fullscreen","future","focus","focus-visible","focus-within","has","host","host-context","hover","indeterminate","in-range","invalid","is","lang","last-child","last-of-type","left","link","local-link","not","nth-child","nth-col","nth-last-child","nth-last-col","nth-last-of-type","nth-of-type","only-child","only-of-type","optional","out-of-range","past","placeholder-shown","read-only","read-write","required","right","root","scope","target","target-within","user-invalid","valid","visited","where"],VT=["after","backdrop","before","cue","cue-region","first-letter","first-line","grammar-error","marker","part","placeholder","selection","slotted","spelling-error"],KT=["align-content","align-items","align-self","all","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","backface-visibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","block-size","border","border-block","border-block-color","border-block-end","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start","border-block-start-color","border-block-start-style","border-block-start-width","border-block-style","border-block-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-inline","border-inline-color","border-inline-end","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-inline-style","border-inline-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","caret-color","clear","clip","clip-path","clip-rule","color","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","contain","content","content-visibility","counter-increment","counter-reset","cue","cue-after","cue-before","cursor","direction","display","empty-cells","filter","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","flow","font","font-display","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","font-smoothing","font-stretch","font-style","font-synthesis","font-variant","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-variation-settings","font-weight","gap","glyph-orientation-vertical","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-gap","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","ime-mode","inline-size","isolation","justify-content","left","letter-spacing","line-break","line-height","list-style","list-style-image","list-style-position","list-style-type","margin","margin-block","margin-block-end","margin-block-start","margin-bottom","margin-inline","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","marks","mask","mask-border","mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width","mask-clip","mask-composite","mask-image","mask-mode","mask-origin","mask-position","mask-repeat","mask-size","mask-type","max-block-size","max-height","max-inline-size","max-width","min-block-size","min-height","min-inline-size","min-width","mix-blend-mode","nav-down","nav-index","nav-left","nav-right","nav-up","none","normal","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-wrap","overflow-x","overflow-y","padding","padding-block","padding-block-end","padding-block-start","padding-bottom","padding-inline","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","pause","pause-after","pause-before","perspective","perspective-origin","pointer-events","position","quotes","resize","rest","rest-after","rest-before","right","row-gap","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-align","scroll-snap-stop","scroll-snap-type","scrollbar-color","scrollbar-gutter","scrollbar-width","shape-image-threshold","shape-margin","shape-outside","speak","speak-as","src","tab-size","table-layout","text-align","text-align-all","text-align-last","text-combine-upright","text-decoration","text-decoration-color","text-decoration-line","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-indent","text-justify","text-orientation","text-overflow","text-rendering","text-shadow","text-transform","text-underline-position","top","transform","transform-box","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","writing-mode","z-index"].reverse();var qT="\\.([0-9](_*[0-9])*)",UT="[0-9a-fA-F](_*[0-9a-fA-F])*",WT={className:"number",variants:[{begin:`(\\b([0-9](_*[0-9])*)((${qT})|\\.)?|(${qT}))[eE][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`},{begin:`\\b([0-9](_*[0-9])*)((${qT})[fFdD]?\\b|\\.([fFdD]\\b)?)`},{begin:`(${qT})[fFdD]?\\b`},{begin:"\\b([0-9](_*[0-9])*)[fFdD]\\b"},{begin:`\\b0[xX]((${UT})\\.?|(${UT})?\\.(${UT}))[pP][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`},{begin:"\\b(0|[1-9](_*[0-9])*)[lL]?\\b"},{begin:`\\b0[xX](${UT})[lL]?\\b`},{begin:"\\b0(_*[0-7])*[lL]?\\b"},{begin:"\\b0[bB][01](_*[01])*[lL]?\\b"}],relevance:0};function GT(e,t,n){return -1===n?"":e.replace(t,(r=>GT(e,t,n-1)))}const JT=["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends"],ZT=["true","false","null","undefined","NaN","Infinity"],XT=["Object","Function","Boolean","Symbol","Math","Date","Number","BigInt","String","RegExp","Array","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Int32Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Set","Map","WeakSet","WeakMap","ArrayBuffer","SharedArrayBuffer","Atomics","DataView","JSON","Promise","Generator","GeneratorFunction","AsyncFunction","Reflect","Proxy","Intl","WebAssembly"],QT=["Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],YT=["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],eL=["arguments","this","super","console","window","document","localStorage","module","global"],tL=[].concat(YT,XT,QT);var nL="\\.([0-9](_*[0-9])*)",rL="[0-9a-fA-F](_*[0-9a-fA-F])*",iL={className:"number",variants:[{begin:`(\\b([0-9](_*[0-9])*)((${nL})|\\.)?|(${nL}))[eE][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`},{begin:`\\b([0-9](_*[0-9])*)((${nL})[fFdD]?\\b|\\.([fFdD]\\b)?)`},{begin:`(${nL})[fFdD]?\\b`},{begin:"\\b([0-9](_*[0-9])*)[fFdD]\\b"},{begin:`\\b0[xX]((${rL})\\.?|(${rL})?\\.(${rL}))[pP][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`},{begin:"\\b(0|[1-9](_*[0-9])*)[lL]?\\b"},{begin:`\\b0[xX](${rL})[lL]?\\b`},{begin:"\\b0(_*[0-7])*[lL]?\\b"},{begin:"\\b0[bB][01](_*[01])*[lL]?\\b"}],relevance:0};const oL=["a","abbr","address","article","aside","audio","b","blockquote","body","button","canvas","caption","cite","code","dd","del","details","dfn","div","dl","dt","em","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","html","i","iframe","img","input","ins","kbd","label","legend","li","main","mark","menu","nav","object","ol","p","q","quote","samp","section","span","strong","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","ul","var","video"],sL=["any-hover","any-pointer","aspect-ratio","color","color-gamut","color-index","device-aspect-ratio","device-height","device-width","display-mode","forced-colors","grid","height","hover","inverted-colors","monochrome","orientation","overflow-block","overflow-inline","pointer","prefers-color-scheme","prefers-contrast","prefers-reduced-motion","prefers-reduced-transparency","resolution","scan","scripting","update","width","min-width","max-width","min-height","max-height"],aL=["active","any-link","blank","checked","current","default","defined","dir","disabled","drop","empty","enabled","first","first-child","first-of-type","fullscreen","future","focus","focus-visible","focus-within","has","host","host-context","hover","indeterminate","in-range","invalid","is","lang","last-child","last-of-type","left","link","local-link","not","nth-child","nth-col","nth-last-child","nth-last-col","nth-last-of-type","nth-of-type","only-child","only-of-type","optional","out-of-range","past","placeholder-shown","read-only","read-write","required","right","root","scope","target","target-within","user-invalid","valid","visited","where"],lL=["after","backdrop","before","cue","cue-region","first-letter","first-line","grammar-error","marker","part","placeholder","selection","slotted","spelling-error"],cL=["align-content","align-items","align-self","all","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","backface-visibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","block-size","border","border-block","border-block-color","border-block-end","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start","border-block-start-color","border-block-start-style","border-block-start-width","border-block-style","border-block-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-inline","border-inline-color","border-inline-end","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-inline-style","border-inline-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","caret-color","clear","clip","clip-path","clip-rule","color","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","contain","content","content-visibility","counter-increment","counter-reset","cue","cue-after","cue-before","cursor","direction","display","empty-cells","filter","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","flow","font","font-display","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","font-smoothing","font-stretch","font-style","font-synthesis","font-variant","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-variation-settings","font-weight","gap","glyph-orientation-vertical","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-gap","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","ime-mode","inline-size","isolation","justify-content","left","letter-spacing","line-break","line-height","list-style","list-style-image","list-style-position","list-style-type","margin","margin-block","margin-block-end","margin-block-start","margin-bottom","margin-inline","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","marks","mask","mask-border","mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width","mask-clip","mask-composite","mask-image","mask-mode","mask-origin","mask-position","mask-repeat","mask-size","mask-type","max-block-size","max-height","max-inline-size","max-width","min-block-size","min-height","min-inline-size","min-width","mix-blend-mode","nav-down","nav-index","nav-left","nav-right","nav-up","none","normal","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-wrap","overflow-x","overflow-y","padding","padding-block","padding-block-end","padding-block-start","padding-bottom","padding-inline","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","pause","pause-after","pause-before","perspective","perspective-origin","pointer-events","position","quotes","resize","rest","rest-after","rest-before","right","row-gap","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-align","scroll-snap-stop","scroll-snap-type","scrollbar-color","scrollbar-gutter","scrollbar-width","shape-image-threshold","shape-margin","shape-outside","speak","speak-as","src","tab-size","table-layout","text-align","text-align-all","text-align-last","text-combine-upright","text-decoration","text-decoration-color","text-decoration-line","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-indent","text-justify","text-orientation","text-overflow","text-rendering","text-shadow","text-transform","text-underline-position","top","transform","transform-box","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","writing-mode","z-index"].reverse(),uL=aL.concat(lL);const dL=["a","abbr","address","article","aside","audio","b","blockquote","body","button","canvas","caption","cite","code","dd","del","details","dfn","div","dl","dt","em","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","html","i","iframe","img","input","ins","kbd","label","legend","li","main","mark","menu","nav","object","ol","p","q","quote","samp","section","span","strong","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","ul","var","video"],hL=["any-hover","any-pointer","aspect-ratio","color","color-gamut","color-index","device-aspect-ratio","device-height","device-width","display-mode","forced-colors","grid","height","hover","inverted-colors","monochrome","orientation","overflow-block","overflow-inline","pointer","prefers-color-scheme","prefers-contrast","prefers-reduced-motion","prefers-reduced-transparency","resolution","scan","scripting","update","width","min-width","max-width","min-height","max-height"],pL=["active","any-link","blank","checked","current","default","defined","dir","disabled","drop","empty","enabled","first","first-child","first-of-type","fullscreen","future","focus","focus-visible","focus-within","has","host","host-context","hover","indeterminate","in-range","invalid","is","lang","last-child","last-of-type","left","link","local-link","not","nth-child","nth-col","nth-last-child","nth-last-col","nth-last-of-type","nth-of-type","only-child","only-of-type","optional","out-of-range","past","placeholder-shown","read-only","read-write","required","right","root","scope","target","target-within","user-invalid","valid","visited","where"],fL=["after","backdrop","before","cue","cue-region","first-letter","first-line","grammar-error","marker","part","placeholder","selection","slotted","spelling-error"],mL=["align-content","align-items","align-self","all","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","backface-visibility","background","background-attachment","background-blend-mode","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","block-size","border","border-block","border-block-color","border-block-end","border-block-end-color","border-block-end-style","border-block-end-width","border-block-start","border-block-start-color","border-block-start-style","border-block-start-width","border-block-style","border-block-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-inline","border-inline-color","border-inline-end","border-inline-end-color","border-inline-end-style","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-style","border-inline-start-width","border-inline-style","border-inline-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","caret-color","clear","clip","clip-path","clip-rule","color","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","contain","content","content-visibility","counter-increment","counter-reset","cue","cue-after","cue-before","cursor","direction","display","empty-cells","filter","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","flow","font","font-display","font-family","font-feature-settings","font-kerning","font-language-override","font-size","font-size-adjust","font-smoothing","font-stretch","font-style","font-synthesis","font-variant","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-variation-settings","font-weight","gap","glyph-orientation-vertical","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-gap","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","ime-mode","inline-size","isolation","justify-content","left","letter-spacing","line-break","line-height","list-style","list-style-image","list-style-position","list-style-type","margin","margin-block","margin-block-end","margin-block-start","margin-bottom","margin-inline","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","marks","mask","mask-border","mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width","mask-clip","mask-composite","mask-image","mask-mode","mask-origin","mask-position","mask-repeat","mask-size","mask-type","max-block-size","max-height","max-inline-size","max-width","min-block-size","min-height","min-inline-size","min-width","mix-blend-mode","nav-down","nav-index","nav-left","nav-right","nav-up","none","normal","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-wrap","overflow-x","overflow-y","padding","padding-block","padding-block-end","padding-block-start","padding-bottom","padding-inline","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","page-break-after","page-break-before","page-break-inside","pause","pause-after","pause-before","perspective","perspective-origin","pointer-events","position","quotes","resize","rest","rest-after","rest-before","right","row-gap","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-align","scroll-snap-stop","scroll-snap-type","scrollbar-color","scrollbar-gutter","scrollbar-width","shape-image-threshold","shape-margin","shape-outside","speak","speak-as","src","tab-size","table-layout","text-align","text-align-all","text-align-last","text-combine-upright","text-decoration","text-decoration-color","text-decoration-line","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-indent","text-justify","text-orientation","text-overflow","text-rendering","text-shadow","text-transform","text-underline-position","top","transform","transform-box","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","writing-mode","z-index"].reverse();function gL(e){return e?"string"==typeof e?e:e.source:null}function vL(e){return yL("(?=",e,")")}function yL(...e){return e.map((e=>gL(e))).join("")}function bL(...e){const t=function(e){const t=e[e.length-1];return "object"==typeof t&&t.constructor===Object?(e.splice(e.length-1,1),t):{}}(e);return "("+(t.capture?"":"?:")+e.map((e=>gL(e))).join("|")+")"}const wL=e=>yL(/\b/,e,/\w$/.test(e)?/\b/:/\B/),kL=["Protocol","Type"].map(wL),CL=["init","self"].map(wL),EL=["Any","Self"],xL=["actor","any","associatedtype","async","await",/as\?/,/as!/,"as","break","case","catch","class","continue","convenience","default","defer","deinit","didSet","distributed","do","dynamic","else","enum","extension","fallthrough",/fileprivate\(set\)/,"fileprivate","final","for","func","get","guard","if","import","indirect","infix",/init\?/,/init!/,"inout",/internal\(set\)/,"internal","in","is","isolated","nonisolated","lazy","let","mutating","nonmutating",/open\(set\)/,"open","operator","optional","override","postfix","precedencegroup","prefix",/private\(set\)/,"private","protocol",/public\(set\)/,"public","repeat","required","rethrows","return","set","some","static","struct","subscript","super","switch","throws","throw",/try\?/,/try!/,"try","typealias",/unowned\(safe\)/,/unowned\(unsafe\)/,"unowned","var","weak","where","while","willSet"],SL=["false","nil","true"],DL=["assignment","associativity","higherThan","left","lowerThan","none","right"],ML=["#colorLiteral","#column","#dsohandle","#else","#elseif","#endif","#error","#file","#fileID","#fileLiteral","#filePath","#function","#if","#imageLiteral","#keyPath","#line","#selector","#sourceLocation","#warn_unqualified_access","#warning"],OL=["abs","all","any","assert","assertionFailure","debugPrint","dump","fatalError","getVaList","isKnownUniquelyReferenced","max","min","numericCast","pointwiseMax","pointwiseMin","precondition","preconditionFailure","print","readLine","repeatElement","sequence","stride","swap","swift_unboxFromSwiftValueWithType","transcode","type","unsafeBitCast","unsafeDowncast","withExtendedLifetime","withUnsafeMutablePointer","withUnsafePointer","withVaList","withoutActuallyEscaping","zip"],AL=bL(/[/=\-+!*%<>&|^~?]/,/[\u00A1-\u00A7]/,/[\u00A9\u00AB]/,/[\u00AC\u00AE]/,/[\u00B0\u00B1]/,/[\u00B6\u00BB\u00BF\u00D7\u00F7]/,/[\u2016-\u2017]/,/[\u2020-\u2027]/,/[\u2030-\u203E]/,/[\u2041-\u2053]/,/[\u2055-\u205E]/,/[\u2190-\u23FF]/,/[\u2500-\u2775]/,/[\u2794-\u2BFF]/,/[\u2E00-\u2E7F]/,/[\u3001-\u3003]/,/[\u3008-\u3020]/,/[\u3030]/),NL=bL(AL,/[\u0300-\u036F]/,/[\u1DC0-\u1DFF]/,/[\u20D0-\u20FF]/,/[\uFE00-\uFE0F]/,/[\uFE20-\uFE2F]/),_L=yL(AL,NL,"*"),TL=bL(/[a-zA-Z_]/,/[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,/[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,/[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,/[\u1E00-\u1FFF]/,/[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,/[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,/[\u2C00-\u2DFF\u2E80-\u2FFF]/,/[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,/[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,/[\uFE47-\uFEFE\uFF00-\uFFFD]/),LL=bL(TL,/\d/,/[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),RL=yL(TL,LL,"*"),FL=yL(/[A-Z]/,LL,"*"),BL=["autoclosure",yL(/convention\(/,bL("swift","block","c"),/\)/),"discardableResult","dynamicCallable","dynamicMemberLookup","escaping","frozen","GKInspectable","IBAction","IBDesignable","IBInspectable","IBOutlet","IBSegueAction","inlinable","main","nonobjc","NSApplicationMain","NSCopying","NSManaged",yL(/objc\(/,RL,/\)/),"objc","objcMembers","propertyWrapper","requires_stored_property_inits","resultBuilder","testable","UIApplicationMain","unknown","usableFromInline"],IL=["iOS","iOSApplicationExtension","macOS","macOSApplicationExtension","macCatalyst","macCatalystApplicationExtension","watchOS","watchOSApplicationExtension","tvOS","tvOSApplicationExtension","swift"];const PL="[A-Za-z$_][0-9A-Za-z$_]*",zL=["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends"],$L=["true","false","null","undefined","NaN","Infinity"],jL=["Object","Function","Boolean","Symbol","Math","Date","Number","BigInt","String","RegExp","Array","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Int32Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Set","Map","WeakSet","WeakMap","ArrayBuffer","SharedArrayBuffer","Atomics","DataView","JSON","Promise","Generator","GeneratorFunction","AsyncFunction","Reflect","Proxy","Intl","WebAssembly"],HL=["Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],VL=["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],KL=["arguments","this","super","console","window","document","localStorage","module","global"],qL=[].concat(VL,jL,HL);function UL(e){const t=e.regex,n=PL,r="<>",i="</>",o={begin:/<[A-Za-z0-9\\._:-]+/,end:/\/[A-Za-z0-9\\._:-]+>|\/>/,isTrulyOpeningTag:(e,t)=>{const n=e[0].length+e.index,r=e.input[n];if("<"===r||","===r)return void t.ignoreMatch();let i;">"===r&&(((e,{after:t})=>{const n="</"+e[0].slice(1);return -1!==e.input.indexOf(n,t)})(e,{after:n})||t.ignoreMatch());(i=e.input.substring(n).match(/^\s+extends\s+/))&&0===i.index&&t.ignoreMatch();}},s={$pattern:PL,keyword:zL,literal:$L,built_in:qL,"variable.language":KL},a="\\.([0-9](_?[0-9])*)",l="0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",c={className:"number",variants:[{begin:`(\\b(${l})((${a})|\\.)?|(${a}))[eE][+-]?([0-9](_?[0-9])*)\\b`},{begin:`\\b(${l})\\b((${a})\\b|\\.)?|(${a})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0},u={className:"subst",begin:"\\$\\{",end:"\\}",keywords:s,contains:[]},d={begin:"html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"xml"}},h={begin:"css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"css"}},p={className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,u]},f={className:"comment",variants:[e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:n+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]},m=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,h,p,c];u.contains=m.concat({begin:/\{/,end:/\}/,keywords:s,contains:["self"].concat(m)});const g=[].concat(f,u.contains),v=g.concat([{begin:/\(/,end:/\)/,keywords:s,contains:["self"].concat(g)}]),y={className:"params",begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:s,contains:v},b={variants:[{match:[/class/,/\s+/,n,/\s+/,/extends/,/\s+/,t.concat(n,"(",t.concat(/\./,n),")*")],scope:{1:"keyword",3:"title.class",5:"keyword",7:"title.class.inherited"}},{match:[/class/,/\s+/,n],scope:{1:"keyword",3:"title.class"}}]},w={relevance:0,match:t.either(/\bJSON/,/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),className:"title.class",keywords:{_:[...jL,...HL]}},k={variants:[{match:[/function/,/\s+/,n,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[y],illegal:/%/};const C={match:t.concat(/\b/,(E=[...VL,"super"],t.concat("(?!",E.join("|"),")")),n,t.lookahead(/\(/)),className:"title.function",relevance:0};var E;const x={begin:t.concat(/\./,t.lookahead(t.concat(n,/(?![0-9A-Za-z$_(])/))),end:n,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},S={match:[/get|set/,/\s+/,n,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},y]},D="(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=>",M={match:[/const|var|let/,/\s+/,n,/\s*/,/=\s*/,/(async\s*)?/,t.lookahead(D)],keywords:"async",className:{1:"keyword",3:"title.function"},contains:[y]};return {name:"Javascript",aliases:["js","jsx","mjs","cjs"],keywords:s,exports:{PARAMS_CONTAINS:v,CLASS_REFERENCE:w},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),{label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,h,p,f,c,w,{className:"attr",begin:n+t.lookahead(":"),relevance:0},M,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[f,e.REGEXP_MODE,{className:"function",begin:D,returnBegin:!0,end:"\\s*=>",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:s,contains:v}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:r,end:i},{match:/<[A-Za-z0-9\\._:-]+\s*\/>/},{begin:o.begin,"on:begin":o.isTrulyOpeningTag,end:o.end}],subLanguage:"xml",contains:[{begin:o.begin,end:o.end,skip:!0,contains:["self"]}]}]},k,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[y,e.inherit(e.TITLE_MODE,{begin:n,className:"title.function"})]},{match:/\.\.\./,relevance:0},x,{match:"\\$"+n,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[y]},C,{relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"},b,S,{match:/\$[(.]/}]}}var WL={exports:{}};function GL(e){return e instanceof Map?e.clear=e.delete=e.set=function(){throw new Error("map is read-only")}:e instanceof Set&&(e.add=e.clear=e.delete=function(){throw new Error("set is read-only")}),Object.freeze(e),Object.getOwnPropertyNames(e).forEach((function(t){var n=e[t];"object"!=typeof n||Object.isFrozen(n)||GL(n);})),e}WL.exports=GL,WL.exports.default=GL;class JL{constructor(e){void 0===e.data&&(e.data={}),this.data=e.data,this.isMatchIgnored=!1;}ignoreMatch(){this.isMatchIgnored=!0;}}function ZL(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function XL(e,...t){const n=Object.create(null);for(const t in e)n[t]=e[t];return t.forEach((function(e){for(const t in e)n[t]=e[t];})),n}const QL=e=>!!e.scope||e.sublanguage&&e.language;class YL{constructor(e,t){this.buffer="",this.classPrefix=t.classPrefix,e.walk(this);}addText(e){this.buffer+=ZL(e);}openNode(e){if(!QL(e))return;let t="";t=e.sublanguage?`language-${e.language}`:((e,{prefix:t})=>{if(e.includes(".")){const n=e.split(".");return [`${t}${n.shift()}`,...n.map(((e,t)=>`${e}${"_".repeat(t+1)}`))].join(" ")}return `${t}${e}`})(e.scope,{prefix:this.classPrefix}),this.span(t);}closeNode(e){QL(e)&&(this.buffer+="</span>");}value(){return this.buffer}span(e){this.buffer+=`<span class="${e}">`;}}const eR=(e={})=>{const t={children:[]};return Object.assign(t,e),t};class tR{constructor(){this.rootNode=eR(),this.stack=[this.rootNode];}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){this.top.children.push(e);}openNode(e){const t=eR({scope:e});this.add(t),this.stack.push(t);}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,t){return "string"==typeof t?e.addText(t):t.children&&(e.openNode(t),t.children.forEach((t=>this._walk(e,t))),e.closeNode(t)),e}static _collapse(e){"string"!=typeof e&&e.children&&(e.children.every((e=>"string"==typeof e))?e.children=[e.children.join("")]:e.children.forEach((e=>{tR._collapse(e);})));}}class nR extends tR{constructor(e){super(),this.options=e;}addKeyword(e,t){""!==e&&(this.openNode(t),this.addText(e),this.closeNode());}addText(e){""!==e&&this.add(e);}addSublanguage(e,t){const n=e.root;n.sublanguage=!0,n.language=t,this.add(n);}toHTML(){return new YL(this,this.options).value()}finalize(){return !0}}function rR(e){return e?"string"==typeof e?e:e.source:null}function iR(e){return aR("(?=",e,")")}function oR(e){return aR("(?:",e,")*")}function sR(e){return aR("(?:",e,")?")}function aR(...e){return e.map((e=>rR(e))).join("")}function lR(...e){const t=function(e){const t=e[e.length-1];return "object"==typeof t&&t.constructor===Object?(e.splice(e.length-1,1),t):{}}(e);return "("+(t.capture?"":"?:")+e.map((e=>rR(e))).join("|")+")"}function cR(e){return new RegExp(e.toString()+"|").exec("").length-1}const uR=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function dR(e,{joinWith:t}){let n=0;return e.map((e=>{n+=1;const t=n;let r=rR(e),i="";for(;r.length>0;){const e=uR.exec(r);if(!e){i+=r;break}i+=r.substring(0,e.index),r=r.substring(e.index+e[0].length),"\\"===e[0][0]&&e[1]?i+="\\"+String(Number(e[1])+t):(i+=e[0],"("===e[0]&&n++);}return i})).map((e=>`(${e})`)).join(t)}const hR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",pR={begin:"\\\\[\\s\\S]",relevance:0},fR={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[pR]},mR={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[pR]},gR=function(e,t,n={}){const r=XL({scope:"comment",begin:e,end:t,contains:[]},n);r.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});const i=lR("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return r.contains.push({begin:aR(/[ ]+/,"(",i,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),r},vR=gR("//","$"),yR=gR("/\\*","\\*/"),bR=gR("#","$"),wR={scope:"number",begin:"\\b\\d+(\\.\\d+)?",relevance:0},kR={scope:"number",begin:hR,relevance:0},CR={scope:"number",begin:"\\b(0b[01]+)",relevance:0},ER={begin:/(?=\/[^/\n]*\/)/,contains:[{scope:"regexp",begin:/\//,end:/\/[gimuy]*/,illegal:/\n/,contains:[pR,{begin:/\[/,end:/\]/,relevance:0,contains:[pR]}]}]},xR={scope:"title",begin:"[a-zA-Z]\\w*",relevance:0},SR={scope:"title",begin:"[a-zA-Z_]\\w*",relevance:0},DR={begin:"\\.\\s*[a-zA-Z_]\\w*",relevance:0};var MR=Object.freeze({__proto__:null,MATCH_NOTHING_RE:/\b\B/,IDENT_RE:"[a-zA-Z]\\w*",UNDERSCORE_IDENT_RE:"[a-zA-Z_]\\w*",NUMBER_RE:"\\b\\d+(\\.\\d+)?",C_NUMBER_RE:hR,BINARY_NUMBER_RE:"\\b(0b[01]+)",RE_STARTERS_RE:"!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",SHEBANG:(e={})=>{const t=/^#![ ]*\//;return e.binary&&(e.begin=aR(t,/.*\b/,e.binary,/\b.*/)),XL({scope:"meta",begin:t,end:/$/,relevance:0,"on:begin":(e,t)=>{0!==e.index&&t.ignoreMatch();}},e)},BACKSLASH_ESCAPE:pR,APOS_STRING_MODE:fR,QUOTE_STRING_MODE:mR,PHRASAL_WORDS_MODE:{begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},COMMENT:gR,C_LINE_COMMENT_MODE:vR,C_BLOCK_COMMENT_MODE:yR,HASH_COMMENT_MODE:bR,NUMBER_MODE:wR,C_NUMBER_MODE:kR,BINARY_NUMBER_MODE:CR,REGEXP_MODE:ER,TITLE_MODE:xR,UNDERSCORE_TITLE_MODE:SR,METHOD_GUARD:DR,END_SAME_AS_BEGIN:function(e){return Object.assign(e,{"on:begin":(e,t)=>{t.data._beginMatch=e[1];},"on:end":(e,t)=>{t.data._beginMatch!==e[1]&&t.ignoreMatch();}})}});function OR(e,t){"."===e.input[e.index-1]&&t.ignoreMatch();}function AR(e,t){void 0!==e.className&&(e.scope=e.className,delete e.className);}function NR(e,t){t&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",e.__beforeBegin=OR,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,void 0===e.relevance&&(e.relevance=0));}function _R(e,t){Array.isArray(e.illegal)&&(e.illegal=lR(...e.illegal));}function TR(e,t){if(e.match){if(e.begin||e.end)throw new Error("begin & end are not supported with match");e.begin=e.match,delete e.match;}}function LR(e,t){void 0===e.relevance&&(e.relevance=1);}const RR=(e,t)=>{if(!e.beforeMatch)return;if(e.starts)throw new Error("beforeMatch cannot be used with starts");const n=Object.assign({},e);Object.keys(e).forEach((t=>{delete e[t];})),e.keywords=n.keywords,e.begin=aR(n.beforeMatch,iR(n.begin)),e.starts={relevance:0,contains:[Object.assign(n,{endsParent:!0})]},e.relevance=0,delete n.beforeMatch;},FR=["of","and","for","in","not","or","if","then","parent","list","value"];function BR(e,t,n="keyword"){const r=Object.create(null);return "string"==typeof e?i(n,e.split(" ")):Array.isArray(e)?i(n,e):Object.keys(e).forEach((function(n){Object.assign(r,BR(e[n],t,n));})),r;function i(e,n){t&&(n=n.map((e=>e.toLowerCase()))),n.forEach((function(t){const n=t.split("|");r[n[0]]=[e,IR(n[0],n[1])];}));}}function IR(e,t){return t?Number(t):function(e){return FR.includes(e.toLowerCase())}(e)?0:1}const PR={},zR=e=>{console.error(e);},$R=(e,...t)=>{console.log(`WARN: ${e}`,...t);},jR=(e,t)=>{PR[`${e}/${t}`]||(console.log(`Deprecated as of ${e}. ${t}`),PR[`${e}/${t}`]=!0);},HR=new Error;function VR(e,t,{key:n}){let r=0;const i=e[n],o={},s={};for(let e=1;e<=t.length;e++)s[e+r]=i[e],o[e+r]=!0,r+=cR(t[e-1]);e[n]=s,e[n]._emit=o,e[n]._multi=!0;}function KR(e){!function(e){e.scope&&"object"==typeof e.scope&&null!==e.scope&&(e.beginScope=e.scope,delete e.scope);}(e),"string"==typeof e.beginScope&&(e.beginScope={_wrap:e.beginScope}),"string"==typeof e.endScope&&(e.endScope={_wrap:e.endScope}),function(e){if(Array.isArray(e.begin)){if(e.skip||e.excludeBegin||e.returnBegin)throw zR("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),HR;if("object"!=typeof e.beginScope||null===e.beginScope)throw zR("beginScope must be object"),HR;VR(e,e.begin,{key:"beginScope"}),e.begin=dR(e.begin,{joinWith:""});}}(e),function(e){if(Array.isArray(e.end)){if(e.skip||e.excludeEnd||e.returnEnd)throw zR("skip, excludeEnd, returnEnd not compatible with endScope: {}"),HR;if("object"!=typeof e.endScope||null===e.endScope)throw zR("endScope must be object"),HR;VR(e,e.end,{key:"endScope"}),e.end=dR(e.end,{joinWith:""});}}(e);}function qR(e){function t(t,n){return new RegExp(rR(t),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(n?"g":""))}class n{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0;}addRule(e,t){t.position=this.position++,this.matchIndexes[this.matchAt]=t,this.regexes.push([t,e]),this.matchAt+=cR(e)+1;}compile(){0===this.regexes.length&&(this.exec=()=>null);const e=this.regexes.map((e=>e[1]));this.matcherRe=t(dR(e,{joinWith:"|"}),!0),this.lastIndex=0;}exec(e){this.matcherRe.lastIndex=this.lastIndex;const t=this.matcherRe.exec(e);if(!t)return null;const n=t.findIndex(((e,t)=>t>0&&void 0!==e)),r=this.matchIndexes[n];return t.splice(0,n),Object.assign(t,r)}}class r{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0;}getMatcher(e){if(this.multiRegexes[e])return this.multiRegexes[e];const t=new n;return this.rules.slice(e).forEach((([e,n])=>t.addRule(e,n))),t.compile(),this.multiRegexes[e]=t,t}resumingScanAtSamePosition(){return 0!==this.regexIndex}considerAll(){this.regexIndex=0;}addRule(e,t){this.rules.push([e,t]),"begin"===t.type&&this.count++;}exec(e){const t=this.getMatcher(this.regexIndex);t.lastIndex=this.lastIndex;let n=t.exec(e);if(this.resumingScanAtSamePosition())if(n&&n.index===this.lastIndex);else {const t=this.getMatcher(0);t.lastIndex=this.lastIndex+1,n=t.exec(e);}return n&&(this.regexIndex+=n.position+1,this.regexIndex===this.count&&this.considerAll()),n}}if(e.compilerExtensions||(e.compilerExtensions=[]),e.contains&&e.contains.includes("self"))throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return e.classNameAliases=XL(e.classNameAliases||{}),function n(i,o){const s=i;if(i.isCompiled)return s;[AR,TR,KR,RR].forEach((e=>e(i,o))),e.compilerExtensions.forEach((e=>e(i,o))),i.__beforeBegin=null,[NR,_R,LR].forEach((e=>e(i,o))),i.isCompiled=!0;let a=null;return "object"==typeof i.keywords&&i.keywords.$pattern&&(i.keywords=Object.assign({},i.keywords),a=i.keywords.$pattern,delete i.keywords.$pattern),a=a||/\w+/,i.keywords&&(i.keywords=BR(i.keywords,e.case_insensitive)),s.keywordPatternRe=t(a,!0),o&&(i.begin||(i.begin=/\B|\b/),s.beginRe=t(s.begin),i.end||i.endsWithParent||(i.end=/\B|\b/),i.end&&(s.endRe=t(s.end)),s.terminatorEnd=rR(s.end)||"",i.endsWithParent&&o.terminatorEnd&&(s.terminatorEnd+=(i.end?"|":"")+o.terminatorEnd)),i.illegal&&(s.illegalRe=t(i.illegal)),i.contains||(i.contains=[]),i.contains=[].concat(...i.contains.map((function(e){return function(e){e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map((function(t){return XL(e,{variants:null},t)})));if(e.cachedVariants)return e.cachedVariants;if(UR(e))return XL(e,{starts:e.starts?XL(e.starts):null});if(Object.isFrozen(e))return XL(e);return e}("self"===e?i:e)}))),i.contains.forEach((function(e){n(e,s);})),i.starts&&n(i.starts,o),s.matcher=function(e){const t=new r;return e.contains.forEach((e=>t.addRule(e.begin,{rule:e,type:"begin"}))),e.terminatorEnd&&t.addRule(e.terminatorEnd,{type:"end"}),e.illegal&&t.addRule(e.illegal,{type:"illegal"}),t}(s),s}(e)}function UR(e){return !!e&&(e.endsWithParent||UR(e.starts))}class WR extends Error{constructor(e,t){super(e),this.name="HTMLInjectionError",this.html=t;}}const GR=ZL,JR=XL,ZR=Symbol("nomatch");var XR=function(e){const t=Object.create(null),n=Object.create(null),r=[];let i=!0;const o="Could not find the language '{}', did you forget to load/include a language module?",s={disableAutodetect:!0,name:"Plain text",contains:[]};let a={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:nR};function l(e){return a.noHighlightRe.test(e)}function c(e,t,n){let r="",i="";"object"==typeof t?(r=e,n=t.ignoreIllegals,i=t.language):(jR("10.7.0","highlight(lang, code, ...args) has been deprecated."),jR("10.7.0","Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),i=e,r=t),void 0===n&&(n=!0);const o={code:r,language:i};y("before:highlight",o);const s=o.result?o.result:u(o.language,o.code,n);return s.code=o.code,y("after:highlight",s),s}function u(e,n,r,s){const l=Object.create(null);function c(){if(!x.keywords)return void D.addText(M);let e=0;x.keywordPatternRe.lastIndex=0;let t=x.keywordPatternRe.exec(M),n="";for(;t;){n+=M.substring(e,t.index);const i=k.case_insensitive?t[0].toLowerCase():t[0],o=(r=i,x.keywords[r]);if(o){const[e,r]=o;if(D.addText(n),n="",l[i]=(l[i]||0)+1,l[i]<=7&&(O+=r),e.startsWith("_"))n+=t[0];else {const n=k.classNameAliases[e]||e;D.addKeyword(t[0],n);}}else n+=t[0];e=x.keywordPatternRe.lastIndex,t=x.keywordPatternRe.exec(M);}var r;n+=M.substring(e),D.addText(n);}function h(){null!=x.subLanguage?function(){if(""===M)return;let e=null;if("string"==typeof x.subLanguage){if(!t[x.subLanguage])return void D.addText(M);e=u(x.subLanguage,M,!0,S[x.subLanguage]),S[x.subLanguage]=e._top;}else e=d(M,x.subLanguage.length?x.subLanguage:null);x.relevance>0&&(O+=e.relevance),D.addSublanguage(e._emitter,e.language);}():c(),M="";}function p(e,t){let n=1;const r=t.length-1;for(;n<=r;){if(!e._emit[n]){n++;continue}const r=k.classNameAliases[e[n]]||e[n],i=t[n];r?D.addKeyword(i,r):(M=i,c(),M=""),n++;}}function f(e,t){return e.scope&&"string"==typeof e.scope&&D.openNode(k.classNameAliases[e.scope]||e.scope),e.beginScope&&(e.beginScope._wrap?(D.addKeyword(M,k.classNameAliases[e.beginScope._wrap]||e.beginScope._wrap),M=""):e.beginScope._multi&&(p(e.beginScope,t),M="")),x=Object.create(e,{parent:{value:x}}),x}function g(e,t,n){let r=function(e,t){const n=e&&e.exec(t);return n&&0===n.index}(e.endRe,n);if(r){if(e["on:end"]){const n=new JL(e);e["on:end"](t,n),n.isMatchIgnored&&(r=!1);}if(r){for(;e.endsParent&&e.parent;)e=e.parent;return e}}if(e.endsWithParent)return g(e.parent,t,n)}function v(e){return 0===x.matcher.regexIndex?(M+=e[0],1):(_=!0,0)}function y(e){const t=e[0],r=n.substring(e.index),i=g(x,e,r);if(!i)return ZR;const o=x;x.endScope&&x.endScope._wrap?(h(),D.addKeyword(t,x.endScope._wrap)):x.endScope&&x.endScope._multi?(h(),p(x.endScope,e)):o.skip?M+=t:(o.returnEnd||o.excludeEnd||(M+=t),h(),o.excludeEnd&&(M=t));do{x.scope&&D.closeNode(),x.skip||x.subLanguage||(O+=x.relevance),x=x.parent;}while(x!==i.parent);return i.starts&&f(i.starts,e),o.returnEnd?0:t.length}let b={};function w(t,o){const s=o&&o[0];if(M+=t,null==s)return h(),0;if("begin"===b.type&&"end"===o.type&&b.index===o.index&&""===s){if(M+=n.slice(o.index,o.index+1),!i){const t=new Error(`0 width match regex (${e})`);throw t.languageName=e,t.badRule=b.rule,t}return 1}if(b=o,"begin"===o.type)return function(e){const t=e[0],n=e.rule,r=new JL(n),i=[n.__beforeBegin,n["on:begin"]];for(const n of i)if(n&&(n(e,r),r.isMatchIgnored))return v(t);return n.skip?M+=t:(n.excludeBegin&&(M+=t),h(),n.returnBegin||n.excludeBegin||(M=t)),f(n,e),n.returnBegin?0:t.length}(o);if("illegal"===o.type&&!r){const e=new Error('Illegal lexeme "'+s+'" for mode "'+(x.scope||"<unnamed>")+'"');throw e.mode=x,e}if("end"===o.type){const e=y(o);if(e!==ZR)return e}if("illegal"===o.type&&""===s)return 1;if(N>1e5&&N>3*o.index){throw new Error("potential infinite loop, way more iterations than matches")}return M+=s,s.length}const k=m(e);if(!k)throw zR(o.replace("{}",e)),new Error('Unknown language: "'+e+'"');const C=qR(k);let E="",x=s||C;const S={},D=new a.__emitter(a);!function(){const e=[];for(let t=x;t!==k;t=t.parent)t.scope&&e.unshift(t.scope);e.forEach((e=>D.openNode(e)));}();let M="",O=0,A=0,N=0,_=!1;try{for(x.matcher.considerAll();;){N++,_?_=!1:x.matcher.considerAll(),x.matcher.lastIndex=A;const e=x.matcher.exec(n);if(!e)break;const t=w(n.substring(A,e.index),e);A=e.index+t;}return w(n.substring(A)),D.closeAllNodes(),D.finalize(),E=D.toHTML(),{language:e,value:E,relevance:O,illegal:!1,_emitter:D,_top:x}}catch(t){if(t.message&&t.message.includes("Illegal"))return {language:e,value:GR(n),illegal:!0,relevance:0,_illegalBy:{message:t.message,index:A,context:n.slice(A-100,A+100),mode:t.mode,resultSoFar:E},_emitter:D};if(i)return {language:e,value:GR(n),illegal:!1,relevance:0,errorRaised:t,_emitter:D,_top:x};throw t}}function d(e,n){n=n||a.languages||Object.keys(t);const r=function(e){const t={value:GR(e),illegal:!1,relevance:0,_top:s,_emitter:new a.__emitter(a)};return t._emitter.addText(e),t}(e),i=n.filter(m).filter(v).map((t=>u(t,e,!1)));i.unshift(r);const o=i.sort(((e,t)=>{if(e.relevance!==t.relevance)return t.relevance-e.relevance;if(e.language&&t.language){if(m(e.language).supersetOf===t.language)return 1;if(m(t.language).supersetOf===e.language)return -1}return 0})),[l,c]=o,d=l;return d.secondBest=c,d}function h(e){let t=null;const r=function(e){let t=e.className+" ";t+=e.parentNode?e.parentNode.className:"";const n=a.languageDetectRe.exec(t);if(n){const t=m(n[1]);return t||($R(o.replace("{}",n[1])),$R("Falling back to no-highlight mode for this block.",e)),t?n[1]:"no-highlight"}return t.split(/\s+/).find((e=>l(e)||m(e)))}(e);if(l(r))return;if(y("before:highlightElement",{el:e,language:r}),e.children.length>0&&(a.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(e)),a.throwUnescapedHTML)){throw new WR("One of your code blocks includes unescaped HTML.",e.innerHTML)}t=e;const i=t.textContent,s=r?c(i,{language:r,ignoreIllegals:!0}):d(i);e.innerHTML=s.value,function(e,t,r){const i=t&&n[t]||r;e.classList.add("hljs"),e.classList.add(`language-${i}`);}(e,r,s.language),e.result={language:s.language,re:s.relevance,relevance:s.relevance},s.secondBest&&(e.secondBest={language:s.secondBest.language,relevance:s.secondBest.relevance}),y("after:highlightElement",{el:e,result:s,text:i});}let p=!1;function f(){if("loading"===document.readyState)return void(p=!0);document.querySelectorAll(a.cssSelector).forEach(h);}function m(e){return e=(e||"").toLowerCase(),t[e]||t[n[e]]}function g(e,{languageName:t}){"string"==typeof e&&(e=[e]),e.forEach((e=>{n[e.toLowerCase()]=t;}));}function v(e){const t=m(e);return t&&!t.disableAutodetect}function y(e,t){const n=e;r.forEach((function(e){e[n]&&e[n](t);}));}"undefined"!=typeof window&&window.addEventListener&&window.addEventListener("DOMContentLoaded",(function(){p&&f();}),!1),Object.assign(e,{highlight:c,highlightAuto:d,highlightAll:f,highlightElement:h,highlightBlock:function(e){return jR("10.7.0","highlightBlock will be removed entirely in v12.0"),jR("10.7.0","Please use highlightElement now."),h(e)},configure:function(e){a=JR(a,e);},initHighlighting:()=>{f(),jR("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.");},initHighlightingOnLoad:function(){f(),jR("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.");},registerLanguage:function(n,r){let o=null;try{o=r(e);}catch(e){if(zR("Language definition for '{}' could not be registered.".replace("{}",n)),!i)throw e;zR(e),o=s;}o.name||(o.name=n),t[n]=o,o.rawDefinition=r.bind(null,e),o.aliases&&g(o.aliases,{languageName:n});},unregisterLanguage:function(e){delete t[e];for(const t of Object.keys(n))n[t]===e&&delete n[t];},listLanguages:function(){return Object.keys(t)},getLanguage:m,registerAliases:g,autoDetection:v,inherit:JR,addPlugin:function(e){!function(e){e["before:highlightBlock"]&&!e["before:highlightElement"]&&(e["before:highlightElement"]=t=>{e["before:highlightBlock"](Object.assign({block:t.el},t));}),e["after:highlightBlock"]&&!e["after:highlightElement"]&&(e["after:highlightElement"]=t=>{e["after:highlightBlock"](Object.assign({block:t.el},t));});}(e),r.push(e);}}),e.debugMode=function(){i=!1;},e.safeMode=function(){i=!0;},e.versionString="11.6.0",e.regex={concat:aR,lookahead:iR,either:lR,optional:sR,anyNumberOfTimes:oR};for(const e in MR)"object"==typeof MR[e]&&WL.exports(MR[e]);return Object.assign(e,MR),e}({}),QR=XR;XR.HighlightJS=XR,XR.default=XR;var YR,eF={exports:{}};YR=eF,function(){var e;function t(e){for(var t,n,r,i,o=1,s=[].slice.call(arguments),a=0,l=e.length,c="",u=!1,d=!1,h=function(){return s[o++]},p=function(){for(var n="";/\d/.test(e[a]);)n+=e[a++],t=e[a];return n.length>0?parseInt(n):null};a<l;++a)if(t=e[a],u)switch(u=!1,"."==t?(d=!1,t=e[++a]):"0"==t&&"."==e[a+1]?(d=!0,t=e[a+=2]):d=!0,i=p(),t){case"b":c+=parseInt(h(),10).toString(2);break;case"c":c+="string"==typeof(n=h())||n instanceof String?n:String.fromCharCode(parseInt(n,10));break;case"d":c+=parseInt(h(),10);break;case"f":r=String(parseFloat(h()).toFixed(i||6)),c+=d?r:r.replace(/^0/,"");break;case"j":c+=JSON.stringify(h());break;case"o":c+="0"+parseInt(h(),10).toString(8);break;case"s":c+=h();break;case"x":c+="0x"+parseInt(h(),10).toString(16);break;case"X":c+="0x"+parseInt(h(),10).toString(16).toUpperCase();break;default:c+=t;}else "%"===t?u=!0:c+=t;return c}(e=YR.exports=t).format=t,e.vsprintf=function(e,n){return t.apply(null,[e].concat(n))},"undefined"!=typeof console&&"function"==typeof console.log&&(e.printf=function(){console.log(t.apply(null,arguments));});}();var tF=eF.exports;const nF=Object.assign(rF(Error),{eval:rF(EvalError),range:rF(RangeError),reference:rF(ReferenceError),syntax:rF(SyntaxError),type:rF(TypeError),uri:rF(URIError)});function rF(e){return t.displayName=e.displayName||e.name,t;function t(t,...n){const r=t?tF(t,...n):t;return new e(r)}}const iF={}.hasOwnProperty;function oF(e,t,n={}){let r=n.prefix;if("string"!=typeof e)throw nF("Expected `string` for name, got `%s`",e);if(!QR.getLanguage(e))throw nF("Unknown language: `%s` is not registered",e);if("string"!=typeof t)throw nF("Expected `string` for value, got `%s`",t);null==r&&(r="hljs-"),QR.configure({__emitter:sF,classPrefix:r});const i=QR.highlight(t,{language:e,ignoreIllegals:!0});if(QR.configure({}),i.errorRaised)throw i.errorRaised;return i._emitter.root.data.language=i.language,i._emitter.root.data.relevance=i.relevance,i._emitter.root}class sF{constructor(e){this.options=e,this.root={type:"root",data:{language:null,relevance:0},children:[]},this.stack=[this.root];}addText(e){if(""===e)return;const t=this.stack[this.stack.length-1],n=t.children[t.children.length-1];n&&"text"===n.type?n.value+=e:t.children.push({type:"text",value:e});}addKeyword(e,t){this.openNode(t),this.addText(e),this.closeNode();}addSublanguage(e,t){const n=this.stack[this.stack.length-1],r=e.root.children;t?n.children.push({type:"element",tagName:"span",properties:{className:[t]},children:r}):n.children.push(...r);}openNode(e){const t=e.split(".").map(((e,t)=>t?e+"_".repeat(t):this.options.classPrefix+e)),n={type:"element",tagName:"span",properties:{className:t},children:[]};this.stack[this.stack.length-1].children.push(n),this.stack.push(n);}closeNode(){this.stack.pop();}closeAllNodes(){}finalize(){}toHTML(){return ""}}const aF={highlight:oF,highlightAuto:function(e,t={}){const n=t.subset||QR.listLanguages();t.prefix;let r=-1,i={type:"root",data:{language:null,relevance:0},children:[]};if("string"!=typeof e)throw nF("Expected `string` for value, got `%s`",e);for(;++r<n.length;){const o=n[r];if(!QR.getLanguage(o))continue;const s=oF(o,e,t);s.data.relevance>i.data.relevance&&(i=s);}return i},registerLanguage:function(e,t){QR.registerLanguage(e,t);},registered:function(e){return Boolean(QR.getLanguage(e))},listLanguages:function(){return QR.listLanguages()},registerAlias:function(e,t){if("string"==typeof e)QR.registerAliases(t,{languageName:e});else {let t;for(t in e)iF.call(e,t)&&QR.registerAliases(e[t],{languageName:t});}}};aF.registerLanguage("arduino",(function(e){const t={type:["boolean","byte","word","String"],built_in:["KeyboardController","MouseController","SoftwareSerial","EthernetServer","EthernetClient","LiquidCrystal","RobotControl","GSMVoiceCall","EthernetUDP","EsploraTFT","HttpClient","RobotMotor","WiFiClient","GSMScanner","FileSystem","Scheduler","GSMServer","YunClient","YunServer","IPAddress","GSMClient","GSMModem","Keyboard","Ethernet","Console","GSMBand","Esplora","Stepper","Process","WiFiUDP","GSM_SMS","Mailbox","USBHost","Firmata","PImage","Client","Server","GSMPIN","FileIO","Bridge","Serial","EEPROM","Stream","Mouse","Audio","Servo","File","Task","GPRS","WiFi","Wire","TFT","GSM","SPI","SD"],_hints:["setup","loop","runShellCommandAsynchronously","analogWriteResolution","retrieveCallingNumber","printFirmwareVersion","analogReadResolution","sendDigitalPortPair","noListenOnLocalhost","readJoystickButton","setFirmwareVersion","readJoystickSwitch","scrollDisplayRight","getVoiceCallStatus","scrollDisplayLeft","writeMicroseconds","delayMicroseconds","beginTransmission","getSignalStrength","runAsynchronously","getAsynchronously","listenOnLocalhost","getCurrentCarrier","readAccelerometer","messageAvailable","sendDigitalPorts","lineFollowConfig","countryNameWrite","runShellCommand","readStringUntil","rewindDirectory","readTemperature","setClockDivider","readLightSensor","endTransmission","analogReference","detachInterrupt","countryNameRead","attachInterrupt","encryptionType","readBytesUntil","robotNameWrite","readMicrophone","robotNameRead","cityNameWrite","userNameWrite","readJoystickY","readJoystickX","mouseReleased","openNextFile","scanNetworks","noInterrupts","digitalWrite","beginSpeaker","mousePressed","isActionDone","mouseDragged","displayLogos","noAutoscroll","addParameter","remoteNumber","getModifiers","keyboardRead","userNameRead","waitContinue","processInput","parseCommand","printVersion","readNetworks","writeMessage","blinkVersion","cityNameRead","readMessage","setDataMode","parsePacket","isListening","setBitOrder","beginPacket","isDirectory","motorsWrite","drawCompass","digitalRead","clearScreen","serialEvent","rightToLeft","setTextSize","leftToRight","requestFrom","keyReleased","compassRead","analogWrite","interrupts","WiFiServer","disconnect","playMelody","parseFloat","autoscroll","getPINUsed","setPINUsed","setTimeout","sendAnalog","readSlider","analogRead","beginWrite","createChar","motorsStop","keyPressed","tempoWrite","readButton","subnetMask","debugPrint","macAddress","writeGreen","randomSeed","attachGPRS","readString","sendString","remotePort","releaseAll","mouseMoved","background","getXChange","getYChange","answerCall","getResult","voiceCall","endPacket","constrain","getSocket","writeJSON","getButton","available","connected","findUntil","readBytes","exitValue","readGreen","writeBlue","startLoop","IPAddress","isPressed","sendSysex","pauseMode","gatewayIP","setCursor","getOemKey","tuneWrite","noDisplay","loadImage","switchPIN","onRequest","onReceive","changePIN","playFile","noBuffer","parseInt","overflow","checkPIN","knobRead","beginTFT","bitClear","updateIR","bitWrite","position","writeRGB","highByte","writeRed","setSpeed","readBlue","noStroke","remoteIP","transfer","shutdown","hangCall","beginSMS","endWrite","attached","maintain","noCursor","checkReg","checkPUK","shiftOut","isValid","shiftIn","pulseIn","connect","println","localIP","pinMode","getIMEI","display","noBlink","process","getBand","running","beginSD","drawBMP","lowByte","setBand","release","bitRead","prepare","pointTo","readRed","setMode","noFill","remove","listen","stroke","detach","attach","noTone","exists","buffer","height","bitSet","circle","config","cursor","random","IRread","setDNS","endSMS","getKey","micros","millis","begin","print","write","ready","flush","width","isPIN","blink","clear","press","mkdir","rmdir","close","point","yield","image","BSSID","click","delay","read","text","move","peek","beep","rect","line","open","seek","fill","size","turn","stop","home","find","step","tone","sqrt","RSSI","SSID","end","bit","tan","cos","sin","pow","map","abs","max","min","get","run","put"],literal:["DIGITAL_MESSAGE","FIRMATA_STRING","ANALOG_MESSAGE","REPORT_DIGITAL","REPORT_ANALOG","INPUT_PULLUP","SET_PIN_MODE","INTERNAL2V56","SYSTEM_RESET","LED_BUILTIN","INTERNAL1V1","SYSEX_START","INTERNAL","EXTERNAL","DEFAULT","OUTPUT","INPUT","HIGH","LOW"]},n=function(e){const t=e.regex,n=e.COMMENT("//","$",{contains:[{begin:/\\\n/}]}),r="decltype\\(auto\\)",i="[a-zA-Z_]\\w*::",o="(?!struct)(decltype\\(auto\\)|"+t.optional(i)+"[a-zA-Z_]\\w*"+t.optional("<[^<>]+>")+")",s={className:"type",begin:"\\b[a-z\\d_]*_t\\b"},a={className:"string",variants:[{begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",end:"'",illegal:"."},e.END_SAME_AS_BEGIN({begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},l={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},c={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},e.inherit(a,{className:"string"}),{className:"string",begin:/<.*?>/},n,e.C_BLOCK_COMMENT_MODE]},u={className:"title",begin:t.optional(i)+e.IDENT_RE,relevance:0},d=t.optional(i)+e.IDENT_RE+"\\s*\\(",h={type:["bool","char","char16_t","char32_t","char8_t","double","float","int","long","short","void","wchar_t","unsigned","signed","const","static"],keyword:["alignas","alignof","and","and_eq","asm","atomic_cancel","atomic_commit","atomic_noexcept","auto","bitand","bitor","break","case","catch","class","co_await","co_return","co_yield","compl","concept","const_cast|10","consteval","constexpr","constinit","continue","decltype","default","delete","do","dynamic_cast|10","else","enum","explicit","export","extern","false","final","for","friend","goto","if","import","inline","module","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","override","private","protected","public","reflexpr","register","reinterpret_cast|10","requires","return","sizeof","static_assert","static_cast|10","struct","switch","synchronized","template","this","thread_local","throw","transaction_safe","transaction_safe_dynamic","true","try","typedef","typeid","typename","union","using","virtual","volatile","while","xor","xor_eq"],literal:["NULL","false","nullopt","nullptr","true"],built_in:["_Pragma"],_type_hints:["any","auto_ptr","barrier","binary_semaphore","bitset","complex","condition_variable","condition_variable_any","counting_semaphore","deque","false_type","future","imaginary","initializer_list","istringstream","jthread","latch","lock_guard","multimap","multiset","mutex","optional","ostringstream","packaged_task","pair","promise","priority_queue","queue","recursive_mutex","recursive_timed_mutex","scoped_lock","set","shared_future","shared_lock","shared_mutex","shared_timed_mutex","shared_ptr","stack","string_view","stringstream","timed_mutex","thread","true_type","tuple","unique_lock","unique_ptr","unordered_map","unordered_multimap","unordered_multiset","unordered_set","variant","vector","weak_ptr","wstring","wstring_view"]},p={className:"function.dispatch",relevance:0,keywords:{_hint:["abort","abs","acos","apply","as_const","asin","atan","atan2","calloc","ceil","cerr","cin","clog","cos","cosh","cout","declval","endl","exchange","exit","exp","fabs","floor","fmod","forward","fprintf","fputs","free","frexp","fscanf","future","invoke","isalnum","isalpha","iscntrl","isdigit","isgraph","islower","isprint","ispunct","isspace","isupper","isxdigit","labs","launder","ldexp","log","log10","make_pair","make_shared","make_shared_for_overwrite","make_tuple","make_unique","malloc","memchr","memcmp","memcpy","memset","modf","move","pow","printf","putchar","puts","realloc","scanf","sin","sinh","snprintf","sprintf","sqrt","sscanf","std","stderr","stdin","stdout","strcat","strchr","strcmp","strcpy","strcspn","strlen","strncat","strncmp","strncpy","strpbrk","strrchr","strspn","strstr","swap","tan","tanh","terminate","to_underlying","tolower","toupper","vfprintf","visit","vprintf","vsprintf"]},begin:t.concat(/\b/,/(?!decltype)/,/(?!if)/,/(?!for)/,/(?!switch)/,/(?!while)/,e.IDENT_RE,t.lookahead(/(<[^<>]+>|)\s*\(/))},f=[p,c,s,n,e.C_BLOCK_COMMENT_MODE,l,a],m={variants:[{begin:/=/,end:/;/},{begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],keywords:h,contains:f.concat([{begin:/\(/,end:/\)/,keywords:h,contains:f.concat(["self"]),relevance:0}]),relevance:0},g={className:"function",begin:"("+o+"[\\*&\\s]+)+"+d,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,keywords:h,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:r,keywords:h,relevance:0},{begin:d,returnBegin:!0,contains:[u],relevance:0},{begin:/::/,relevance:0},{begin:/:/,endsWithParent:!0,contains:[a,l]},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:[n,e.C_BLOCK_COMMENT_MODE,a,l,s,{begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:["self",n,e.C_BLOCK_COMMENT_MODE,a,l,s]}]},s,n,e.C_BLOCK_COMMENT_MODE,c]};return {name:"C++",aliases:["cc","c++","h++","hpp","hh","hxx","cxx"],keywords:h,illegal:"</",classNameAliases:{"function.dispatch":"built_in"},contains:[].concat(m,g,p,f,[c,{begin:"\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",end:">",keywords:h,contains:["self",s]},{begin:e.IDENT_RE+"::",keywords:h},{match:[/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,/\s+/,/\w+/],className:{1:"keyword",3:"title.class"}}])}}(e),r=n.keywords;return r.type=[...r.type,...t.type],r.literal=[...r.literal,...t.literal],r.built_in=[...r.built_in,...t.built_in],r._hints=t._hints,n.name="Arduino",n.aliases=["ino"],n.supersetOf="cpp",n})),aF.registerLanguage("bash",(function(e){const t=e.regex,n={},r={begin:/\$\{/,end:/\}/,contains:["self",{begin:/:-/,contains:[n]}]};Object.assign(n,{className:"variable",variants:[{begin:t.concat(/\$[\w\d#@][\w\d_]*/,"(?![\\w\\d])(?![$])")},r]});const i={className:"subst",begin:/\$\(/,end:/\)/,contains:[e.BACKSLASH_ESCAPE]},o={begin:/<<-?\s*(?=\w+)/,starts:{contains:[e.END_SAME_AS_BEGIN({begin:/(\w+)/,end:/(\w+)/,className:"string"})]}},s={className:"string",begin:/"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,n,i]};i.contains.push(s);const a={begin:/\$\(\(/,end:/\)\)/,contains:[{begin:/\d+#[0-9a-f]+/,className:"number"},e.NUMBER_MODE,n]},l=e.SHEBANG({binary:`(${["fish","bash","zsh","sh","csh","ksh","tcsh","dash","scsh"].join("|")})`,relevance:10}),c={className:"function",begin:/\w[\w\d_]*\s*\(\s*\)\s*\{/,returnBegin:!0,contains:[e.inherit(e.TITLE_MODE,{begin:/\w[\w\d_]*/})],relevance:0};return {name:"Bash",aliases:["sh"],keywords:{$pattern:/\b[a-z][a-z0-9._-]+\b/,keyword:["if","then","else","elif","fi","for","while","in","do","done","case","esac","function"],literal:["true","false"],built_in:["break","cd","continue","eval","exec","exit","export","getopts","hash","pwd","readonly","return","shift","test","times","trap","umask","unset","alias","bind","builtin","caller","command","declare","echo","enable","help","let","local","logout","mapfile","printf","read","readarray","source","type","typeset","ulimit","unalias","set","shopt","autoload","bg","bindkey","bye","cap","chdir","clone","comparguments","compcall","compctl","compdescribe","compfiles","compgroups","compquote","comptags","comptry","compvalues","dirs","disable","disown","echotc","echoti","emulate","fc","fg","float","functions","getcap","getln","history","integer","jobs","kill","limit","log","noglob","popd","print","pushd","pushln","rehash","sched","setcap","setopt","stat","suspend","ttyctl","unfunction","unhash","unlimit","unsetopt","vared","wait","whence","where","which","zcompile","zformat","zftp","zle","zmodload","zparseopts","zprof","zpty","zregexparse","zsocket","zstyle","ztcp","chcon","chgrp","chown","chmod","cp","dd","df","dir","dircolors","ln","ls","mkdir","mkfifo","mknod","mktemp","mv","realpath","rm","rmdir","shred","sync","touch","truncate","vdir","b2sum","base32","base64","cat","cksum","comm","csplit","cut","expand","fmt","fold","head","join","md5sum","nl","numfmt","od","paste","ptx","pr","sha1sum","sha224sum","sha256sum","sha384sum","sha512sum","shuf","sort","split","sum","tac","tail","tr","tsort","unexpand","uniq","wc","arch","basename","chroot","date","dirname","du","echo","env","expr","factor","groups","hostid","id","link","logname","nice","nohup","nproc","pathchk","pinky","printenv","printf","pwd","readlink","runcon","seq","sleep","stat","stdbuf","stty","tee","test","timeout","tty","uname","unlink","uptime","users","who","whoami","yes"]},contains:[l,e.SHEBANG(),c,a,e.HASH_COMMENT_MODE,o,{match:/(\/[a-z._-]+)+/},s,{className:"",begin:/\\"/},{className:"string",begin:/'/,end:/'/},n]}})),aF.registerLanguage("c",(function(e){const t=e.regex,n=e.COMMENT("//","$",{contains:[{begin:/\\\n/}]}),r="decltype\\(auto\\)",i="[a-zA-Z_]\\w*::",o="(decltype\\(auto\\)|"+t.optional(i)+"[a-zA-Z_]\\w*"+t.optional("<[^<>]+>")+")",s={className:"type",variants:[{begin:"\\b[a-z\\d_]*_t\\b"},{match:/\batomic_[a-z]{3,6}\b/}]},a={className:"string",variants:[{begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",end:"'",illegal:"."},e.END_SAME_AS_BEGIN({begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},l={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},c={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},e.inherit(a,{className:"string"}),{className:"string",begin:/<.*?>/},n,e.C_BLOCK_COMMENT_MODE]},u={className:"title",begin:t.optional(i)+e.IDENT_RE,relevance:0},d=t.optional(i)+e.IDENT_RE+"\\s*\\(",h={keyword:["asm","auto","break","case","continue","default","do","else","enum","extern","for","fortran","goto","if","inline","register","restrict","return","sizeof","struct","switch","typedef","union","volatile","while","_Alignas","_Alignof","_Atomic","_Generic","_Noreturn","_Static_assert","_Thread_local","alignas","alignof","noreturn","static_assert","thread_local","_Pragma"],type:["float","double","signed","unsigned","int","short","long","char","void","_Bool","_Complex","_Imaginary","_Decimal32","_Decimal64","_Decimal128","const","static","complex","bool","imaginary"],literal:"true false NULL",built_in:"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"},p=[c,s,n,e.C_BLOCK_COMMENT_MODE,l,a],f={variants:[{begin:/=/,end:/;/},{begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],keywords:h,contains:p.concat([{begin:/\(/,end:/\)/,keywords:h,contains:p.concat(["self"]),relevance:0}]),relevance:0},m={begin:"("+o+"[\\*&\\s]+)+"+d,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,keywords:h,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:r,keywords:h,relevance:0},{begin:d,returnBegin:!0,contains:[e.inherit(u,{className:"title.function"})],relevance:0},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:[n,e.C_BLOCK_COMMENT_MODE,a,l,s,{begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:["self",n,e.C_BLOCK_COMMENT_MODE,a,l,s]}]},s,n,e.C_BLOCK_COMMENT_MODE,c]};return {name:"C",aliases:["h"],keywords:h,disableAutodetect:!0,illegal:"</",contains:[].concat(f,m,p,[c,{begin:e.IDENT_RE+"::",keywords:h},{className:"class",beginKeywords:"enum class struct union",end:/[{;:<>=]/,contains:[{beginKeywords:"final class struct"},e.TITLE_MODE]}]),exports:{preprocessor:c,strings:a,keywords:h}}})),aF.registerLanguage("cpp",(function(e){const t=e.regex,n=e.COMMENT("//","$",{contains:[{begin:/\\\n/}]}),r="decltype\\(auto\\)",i="[a-zA-Z_]\\w*::",o="(?!struct)(decltype\\(auto\\)|"+t.optional(i)+"[a-zA-Z_]\\w*"+t.optional("<[^<>]+>")+")",s={className:"type",begin:"\\b[a-z\\d_]*_t\\b"},a={className:"string",variants:[{begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",end:"'",illegal:"."},e.END_SAME_AS_BEGIN({begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},l={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},c={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},e.inherit(a,{className:"string"}),{className:"string",begin:/<.*?>/},n,e.C_BLOCK_COMMENT_MODE]},u={className:"title",begin:t.optional(i)+e.IDENT_RE,relevance:0},d=t.optional(i)+e.IDENT_RE+"\\s*\\(",h={type:["bool","char","char16_t","char32_t","char8_t","double","float","int","long","short","void","wchar_t","unsigned","signed","const","static"],keyword:["alignas","alignof","and","and_eq","asm","atomic_cancel","atomic_commit","atomic_noexcept","auto","bitand","bitor","break","case","catch","class","co_await","co_return","co_yield","compl","concept","const_cast|10","consteval","constexpr","constinit","continue","decltype","default","delete","do","dynamic_cast|10","else","enum","explicit","export","extern","false","final","for","friend","goto","if","import","inline","module","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","override","private","protected","public","reflexpr","register","reinterpret_cast|10","requires","return","sizeof","static_assert","static_cast|10","struct","switch","synchronized","template","this","thread_local","throw","transaction_safe","transaction_safe_dynamic","true","try","typedef","typeid","typename","union","using","virtual","volatile","while","xor","xor_eq"],literal:["NULL","false","nullopt","nullptr","true"],built_in:["_Pragma"],_type_hints:["any","auto_ptr","barrier","binary_semaphore","bitset","complex","condition_variable","condition_variable_any","counting_semaphore","deque","false_type","future","imaginary","initializer_list","istringstream","jthread","latch","lock_guard","multimap","multiset","mutex","optional","ostringstream","packaged_task","pair","promise","priority_queue","queue","recursive_mutex","recursive_timed_mutex","scoped_lock","set","shared_future","shared_lock","shared_mutex","shared_timed_mutex","shared_ptr","stack","string_view","stringstream","timed_mutex","thread","true_type","tuple","unique_lock","unique_ptr","unordered_map","unordered_multimap","unordered_multiset","unordered_set","variant","vector","weak_ptr","wstring","wstring_view"]},p={className:"function.dispatch",relevance:0,keywords:{_hint:["abort","abs","acos","apply","as_const","asin","atan","atan2","calloc","ceil","cerr","cin","clog","cos","cosh","cout","declval","endl","exchange","exit","exp","fabs","floor","fmod","forward","fprintf","fputs","free","frexp","fscanf","future","invoke","isalnum","isalpha","iscntrl","isdigit","isgraph","islower","isprint","ispunct","isspace","isupper","isxdigit","labs","launder","ldexp","log","log10","make_pair","make_shared","make_shared_for_overwrite","make_tuple","make_unique","malloc","memchr","memcmp","memcpy","memset","modf","move","pow","printf","putchar","puts","realloc","scanf","sin","sinh","snprintf","sprintf","sqrt","sscanf","std","stderr","stdin","stdout","strcat","strchr","strcmp","strcpy","strcspn","strlen","strncat","strncmp","strncpy","strpbrk","strrchr","strspn","strstr","swap","tan","tanh","terminate","to_underlying","tolower","toupper","vfprintf","visit","vprintf","vsprintf"]},begin:t.concat(/\b/,/(?!decltype)/,/(?!if)/,/(?!for)/,/(?!switch)/,/(?!while)/,e.IDENT_RE,t.lookahead(/(<[^<>]+>|)\s*\(/))},f=[p,c,s,n,e.C_BLOCK_COMMENT_MODE,l,a],m={variants:[{begin:/=/,end:/;/},{begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],keywords:h,contains:f.concat([{begin:/\(/,end:/\)/,keywords:h,contains:f.concat(["self"]),relevance:0}]),relevance:0},g={className:"function",begin:"("+o+"[\\*&\\s]+)+"+d,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,keywords:h,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:r,keywords:h,relevance:0},{begin:d,returnBegin:!0,contains:[u],relevance:0},{begin:/::/,relevance:0},{begin:/:/,endsWithParent:!0,contains:[a,l]},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:[n,e.C_BLOCK_COMMENT_MODE,a,l,s,{begin:/\(/,end:/\)/,keywords:h,relevance:0,contains:["self",n,e.C_BLOCK_COMMENT_MODE,a,l,s]}]},s,n,e.C_BLOCK_COMMENT_MODE,c]};return {name:"C++",aliases:["cc","c++","h++","hpp","hh","hxx","cxx"],keywords:h,illegal:"</",classNameAliases:{"function.dispatch":"built_in"},contains:[].concat(m,g,p,f,[c,{begin:"\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",end:">",keywords:h,contains:["self",s]},{begin:e.IDENT_RE+"::",keywords:h},{match:[/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,/\s+/,/\w+/],className:{1:"keyword",3:"title.class"}}])}})),aF.registerLanguage("csharp",(function(e){const t={keyword:["abstract","as","base","break","case","catch","class","const","continue","do","else","event","explicit","extern","finally","fixed","for","foreach","goto","if","implicit","in","interface","internal","is","lock","namespace","new","operator","out","override","params","private","protected","public","readonly","record","ref","return","scoped","sealed","sizeof","stackalloc","static","struct","switch","this","throw","try","typeof","unchecked","unsafe","using","virtual","void","volatile","while"].concat(["add","alias","and","ascending","async","await","by","descending","equals","from","get","global","group","init","into","join","let","nameof","not","notnull","on","or","orderby","partial","remove","select","set","unmanaged","value|0","var","when","where","with","yield"]),built_in:["bool","byte","char","decimal","delegate","double","dynamic","enum","float","int","long","nint","nuint","object","sbyte","short","string","ulong","uint","ushort"],literal:["default","false","null","true"]},n=e.inherit(e.TITLE_MODE,{begin:"[a-zA-Z](\\.?\\w)*"}),r={className:"number",variants:[{begin:"\\b(0b[01']+)"},{begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],relevance:0},i={className:"string",begin:'@"',end:'"',contains:[{begin:'""'}]},o=e.inherit(i,{illegal:/\n/}),s={className:"subst",begin:/\{/,end:/\}/,keywords:t},a=e.inherit(s,{illegal:/\n/}),l={className:"string",begin:/\$"/,end:'"',illegal:/\n/,contains:[{begin:/\{\{/},{begin:/\}\}/},e.BACKSLASH_ESCAPE,a]},c={className:"string",begin:/\$@"/,end:'"',contains:[{begin:/\{\{/},{begin:/\}\}/},{begin:'""'},s]},u=e.inherit(c,{illegal:/\n/,contains:[{begin:/\{\{/},{begin:/\}\}/},{begin:'""'},a]});s.contains=[c,l,i,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,r,e.C_BLOCK_COMMENT_MODE],a.contains=[u,l,o,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,r,e.inherit(e.C_BLOCK_COMMENT_MODE,{illegal:/\n/})];const d={variants:[c,l,i,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},h={begin:"<",end:">",contains:[{beginKeywords:"in out"},n]},p=e.IDENT_RE+"(<"+e.IDENT_RE+"(\\s*,\\s*"+e.IDENT_RE+")*>)?(\\[\\])?",f={begin:"@"+e.IDENT_RE,relevance:0};return {name:"C#",aliases:["cs","c#"],keywords:t,illegal:/::/,contains:[e.COMMENT("///","$",{returnBegin:!0,contains:[{className:"doctag",variants:[{begin:"///",relevance:0},{begin:"\x3c!--|--\x3e"},{begin:"</?",end:">"}]}]}),e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,{className:"meta",begin:"#",end:"$",keywords:{keyword:"if else elif endif define undef warning error line region endregion pragma checksum"}},d,r,{beginKeywords:"class interface",relevance:0,end:/[{;=]/,illegal:/[^\s:,]/,contains:[{beginKeywords:"where class"},n,h,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},{beginKeywords:"namespace",relevance:0,end:/[{;=]/,illegal:/[^\s:]/,contains:[n,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},{beginKeywords:"record",relevance:0,end:/[{;=]/,illegal:/[^\s:]/,contains:[n,h,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},{className:"meta",begin:"^\\s*\\[(?=[\\w])",excludeBegin:!0,end:"\\]",excludeEnd:!0,contains:[{className:"string",begin:/"/,end:/"/}]},{beginKeywords:"new return throw await else",relevance:0},{className:"function",begin:"("+p+"\\s+)+"+e.IDENT_RE+"\\s*(<[^=]+>\\s*)?\\(",returnBegin:!0,end:/\s*[{;=]/,excludeEnd:!0,keywords:t,contains:[{beginKeywords:["public","private","protected","static","internal","protected","abstract","async","extern","override","unsafe","virtual","new","sealed","partial"].join(" "),relevance:0},{begin:e.IDENT_RE+"\\s*(<[^=]+>\\s*)?\\(",returnBegin:!0,contains:[e.TITLE_MODE,h],relevance:0},{match:/\(\)/},{className:"params",begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:t,relevance:0,contains:[d,r,e.C_BLOCK_COMMENT_MODE]},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},f]}})),aF.registerLanguage("css",(function(e){const t=e.regex,n=(e=>({IMPORTANT:{scope:"meta",begin:"!important"},BLOCK_COMMENT:e.C_BLOCK_COMMENT_MODE,HEXCOLOR:{scope:"number",begin:/#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/},FUNCTION_DISPATCH:{className:"built_in",begin:/[\w-]+(?=\()/},ATTRIBUTE_SELECTOR_MODE:{scope:"selector-attr",begin:/\[/,end:/\]/,illegal:"$",contains:[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},CSS_NUMBER_MODE:{scope:"number",begin:e.NUMBER_RE+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",relevance:0},CSS_VARIABLE:{className:"attr",begin:/--[A-Za-z][A-Za-z0-9_-]*/}}))(e),r=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE];return {name:"CSS",case_insensitive:!0,illegal:/[=|'\$]/,keywords:{keyframePosition:"from to"},classNameAliases:{keyframePosition:"selector-tag"},contains:[n.BLOCK_COMMENT,{begin:/-(webkit|moz|ms|o)-(?=[a-z])/},n.CSS_NUMBER_MODE,{className:"selector-id",begin:/#[A-Za-z0-9_-]+/,relevance:0},{className:"selector-class",begin:"\\.[a-zA-Z-][a-zA-Z0-9_-]*",relevance:0},n.ATTRIBUTE_SELECTOR_MODE,{className:"selector-pseudo",variants:[{begin:":("+HT.join("|")+")"},{begin:":(:)?("+VT.join("|")+")"}]},n.CSS_VARIABLE,{className:"attribute",begin:"\\b("+KT.join("|")+")\\b"},{begin:/:/,end:/[;}{]/,contains:[n.BLOCK_COMMENT,n.HEXCOLOR,n.IMPORTANT,n.CSS_NUMBER_MODE,...r,{begin:/(url|data-uri)\(/,end:/\)/,relevance:0,keywords:{built_in:"url data-uri"},contains:[...r,{className:"string",begin:/[^)]/,endsWithParent:!0,excludeEnd:!0}]},n.FUNCTION_DISPATCH]},{begin:t.lookahead(/@/),end:"[{;]",relevance:0,illegal:/:/,contains:[{className:"keyword",begin:/@-?\w[\w]*(-\w+)*/},{begin:/\s/,endsWithParent:!0,excludeEnd:!0,relevance:0,keywords:{$pattern:/[a-z-]+/,keyword:"and or not only",attribute:jT.join(" ")},contains:[{begin:/[a-z-]+(?=:)/,className:"attribute"},...r,n.CSS_NUMBER_MODE]}]},{className:"selector-tag",begin:"\\b("+$T.join("|")+")\\b"}]}})),aF.registerLanguage("diff",(function(e){const t=e.regex;return {name:"Diff",aliases:["patch"],contains:[{className:"meta",relevance:10,match:t.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,/^\*\*\* +\d+,\d+ +\*\*\*\*$/,/^--- +\d+,\d+ +----$/)},{className:"comment",variants:[{begin:t.either(/Index: /,/^index/,/={3,}/,/^-{3}/,/^\*{3} /,/^\+{3}/,/^diff --git/),end:/$/},{match:/^\*{15}$/}]},{className:"addition",begin:/^\+/,end:/$/},{className:"deletion",begin:/^-/,end:/$/},{className:"addition",begin:/^!/,end:/$/}]}})),aF.registerLanguage("go",(function(e){const t={keyword:["break","case","chan","const","continue","default","defer","else","fallthrough","for","func","go","goto","if","import","interface","map","package","range","return","select","struct","switch","type","var"],type:["bool","byte","complex64","complex128","error","float32","float64","int8","int16","int32","int64","string","uint8","uint16","uint32","uint64","int","uint","uintptr","rune"],literal:["true","false","iota","nil"],built_in:["append","cap","close","complex","copy","imag","len","make","new","panic","print","println","real","recover","delete"]};return {name:"Go",aliases:["golang"],keywords:t,illegal:"</",contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,{className:"string",variants:[e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,{begin:"`",end:"`"}]},{className:"number",variants:[{begin:e.C_NUMBER_RE+"[i]",relevance:1},e.C_NUMBER_MODE]},{begin:/:=/},{className:"function",beginKeywords:"func",end:"\\s*(\\{|$)",excludeEnd:!0,contains:[e.TITLE_MODE,{className:"params",begin:/\(/,end:/\)/,endsParent:!0,keywords:t,illegal:/["']/}]}]}})),aF.registerLanguage("graphql",(function(e){const t=e.regex;return {name:"GraphQL",aliases:["gql"],case_insensitive:!0,disableAutodetect:!1,keywords:{keyword:["query","mutation","subscription","type","input","schema","directive","interface","union","scalar","fragment","enum","on"],literal:["true","false","null"]},contains:[e.HASH_COMMENT_MODE,e.QUOTE_STRING_MODE,e.NUMBER_MODE,{scope:"punctuation",match:/[.]{3}/,relevance:0},{scope:"punctuation",begin:/[\!\(\)\:\=\[\]\{\|\}]{1}/,relevance:0},{scope:"variable",begin:/\$/,end:/\W/,excludeEnd:!0,relevance:0},{scope:"meta",match:/@\w+/,excludeEnd:!0},{scope:"symbol",begin:t.concat(/[_A-Za-z][_0-9A-Za-z]*/,t.lookahead(/\s*:/)),relevance:0}],illegal:[/[;<']/,/BEGIN/]}})),aF.registerLanguage("ini",(function(e){const t=e.regex,n={className:"number",relevance:0,variants:[{begin:/([+-]+)?[\d]+_[\d_]+/},{begin:e.NUMBER_RE}]},r=e.COMMENT();r.variants=[{begin:/;/,end:/$/},{begin:/#/,end:/$/}];const i={className:"variable",variants:[{begin:/\$[\w\d"][\w\d_]*/},{begin:/\$\{(.*?)\}/}]},o={className:"literal",begin:/\bon|off|true|false|yes|no\b/},s={className:"string",contains:[e.BACKSLASH_ESCAPE],variants:[{begin:"'''",end:"'''",relevance:10},{begin:'"""',end:'"""',relevance:10},{begin:'"',end:'"'},{begin:"'",end:"'"}]},a={begin:/\[/,end:/\]/,contains:[r,o,i,s,n,"self"],relevance:0},l=t.either(/[A-Za-z0-9_-]+/,/"(\\"|[^"])*"/,/'[^']*'/);return {name:"TOML, also INI",aliases:["toml"],case_insensitive:!0,illegal:/\S/,contains:[r,{className:"section",begin:/\[+/,end:/\]+/},{begin:t.concat(l,"(\\s*\\.\\s*",l,")*",t.lookahead(/\s*=\s*[^#\s]/)),className:"attr",starts:{end:/$/,contains:[r,a,o,i,s,n]}}]}})),aF.registerLanguage("java",(function(e){const t=e.regex,n="[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*",r=n+GT("(?:<"+n+"~~~(?:\\s*,\\s*"+n+"~~~)*>)?",/~~~/g,2),i={keyword:["synchronized","abstract","private","var","static","if","const ","for","while","strictfp","finally","protected","import","native","final","void","enum","else","break","transient","catch","instanceof","volatile","case","assert","package","default","public","try","switch","continue","throws","protected","public","private","module","requires","exports","do","sealed"],literal:["false","true","null"],type:["char","boolean","long","float","int","byte","short","double"],built_in:["super","this"]},o={className:"meta",begin:"@"+n,contains:[{begin:/\(/,end:/\)/,contains:["self"]}]},s={className:"params",begin:/\(/,end:/\)/,keywords:i,relevance:0,contains:[e.C_BLOCK_COMMENT_MODE],endsParent:!0};return {name:"Java",aliases:["jsp"],keywords:i,illegal:/<\/|#/,contains:[e.COMMENT("/\\*\\*","\\*/",{relevance:0,contains:[{begin:/\w+@/,relevance:0},{className:"doctag",begin:"@[A-Za-z]+"}]}),{begin:/import java\.[a-z]+\./,keywords:"import",relevance:2},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,{begin:/"""/,end:/"""/,className:"string",contains:[e.BACKSLASH_ESCAPE]},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,{match:[/\b(?:class|interface|enum|extends|implements|new)/,/\s+/,n],className:{1:"keyword",3:"title.class"}},{match:/non-sealed/,scope:"keyword"},{begin:[t.concat(/(?!else)/,n),/\s+/,n,/\s+/,/=(?!=)/],className:{1:"type",3:"variable",5:"operator"}},{begin:[/record/,/\s+/,n],className:{1:"keyword",3:"title.class"},contains:[s,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},{beginKeywords:"new throw return else",relevance:0},{begin:["(?:"+r+"\\s+)",e.UNDERSCORE_IDENT_RE,/\s*(?=\()/],className:{2:"title.function"},keywords:i,contains:[{className:"params",begin:/\(/,end:/\)/,keywords:i,relevance:0,contains:[o,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,WT,e.C_BLOCK_COMMENT_MODE]},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},WT,o]}})),aF.registerLanguage("javascript",(function(e){const t=e.regex,n="[A-Za-z$_][0-9A-Za-z$_]*",r="<>",i="</>",o={begin:/<[A-Za-z0-9\\._:-]+/,end:/\/[A-Za-z0-9\\._:-]+>|\/>/,isTrulyOpeningTag:(e,t)=>{const n=e[0].length+e.index,r=e.input[n];if("<"===r||","===r)return void t.ignoreMatch();let i;">"===r&&(((e,{after:t})=>{const n="</"+e[0].slice(1);return -1!==e.input.indexOf(n,t)})(e,{after:n})||t.ignoreMatch());(i=e.input.substring(n).match(/^\s+extends\s+/))&&0===i.index&&t.ignoreMatch();}},s={$pattern:"[A-Za-z$_][0-9A-Za-z$_]*",keyword:JT,literal:ZT,built_in:tL,"variable.language":eL},a="\\.([0-9](_?[0-9])*)",l="0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",c={className:"number",variants:[{begin:`(\\b(${l})((${a})|\\.)?|(${a}))[eE][+-]?([0-9](_?[0-9])*)\\b`},{begin:`\\b(${l})\\b((${a})\\b|\\.)?|(${a})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0},u={className:"subst",begin:"\\$\\{",end:"\\}",keywords:s,contains:[]},d={begin:"html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"xml"}},h={begin:"css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,u],subLanguage:"css"}},p={className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,u]},f={className:"comment",variants:[e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:n+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]},m=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,h,p,c];u.contains=m.concat({begin:/\{/,end:/\}/,keywords:s,contains:["self"].concat(m)});const g=[].concat(f,u.contains),v=g.concat([{begin:/\(/,end:/\)/,keywords:s,contains:["self"].concat(g)}]),y={className:"params",begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:s,contains:v},b={variants:[{match:[/class/,/\s+/,n,/\s+/,/extends/,/\s+/,t.concat(n,"(",t.concat(/\./,n),")*")],scope:{1:"keyword",3:"title.class",5:"keyword",7:"title.class.inherited"}},{match:[/class/,/\s+/,n],scope:{1:"keyword",3:"title.class"}}]},w={relevance:0,match:t.either(/\bJSON/,/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),className:"title.class",keywords:{_:[...XT,...QT]}},k={variants:[{match:[/function/,/\s+/,n,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[y],illegal:/%/},C={match:t.concat(/\b/,(E=[...YT,"super"],t.concat("(?!",E.join("|"),")")),n,t.lookahead(/\(/)),className:"title.function",relevance:0};var E;const x={begin:t.concat(/\./,t.lookahead(t.concat(n,/(?![0-9A-Za-z$_(])/))),end:n,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},S={match:[/get|set/,/\s+/,n,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},y]},D="(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=>",M={match:[/const|var|let/,/\s+/,n,/\s*/,/=\s*/,/(async\s*)?/,t.lookahead(D)],keywords:"async",className:{1:"keyword",3:"title.function"},contains:[y]};return {name:"Javascript",aliases:["js","jsx","mjs","cjs"],keywords:s,exports:{PARAMS_CONTAINS:v,CLASS_REFERENCE:w},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),{label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,d,h,p,f,c,w,{className:"attr",begin:n+t.lookahead(":"),relevance:0},M,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[f,e.REGEXP_MODE,{className:"function",begin:D,returnBegin:!0,end:"\\s*=>",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:s,contains:v}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:r,end:i},{match:/<[A-Za-z0-9\\._:-]+\s*\/>/},{begin:o.begin,"on:begin":o.isTrulyOpeningTag,end:o.end}],subLanguage:"xml",contains:[{begin:o.begin,end:o.end,skip:!0,contains:["self"]}]}]},k,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[y,e.inherit(e.TITLE_MODE,{begin:n,className:"title.function"})]},{match:/\.\.\./,relevance:0},x,{match:"\\$"+n,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[y]},C,{relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"},b,S,{match:/\$[(.]/}]}})),aF.registerLanguage("json",(function(e){const t=["true","false","null"],n={scope:"literal",beginKeywords:t.join(" ")};return {name:"JSON",keywords:{literal:t},contains:[{className:"attr",begin:/"(\\.|[^\\"\r\n])*"(?=\s*:)/,relevance:1.01},{match:/[{}[\],:]/,className:"punctuation",relevance:0},e.QUOTE_STRING_MODE,n,e.C_NUMBER_MODE,e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE],illegal:"\\S"}})),aF.registerLanguage("kotlin",(function(e){const t={keyword:"abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",built_in:"Byte Short Char Int Long Boolean Float Double Void Unit Nothing",literal:"true false null"},n={className:"symbol",begin:e.UNDERSCORE_IDENT_RE+"@"},r={className:"subst",begin:/\$\{/,end:/\}/,contains:[e.C_NUMBER_MODE]},i={className:"variable",begin:"\\$"+e.UNDERSCORE_IDENT_RE},o={className:"string",variants:[{begin:'"""',end:'"""(?=[^"])',contains:[i,r]},{begin:"'",end:"'",illegal:/\n/,contains:[e.BACKSLASH_ESCAPE]},{begin:'"',end:'"',illegal:/\n/,contains:[e.BACKSLASH_ESCAPE,i,r]}]};r.contains.push(o);const s={className:"meta",begin:"@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*"+e.UNDERSCORE_IDENT_RE+")?"},a={className:"meta",begin:"@"+e.UNDERSCORE_IDENT_RE,contains:[{begin:/\(/,end:/\)/,contains:[e.inherit(o,{className:"string"}),"self"]}]},l=iL,c=e.COMMENT("/\\*","\\*/",{contains:[e.C_BLOCK_COMMENT_MODE]}),u={variants:[{className:"type",begin:e.UNDERSCORE_IDENT_RE},{begin:/\(/,end:/\)/,contains:[]}]},d=u;return d.variants[1].contains=[u],u.variants[1].contains=[d],{name:"Kotlin",aliases:["kt","kts"],keywords:t,contains:[e.COMMENT("/\\*\\*","\\*/",{relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"}]}),e.C_LINE_COMMENT_MODE,c,{className:"keyword",begin:/\b(break|continue|return|this)\b/,starts:{contains:[{className:"symbol",begin:/@\w+/}]}},n,s,a,{className:"function",beginKeywords:"fun",end:"[(]|$",returnBegin:!0,excludeEnd:!0,keywords:t,relevance:5,contains:[{begin:e.UNDERSCORE_IDENT_RE+"\\s*\\(",returnBegin:!0,relevance:0,contains:[e.UNDERSCORE_TITLE_MODE]},{className:"type",begin:/</,end:/>/,keywords:"reified",relevance:0},{className:"params",begin:/\(/,end:/\)/,endsParent:!0,keywords:t,relevance:0,contains:[{begin:/:/,end:/[=,\/]/,endsWithParent:!0,contains:[u,e.C_LINE_COMMENT_MODE,c],relevance:0},e.C_LINE_COMMENT_MODE,c,s,a,o,e.C_NUMBER_MODE]},c]},{begin:[/class|interface|trait/,/\s+/,e.UNDERSCORE_IDENT_RE],beginScope:{3:"title.class"},keywords:"class interface trait",end:/[:\{(]|$/,excludeEnd:!0,illegal:"extends implements",contains:[{beginKeywords:"public protected internal private constructor"},e.UNDERSCORE_TITLE_MODE,{className:"type",begin:/</,end:/>/,excludeBegin:!0,excludeEnd:!0,relevance:0},{className:"type",begin:/[,:]\s*/,end:/[<\(,){\s]|$/,excludeBegin:!0,returnEnd:!0},s,a]},o,{className:"meta",begin:"^#!/usr/bin/env",end:"$",illegal:"\n"},l]}})),aF.registerLanguage("less",(function(e){const t=(e=>({IMPORTANT:{scope:"meta",begin:"!important"},BLOCK_COMMENT:e.C_BLOCK_COMMENT_MODE,HEXCOLOR:{scope:"number",begin:/#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/},FUNCTION_DISPATCH:{className:"built_in",begin:/[\w-]+(?=\()/},ATTRIBUTE_SELECTOR_MODE:{scope:"selector-attr",begin:/\[/,end:/\]/,illegal:"$",contains:[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},CSS_NUMBER_MODE:{scope:"number",begin:e.NUMBER_RE+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",relevance:0},CSS_VARIABLE:{className:"attr",begin:/--[A-Za-z][A-Za-z0-9_-]*/}}))(e),n=uL,r="([\\w-]+|@\\{[\\w-]+\\})",i=[],o=[],s=function(e){return {className:"string",begin:"~?"+e+".*?"+e}},a=function(e,t,n){return {className:e,begin:t,relevance:n}},l={$pattern:/[a-z-]+/,keyword:"and or not only",attribute:sL.join(" ")},c={begin:"\\(",end:"\\)",contains:o,keywords:l,relevance:0};o.push(e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,s("'"),s('"'),t.CSS_NUMBER_MODE,{begin:"(url|data-uri)\\(",starts:{className:"string",end:"[\\)\\n]",excludeEnd:!0}},t.HEXCOLOR,c,a("variable","@@?[\\w-]+",10),a("variable","@\\{[\\w-]+\\}"),a("built_in","~?`[^`]*?`"),{className:"attribute",begin:"[\\w-]+\\s*:",end:":",returnBegin:!0,excludeEnd:!0},t.IMPORTANT,{beginKeywords:"and not"},t.FUNCTION_DISPATCH);const u=o.concat({begin:/\{/,end:/\}/,contains:i}),d={beginKeywords:"when",endsWithParent:!0,contains:[{beginKeywords:"and not"}].concat(o)},h={begin:r+"\\s*:",returnBegin:!0,end:/[;}]/,relevance:0,contains:[{begin:/-(webkit|moz|ms|o)-/},t.CSS_VARIABLE,{className:"attribute",begin:"\\b("+cL.join("|")+")\\b",end:/(?=:)/,starts:{endsWithParent:!0,illegal:"[<=$]",relevance:0,contains:o}}]},p={className:"keyword",begin:"@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",starts:{end:"[;{}]",keywords:l,returnEnd:!0,contains:o,relevance:0}},f={className:"variable",variants:[{begin:"@[\\w-]+\\s*:",relevance:15},{begin:"@[\\w-]+"}],starts:{end:"[;}]",returnEnd:!0,contains:u}},m={variants:[{begin:"[\\.#:&\\[>]",end:"[;{}]"},{begin:r,end:/\{/}],returnBegin:!0,returnEnd:!0,illegal:"[<='$\"]",relevance:0,contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,d,a("keyword","all\\b"),a("variable","@\\{[\\w-]+\\}"),{begin:"\\b("+oL.join("|")+")\\b",className:"selector-tag"},t.CSS_NUMBER_MODE,a("selector-tag",r,0),a("selector-id","#"+r),a("selector-class","\\."+r,0),a("selector-tag","&",0),t.ATTRIBUTE_SELECTOR_MODE,{className:"selector-pseudo",begin:":("+aL.join("|")+")"},{className:"selector-pseudo",begin:":(:)?("+lL.join("|")+")"},{begin:/\(/,end:/\)/,relevance:0,contains:u},{begin:"!important"},t.FUNCTION_DISPATCH]},g={begin:`[\\w-]+:(:)?(${n.join("|")})`,returnBegin:!0,contains:[m]};return i.push(e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,p,f,g,h,m,d,t.FUNCTION_DISPATCH),{name:"Less",case_insensitive:!0,illegal:"[=>'/<($\"]",contains:i}})),aF.registerLanguage("lua",(function(e){const t="\\[=*\\[",n="\\]=*\\]",r={begin:t,end:n,contains:["self"]},i=[e.COMMENT("--(?!\\[=*\\[)","$"),e.COMMENT("--\\[=*\\[",n,{contains:[r],relevance:10})];return {name:"Lua",keywords:{$pattern:e.UNDERSCORE_IDENT_RE,literal:"true false nil",keyword:"and break do else elseif end for goto if in local not or repeat return then until while",built_in:"_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"},contains:i.concat([{className:"function",beginKeywords:"function",end:"\\)",contains:[e.inherit(e.TITLE_MODE,{begin:"([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*"}),{className:"params",begin:"\\(",endsWithParent:!0,contains:i}].concat(i)},e.C_NUMBER_MODE,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,{className:"string",begin:t,end:n,contains:[r],relevance:5}])}})),aF.registerLanguage("makefile",(function(e){const t={className:"variable",variants:[{begin:"\\$\\("+e.UNDERSCORE_IDENT_RE+"\\)",contains:[e.BACKSLASH_ESCAPE]},{begin:/\$[@%<?\^\+\*]/}]},n={className:"string",begin:/"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,t]},r={className:"variable",begin:/\$\([\w-]+\s/,end:/\)/,keywords:{built_in:"subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"},contains:[t]},i={begin:"^"+e.UNDERSCORE_IDENT_RE+"\\s*(?=[:+?]?=)"},o={className:"section",begin:/^[^\s]+:/,end:/$/,contains:[t]};return {name:"Makefile",aliases:["mk","mak","make"],keywords:{$pattern:/[\w-]+/,keyword:"define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"},contains:[e.HASH_COMMENT_MODE,t,n,r,i,{className:"meta",begin:/^\.PHONY:/,end:/$/,keywords:{$pattern:/[\.\w]+/,keyword:".PHONY"}},o]}})),aF.registerLanguage("markdown",(function(e){const t={begin:/<\/?[A-Za-z_]/,end:">",subLanguage:"xml",relevance:0},n={variants:[{begin:/\[.+?\]\[.*?\]/,relevance:0},{begin:/\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,relevance:2},{begin:e.regex.concat(/\[.+?\]\(/,/[A-Za-z][A-Za-z0-9+.-]*/,/:\/\/.*?\)/),relevance:2},{begin:/\[.+?\]\([./?&#].*?\)/,relevance:1},{begin:/\[.*?\]\(.*?\)/,relevance:0}],returnBegin:!0,contains:[{match:/\[(?=\])/},{className:"string",relevance:0,begin:"\\[",end:"\\]",excludeBegin:!0,returnEnd:!0},{className:"link",relevance:0,begin:"\\]\\(",end:"\\)",excludeBegin:!0,excludeEnd:!0},{className:"symbol",relevance:0,begin:"\\]\\[",end:"\\]",excludeBegin:!0,excludeEnd:!0}]},r={className:"strong",contains:[],variants:[{begin:/_{2}/,end:/_{2}/},{begin:/\*{2}/,end:/\*{2}/}]},i={className:"emphasis",contains:[],variants:[{begin:/\*(?!\*)/,end:/\*/},{begin:/_(?!_)/,end:/_/,relevance:0}]},o=e.inherit(r,{contains:[]}),s=e.inherit(i,{contains:[]});r.contains.push(s),i.contains.push(o);let a=[t,n];return [r,i,o,s].forEach((e=>{e.contains=e.contains.concat(a);})),a=a.concat(r,i),{name:"Markdown",aliases:["md","mkdown","mkd"],contains:[{className:"section",variants:[{begin:"^#{1,6}",end:"$",contains:a},{begin:"(?=^.+?\\n[=-]{2,}$)",contains:[{begin:"^[=-]*$"},{begin:"^",end:"\\n",contains:a}]}]},t,{className:"bullet",begin:"^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)",end:"\\s+",excludeEnd:!0},r,i,{className:"quote",begin:"^>\\s+",contains:a,end:"$"},{className:"code",variants:[{begin:"(`{3,})[^`](.|\\n)*?\\1`*[ ]*"},{begin:"(~{3,})[^~](.|\\n)*?\\1~*[ ]*"},{begin:"```",end:"```+[ ]*$"},{begin:"~~~",end:"~~~+[ ]*$"},{begin:"`.+?`"},{begin:"(?=^( {4}|\\t))",contains:[{begin:"^( {4}|\\t)",end:"(\\n)$"}],relevance:0}]},{begin:"^[-\\*]{3,}",end:"$"},n,{begin:/^\[[^\n]+\]:/,returnBegin:!0,contains:[{className:"symbol",begin:/\[/,end:/\]/,excludeBegin:!0,excludeEnd:!0},{className:"link",begin:/:\s*/,end:/$/,excludeBegin:!0}]}]}})),aF.registerLanguage("objectivec",(function(e){const t=/[a-zA-Z@][a-zA-Z0-9_]*/,n={$pattern:t,keyword:["@interface","@class","@protocol","@implementation"]};return {name:"Objective-C",aliases:["mm","objc","obj-c","obj-c++","objective-c++"],keywords:{"variable.language":["this","super"],$pattern:t,keyword:["while","export","sizeof","typedef","const","struct","for","union","volatile","static","mutable","if","do","return","goto","enum","else","break","extern","asm","case","default","register","explicit","typename","switch","continue","inline","readonly","assign","readwrite","self","@synchronized","id","typeof","nonatomic","IBOutlet","IBAction","strong","weak","copy","in","out","inout","bycopy","byref","oneway","__strong","__weak","__block","__autoreleasing","@private","@protected","@public","@try","@property","@end","@throw","@catch","@finally","@autoreleasepool","@synthesize","@dynamic","@selector","@optional","@required","@encode","@package","@import","@defs","@compatibility_alias","__bridge","__bridge_transfer","__bridge_retained","__bridge_retain","__covariant","__contravariant","__kindof","_Nonnull","_Nullable","_Null_unspecified","__FUNCTION__","__PRETTY_FUNCTION__","__attribute__","getter","setter","retain","unsafe_unretained","nonnull","nullable","null_unspecified","null_resettable","class","instancetype","NS_DESIGNATED_INITIALIZER","NS_UNAVAILABLE","NS_REQUIRES_SUPER","NS_RETURNS_INNER_POINTER","NS_INLINE","NS_AVAILABLE","NS_DEPRECATED","NS_ENUM","NS_OPTIONS","NS_SWIFT_UNAVAILABLE","NS_ASSUME_NONNULL_BEGIN","NS_ASSUME_NONNULL_END","NS_REFINED_FOR_SWIFT","NS_SWIFT_NAME","NS_SWIFT_NOTHROW","NS_DURING","NS_HANDLER","NS_ENDHANDLER","NS_VALUERETURN","NS_VOIDRETURN"],literal:["false","true","FALSE","TRUE","nil","YES","NO","NULL"],built_in:["dispatch_once_t","dispatch_queue_t","dispatch_sync","dispatch_async","dispatch_once"],type:["int","float","char","unsigned","signed","short","long","double","wchar_t","unichar","void","bool","BOOL","id|0","_Bool"]},illegal:"</",contains:[{className:"built_in",begin:"\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,e.C_NUMBER_MODE,e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,{className:"string",variants:[{begin:'@"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]}]},{className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{keyword:"if else elif endif define undef warning error line pragma ifdef ifndef include"},contains:[{begin:/\\\n/,relevance:0},e.inherit(e.QUOTE_STRING_MODE,{className:"string"}),{className:"string",begin:/<.*?>/,end:/$/,illegal:"\\n"},e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE]},{className:"class",begin:"("+n.keyword.join("|")+")\\b",end:/(\{|$)/,excludeEnd:!0,keywords:n,contains:[e.UNDERSCORE_TITLE_MODE]},{begin:"\\."+e.UNDERSCORE_IDENT_RE,relevance:0}]}})),aF.registerLanguage("perl",(function(e){const t=e.regex,n=/[dualxmsipngr]{0,12}/,r={$pattern:/[\w.]+/,keyword:["abs","accept","alarm","and","atan2","bind","binmode","bless","break","caller","chdir","chmod","chomp","chop","chown","chr","chroot","close","closedir","connect","continue","cos","crypt","dbmclose","dbmopen","defined","delete","die","do","dump","each","else","elsif","endgrent","endhostent","endnetent","endprotoent","endpwent","endservent","eof","eval","exec","exists","exit","exp","fcntl","fileno","flock","for","foreach","fork","format","formline","getc","getgrent","getgrgid","getgrnam","gethostbyaddr","gethostbyname","gethostent","getlogin","getnetbyaddr","getnetbyname","getnetent","getpeername","getpgrp","getpriority","getprotobyname","getprotobynumber","getprotoent","getpwent","getpwnam","getpwuid","getservbyname","getservbyport","getservent","getsockname","getsockopt","given","glob","gmtime","goto","grep","gt","hex","if","index","int","ioctl","join","keys","kill","last","lc","lcfirst","length","link","listen","local","localtime","log","lstat","lt","ma","map","mkdir","msgctl","msgget","msgrcv","msgsnd","my","ne","next","no","not","oct","open","opendir","or","ord","our","pack","package","pipe","pop","pos","print","printf","prototype","push","q|0","qq","quotemeta","qw","qx","rand","read","readdir","readline","readlink","readpipe","recv","redo","ref","rename","require","reset","return","reverse","rewinddir","rindex","rmdir","say","scalar","seek","seekdir","select","semctl","semget","semop","send","setgrent","sethostent","setnetent","setpgrp","setpriority","setprotoent","setpwent","setservent","setsockopt","shift","shmctl","shmget","shmread","shmwrite","shutdown","sin","sleep","socket","socketpair","sort","splice","split","sprintf","sqrt","srand","stat","state","study","sub","substr","symlink","syscall","sysopen","sysread","sysseek","system","syswrite","tell","telldir","tie","tied","time","times","tr","truncate","uc","ucfirst","umask","undef","unless","unlink","unpack","unshift","untie","until","use","utime","values","vec","wait","waitpid","wantarray","warn","when","while","write","x|0","xor","y|0"].join(" ")},i={className:"subst",begin:"[$@]\\{",end:"\\}",keywords:r},o={begin:/->\{/,end:/\}/},s={variants:[{begin:/\$\d/},{begin:t.concat(/[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,"(?![A-Za-z])(?![@$%])")},{begin:/[$%@][^\s\w{]/,relevance:0}]},a=[e.BACKSLASH_ESCAPE,i,s],l=[/!/,/\//,/\|/,/\?/,/'/,/"/,/#/],c=(e,r,i="\\1")=>{const o="\\1"===i?i:t.concat(i,r);return t.concat(t.concat("(?:",e,")"),r,/(?:\\.|[^\\\/])*?/,o,/(?:\\.|[^\\\/])*?/,i,n)},u=(e,r,i)=>t.concat(t.concat("(?:",e,")"),r,/(?:\\.|[^\\\/])*?/,i,n),d=[s,e.HASH_COMMENT_MODE,e.COMMENT(/^=\w/,/=cut/,{endsWithParent:!0}),o,{className:"string",contains:a,variants:[{begin:"q[qwxr]?\\s*\\(",end:"\\)",relevance:5},{begin:"q[qwxr]?\\s*\\[",end:"\\]",relevance:5},{begin:"q[qwxr]?\\s*\\{",end:"\\}",relevance:5},{begin:"q[qwxr]?\\s*\\|",end:"\\|",relevance:5},{begin:"q[qwxr]?\\s*<",end:">",relevance:5},{begin:"qw\\s+q",end:"q",relevance:5},{begin:"'",end:"'",contains:[e.BACKSLASH_ESCAPE]},{begin:'"',end:'"'},{begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE]},{begin:/\{\w+\}/,relevance:0},{begin:"-?\\w+\\s*=>",relevance:0}]},{className:"number",begin:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",relevance:0},{begin:"(\\/\\/|"+e.RE_STARTERS_RE+"|\\b(split|return|print|reverse|grep)\\b)\\s*",keywords:"split return print reverse grep",relevance:0,contains:[e.HASH_COMMENT_MODE,{className:"regexp",variants:[{begin:c("s|tr|y",t.either(...l,{capture:!0}))},{begin:c("s|tr|y","\\(","\\)")},{begin:c("s|tr|y","\\[","\\]")},{begin:c("s|tr|y","\\{","\\}")}],relevance:2},{className:"regexp",variants:[{begin:/(m|qr)\/\//,relevance:0},{begin:u("(?:m|qr)?",/\//,/\//)},{begin:u("m|qr",t.either(...l,{capture:!0}),/\1/)},{begin:u("m|qr",/\(/,/\)/)},{begin:u("m|qr",/\[/,/\]/)},{begin:u("m|qr",/\{/,/\}/)}]}]},{className:"function",beginKeywords:"sub",end:"(\\s*\\(.*?\\))?[;{]",excludeEnd:!0,relevance:5,contains:[e.TITLE_MODE]},{begin:"-\\w\\b",relevance:0},{begin:"^__DATA__$",end:"^__END__$",subLanguage:"mojolicious",contains:[{begin:"^@@.*",end:"$",className:"comment"}]}];return i.contains=d,o.contains=d,{name:"Perl",aliases:["pl","pm"],keywords:r,contains:d}})),aF.registerLanguage("php",(function(e){const t=e.regex,n=/(?![A-Za-z0-9])(?![$])/,r=t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,n),i=t.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,n),o={scope:"variable",match:"\\$+"+r},s={scope:"subst",variants:[{begin:/\$\w+/},{begin:/\{\$/,end:/\}/}]},a=e.inherit(e.APOS_STRING_MODE,{illegal:null}),l="[ \t\n]",c={scope:"string",variants:[e.inherit(e.QUOTE_STRING_MODE,{illegal:null,contains:e.QUOTE_STRING_MODE.contains.concat(s)}),a,e.END_SAME_AS_BEGIN({begin:/<<<[ \t]*(\w+)\n/,end:/[ \t]*(\w+)\b/,contains:e.QUOTE_STRING_MODE.contains.concat(s)})]},u={scope:"number",variants:[{begin:"\\b0[bB][01]+(?:_[01]+)*\\b"},{begin:"\\b0[oO][0-7]+(?:_[0-7]+)*\\b"},{begin:"\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b"},{begin:"(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?"}],relevance:0},d=["false","null","true"],h=["__CLASS__","__DIR__","__FILE__","__FUNCTION__","__COMPILER_HALT_OFFSET__","__LINE__","__METHOD__","__NAMESPACE__","__TRAIT__","die","echo","exit","include","include_once","print","require","require_once","array","abstract","and","as","binary","bool","boolean","break","callable","case","catch","class","clone","const","continue","declare","default","do","double","else","elseif","empty","enddeclare","endfor","endforeach","endif","endswitch","endwhile","enum","eval","extends","final","finally","float","for","foreach","from","global","goto","if","implements","instanceof","insteadof","int","integer","interface","isset","iterable","list","match|0","mixed","new","never","object","or","private","protected","public","readonly","real","return","string","switch","throw","trait","try","unset","use","var","void","while","xor","yield"],p=["Error|0","AppendIterator","ArgumentCountError","ArithmeticError","ArrayIterator","ArrayObject","AssertionError","BadFunctionCallException","BadMethodCallException","CachingIterator","CallbackFilterIterator","CompileError","Countable","DirectoryIterator","DivisionByZeroError","DomainException","EmptyIterator","ErrorException","Exception","FilesystemIterator","FilterIterator","GlobIterator","InfiniteIterator","InvalidArgumentException","IteratorIterator","LengthException","LimitIterator","LogicException","MultipleIterator","NoRewindIterator","OutOfBoundsException","OutOfRangeException","OuterIterator","OverflowException","ParentIterator","ParseError","RangeException","RecursiveArrayIterator","RecursiveCachingIterator","RecursiveCallbackFilterIterator","RecursiveDirectoryIterator","RecursiveFilterIterator","RecursiveIterator","RecursiveIteratorIterator","RecursiveRegexIterator","RecursiveTreeIterator","RegexIterator","RuntimeException","SeekableIterator","SplDoublyLinkedList","SplFileInfo","SplFileObject","SplFixedArray","SplHeap","SplMaxHeap","SplMinHeap","SplObjectStorage","SplObserver","SplPriorityQueue","SplQueue","SplStack","SplSubject","SplTempFileObject","TypeError","UnderflowException","UnexpectedValueException","UnhandledMatchError","ArrayAccess","BackedEnum","Closure","Fiber","Generator","Iterator","IteratorAggregate","Serializable","Stringable","Throwable","Traversable","UnitEnum","WeakReference","WeakMap","Directory","__PHP_Incomplete_Class","parent","php_user_filter","self","static","stdClass"],f={keyword:h,literal:(e=>{const t=[];return e.forEach((e=>{t.push(e),e.toLowerCase()===e?t.push(e.toUpperCase()):t.push(e.toLowerCase());})),t})(d),built_in:p},m=e=>e.map((e=>e.replace(/\|\d+$/,""))),g={variants:[{match:[/new/,t.concat(l,"+"),t.concat("(?!",m(p).join("\\b|"),"\\b)"),i],scope:{1:"keyword",4:"title.class"}}]},v=t.concat(r,"\\b(?!\\()"),y={variants:[{match:[t.concat(/::/,t.lookahead(/(?!class\b)/)),v],scope:{2:"variable.constant"}},{match:[/::/,/class/],scope:{2:"variable.language"}},{match:[i,t.concat(/::/,t.lookahead(/(?!class\b)/)),v],scope:{1:"title.class",3:"variable.constant"}},{match:[i,t.concat("::",t.lookahead(/(?!class\b)/))],scope:{1:"title.class"}},{match:[i,/::/,/class/],scope:{1:"title.class",3:"variable.language"}}]},b={scope:"attr",match:t.concat(r,t.lookahead(":"),t.lookahead(/(?!::)/))},w={relevance:0,begin:/\(/,end:/\)/,keywords:f,contains:[b,o,y,e.C_BLOCK_COMMENT_MODE,c,u,g]},k={relevance:0,match:[/\b/,t.concat("(?!fn\\b|function\\b|",m(h).join("\\b|"),"|",m(p).join("\\b|"),"\\b)"),r,t.concat(l,"*"),t.lookahead(/(?=\()/)],scope:{3:"title.function.invoke"},contains:[w]};w.contains.push(k);const C=[b,y,e.C_BLOCK_COMMENT_MODE,c,u,g];return {case_insensitive:!1,keywords:f,contains:[{begin:t.concat(/#\[\s*/,i),beginScope:"meta",end:/]/,endScope:"meta",keywords:{literal:d,keyword:["new","array"]},contains:[{begin:/\[/,end:/]/,keywords:{literal:d,keyword:["new","array"]},contains:["self",...C]},...C,{scope:"meta",match:i}]},e.HASH_COMMENT_MODE,e.COMMENT("//","$"),e.COMMENT("/\\*","\\*/",{contains:[{scope:"doctag",match:"@[A-Za-z]+"}]}),{match:/__halt_compiler\(\);/,keywords:"__halt_compiler",starts:{scope:"comment",end:e.MATCH_NOTHING_RE,contains:[{match:/\?>/,scope:"meta",endsParent:!0}]}},{scope:"meta",variants:[{begin:/<\?php/,relevance:10},{begin:/<\?=/},{begin:/<\?/,relevance:.1},{begin:/\?>/}]},{scope:"variable.language",match:/\$this\b/},o,k,y,{match:[/const/,/\s/,r],scope:{1:"keyword",3:"variable.constant"}},g,{scope:"function",relevance:0,beginKeywords:"fn function",end:/[;{]/,excludeEnd:!0,illegal:"[$%\\[]",contains:[{beginKeywords:"use"},e.UNDERSCORE_TITLE_MODE,{begin:"=>",endsParent:!0},{scope:"params",begin:"\\(",end:"\\)",excludeBegin:!0,excludeEnd:!0,keywords:f,contains:["self",o,y,e.C_BLOCK_COMMENT_MODE,c,u]}]},{scope:"class",variants:[{beginKeywords:"enum",illegal:/[($"]/},{beginKeywords:"class interface trait",illegal:/[:($"]/}],relevance:0,end:/\{/,excludeEnd:!0,contains:[{beginKeywords:"extends implements"},e.UNDERSCORE_TITLE_MODE]},{beginKeywords:"namespace",relevance:0,end:";",illegal:/[.']/,contains:[e.inherit(e.UNDERSCORE_TITLE_MODE,{scope:"title.class"})]},{beginKeywords:"use",relevance:0,end:";",contains:[{match:/\b(as|const|function)\b/,scope:"keyword"},e.UNDERSCORE_TITLE_MODE]},c,u]}})),aF.registerLanguage("php-template",(function(e){return {name:"PHP template",subLanguage:"xml",contains:[{begin:/<\?(php|=)?/,end:/\?>/,subLanguage:"php",contains:[{begin:"/\\*",end:"\\*/",skip:!0},{begin:'b"',end:'"',skip:!0},{begin:"b'",end:"'",skip:!0},e.inherit(e.APOS_STRING_MODE,{illegal:null,className:null,contains:null,skip:!0}),e.inherit(e.QUOTE_STRING_MODE,{illegal:null,className:null,contains:null,skip:!0})]}]}})),aF.registerLanguage("plaintext",(function(e){return {name:"Plain text",aliases:["text","txt"],disableAutodetect:!0}})),aF.registerLanguage("python",(function(e){const t=e.regex,n=/[\p{XID_Start}_]\p{XID_Continue}*/u,r=["and","as","assert","async","await","break","case","class","continue","def","del","elif","else","except","finally","for","from","global","if","import","in","is","lambda","match","nonlocal|10","not","or","pass","raise","return","try","while","with","yield"],i={$pattern:/[A-Za-z]\w+|__\w+__/,keyword:r,built_in:["__import__","abs","all","any","ascii","bin","bool","breakpoint","bytearray","bytes","callable","chr","classmethod","compile","complex","delattr","dict","dir","divmod","enumerate","eval","exec","filter","float","format","frozenset","getattr","globals","hasattr","hash","help","hex","id","input","int","isinstance","issubclass","iter","len","list","locals","map","max","memoryview","min","next","object","oct","open","ord","pow","print","property","range","repr","reversed","round","set","setattr","slice","sorted","staticmethod","str","sum","super","tuple","type","vars","zip"],literal:["__debug__","Ellipsis","False","None","NotImplemented","True"],type:["Any","Callable","Coroutine","Dict","List","Literal","Generic","Optional","Sequence","Set","Tuple","Type","Union"]},o={className:"meta",begin:/^(>>>|\.\.\.) /},s={className:"subst",begin:/\{/,end:/\}/,keywords:i,illegal:/#/},a={begin:/\{\{/,relevance:0},l={className:"string",contains:[e.BACKSLASH_ESCAPE],variants:[{begin:/([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,end:/'''/,contains:[e.BACKSLASH_ESCAPE,o],relevance:10},{begin:/([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,end:/"""/,contains:[e.BACKSLASH_ESCAPE,o],relevance:10},{begin:/([fF][rR]|[rR][fF]|[fF])'''/,end:/'''/,contains:[e.BACKSLASH_ESCAPE,o,a,s]},{begin:/([fF][rR]|[rR][fF]|[fF])"""/,end:/"""/,contains:[e.BACKSLASH_ESCAPE,o,a,s]},{begin:/([uU]|[rR])'/,end:/'/,relevance:10},{begin:/([uU]|[rR])"/,end:/"/,relevance:10},{begin:/([bB]|[bB][rR]|[rR][bB])'/,end:/'/},{begin:/([bB]|[bB][rR]|[rR][bB])"/,end:/"/},{begin:/([fF][rR]|[rR][fF]|[fF])'/,end:/'/,contains:[e.BACKSLASH_ESCAPE,a,s]},{begin:/([fF][rR]|[rR][fF]|[fF])"/,end:/"/,contains:[e.BACKSLASH_ESCAPE,a,s]},e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},c="[0-9](_?[0-9])*",u=`(\\b(${c}))?\\.(${c})|\\b(${c})\\.`,d=`\\b|${r.join("|")}`,h={className:"number",relevance:0,variants:[{begin:`(\\b(${c})|(${u}))[eE][+-]?(${c})[jJ]?(?=${d})`},{begin:`(${u})[jJ]?`},{begin:`\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`},{begin:`\\b0[bB](_?[01])+[lL]?(?=${d})`},{begin:`\\b0[oO](_?[0-7])+[lL]?(?=${d})`},{begin:`\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`},{begin:`\\b(${c})[jJ](?=${d})`}]},p={className:"comment",begin:t.lookahead(/# type:/),end:/$/,keywords:i,contains:[{begin:/# type:/},{begin:/#/,end:/\b\B/,endsWithParent:!0}]},f={className:"params",variants:[{className:"",begin:/\(\s*\)/,skip:!0},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:i,contains:["self",o,h,l,e.HASH_COMMENT_MODE]}]};return s.contains=[l,h,o],{name:"Python",aliases:["py","gyp","ipython"],unicodeRegex:!0,keywords:i,illegal:/(<\/|->|\?)|=>/,contains:[o,h,{begin:/\bself\b/},{beginKeywords:"if",relevance:0},l,p,e.HASH_COMMENT_MODE,{match:[/\bdef/,/\s+/,n],scope:{1:"keyword",3:"title.function"},contains:[f]},{variants:[{match:[/\bclass/,/\s+/,n,/\s*/,/\(\s*/,n,/\s*\)/]},{match:[/\bclass/,/\s+/,n]}],scope:{1:"keyword",3:"title.class",6:"title.class.inherited"}},{className:"meta",begin:/^[\t ]*@/,end:/(?=#)|$/,contains:[h,f,l]}]}})),aF.registerLanguage("python-repl",(function(e){return {aliases:["pycon"],contains:[{className:"meta.prompt",starts:{end:/ |$/,starts:{end:"$",subLanguage:"python"}},variants:[{begin:/^>>>(?=[ ]|$)/},{begin:/^\.\.\.(?=[ ]|$)/}]}]}})),aF.registerLanguage("r",(function(e){const t=e.regex,n=/(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,r=t.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,/0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,/(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/),i=/[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,o=t.either(/[()]/,/[{}]/,/\[\[/,/[[\]]/,/\\/,/,/);return {name:"R",keywords:{$pattern:n,keyword:"function if in break next repeat else for while",literal:"NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",built_in:"LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"},contains:[e.COMMENT(/#'/,/$/,{contains:[{scope:"doctag",match:/@examples/,starts:{end:t.lookahead(t.either(/\n^#'\s*(?=@[a-zA-Z]+)/,/\n^(?!#')/)),endsParent:!0}},{scope:"doctag",begin:"@param",end:/$/,contains:[{scope:"variable",variants:[{match:n},{match:/`(?:\\.|[^`\\])+`/}],endsParent:!0}]},{scope:"doctag",match:/@[a-zA-Z]+/},{scope:"keyword",match:/\\[a-zA-Z]+/}]}),e.HASH_COMMENT_MODE,{scope:"string",contains:[e.BACKSLASH_ESCAPE],variants:[e.END_SAME_AS_BEGIN({begin:/[rR]"(-*)\(/,end:/\)(-*)"/}),e.END_SAME_AS_BEGIN({begin:/[rR]"(-*)\{/,end:/\}(-*)"/}),e.END_SAME_AS_BEGIN({begin:/[rR]"(-*)\[/,end:/\](-*)"/}),e.END_SAME_AS_BEGIN({begin:/[rR]'(-*)\(/,end:/\)(-*)'/}),e.END_SAME_AS_BEGIN({begin:/[rR]'(-*)\{/,end:/\}(-*)'/}),e.END_SAME_AS_BEGIN({begin:/[rR]'(-*)\[/,end:/\](-*)'/}),{begin:'"',end:'"',relevance:0},{begin:"'",end:"'",relevance:0}]},{relevance:0,variants:[{scope:{1:"operator",2:"number"},match:[i,r]},{scope:{1:"operator",2:"number"},match:[/%[^%]*%/,r]},{scope:{1:"punctuation",2:"number"},match:[o,r]},{scope:{2:"number"},match:[/[^a-zA-Z0-9._]|^/,r]}]},{scope:{3:"operator"},match:[n,/\s+/,/<-/,/\s+/]},{scope:"operator",relevance:0,variants:[{match:i},{match:/%[^%]*%/}]},{scope:"punctuation",relevance:0,match:o},{begin:"`",end:"`",contains:[{begin:/\\./}]}]}})),aF.registerLanguage("ruby",(function(e){const t=e.regex,n="([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)",r=t.either(/\b([A-Z]+[a-z0-9]+)+/,/\b([A-Z]+[a-z0-9]+)+[A-Z]+/),i=t.concat(r,/(::\w+)*/),o={"variable.constant":["__FILE__","__LINE__"],"variable.language":["self","super"],keyword:["alias","and","attr_accessor","attr_reader","attr_writer","begin","BEGIN","break","case","class","defined","do","else","elsif","end","END","ensure","for","if","in","include","module","next","not","or","redo","require","rescue","retry","return","then","undef","unless","until","when","while","yield"],built_in:["proc","lambda"],literal:["true","false","nil"]},s={className:"doctag",begin:"@[A-Za-z]+"},a={begin:"#<",end:">"},l=[e.COMMENT("#","$",{contains:[s]}),e.COMMENT("^=begin","^=end",{contains:[s],relevance:10}),e.COMMENT("^__END__",e.MATCH_NOTHING_RE)],c={className:"subst",begin:/#\{/,end:/\}/,keywords:o},u={className:"string",contains:[e.BACKSLASH_ESCAPE,c],variants:[{begin:/'/,end:/'/},{begin:/"/,end:/"/},{begin:/`/,end:/`/},{begin:/%[qQwWx]?\(/,end:/\)/},{begin:/%[qQwWx]?\[/,end:/\]/},{begin:/%[qQwWx]?\{/,end:/\}/},{begin:/%[qQwWx]?</,end:/>/},{begin:/%[qQwWx]?\//,end:/\//},{begin:/%[qQwWx]?%/,end:/%/},{begin:/%[qQwWx]?-/,end:/-/},{begin:/%[qQwWx]?\|/,end:/\|/},{begin:/\B\?(\\\d{1,3})/},{begin:/\B\?(\\x[A-Fa-f0-9]{1,2})/},{begin:/\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/},{begin:/\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/},{begin:/\B\?\\(c|C-)[\x20-\x7e]/},{begin:/\B\?\\?\S/},{begin:t.concat(/<<[-~]?'?/,t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),contains:[e.END_SAME_AS_BEGIN({begin:/(\w+)/,end:/(\w+)/,contains:[e.BACKSLASH_ESCAPE,c]})]}]},d="[0-9](_?[0-9])*",h={className:"number",relevance:0,variants:[{begin:`\\b([1-9](_?[0-9])*|0)(\\.(${d}))?([eE][+-]?(${d})|r)?i?\\b`},{begin:"\\b0[dD][0-9](_?[0-9])*r?i?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*r?i?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*r?i?\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"},{begin:"\\b0(_?[0-7])+r?i?\\b"}]},p={variants:[{match:/\(\)/},{className:"params",begin:/\(/,end:/(?=\))/,excludeBegin:!0,endsParent:!0,keywords:o}]},f=[u,{variants:[{match:[/class\s+/,i,/\s+<\s+/,i]},{match:[/class\s+/,i]}],scope:{2:"title.class",4:"title.class.inherited"},keywords:o},{relevance:0,match:[i,/\.new[ (]/],scope:{1:"title.class"}},{relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"},{match:[/def/,/\s+/,n],scope:{1:"keyword",3:"title.function"},contains:[p]},{begin:e.IDENT_RE+"::"},{className:"symbol",begin:e.UNDERSCORE_IDENT_RE+"(!|\\?)?:",relevance:0},{className:"symbol",begin:":(?!\\s)",contains:[u,{begin:n}],relevance:0},h,{className:"variable",begin:"(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"},{className:"params",begin:/\|/,end:/\|/,excludeBegin:!0,excludeEnd:!0,relevance:0,keywords:o},{begin:"("+e.RE_STARTERS_RE+"|unless)\\s*",keywords:"unless",contains:[{className:"regexp",contains:[e.BACKSLASH_ESCAPE,c],illegal:/\n/,variants:[{begin:"/",end:"/[a-z]*"},{begin:/%r\{/,end:/\}[a-z]*/},{begin:"%r\\(",end:"\\)[a-z]*"},{begin:"%r!",end:"![a-z]*"},{begin:"%r\\[",end:"\\][a-z]*"}]}].concat(a,l),relevance:0}].concat(a,l);c.contains=f,p.contains=f;const m=[{begin:/^\s*=>/,starts:{end:"$",contains:f}},{className:"meta.prompt",begin:"^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",starts:{end:"$",keywords:o,contains:f}}];return l.unshift(a),{name:"Ruby",aliases:["rb","gemspec","podspec","thor","irb"],keywords:o,illegal:/\/\*/,contains:[e.SHEBANG({binary:"ruby"})].concat(m).concat(l).concat(f)}})),aF.registerLanguage("rust",(function(e){const t=e.regex,n={className:"title.function.invoke",relevance:0,begin:t.concat(/\b/,/(?!let\b)/,e.IDENT_RE,t.lookahead(/\s*\(/))},r="([ui](8|16|32|64|128|size)|f(32|64))?",i=["drop ","Copy","Send","Sized","Sync","Drop","Fn","FnMut","FnOnce","ToOwned","Clone","Debug","PartialEq","PartialOrd","Eq","Ord","AsRef","AsMut","Into","From","Default","Iterator","Extend","IntoIterator","DoubleEndedIterator","ExactSizeIterator","SliceConcatExt","ToString","assert!","assert_eq!","bitflags!","bytes!","cfg!","col!","concat!","concat_idents!","debug_assert!","debug_assert_eq!","env!","panic!","file!","format!","format_args!","include_bytes!","include_str!","line!","local_data_key!","module_path!","option_env!","print!","println!","select!","stringify!","try!","unimplemented!","unreachable!","vec!","write!","writeln!","macro_rules!","assert_ne!","debug_assert_ne!"],o=["i8","i16","i32","i64","i128","isize","u8","u16","u32","u64","u128","usize","f32","f64","str","char","bool","Box","Option","Result","String","Vec"];return {name:"Rust",aliases:["rs"],keywords:{$pattern:e.IDENT_RE+"!?",type:o,keyword:["abstract","as","async","await","become","box","break","const","continue","crate","do","dyn","else","enum","extern","false","final","fn","for","if","impl","in","let","loop","macro","match","mod","move","mut","override","priv","pub","ref","return","self","Self","static","struct","super","trait","true","try","type","typeof","unsafe","unsized","use","virtual","where","while","yield"],literal:["true","false","Some","None","Ok","Err"],built_in:i},illegal:"</",contains:[e.C_LINE_COMMENT_MODE,e.COMMENT("/\\*","\\*/",{contains:["self"]}),e.inherit(e.QUOTE_STRING_MODE,{begin:/b?"/,illegal:null}),{className:"string",variants:[{begin:/b?r(#*)"(.|\n)*?"\1(?!#)/},{begin:/b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/}]},{className:"symbol",begin:/'[a-zA-Z_][a-zA-Z0-9_]*/},{className:"number",variants:[{begin:"\\b0b([01_]+)"+r},{begin:"\\b0o([0-7_]+)"+r},{begin:"\\b0x([A-Fa-f0-9_]+)"+r},{begin:"\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)"+r}],relevance:0},{begin:[/fn/,/\s+/,e.UNDERSCORE_IDENT_RE],className:{1:"keyword",3:"title.function"}},{className:"meta",begin:"#!?\\[",end:"\\]",contains:[{className:"string",begin:/"/,end:/"/}]},{begin:[/let/,/\s+/,/(?:mut\s+)?/,e.UNDERSCORE_IDENT_RE],className:{1:"keyword",3:"keyword",4:"variable"}},{begin:[/for/,/\s+/,e.UNDERSCORE_IDENT_RE,/\s+/,/in/],className:{1:"keyword",3:"variable",5:"keyword"}},{begin:[/type/,/\s+/,e.UNDERSCORE_IDENT_RE],className:{1:"keyword",3:"title.class"}},{begin:[/(?:trait|enum|struct|union|impl|for)/,/\s+/,e.UNDERSCORE_IDENT_RE],className:{1:"keyword",3:"title.class"}},{begin:e.IDENT_RE+"::",keywords:{keyword:"Self",built_in:i,type:o}},{className:"punctuation",begin:"->"},n]}})),aF.registerLanguage("scss",(function(e){const t=(e=>({IMPORTANT:{scope:"meta",begin:"!important"},BLOCK_COMMENT:e.C_BLOCK_COMMENT_MODE,HEXCOLOR:{scope:"number",begin:/#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/},FUNCTION_DISPATCH:{className:"built_in",begin:/[\w-]+(?=\()/},ATTRIBUTE_SELECTOR_MODE:{scope:"selector-attr",begin:/\[/,end:/\]/,illegal:"$",contains:[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE]},CSS_NUMBER_MODE:{scope:"number",begin:e.NUMBER_RE+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",relevance:0},CSS_VARIABLE:{className:"attr",begin:/--[A-Za-z][A-Za-z0-9_-]*/}}))(e),n=fL,r=pL,i="@[a-z-]+",o={className:"variable",begin:"(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",relevance:0};return {name:"SCSS",case_insensitive:!0,illegal:"[=/|']",contains:[e.C_LINE_COMMENT_MODE,e.C_BLOCK_COMMENT_MODE,t.CSS_NUMBER_MODE,{className:"selector-id",begin:"#[A-Za-z0-9_-]+",relevance:0},{className:"selector-class",begin:"\\.[A-Za-z0-9_-]+",relevance:0},t.ATTRIBUTE_SELECTOR_MODE,{className:"selector-tag",begin:"\\b("+dL.join("|")+")\\b",relevance:0},{className:"selector-pseudo",begin:":("+r.join("|")+")"},{className:"selector-pseudo",begin:":(:)?("+n.join("|")+")"},o,{begin:/\(/,end:/\)/,contains:[t.CSS_NUMBER_MODE]},t.CSS_VARIABLE,{className:"attribute",begin:"\\b("+mL.join("|")+")\\b"},{begin:"\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"},{begin:/:/,end:/[;}{]/,relevance:0,contains:[t.BLOCK_COMMENT,o,t.HEXCOLOR,t.CSS_NUMBER_MODE,e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,t.IMPORTANT,t.FUNCTION_DISPATCH]},{begin:"@(page|font-face)",keywords:{$pattern:i,keyword:"@page @font-face"}},{begin:"@",end:"[{;]",returnBegin:!0,keywords:{$pattern:/[a-z-]+/,keyword:"and or not only",attribute:hL.join(" ")},contains:[{begin:i,className:"keyword"},{begin:/[a-z-]+(?=:)/,className:"attribute"},o,e.QUOTE_STRING_MODE,e.APOS_STRING_MODE,t.HEXCOLOR,t.CSS_NUMBER_MODE]},t.FUNCTION_DISPATCH]}})),aF.registerLanguage("shell",(function(e){return {name:"Shell Session",aliases:["console","shellsession"],contains:[{className:"meta.prompt",begin:/^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,starts:{end:/[^\\](?=\s*$)/,subLanguage:"bash"}}]}})),aF.registerLanguage("sql",(function(e){const t=e.regex,n=e.COMMENT("--","$"),r=["true","false","unknown"],i=["bigint","binary","blob","boolean","char","character","clob","date","dec","decfloat","decimal","float","int","integer","interval","nchar","nclob","national","numeric","real","row","smallint","time","timestamp","varchar","varying","varbinary"],o=["abs","acos","array_agg","asin","atan","avg","cast","ceil","ceiling","coalesce","corr","cos","cosh","count","covar_pop","covar_samp","cume_dist","dense_rank","deref","element","exp","extract","first_value","floor","json_array","json_arrayagg","json_exists","json_object","json_objectagg","json_query","json_table","json_table_primitive","json_value","lag","last_value","lead","listagg","ln","log","log10","lower","max","min","mod","nth_value","ntile","nullif","percent_rank","percentile_cont","percentile_disc","position","position_regex","power","rank","regr_avgx","regr_avgy","regr_count","regr_intercept","regr_r2","regr_slope","regr_sxx","regr_sxy","regr_syy","row_number","sin","sinh","sqrt","stddev_pop","stddev_samp","substring","substring_regex","sum","tan","tanh","translate","translate_regex","treat","trim","trim_array","unnest","upper","value_of","var_pop","var_samp","width_bucket"],s=["create table","insert into","primary key","foreign key","not null","alter table","add constraint","grouping sets","on overflow","character set","respect nulls","ignore nulls","nulls first","nulls last","depth first","breadth first"],a=o,l=["abs","acos","all","allocate","alter","and","any","are","array","array_agg","array_max_cardinality","as","asensitive","asin","asymmetric","at","atan","atomic","authorization","avg","begin","begin_frame","begin_partition","between","bigint","binary","blob","boolean","both","by","call","called","cardinality","cascaded","case","cast","ceil","ceiling","char","char_length","character","character_length","check","classifier","clob","close","coalesce","collate","collect","column","commit","condition","connect","constraint","contains","convert","copy","corr","corresponding","cos","cosh","count","covar_pop","covar_samp","create","cross","cube","cume_dist","current","current_catalog","current_date","current_default_transform_group","current_path","current_role","current_row","current_schema","current_time","current_timestamp","current_path","current_role","current_transform_group_for_type","current_user","cursor","cycle","date","day","deallocate","dec","decimal","decfloat","declare","default","define","delete","dense_rank","deref","describe","deterministic","disconnect","distinct","double","drop","dynamic","each","element","else","empty","end","end_frame","end_partition","end-exec","equals","escape","every","except","exec","execute","exists","exp","external","extract","false","fetch","filter","first_value","float","floor","for","foreign","frame_row","free","from","full","function","fusion","get","global","grant","group","grouping","groups","having","hold","hour","identity","in","indicator","initial","inner","inout","insensitive","insert","int","integer","intersect","intersection","interval","into","is","join","json_array","json_arrayagg","json_exists","json_object","json_objectagg","json_query","json_table","json_table_primitive","json_value","lag","language","large","last_value","lateral","lead","leading","left","like","like_regex","listagg","ln","local","localtime","localtimestamp","log","log10","lower","match","match_number","match_recognize","matches","max","member","merge","method","min","minute","mod","modifies","module","month","multiset","national","natural","nchar","nclob","new","no","none","normalize","not","nth_value","ntile","null","nullif","numeric","octet_length","occurrences_regex","of","offset","old","omit","on","one","only","open","or","order","out","outer","over","overlaps","overlay","parameter","partition","pattern","per","percent","percent_rank","percentile_cont","percentile_disc","period","portion","position","position_regex","power","precedes","precision","prepare","primary","procedure","ptf","range","rank","reads","real","recursive","ref","references","referencing","regr_avgx","regr_avgy","regr_count","regr_intercept","regr_r2","regr_slope","regr_sxx","regr_sxy","regr_syy","release","result","return","returns","revoke","right","rollback","rollup","row","row_number","rows","running","savepoint","scope","scroll","search","second","seek","select","sensitive","session_user","set","show","similar","sin","sinh","skip","smallint","some","specific","specifictype","sql","sqlexception","sqlstate","sqlwarning","sqrt","start","static","stddev_pop","stddev_samp","submultiset","subset","substring","substring_regex","succeeds","sum","symmetric","system","system_time","system_user","table","tablesample","tan","tanh","then","time","timestamp","timezone_hour","timezone_minute","to","trailing","translate","translate_regex","translation","treat","trigger","trim","trim_array","true","truncate","uescape","union","unique","unknown","unnest","update","upper","user","using","value","values","value_of","var_pop","var_samp","varbinary","varchar","varying","versioning","when","whenever","where","width_bucket","window","with","within","without","year","add","asc","collation","desc","final","first","last","view"].filter((e=>!o.includes(e))),c={begin:t.concat(/\b/,t.either(...a),/\s*\(/),relevance:0,keywords:{built_in:a}};return {name:"SQL",case_insensitive:!0,illegal:/[{}]|<\//,keywords:{$pattern:/\b[\w\.]+/,keyword:function(e,{exceptions:t,when:n}={}){const r=n;return t=t||[],e.map((e=>e.match(/\|\d+$/)||t.includes(e)?e:r(e)?`${e}|0`:e))}(l,{when:e=>e.length<3}),literal:r,type:i,built_in:["current_catalog","current_date","current_default_transform_group","current_path","current_role","current_schema","current_transform_group_for_type","current_user","session_user","system_time","system_user","current_time","localtime","current_timestamp","localtimestamp"]},contains:[{begin:t.either(...s),relevance:0,keywords:{$pattern:/[\w\.]+/,keyword:l.concat(s),literal:r,type:i}},{className:"type",begin:t.either("double precision","large object","with timezone","without timezone")},c,{className:"variable",begin:/@[a-z0-9]+/},{className:"string",variants:[{begin:/'/,end:/'/,contains:[{begin:/''/}]}]},{begin:/"/,end:/"/,contains:[{begin:/""/}]},e.C_NUMBER_MODE,e.C_BLOCK_COMMENT_MODE,n,{className:"operator",begin:/[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,relevance:0}]}})),aF.registerLanguage("swift",(function(e){const t={match:/\s+/,relevance:0},n=e.COMMENT("/\\*","\\*/",{contains:["self"]}),r=[e.C_LINE_COMMENT_MODE,n],i={match:[/\./,bL(...kL,...CL)],className:{2:"keyword"}},o={match:yL(/\./,bL(...xL)),relevance:0},s=xL.filter((e=>"string"==typeof e)).concat(["_|0"]),a={variants:[{className:"keyword",match:bL(...xL.filter((e=>"string"!=typeof e)).concat(EL).map(wL),...CL)}]},l={$pattern:bL(/\b\w+/,/#\w+/),keyword:s.concat(ML),literal:SL},c=[i,o,a],u=[{match:yL(/\./,bL(...OL)),relevance:0},{className:"built_in",match:yL(/\b/,bL(...OL),/(?=\()/)}],d={match:/->/,relevance:0},h=[d,{className:"operator",relevance:0,variants:[{match:_L},{match:`\\.(\\.|${NL})+`}]}],p="([0-9a-fA-F]_*)+",f={className:"number",relevance:0,variants:[{match:"\\b(([0-9]_*)+)(\\.(([0-9]_*)+))?([eE][+-]?(([0-9]_*)+))?\\b"},{match:`\\b0x(${p})(\\.(${p}))?([pP][+-]?(([0-9]_*)+))?\\b`},{match:/\b0o([0-7]_*)+\b/},{match:/\b0b([01]_*)+\b/}]},m=(e="")=>({className:"subst",variants:[{match:yL(/\\/,e,/[0\\tnr"']/)},{match:yL(/\\/,e,/u\{[0-9a-fA-F]{1,8}\}/)}]}),g=(e="")=>({className:"subst",match:yL(/\\/,e,/[\t ]*(?:[\r\n]|\r\n)/)}),v=(e="")=>({className:"subst",label:"interpol",begin:yL(/\\/,e,/\(/),end:/\)/}),y=(e="")=>({begin:yL(e,/"""/),end:yL(/"""/,e),contains:[m(e),g(e),v(e)]}),b=(e="")=>({begin:yL(e,/"/),end:yL(/"/,e),contains:[m(e),v(e)]}),w={className:"string",variants:[y(),y("#"),y("##"),y("###"),b(),b("#"),b("##"),b("###")]},k={match:yL(/`/,RL,/`/)},C=[k,{className:"variable",match:/\$\d+/},{className:"variable",match:`\\$${LL}+`}],E=[{match:/(@|#(un)?)available/,className:"keyword",starts:{contains:[{begin:/\(/,end:/\)/,keywords:IL,contains:[...h,f,w]}]}},{className:"keyword",match:yL(/@/,bL(...BL))},{className:"meta",match:yL(/@/,RL)}],x={match:vL(/\b[A-Z]/),relevance:0,contains:[{className:"type",match:yL(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,LL,"+")},{className:"type",match:FL,relevance:0},{match:/[?!]+/,relevance:0},{match:/\.\.\./,relevance:0},{match:yL(/\s+&\s+/,vL(FL)),relevance:0}]},S={begin:/</,end:/>/,keywords:l,contains:[...r,...c,...E,d,x]};x.contains.push(S);const D={begin:/\(/,end:/\)/,relevance:0,keywords:l,contains:["self",{match:yL(RL,/\s*:/),keywords:"_|0",relevance:0},...r,...c,...u,...h,f,w,...C,...E,x]},M={begin:/</,end:/>/,contains:[...r,x]},O={begin:/\(/,end:/\)/,keywords:l,contains:[{begin:bL(vL(yL(RL,/\s*:/)),vL(yL(RL,/\s+/,RL,/\s*:/))),end:/:/,relevance:0,contains:[{className:"keyword",match:/\b_\b/},{className:"params",match:RL}]},...r,...c,...h,f,w,...E,x,D],endsParent:!0,illegal:/["']/},A={match:[/func/,/\s+/,bL(k.match,RL,_L)],className:{1:"keyword",3:"title.function"},contains:[M,O,t],illegal:[/\[/,/%/]},N={match:[/\b(?:subscript|init[?!]?)/,/\s*(?=[<(])/],className:{1:"keyword"},contains:[M,O,t],illegal:/\[|%/},_={match:[/operator/,/\s+/,_L],className:{1:"keyword",3:"title"}},T={begin:[/precedencegroup/,/\s+/,FL],className:{1:"keyword",3:"title"},contains:[x],keywords:[...DL,...SL],end:/}/};for(const e of w.variants){const t=e.contains.find((e=>"interpol"===e.label));t.keywords=l;const n=[...c,...u,...h,f,w,...C];t.contains=[...n,{begin:/\(/,end:/\)/,contains:["self",...n]}];}return {name:"Swift",keywords:l,contains:[...r,A,N,{beginKeywords:"struct protocol class extension enum actor",end:"\\{",excludeEnd:!0,keywords:l,contains:[e.inherit(e.TITLE_MODE,{className:"title.class",begin:/[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/}),...c]},_,T,{beginKeywords:"import",end:/$/,contains:[...r],relevance:0},...c,...u,...h,f,w,...C,...E,x,D]}})),aF.registerLanguage("typescript",(function(e){const t=UL(e),n=["any","void","number","boolean","string","object","never","symbol","bigint","unknown"],r={beginKeywords:"namespace",end:/\{/,excludeEnd:!0,contains:[t.exports.CLASS_REFERENCE]},i={beginKeywords:"interface",end:/\{/,excludeEnd:!0,keywords:{keyword:"interface extends",built_in:n},contains:[t.exports.CLASS_REFERENCE]},o={$pattern:PL,keyword:zL.concat(["type","namespace","interface","public","private","protected","implements","declare","abstract","readonly","enum","override"]),literal:$L,built_in:qL.concat(n),"variable.language":KL},s={className:"meta",begin:"@[A-Za-z$_][0-9A-Za-z$_]*"},a=(e,t,n)=>{const r=e.contains.findIndex((e=>e.label===t));if(-1===r)throw new Error("can not find mode to replace");e.contains.splice(r,1,n);};return Object.assign(t.keywords,o),t.exports.PARAMS_CONTAINS.push(s),t.contains=t.contains.concat([s,r,i]),a(t,"shebang",e.SHEBANG()),a(t,"use_strict",{className:"meta",relevance:10,begin:/^\s*['"]use strict['"]/}),t.contains.find((e=>"func.def"===e.label)).relevance=0,Object.assign(t,{name:"TypeScript",aliases:["ts","tsx"]}),t})),aF.registerLanguage("vbnet",(function(e){const t=e.regex,n=/\d{1,2}\/\d{1,2}\/\d{4}/,r=/\d{4}-\d{1,2}-\d{1,2}/,i=/(\d|1[012])(:\d+){0,2} *(AM|PM)/,o=/\d{1,2}(:\d{1,2}){1,2}/,s={className:"literal",variants:[{begin:t.concat(/# */,t.either(r,n),/ *#/)},{begin:t.concat(/# */,o,/ *#/)},{begin:t.concat(/# */,i,/ *#/)},{begin:t.concat(/# */,t.either(r,n),/ +/,t.either(i,o),/ *#/)}]},a=e.COMMENT(/'''/,/$/,{contains:[{className:"doctag",begin:/<\/?/,end:/>/}]}),l=e.COMMENT(null,/$/,{variants:[{begin:/'/},{begin:/([\t ]|^)REM(?=\s)/}]});return {name:"Visual Basic .NET",aliases:["vb"],case_insensitive:!0,classNameAliases:{label:"symbol"},keywords:{keyword:"addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",built_in:"addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",type:"boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",literal:"true false nothing"},illegal:"//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",contains:[{className:"string",begin:/"(""|[^/n])"C\b/},{className:"string",begin:/"/,end:/"/,illegal:/\n/,contains:[{begin:/""/}]},s,{className:"number",relevance:0,variants:[{begin:/\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/},{begin:/\b\d[\d_]*((U?[SIL])|[%&])?/},{begin:/&H[\dA-F_]+((U?[SIL])|[%&])?/},{begin:/&O[0-7_]+((U?[SIL])|[%&])?/},{begin:/&B[01_]+((U?[SIL])|[%&])?/}]},{className:"label",begin:/^\w+:/},a,l,{className:"meta",begin:/[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,end:/$/,keywords:{keyword:"const disable else elseif enable end externalsource if region then"},contains:[l]}]}})),aF.registerLanguage("wasm",(function(e){e.regex;const t=e.COMMENT(/\(;/,/;\)/);return t.contains.push("self"),{name:"WebAssembly",keywords:{$pattern:/[\w.]+/,keyword:["anyfunc","block","br","br_if","br_table","call","call_indirect","data","drop","elem","else","end","export","func","global.get","global.set","local.get","local.set","local.tee","get_global","get_local","global","if","import","local","loop","memory","memory.grow","memory.size","module","mut","nop","offset","param","result","return","select","set_global","set_local","start","table","tee_local","then","type","unreachable"]},contains:[e.COMMENT(/;;/,/$/),t,{match:[/(?:offset|align)/,/\s*/,/=/],className:{1:"keyword",3:"operator"}},{className:"variable",begin:/\$[\w_]+/},{match:/(\((?!;)|\))+/,className:"punctuation",relevance:0},{begin:[/(?:func|call|call_indirect)/,/\s+/,/\$[^\s)]+/],className:{1:"keyword",3:"title.function"}},e.QUOTE_STRING_MODE,{match:/(i32|i64|f32|f64)(?!\.)/,className:"type"},{className:"keyword",match:/\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/},{className:"number",relevance:0,match:/[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/}]}})),aF.registerLanguage("xml",(function(e){const t=e.regex,n=t.concat(/[\p{L}_]/u,t.optional(/[\p{L}0-9_.-]*:/u),/[\p{L}0-9_.-]*/u),r={className:"symbol",begin:/&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/},i={begin:/\s/,contains:[{className:"keyword",begin:/#?[a-z_][a-z1-9_-]+/,illegal:/\n/}]},o=e.inherit(i,{begin:/\(/,end:/\)/}),s=e.inherit(e.APOS_STRING_MODE,{className:"string"}),a=e.inherit(e.QUOTE_STRING_MODE,{className:"string"}),l={endsWithParent:!0,illegal:/</,relevance:0,contains:[{className:"attr",begin:/[\p{L}0-9._:-]+/u,relevance:0},{begin:/=\s*/,relevance:0,contains:[{className:"string",endsParent:!0,variants:[{begin:/"/,end:/"/,contains:[r]},{begin:/'/,end:/'/,contains:[r]},{begin:/[^\s"'=<>`]+/}]}]}]};return {name:"HTML, XML",aliases:["html","xhtml","rss","atom","xjb","xsd","xsl","plist","wsf","svg"],case_insensitive:!0,unicodeRegex:!0,contains:[{className:"meta",begin:/<![a-z]/,end:/>/,relevance:10,contains:[i,a,s,o,{begin:/\[/,end:/\]/,contains:[{className:"meta",begin:/<![a-z]/,end:/>/,contains:[i,o,a,s]}]}]},e.COMMENT(/<!--/,/-->/,{relevance:10}),{begin:/<!\[CDATA\[/,end:/\]\]>/,relevance:10},r,{className:"meta",end:/\?>/,variants:[{begin:/<\?xml/,relevance:10,contains:[a]},{begin:/<\?[a-z][a-z0-9]+/}]},{className:"tag",begin:/<style(?=\s|>)/,end:/>/,keywords:{name:"style"},contains:[l],starts:{end:/<\/style>/,returnEnd:!0,subLanguage:["css","xml"]}},{className:"tag",begin:/<script(?=\s|>)/,end:/>/,keywords:{name:"script"},contains:[l],starts:{end:/<\/script>/,returnEnd:!0,subLanguage:["javascript","handlebars","xml"]}},{className:"tag",begin:/<>|<\/>/},{className:"tag",begin:t.concat(/</,t.lookahead(t.concat(n,t.either(/\/>/,/>/,/\s/)))),end:/\/?>/,contains:[{className:"name",begin:n,relevance:0,starts:l}]},{className:"tag",begin:t.concat(/<\//,t.lookahead(t.concat(n,/>/))),contains:[{className:"name",begin:n,relevance:0},{begin:/>/,relevance:0,endsParent:!0}]}]}})),aF.registerLanguage("yaml",(function(e){const t="true false yes no null",n="[\\w#;/?:@&=+$,.~*'()[\\]]+",r={className:"string",relevance:0,variants:[{begin:/'/,end:/'/},{begin:/"/,end:/"/},{begin:/\S+/}],contains:[e.BACKSLASH_ESCAPE,{className:"template-variable",variants:[{begin:/\{\{/,end:/\}\}/},{begin:/%\{/,end:/\}/}]}]},i=e.inherit(r,{variants:[{begin:/'/,end:/'/},{begin:/"/,end:/"/},{begin:/[^\s,{}[\]]+/}]}),o={className:"number",begin:"\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"},s={end:",",endsWithParent:!0,excludeEnd:!0,keywords:t,relevance:0},a={begin:/\{/,end:/\}/,contains:[s],illegal:"\\n",relevance:0},l={begin:"\\[",end:"\\]",contains:[s],illegal:"\\n",relevance:0},c=[{className:"attr",variants:[{begin:"\\w[\\w :\\/.-]*:(?=[ \t]|$)"},{begin:'"\\w[\\w :\\/.-]*":(?=[ \t]|$)'},{begin:"'\\w[\\w :\\/.-]*':(?=[ \t]|$)"}]},{className:"meta",begin:"^---\\s*$",relevance:10},{className:"string",begin:"[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"},{begin:"<%[%=-]?",end:"[%-]?%>",subLanguage:"ruby",excludeBegin:!0,excludeEnd:!0,relevance:0},{className:"type",begin:"!\\w+!"+n},{className:"type",begin:"!<"+n+">"},{className:"type",begin:"!"+n},{className:"type",begin:"!!"+n},{className:"meta",begin:"&"+e.UNDERSCORE_IDENT_RE+"$"},{className:"meta",begin:"\\*"+e.UNDERSCORE_IDENT_RE+"$"},{className:"bullet",begin:"-(?=[ ]|$)",relevance:0},e.HASH_COMMENT_MODE,{beginKeywords:t,keywords:{literal:t}},o,{className:"number",begin:e.C_NUMBER_RE+"\\b",relevance:0},a,l,r],u=[...c];return u.pop(),u.push(i),s.contains=u,{name:"YAML",case_insensitive:!0,aliases:["yml"],contains:c}}));var lF=u,cF=Mt,uF=Yn,dF=ti,hF=R,pF=ge,fF=To,mF=Wo;ko("match",(function(e,t,n){return [function(t){var n=hF(this),r=null==t?void 0:pF(t,e);return r?lF(r,t,n):new RegExp(t)[e](dF(n))},function(e){var r=cF(this),i=dF(e),o=n(t,r,i);if(o.done)return o.value;if(!r.global)return mF(r,i);var s=r.unicode;r.lastIndex=0;for(var a,l=[],c=0;null!==(a=mF(r,i));){var u=dF(a[0]);l[c]=u,""===u&&(r.lastIndex=fF(i,uF(r.lastIndex),s)),c++;}return 0===c?null:l}]}));var gF=[{name:"Youtube",buildEmbed:function(e){var t=e.match(/^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/);return t&&t[5]?"https://www.youtube-nocookie.com/embed/{{ID}}".replace("{{ID}}",t[5]):null}},{name:"Codepen",buildEmbed:function(e){var t=e.match(/^https:\/\/codepen.io\/([\w\-]+)\/pen\/([\w\-]+)$/);return t&&t[1]&&t[2]?"https://codepen.io/".concat(t[1],"/embed/").concat(t[2]):null}},{name:"Gist",buildEmbed:function(e){var t=e.match(/^https:\/\/gist.github.com\/([\w\-]+)\/([\w\-]+)$/);return t&&t[1]&&t[2]?"data:text/html;charset=utf-8,<head><base target='_blank' /></head><body><script src='https://gist.github.com/".concat(t[1],"/").concat(t[2],".js'><\/script></body>"):null}}],vF=xp.create({name:"oembed",defaultOptions:{embedOnPaste:!0,inline:!1,HTMLAttributes:{}},group:"block",draggable:!0,atom:!0,addAttributes:function(){return {html:{default:"",rendered:!1},src:{default:null},title:{default:null},frameborder:{default:"0"},allow:{default:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"},allowfullscreen:{default:"allowfullscreen"}}},parseHTML:function(){return [{tag:"iframe[src]"}]},renderHTML:function(e){var t=e.HTMLAttributes;return ["div",{class:"oembed-wrapper"},["iframe",dh(this.options.HTMLAttributes,t)]]},addCommands:function(){var e=this;return {setOembedContentFromHtml:function(e){return function(t){return t.commands.insertContent(e.html+"<p></p>")}},setOembedContentFromAttrs:function(t){return function(n){return n.commands.insertContent({type:e.name,attrs:t})}}}},addProseMirrorPlugins:function(){var e=this,t=[];return this.options.embedOnPaste&&t.push(new Dl({key:new Al("handlePasteLink"),props:{handlePaste:function(t,n,r){var i="",o=!1;return r.content.forEach((function(e){i+=e.textContent;})),!!i&&(gF.forEach((function(e){o||(o=e.buildEmbed(i));})),!!o&&(e.editor.commands.setOembedContentFromAttrs({src:o}),!0))}}})),t}});new FileReader;var yF={name:"paper-wysiwyg-icon",props:{icon:{type:String,required:!0},size:{type:String,default:"24px"}}};function bF(e,t,n,r,i,o,s,a,l,c){"boolean"!=typeof s&&(l=a,a=s,s=!1);const u="function"==typeof n?n.options:n;let d;if(e&&e.render&&(u.render=e.render,u.staticRenderFns=e.staticRenderFns,u._compiled=!0,i&&(u.functional=!0)),r&&(u._scopeId=r),o?(d=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),t&&t.call(this,l(e)),e&&e._registeredComponents&&e._registeredComponents.add(o);},u._ssrRegister=d):t&&(d=s?function(e){t.call(this,c(e,this.$root.$options.shadowRoot));}:function(e){t.call(this,a(e));}),d)if(u.functional){const e=u.render;u.render=function(t,n){return d.call(n),e(t,n)};}else {const e=u.beforeCreate;u.beforeCreate=e?[].concat(e,d):[d];}return n}const wF="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function kF(e){return (e,t)=>function(e,t){const n=wF?t.media||"default":e,r=EF[n]||(EF[n]={ids:new Set,styles:[]});if(!r.ids.has(e)){r.ids.add(e);let n=t.source;if(t.map&&(n+="\n/*# sourceURL="+t.map.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t.map))))+" */"),r.element||(r.element=document.createElement("style"),r.element.type="text/css",t.media&&r.element.setAttribute("media",t.media),void 0===CF&&(CF=document.head||document.getElementsByTagName("head")[0]),CF.appendChild(r.element)),"styleSheet"in r.element)r.styles.push(n),r.element.styleSheet.cssText=r.styles.filter(Boolean).join("\n");else {const e=r.ids.size-1,t=document.createTextNode(n),i=r.element.childNodes;i[e]&&r.element.removeChild(i[e]),i.length?r.element.insertBefore(t,i[e]):r.element.appendChild(t);}}}(e,t)}let CF;const EF={};var xF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("svg",{staticClass:"paper-wysiwyg-icon",attrs:{width:e.size,height:e.size,fill:"currentColor",viewBox:"0 0 24 24"}},["h1"===e.icon?n("g",[n("path",{attrs:{d:"M18,15 L18,8 C18,7.86192881 17.9720178,7.73039322 17.921415,7.61075487 C17.8779612,7.50332041 17.8047379,7.39052429 17.7071068,7.29289322 C17.3165825,6.90236893 16.6834175,6.90236893 16.2928932,7.29289322 L14.2928932,9.29289322 C13.9023689,9.68341751 13.9023689,10.3165825 14.2928932,10.7071068 C14.6834175,11.0976311 15.3165825,11.0976311 15.7071068,10.7071068 L16,10.4142136 L16,15 L15,15 C14.4477153,15 14,15.4477153 14,16 C14,16.5522847 14.4477153,17 15,17 L19,17 C19.5522847,17 20,16.5522847 20,16 C20,15.4477153 19.5522847,15 19,15 L18,15 Z M10,13 L6,13 L6,16 C6,16.5522847 5.55228475,17 5,17 C4.44771525,17 4,16.5522847 4,16 L4,8 L4,8 C4,7.44771525 4.44771525,7 5,7 L5,7 L5,7 C5.55228475,7 6,7.44771525 6,8 L6,11 L10,11 L10,8 L10,8 C10,7.44771525 10.4477153,7 11,7 C11.5522847,7 12,7.44771525 12,8 L12,16 C12,16.5522847 11.5522847,17 11,17 C10.4477153,17 10,16.5522847 10,16 L10,13 Z"}})]):e._e(),e._v(" "),"h2"===e.icon?n("g",[n("path",{attrs:{d:"M10,13 L6,13 L6,16 C6,16.5522847 5.55228475,17 5,17 C4.44771525,17 4,16.5522847 4,16 L4,8 L4,8 C4,7.44771525 4.44771525,7 5,7 L5,7 L5,7 C5.55228475,7 6,7.44771525 6,8 L6,11 L10,11 L10,8 L10,8 C10,7.44771525 10.4477153,7 11,7 C11.5522847,7 12,7.44771525 12,8 L12,16 C12,16.5522847 11.5522847,17 11,17 C10.4477153,17 10,16.5522847 10,16 L10,13 Z M19.8087361,11.0881717 L16.96377,15 L19,15 C19.5522847,15 20,15.4477153 20,16 C20,16.5522847 19.5522847,17 19,17 L15,17 C14.1827132,17 13.710559,16.0727976 14.1912639,15.4118283 L18,10.1748162 L18,9 L16,9 L16,10 C16,10.5522847 15.5522847,11 15,11 C14.4477153,11 14,10.5522847 14,10 L14,9 C14,7.8954305 14.8954305,7 16,7 L18,7 C19.1045695,7 20,7.8954305 20,9 L20,10.5 C20,10.7113425 19.9330418,10.9172514 19.8087361,11.0881717 Z"}})]):e._e(),e._v(" "),"h3"===e.icon?n("g",[n("path",{attrs:{d:"M11,7 C11.5522847,7 12,7.44771525 12,8 L12,16 C12,16.5522847 11.5522847,17 11,17 C10.4477153,17 10,16.5522847 10,16 L10,13 L6,13 L6,16 C6,16.5522847 5.55228475,17 5,17 C4.44771525,17 4,16.5522847 4,16 L4,8 C4,7.44771525 4.44771525,7 5,7 C5.55228475,7 6,7.44771525 6,8 L6,11 L10,11 L10,8 C10,7.44771525 10.4477153,7 11,7 Z M19,7 C19.7865887,7 20.2509345,7.8571835 19.8614991,8.50847393 L19.8,8.6 L17.897,11.137 L18.0117763,11.1748959 C19.1181296,11.5711687 19.9239379,12.5988771 19.9949073,13.8237272 L20,14 C20,15.5976809 18.75108,16.9036609 17.1762728,16.9949073 L17,17 L15,17 C14.4477153,17 14,16.5522847 14,16 C14,15.4871642 14.3860402,15.0644928 14.8833789,15.0067277 L15,15 L17,15 C17.5522847,15 18,14.5522847 18,14 C18,13.4871642 17.6139598,13.0644928 17.1166211,13.0067277 L17,13 L16,13 C15.2134113,13 14.7490655,12.1428165 15.1385009,11.4915261 L15.2,11.4 L17,9 L15,9 C14.4871642,9 14.0644928,8.61395981 14.0067277,8.11662113 L14,8 C14,7.48716416 14.3860402,7.06449284 14.8833789,7.00672773 L15,7 L19,7 Z"}})]):e._e(),e._v(" "),"italic"===e.icon?n("g",[n("path",{attrs:{d:"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"}})]):e._e(),e._v(" "),"bold"===e.icon?n("g",[n("path",{attrs:{d:"M18 15.4286C18 17.9533 16.2091 20 14 20H8C7.44772 20 7 19.4883 7 18.8571V5.14286C7 4.51167 7.44772 4 8 4H13C15.2091 4 17 6.0467 17 8.57143C17 9.69102 16.6478 10.7166 16.0632 11.5114C17.2239 12.3116 18 13.7665 18 15.4286ZM9 17.7143H14C15.1046 17.7143 16 16.6909 16 15.4286C16 14.1662 15.1046 13.1429 14 13.1429H9V17.7143ZM9 10.8571H13C14.1046 10.8571 15 9.83379 15 8.57143C15 7.30906 14.1046 6.28571 13 6.28571H9V10.8571Z"}})]):e._e(),e._v(" "),"strike"===e.icon?n("g",[n("path",{attrs:{d:"M9.26756 9C9.09739 8.70583 9 8.36429 9 8C9 6.89543 9.89543 6 11 6H16C16.5523 6 17 5.55228 17 5C17 4.44772 16.5523 4 16 4H11C8.79086 4 7 5.79086 7 8C7 8.3453 7.04375 8.68038 7.12602 9H9.26756ZM16.874 15C16.9562 15.3196 17 15.6547 17 16C17 18.2091 15.2091 20 13 20H8C7.44772 20 7 19.5523 7 19C7 18.4477 7.44772 18 8 18H13C14.1046 18 15 17.1046 15 16C15 15.6357 14.9026 15.2942 14.7324 15H16.874Z"}}),e._v(" "),n("path",{attrs:{d:"M5 12C5 11.4477 5.44772 11 6 11H18C18.5523 11 19 11.4477 19 12V12C19 12.5523 18.5523 13 18 13H6C5.44772 13 5 12.5523 5 12V12Z"}})]):e._e(),e._v(" "),"menu"===e.icon?n("g",[n("path",{attrs:{d:"M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"}})]):e._e(),e._v(" "),"list"===e.icon?n("g",[n("path",{attrs:{d:"M10,6 L19,6 C19.5522847,6 20,6.44771525 20,7 L20,7 C20,7.55228475 19.5522847,8 19,8 L10,8 C9.44771525,8 9,7.55228475 9,7 L9,7 L9,7 C9,6.44771525 9.44771525,6 10,6 Z M10,16 L19,16 C19.5522847,16 20,16.4477153 20,17 C20,17.5522847 19.5522847,18 19,18 L10,18 C9.44771525,18 9,17.5522847 9,17 C9,16.4477153 9.44771525,16 10,16 Z M10,11 L19,11 C19.5522847,11 20,11.4477153 20,12 C20,12.5522847 19.5522847,13 19,13 L10,13 C9.44771525,13 9,12.5522847 9,12 C9,11.4477153 9.44771525,11 10,11 Z M5,10.5 L5,10.5 C5.82842712,10.5 6.5,11.1715729 6.5,12 C6.5,12.8284271 5.82842712,13.5 5,13.5 C4.17157288,13.5 3.5,12.8284271 3.5,12 C3.5,11.1715729 4.17157288,10.5 5,10.5 L5,10.5 Z M5,5.5 L5,5.5 C5.82842712,5.5 6.5,6.17157288 6.5,7 L6.5,7 C6.5,7.82842712 5.82842712,8.5 5,8.5 C4.17157288,8.5 3.5,7.82842712 3.5,7 L3.5,7 L3.5,7 C3.5,6.17157288 4.17157288,5.5 5,5.5 L5,5.5 Z M5,15.5 L5,15.5 C5.82842712,15.5 6.5,16.1715729 6.5,17 C6.5,17.8284271 5.82842712,18.5 5,18.5 C4.17157288,18.5 3.5,17.8284271 3.5,17 C3.5,16.1715729 4.17157288,15.5 5,15.5 L5,15.5 Z"}})]):e._e(),e._v(" "),"task_list"===e.icon?n("g",[n("path",{attrs:{d:"M9.99992841,5.99992841 L19.0000716,5.99992841 L19.0000716,5.99992841 C19.5523168,5.99992841 20,6.4476116 20,6.99985681 L20,6.99985681 C20,7.55210202 19.5523168,7.99978522 19.0000716,7.99978522 L9.99992841,7.99978522 L9.99992841,7.99978522 C9.4476832,7.99978522 9,7.55210202 9,6.99985681 C9,6.4476116 9.4476832,5.99992841 9.99992841,5.99992841 L9.99992841,5.99992841 Z M9.99992841,15.9992125 L19.0000716,15.9992125 L19.0000716,15.9992125 C19.5523168,15.9992125 20,16.4468957 20,16.9991409 L20,16.9991409 L20,16.9991409 C20,17.5513861 19.5523168,17.9990693 19.0000716,17.9990693 L9.99992841,17.9990693 C9.4476832,17.9990693 9,17.5513861 9,16.9991409 C9,16.4468957 9.4476832,15.9992125 9.99992841,15.9992125 Z M9.99992841,10.9995704 L19.0000716,10.9995704 L19.0000716,10.9995704 C19.5523168,10.9995704 20,11.4472536 20,11.9994988 L20,11.9994988 C20,12.5517441 19.5523168,12.9994273 19.0000716,12.9994273 L9.99992841,12.9994273 C9.4476832,12.9994273 9,12.5517441 9,11.9994988 C9,11.4472536 9.4476832,10.9995704 9.99992841,10.9995704 Z M5.22935099,7.69420576 L7.09998441,5.20002786 C7.26566855,4.97911569 7.57906677,4.93434451 7.79997895,5.10002864 C8.02089112,5.26571278 8.0656623,5.579111 7.89997817,5.80002318 L5.64999574,8.79999974 C5.45636149,9.05817875 5.07249394,9.06801504 4.86589123,8.82009178 L3.61590099,7.3201035 C3.43912033,7.10796671 3.46778214,6.79268682 3.67991893,6.61590616 C3.89205572,6.4391255 4.20733561,6.46778731 4.38411627,6.6799241 L5.22935099,7.69420576 Z M5.22935099,12.6942058 L7.09998441,10.2000279 C7.26566855,9.97911569 7.57906677,9.93434451 7.79997895,10.1000286 C8.02089112,10.2657128 8.0656623,10.579111 7.89997817,10.8000232 L5.64999574,13.7999997 C5.45636149,14.0581787 5.07249394,14.068015 4.86589123,13.8200918 L3.61590099,12.3201035 C3.43912033,12.1079667 3.46778214,11.7926868 3.67991893,11.6159062 C3.89205572,11.4391255 4.20733561,11.4677873 4.38411627,11.6799241 L5.22935099,12.6942058 Z M5.22935099,17.6942058 L7.09998441,15.2000279 C7.26566855,14.9791157 7.57906677,14.9343445 7.79997895,15.1000286 C8.02089112,15.2657128 8.0656623,15.579111 7.89997817,15.8000232 L5.64999574,18.7999997 C5.45636149,19.0581787 5.07249394,19.068015 4.86589123,18.8200918 L3.61590099,17.3201035 C3.43912033,17.1079667 3.46778214,16.7926868 3.67991893,16.6159062 C3.89205572,16.4391255 4.20733561,16.4677873 4.38411627,16.6799241 L5.22935099,17.6942058 Z"}})]):e._e(),e._v(" "),"ordered_list"===e.icon?n("g",[n("path",{attrs:{d:"M5,7.99978522 L5,6.70798687 L4.85355339,6.85442299 C4.65829124,7.04967116 4.34170876,7.04967116 4.14644661,6.85442299 C3.95118446,6.65917483 3.95118446,6.342615 4.14644661,6.14736684 L5.14644661,5.14743843 C5.46142904,4.83247855 6,5.05554597 6,5.50096651 L6,7.99978522 L6.5000358,7.99978522 L6.5000358,7.99978522 C6.7761584,7.99978522 7,8.22362682 7,8.49974942 C7,8.77587203 6.7761584,8.99971363 6.5000358,8.99971363 L5.53191883,8.99971363 C5.52136474,9.00037848 5.51072178,9.00071593 5.5,9.00071593 C5.48927822,9.00071593 5.47863526,9.00037848 5.46808117,8.99971363 L4.4999642,8.99971363 L4.4999642,8.99971363 C4.2238416,8.99971363 4,8.77587203 4,8.49974942 C4,8.22362682 4.2238416,7.99978522 4.4999642,7.99978522 L4.4999642,7.99978522 L5,7.99978522 Z M9.99992841,5.99992841 L19.0000716,5.99992841 L19.0000716,5.99992841 C19.5523168,5.99992841 20,6.4476116 20,6.99985681 L20,6.99985681 L20,6.99985681 C20,7.55210202 19.5523168,7.99978522 19.0000716,7.99978522 L9.99992841,7.99978522 L9.99992841,7.99978522 C9.4476832,7.99978522 9,7.55210202 9,6.99985681 L9,6.99985681 L9,6.99985681 C9,6.4476116 9.4476832,5.99992841 9.99992841,5.99992841 Z M9.99992841,15.9992125 L19.0000716,15.9992125 L19.0000716,15.9992125 C19.5523168,15.9992125 20,16.4468957 20,16.9991409 L20,16.9991409 L20,16.9991409 C20,17.5513861 19.5523168,17.9990693 19.0000716,17.9990693 L9.99992841,17.9990693 C9.4476832,17.9990693 9,17.5513861 9,16.9991409 C9,16.4468957 9.4476832,15.9992125 9.99992841,15.9992125 Z M9.99992841,10.9995704 L19.0000716,10.9995704 L19.0000716,10.9995704 C19.5523168,10.9995704 20,11.4472536 20,11.9994988 L20,11.9994988 C20,12.5517441 19.5523168,12.9994273 19.0000716,12.9994273 L9.99992841,12.9994273 L9.99992841,12.9994273 C9.4476832,12.9994273 9,12.5517441 9,11.9994988 C9,11.4472536 9.4476832,10.9995704 9.99992841,10.9995704 Z M4.64644661,16.6466151 L5.29289322,16.0002148 L4.5,16.0002148 C4.22385763,16.0002148 4,15.7763732 4,15.5002506 C4,15.224128 4.22385763,15.0002864 4.5,15.0002864 L6.5,15.0002864 C6.94545243,15.0002864 7.16853582,15.5388188 6.85355339,15.8537787 L6.14380887,16.5634724 C6.64120863,16.728439 7,17.1973672 7,17.7500895 C7,18.440396 6.44035594,19 5.75,19 L4.5,19 C4.22385763,19 4,18.7761584 4,18.5000358 C4,18.2239132 4.22385763,18.0000716 4.5,18.0000716 L5.75,18.0000716 C5.88807119,18.0000716 6,17.8881508 6,17.7500895 C6,17.6120282 5.88807119,17.5001074 5.75,17.5001074 L5,17.5001074 C4.55454757,17.5001074 4.33146418,16.961575 4.64644661,16.6466151 Z M6.40096969,12.700451 L6.00096969,13.0004296 L6.50096969,13.0004296 C6.77711207,13.0004296 7.00096969,13.2242712 7.00096969,13.5003938 C7.00096969,13.7765164 6.77711207,14.000358 6.50096969,14.000358 L4.50096969,14.000358 C4.02046355,14.000358 3.81656478,13.3887054 4.20096969,13.1004224 L5.80096969,11.9005083 C5.92687261,11.8060879 6.00096969,11.6579043 6.00096969,11.5005369 L6.00096969,11.2505548 C6.00096969,11.1124935 5.88904088,11.0005727 5.75096969,11.0005727 L5.50096969,11.0005727 C5.22482732,11.0005727 5.00096969,11.2244143 5.00096969,11.5005369 C5.00096969,11.7766596 4.77711207,12.0005012 4.50096969,12.0005012 C4.22482732,12.0005012 4.00096969,11.7766596 4.00096969,11.5005369 C4.00096969,10.6721691 4.67254257,10.0006443 5.50096969,10.0006443 L5.75096969,10.0006443 C6.44132563,10.0006443 7.00096969,10.5602483 7.00096969,11.2505548 L7.00096969,11.5005369 C7.00096969,11.9726391 6.77867846,12.4171897 6.40096969,12.700451 Z"}})]):e._e(),e._v(" "),"table"===e.icon?n("g",[n("path",{attrs:{d:"M6,5 L18,5 C19.1045695,5 20,5.8954305 20,7 L20,17 C20,18.1045695 19.1045695,19 18,19 L6,19 C4.8954305,19 4,18.1045695 4,17 L4,7 C4,5.8954305 4.8954305,5 6,5 Z M6,7 L6,9 L11,9 L11,7 L6,7 Z M13,7 L13,9 L18,9 L18,7 L13,7 Z M6,11 L6,13 L11,13 L11,11 L6,11 Z M13,11 L13,13 L18,13 L18,11 L13,11 Z M6,15 L6,17 L11,17 L11,15 L6,15 Z M13,15 L13,17 L18,17 L18,15 L13,15 Z"}})]):e._e(),e._v(" "),"row_add_below"===e.icon?n("g",[n("path",{attrs:{d:"M10.875,7.25 L10.875,4.5 C10.875,3.94771525 11.3227153,3.5 11.875,3.5 L12.125,3.5 C12.6772847,3.5 13.125,3.94771525 13.125,4.5 L13.125,7.25 L15.5,7.25 C16.0522847,7.25 16.5,7.69771525 16.5,8.25 L16.5,8.75 C16.5,9.30228475 16.0522847,9.75 15.5,9.75 L13.125,9.75 L13.125,12.5 C13.125,13.0522847 12.6772847,13.5 12.125,13.5 L11.875,13.5 C11.3227153,13.5 10.875,13.0522847 10.875,12.5 L10.875,9.75 L8.5,9.75 C7.94771525,9.75 7.5,9.30228475 7.5,8.75 L7.5,8.25 C7.5,7.69771525 7.94771525,7.25 8.5,7.25 L10.875,7.25 Z M16.2807612,13.8417088 C16.7884428,13.3860971 17.6115572,13.3860971 18.1192388,13.8417088 C18.6269204,14.2973204 18.6269204,15.0360129 18.1192388,15.4916246 L12.9192388,20.1582912 C12.4115572,20.6139029 11.5884428,20.6139029 11.0807612,20.1582912 L5.88076118,15.4916246 C5.37307961,15.0360129 5.37307961,14.2973204 5.88076118,13.8417088 C6.38844276,13.3860971 7.21155724,13.3860971 7.71923882,13.8417088 L12,17.6834175 L16.2807612,13.8417088 Z"}})]):e._e(),e._v(" "),"row_add_above"===e.icon?n("g",[n("path",{attrs:{d:"M13.125,16.75 L13.125,19.5 C13.125,20.0522847 12.6772847,20.5 12.125,20.5 L11.875,20.5 C11.3227153,20.5 10.875,20.0522847 10.875,19.5 L10.875,16.75 L8.5,16.75 C7.94771525,16.75 7.5,16.3022847 7.5,15.75 L7.5,15.25 C7.5,14.6977153 7.94771525,14.25 8.5,14.25 L10.875,14.25 L10.875,11.5 C10.875,10.9477153 11.3227153,10.5 11.875,10.5 L12.125,10.5 C12.6772847,10.5 13.125,10.9477153 13.125,11.5 L13.125,14.25 L15.5,14.25 C16.0522847,14.25 16.5,14.6977153 16.5,15.25 L16.5,15.75 C16.5,16.3022847 16.0522847,16.75 15.5,16.75 L13.125,16.75 Z M7.38994949,10.6094757 C6.84321549,11.1301748 5.95678451,11.1301748 5.41005051,10.6094757 C4.8633165,10.0887767 4.8633165,9.24455668 5.41005051,8.72385763 L11.0100505,3.39052429 C11.5567845,2.86982524 12.4432155,2.86982524 12.9899495,3.39052429 L18.5899495,8.72385763 C19.1366835,9.24455668 19.1366835,10.0887767 18.5899495,10.6094757 C18.0432155,11.1301748 17.1567845,11.1301748 16.6100505,10.6094757 L12,6.21895142 L7.38994949,10.6094757 Z"}})]):e._e(),e._v(" "),"row_add_left"===e.icon?n("g",[n("path",{attrs:{d:"M16.625,10.75 L19,10.75 C19.5522847,10.75 20,11.1977153 20,11.75 L20,12.25 C20,12.8022847 19.5522847,13.25 19,13.25 L16.625,13.25 L16.625,16 C16.625,16.5522847 16.1772847,17 15.625,17 L15.375,17 C14.8227153,17 14.375,16.5522847 14.375,16 L14.375,13.25 L12,13.25 C11.4477153,13.25 11,12.8022847 11,12.25 L11,11.75 C11,11.1977153 11.4477153,10.75 12,10.75 L14.375,10.75 L14.375,8 C14.375,7.44771525 14.8227153,7 15.375,7 L15.625,7 C16.1772847,7 16.625,7.44771525 16.625,8 L16.625,10.75 Z M10.6582912,15.9514719 C11.1139029,16.420101 11.1139029,17.179899 10.6582912,17.6485281 C10.2026796,18.1171573 9.4639871,18.1171573 9.00837542,17.6485281 L4.34170876,12.8485281 C3.88609708,12.379899 3.88609708,11.620101 4.34170876,11.1514719 L9.00837542,6.35147186 C9.4639871,5.88284271 10.2026796,5.88284271 10.6582912,6.35147186 C11.1139029,6.82010101 11.1139029,7.57989899 10.6582912,8.04852814 L6.81658249,12 L10.6582912,15.9514719 Z"}})]):e._e(),e._v(" "),"row_add_right"===e.icon?n("g",[n("path",{attrs:{d:"M7.375,13.25 L5,13.25 C4.44771525,13.25 4,12.8022847 4,12.25 L4,11.75 C4,11.1977153 4.44771525,10.75 5,10.75 L7.375,10.75 L7.375,8 C7.375,7.44771525 7.82271525,7 8.375,7 L8.625,7 C9.17728475,7 9.625,7.44771525 9.625,8 L9.625,10.75 L12,10.75 C12.5522847,10.75 13,11.1977153 13,11.75 L13,12.25 C13,12.8022847 12.5522847,13.25 12,13.25 L9.625,13.25 L9.625,16 C9.625,16.5522847 9.17728475,17 8.625,17 L8.375,17 C7.82271525,17 7.375,16.5522847 7.375,16 L7.375,13.25 Z M13.3417088,8.04852814 C12.8860971,7.57989899 12.8860971,6.82010101 13.3417088,6.35147186 C13.7973204,5.88284271 14.5360129,5.88284271 14.9916246,6.35147186 L19.6582912,11.1514719 C20.1139029,11.620101 20.1139029,12.379899 19.6582912,12.8485281 L14.9916246,17.6485281 C14.5360129,18.1171573 13.7973204,18.1171573 13.3417088,17.6485281 C12.8860971,17.179899 12.8860971,16.420101 13.3417088,15.9514719 L17.1834175,12 L13.3417088,8.04852814 Z"}})]):e._e(),e._v(" "),"header_row"===e.icon?n("g",[n("path",{attrs:{d:"M4 3H18C19.11 3 20 3.9 20 5V12.08C18.45 11.82 16.92 12.18 15.68 13H12V17H13.08C12.97 17.68 12.97 18.35 13.08 19H4C2.9 19 2 18.11 2 17V5C2 3.9 2.9 3 4 3M4 7V11H10V7H4M12 7V11H18V7H12M4 13V17H10V13H4M19.44 21V19H15.44V17H19.44V15L22.44 18L19.44 21"}})]):e._e(),e._v(" "),"header_col"===e.icon?n("g",[n("path",{attrs:{d:"M4 3H18C19.11 3 20 3.9 20 5V12.08C18.45 11.82 16.92 12.18 15.68 13H12V17H13.08C12.97 17.68 12.97 18.35 13.08 19H4C2.9 19 2 18.11 2 17V5C2 3.9 2.9 3 4 3M4 7V11H10V7H4M12 7V11H18V7H12M4 13V17H10V13H4M15.94 18.5H17.94V14.5H19.94V18.5H21.94L18.94 21.5L15.94 18.5"}})]):e._e(),e._v(" "),"bin"===e.icon?n("g",[n("path",{attrs:{d:"M18,9 L17.5031493,18.108929 C17.4452947,19.1695975 16.5683631,20 15.5061179,20 L8.49388209,20 C7.43163685,20 6.55470532,19.1695975 6.49685067,18.108929 L6,9 L18,9 Z M10,10.5 C9.44771525,10.5 9,10.9477153 9,11.5 L9,11.5 L9,16.5 C9,17.0522847 9.44771525,17.5 10,17.5 C10.5522847,17.5 11,17.0522847 11,16.5 L11,16.5 L11,11.5 C11,10.9477153 10.5522847,10.5 10,10.5 Z M14,10.5 C13.4477153,10.5 13,10.9477153 13,11.5 L13,11.5 L13,16.5 C13,17.0522847 13.4477153,17.5 14,17.5 C14.5522847,17.5 15,17.0522847 15,16.5 L15,16.5 L15,11.5 C15,10.9477153 14.5522847,10.5 14,10.5 Z M13,4 C13.5522847,4 14,4.44771525 14,5 L14,6 L18,6 C18.5522847,6 19,6.44771525 19,7 C19,7.55228475 18.5522847,8 18,8 L6,8 C5.44771525,8 5,7.55228475 5,7 C5,6.44771525 5.44771525,6 6,6 L10,6 L10,6 L10,5 C10,4.44771525 10.4477153,4 11,4 L13,4 Z"}})]):e._e(),e._v(" "),"quote"===e.icon?n("g",[n("path",{attrs:{d:"M7,11 L9.00208688,11 C10.1055038,11 11,11.8982606 11,12.9979131 L11,15.0020869 C11,16.1055038 10.1017394,17 9.00208688,17 L6.99791312,17 C5.89449617,17 5,16.1017394 5,15.0020869 L5,12.9989566 L5,11 C5,8.790861 6.790861,7 9,7 L10,7 C10.5522847,7 11,7.44771525 11,8 C11,8.55228475 10.5522847,9 10,9 L9,9 C7.8954305,9 7,9.8954305 7,11 Z M15,11 L17.0020869,11 C18.1055038,11 19,11.8982606 19,12.9979131 L19,15.0020869 C19,16.1055038 18.1017394,17 17.0020869,17 L14.9979131,17 C13.8944962,17 13,16.1017394 13,15.0020869 L13,12.9989566 L13,11 C13,8.790861 14.790861,7 17,7 L18,7 C18.5522847,7 19,7.44771525 19,8 C19,8.55228475 18.5522847,9 18,9 L17,9 C15.8954305,9 15,9.8954305 15,11 Z"}})]):e._e(),e._v(" "),"code_block"===e.icon?n("g",[n("path",{attrs:{d:"M11.9806 19.1961C11.8723 19.7377 11.3454 20.0889 10.8039 19.9806C10.2623 19.8723 9.91111 19.3455 10.0194 18.8039L12.0194 4.80389C12.1277 4.26233 12.6546 3.91112 13.1961 4.01943C13.7377 4.12774 14.0889 4.65457 13.9806 5.19613L11.9806 19.1961ZM5.41421 12L8.70711 15.2929C9.09763 15.6834 9.09763 16.3166 8.70711 16.7071C8.31658 17.0976 7.68342 17.0976 7.29289 16.7071L3.29289 12.7071C2.90237 12.3166 2.90237 11.6834 3.29289 11.2929L7.29289 7.2929C7.68342 6.90238 8.31658 6.90238 8.70711 7.2929C9.09763 7.68343 9.09763 8.31659 8.70711 8.70712L5.41421 12ZM15.2929 15.2929L18.5858 12L15.2929 8.70712C14.9024 8.31659 14.9024 7.68343 15.2929 7.2929C15.6834 6.90238 16.3166 6.90238 16.7071 7.2929L20.7071 11.2929C21.0976 11.6834 21.0976 12.3166 20.7071 12.7071L16.7071 16.7071C16.3166 17.0976 15.6834 17.0976 15.2929 16.7071C14.9024 16.3166 14.9024 15.6834 15.2929 15.2929Z"}})]):e._e(),e._v(" "),"divider"===e.icon?n("g",[n("path",{attrs:{d:"M5,11 L19,11 C19.5522847,11 20,11.4477153 20,12 C20,12.5522847 19.5522847,13 19,13 L5,13 C4.44771525,13 4,12.5522847 4,12 C4,11.4477153 4.44771525,11 5,11 L5,11 Z M7,6 L17,6 C17.5522847,6 18,6.44771525 18,7 L18,8 C18,8.55228475 17.5522847,9 17,9 L7,9 C6.44771525,9 6,8.55228475 6,8 L6,7 L6,7 C6,6.44771525 6.44771525,6 7,6 Z M7,15 L17,15 C17.5522847,15 18,15.4477153 18,16 L18,17 C18,17.5522847 17.5522847,18 17,18 L7,18 C6.44771525,18 6,17.5522847 6,17 L6,16 C6,15.4477153 6.44771525,15 7,15 Z"}})]):e._e(),e._v(" "),"link"===e.icon?n("g",[n("path",{attrs:{d:"M11.0745387,14.3927712 C10.6944229,13.9921087 10.7110794,13.3591628 11.1117419,12.9790471 C11.5124045,12.5989313 12.1453503,12.6155878 12.5254661,13.0162503 C12.9108834,13.422501 13.5526571,13.4393898 13.9780169,13.0353595 L17.3813571,9.63201937 C18.2122318,8.80114469 18.2122318,7.45403068 17.3813571,6.62315601 C16.5504824,5.79228133 15.2033684,5.79228133 14.3724938,6.62315601 L13.5071091,7.48854062 C13.1165848,7.87906491 12.4834199,7.87906491 12.0928956,7.48854062 C11.7023713,7.09801633 11.7023713,6.46485135 12.0928956,6.07432706 L12.9582802,5.20894244 C14.5702035,3.59701919 17.1836474,3.59701919 18.7955707,5.20894244 C20.4074939,6.8208657 20.4074939,9.43430967 18.7955707,11.0462329 L15.3922305,14.4495731 C15.3640722,14.4774856 15.3640722,14.4774856 15.3354286,14.5048999 C14.1278529,15.6505487 12.2201874,15.6003469 11.0745387,14.3927712 Z M12.9299745,9.60955606 C13.3100902,10.0102186 13.2934337,10.6431644 12.8927712,11.0232802 C12.4921087,11.4033959 11.8591628,11.3867395 11.4790471,10.9860769 C11.0936298,10.5798262 10.4518561,10.5629375 10.0264962,10.9669677 L6.62315601,14.3703079 C5.79228133,15.2011826 5.79228133,16.5482966 6.62315601,17.3791712 C7.45403068,18.2100459 8.80114469,18.2100459 9.63201937,17.3791712 L10.497404,16.5137866 C10.8879283,16.1232623 11.5210933,16.1232623 11.9116175,16.5137866 C12.3021418,16.9043109 12.3021418,17.5374759 11.9116175,17.9280002 L11.0462329,18.7933848 C9.43430967,20.4053081 6.8208657,20.4053081 5.20894244,18.7933848 C3.59701919,17.1814616 3.59701919,14.5680176 5.20894244,12.9560943 L8.61228261,9.55275416 C8.64044095,9.52484169 8.64044095,9.52484169 8.66908451,9.49742738 C9.87666026,8.35177859 11.7843257,8.40198031 12.9299745,9.60955606 Z"}})]):e._e(),e._v(" "),"unlink"===e.icon?n("g",[n("path",{attrs:{d:"M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z"}})]):e._e(),e._v(" "),"image"===e.icon?n("g",[n("path",{attrs:{d:"M19,14.5857864 L13.7071068,9.29289322 C13.3165825,8.90236893 12.6834175,8.90236893 12.2928932,9.29289322 L8,13.5857864 L5,10.5857864 L5,7 L5,7 C5,5.8954305 5.8954305,5 7,5 L7,5 L17,5 L17,5 C18.1045695,5 19,5.8954305 19,7 L19,14.5857864 Z M18.9642423,17.3784559 C18.7873485,18.3020643 17.9751801,19 17,19 L7,19 L7,19 C5.8954305,19 5,18.1045695 5,17 L5,13.4142136 L7.29289322,15.7071068 C7.68341751,16.0976311 8.31658249,16.0976311 8.70710678,15.7071068 L13,11.4142136 L18.9642423,17.3784559 Z M8.5,10 C9.32842712,10 10,9.32842712 10,8.5 C10,7.67157288 9.32842712,7 8.5,7 C7.67157288,7 7,7.67157288 7,8.5 C7,9.32842712 7.67157288,10 8.5,10 Z"}})]):e._e(),e._v(" "),"add"===e.icon?n("g",[n("path",{attrs:{d:"M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"}})]):e._e(),e._v(" "),"help"===e.icon?n("g",[n("path",{attrs:{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}})]):e._e(),e._v(" "),"close"===e.icon?n("g",[n("path",{attrs:{d:"M12,10.5857864 L8.70710678,7.29289322 C8.31658249,6.90236893 7.68341751,6.90236893 7.29289322,7.29289322 C6.90236893,7.68341751 6.90236893,8.31658249 7.29289322,8.70710678 L10.5857864,12 L7.29289322,15.2928932 C6.90236893,15.6834175 6.90236893,16.3165825 7.29289322,16.7071068 C7.68341751,17.0976311 8.31658249,17.0976311 8.70710678,16.7071068 L12,13.4142136 L15.2928932,16.7071068 C15.6834175,17.0976311 16.3165825,17.0976311 16.7071068,16.7071068 C17.0976311,16.3165825 17.0976311,15.6834175 16.7071068,15.2928932 L13.4142136,12 L16.7071068,8.70710678 C17.0976311,8.31658249 17.0976311,7.68341751 16.7071068,7.29289322 C16.3165825,6.90236893 15.6834175,6.90236893 15.2928932,7.29289322 L12,10.5857864 Z"}})]):e._e(),e._v(" "),"external_link"===e.icon?n("g",[n("path",{attrs:{d:"M18,7.41421356 L11.7071068,13.7071068 C11.3165825,14.0976311 10.6834175,14.0976311 10.2928932,13.7071068 C9.90236893,13.3165825 9.90236893,12.6834175 10.2928932,12.2928932 L16.5857864,6 L14,6 C13.4477153,6 13,5.55228475 13,5 C13,4.44771525 13.4477153,4 14,4 L19,4 C19.5522847,4 20,4.44771525 20,5 L20,10 C20,10.5522847 19.5522847,11 19,11 C18.4477153,11 18,10.5522847 18,10 L18,7.41421356 Z M9,6 C9.55228475,6 10,6.44771525 10,7 C10,7.55228475 9.55228475,8 9,8 L6,8 L6,18 L16,18 L16,15 C16,14.4477153 16.4477153,14 17,14 C17.5522847,14 18,14.4477153 18,15 L18,18 C18,19.1045695 17.1045695,20 16,20 L6,20 C4.8954305,20 4,19.1045695 4,18 L4,8 C4,6.8954305 4.8954305,6 6,6 L9,6 Z"}})]):e._e(),e._v(" "),"arrow_left"===e.icon?n("g",[n("path",{attrs:{d:"M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"}})]):e._e()])},staticRenderFns:[]},(function(e){e&&e("data-v-8f7e5fc8_0",{source:".paper-wysiwyg-icon{display:inline-block}",map:void 0,media:void 0});}),yF,undefined,false,undefined,!1,kF,void 0,void 0),SF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("li",{staticClass:"paper-wysiwyg-block-menu__item"},[n("button",{on:{click:function(t){return t.preventDefault(),e.click.apply(null,arguments)}}},[n("span",{staticClass:"paper-wysiwyg-block-menu__item__icon"},[e.icon?n("paper-wysiwyg-icon",{attrs:{icon:e.icon}}):e._e(),e._v(" "),e._t("icon")],2),e._v(" "),n("span",{staticClass:"paper-wysiwyg-block-menu__item__label"},[e._v("\n            "+e._s(e.label)+"\n            "),e._t("label")],2),e._v(" "),n("span",{staticClass:"paper-wysiwyg-block-menu__item__help"},[e._v("\n             "+e._s(e.help)+"\n            "),e._t("help")],2)])])},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-block-menu-item",components:{PaperWysiwygIcon:xF},props:{icon:{type:String,default:null},label:{type:String,default:null},help:{type:String,default:null}},methods:{click:function(){this.$emit("click");}}},undefined,false,undefined,!1,void 0,void 0,void 0),DF=LT.uploadImage,MF={data:function(){return {sets:{heading:[{name:"heading",icon:"h1",args:{level:1},label:"Big heading",method:"toggleHeading",key:"Ctrl+Alt+1"},{name:"heading",icon:"h2",args:{level:2},label:"Medium heading",method:"toggleHeading",key:"Ctrl+Alt+2"},{name:"heading",icon:"h3",args:{level:3},label:"Small heading",method:"toggleHeading",key:"Ctrl+Alt+3"}],list:[{name:"unordered",icon:"list",label:"Bulleted list",method:"toggleBulletList",key:"Ctrl+Shift+8"},{name:"ordered",icon:"ordered_list",label:"Ordered list",method:"toggleOrderedList",key:"Ctrl+Shift+7"},{name:"task",icon:"task_list",label:"Task list",method:"toggleTaskList",key:"Ctrl+Shift+9"}],other:[{name:"code",icon:"code_block",label:"Code block",method:"toggleCodeBlock",key:"```"},{name:"blockquote",icon:"quote",label:"Quote",method:"toggleBlockquote",key:">"},{name:"divider",icon:"divider",label:"Divider",method:"setHorizontalRule",key:"---"},{name:"link",icon:"link",label:"Link",callback:"setLink",key:"---"},{name:"image",icon:"image",label:"Image",callback:"addImage",key:"",visibility:this.canUpload},{name:"table",icon:"table",label:"Table",method:"insertTable",args:{rows:3,cols:3,withHeaderRow:!0},key:""}],inline:[{name:"bold",label:"Bold",icon:"bold",method:"toggleBold"},{name:"italic",label:"Italic",icon:"italic",method:"toggleItalic"},{name:"strike",label:"Strikethrough",icon:"strike",method:"toggleStrike"},{name:"code",label:"Code",icon:"code_block",method:"toggleCode"}]},uploadType:"image"}},methods:{toggleStyle:function(e){var t=e.args||{};if(e.callback)return this[e.callback](t);this.editor.chain().focus()[e.method](t).run(),this.closeMenu();},closeMenu:function(){this.$emit("close");},setLink:function(){var e=this.getSelectionRange(this.editor);if(e.from===e.to){this.closeMenu();var t=prompt("Link Url");this.editor.commands.insertContentAt(e.to,'<p><a href="'.concat(t,'">').concat(t,"</a></p>"));}else this.editor.chain().focus().extendMarkRange("link").setLink({href:""}).run(),this.closeMenu();},canUpload:function(){return !!this.editor.options.editorProps.uploadUrl},upload:function(){if("image"===this.uploadType)return this.uploadImage()},addImage:function(){this.uploadType="image",this.$refs.upload.click(),this.closeMenu();},uploadImage:function(){var e=this,t=this.$refs.upload.files[0];DF(t,this.editor.options.editorProps).then((function(t){e.editor.chain().focus().setImage({src:t}).run();})).catch((function(e){console.log(e),alert("Unable to upload file");}));},getSelectionRange:function(e){var t,n,r=null===(t=e.view.state)||void 0===t||null===(n=t.selection)||void 0===n?void 0:n.ranges;return r?{from:r[0].$from.pos,to:r[0].$to.pos}:{from:1,to:1}},itemVisible:function(e){return "function"==typeof e.visibility?e.visibility():!1!==e.visibility}}},OF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.editor?n("floating-menu",{directives:[{name:"show",rawName:"v-show",value:e.visible,expression:"visible"}],staticClass:"paper-wysiwyg-block-menu",attrs:{editor:e.editor,"tippy-options":e.tippyOptions}},[n("ul",[e._l(e.sets.heading,(function(t){return e.itemVisible(t)?n("paper-wysiwyg-block-menu-item",{key:t.name+t.label,attrs:{icon:t.icon,label:t.label},on:{click:function(n){return e.toggleStyle(t)}}}):e._e()})),e._v(" "),n("paper-wysiwyg-block-menu-item-divider"),e._v(" "),e._l(e.sets.list,(function(t){return e.itemVisible(t)?n("paper-wysiwyg-block-menu-item",{key:t.name,attrs:{icon:t.icon,label:t.label},on:{click:function(n){return e.toggleStyle(t)}}}):e._e()})),e._v(" "),n("paper-wysiwyg-block-menu-item-divider"),e._v(" "),e._l(e.sets.other,(function(t){return e.itemVisible(t)?n("paper-wysiwyg-block-menu-item",{key:t.name,attrs:{icon:t.icon,label:t.label},on:{click:function(n){return e.toggleStyle(t)}}}):e._e()}))],2),e._v(" "),n("input",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}],ref:"upload",attrs:{type:"file"},on:{change:function(t){return t.preventDefault(),e.upload.apply(null,arguments)}}})]):e._e()},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-block-menu",components:{PaperWysiwygBlockMenuItemDivider:bF({render:function(){var e=this;e.$createElement;return e._self._c,e._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("li",{staticClass:"paper-wysiwyg-block-menu__item-divider"},[t("hr")])}]},undefined,{name:"paper-wysiwyg-block-menu-item-divider"},undefined,false,undefined,!1,void 0,void 0,void 0),PaperWysiwygBlockMenuItem:SF,FloatingMenu:Sm},mixins:[MF],props:{editor:{type:Object,required:!0},tippyOptions:{type:Object,default:function(){return {duration:100,placement:"bottom-start"}}}},data:function(){return {menuKey:null}},computed:{wrapperClass:function(){return "paper-wysiwyg-block-menu"},visible:function(){return this.editor.options.editorProps.showBlockMenu}},methods:{closeMenu:function(){this.editor.options.editorProps.showBlockMenu=!1;}}},undefined,false,undefined,!1,void 0,void 0,void 0),AF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("button",{staticClass:"paper-wysiwyg-bubble-menu-button",attrs:{title:e.label},on:{click:function(t){return t.preventDefault(),e.click.apply(null,arguments)}}},[n("paper-wysiwyg-icon",{attrs:{icon:e.icon}})],1)},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-bubble-menu-button",components:{PaperWysiwygIcon:xF},props:{icon:{type:String,required:!0},label:{type:String,default:null}},methods:{click:function(){this.$emit("click");}}},undefined,false,undefined,!1,void 0,void 0,void 0),NF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("bubble-menu",{directives:[{name:"show",rawName:"v-show",value:e.visible,expression:"visible"}],staticClass:"paper-wysiwyg-bubble-menu-inline",attrs:{editor:e.editor,"tippy-options":e.tippyOptions}},[e._l(e.sets.inline,(function(t){return n("paper-wysiwyg-bubble-menu-button",{key:t.name,class:e.buttonClass(t),attrs:{icon:t.icon},on:{click:function(n){return e.toggleStyle(t)}}})})),e._v(" "),n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}),e._v(" "),e._l(e.headingTypes,(function(t){return n("paper-wysiwyg-bubble-menu-button",{key:t.name+t.label,class:e.buttonClass(t),attrs:{icon:t.icon},on:{click:function(n){return e.toggleStyle(t)}}})})),e._v(" "),e._l(e.getTypes("other"),(function(t){return n("paper-wysiwyg-bubble-menu-button",{key:t.name,class:e.buttonClass(t),attrs:{icon:t.icon},on:{click:function(n){return e.toggleStyle(t)}}})})),e._v(" "),n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}),e._v(" "),e._l(e.getTypes("list"),(function(t){return n("paper-wysiwyg-bubble-menu-button",{key:t.name,class:e.buttonClass(t),attrs:{icon:t.icon},on:{click:function(n){return e.toggleStyle(t)}}})})),e._v(" "),n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}),e._v(" "),n("paper-wysiwyg-bubble-menu-button",{class:e.buttonClass(e.linkType),attrs:{icon:e.linkType.icon},on:{click:function(t){return e.toggleStyle(e.linkType)}}})],2)},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-bubble-menu-inline",components:{PaperWysiwygBubbleMenuButton:AF,BubbleMenu:Cm},mixins:[MF],props:{editor:{type:Object,required:!0},tippyOptions:{type:Object,default:function(){return {placement:"top",appendTo:document.body}}}},data:function(){return {visible:!1,exclude:["image","link","table"],activeClass:"paper-wysiwyg-bubble-menu-button--active",heading:[2,3],other:["quote"],list:["unordered","ordered"]}},mounted:function(){var e=this;this.editor.on("selectionUpdate",(function(t){var n=t.editor,r=0!==e.exclude.filter((function(e){return n.isActive(e)})).length;e.visible=e.shouldShow(e.editor)&&!r;})),this.$on("close",(function(){e.visible=!1;}));},methods:{getTypes:function(e){var t=this;return this.sets[e].filter((function(n){return t[e].includes(n.name)}))},buttonClass:function(e){return e.args=e.args||{},this.editor.isActive(e.name,e.args)?this.activeClass:""},shouldShow:function(e){try{var t=this.getSelectionRange(e);return t.to>t.from}catch(e){}return !1}},computed:{headingTypes:function(){var e=this;return this.sets.heading.filter((function(t){return e.heading.includes(t.args.level)}))},linkType:function(){return this.sets.other.filter((function(e){return "link"===e.name}))[0]}}},undefined,false,undefined,!1,void 0,void 0,void 0),_F={exports:{}};!function(e){var t=void 0,n={attributes:!0,attributeOldValue:!0,childList:!0,characterData:!0,characterDataOldValue:!0},r={bind:function(e,n){var r=n.value;if(!r)return console.warn('vue-mutation-observer: "Please set callback or config object."');var i="function"==typeof r&&r||r.callback;t=new MutationObserver(i);},inserted:function(e,r){var i=r.value,o=r.modifiers,s=r.arg,a={},l=!0,c=!1,u=void 0;try{for(var d,h=Object.keys(o)[Symbol.iterator]();!(l=(d=h.next()).done);l=!0){var p=d.value;switch(p){case"characterData":a=Object.assign(a,{characterData:!0,characterDataOldValue:!0});break;case"attributes":a=Object.assign(a,{attributes:!0,attributeOldValue:!0});break;case"childList":a=Object.assign(a,{childList:!0});break;default:console.warn('vue-mutation-observer: "Unknown modifier: '+p+'."');}}}catch(e){c=!0,u=e;}finally{try{!l&&h.return&&h.return();}finally{if(c)throw u}}i.config&&(a=Object.assign(a,i.config));var f=0<Object.keys(a).length&&a||n;f.subtree=!!s&&"subtree"===s;try{t.observe(e,f);}catch(e){console.error('vue-mutation-observer: "'+e+'."');}},install:function(e){e.directive("observer",r);}};"undefined"!=typeof window&&window.Vue&&window.Vue.use(r);var i=r;e.observer=i,e.default=r,Object.defineProperty(e,"__esModule",{value:!0});}(_F.exports);var TF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.editor?n("bubble-menu",{directives:[{name:"show",rawName:"v-show",value:e.editor.isActive("link"),expression:"editor.isActive('link')"},{name:"observer",rawName:"v-observer:subtree.childList",value:e.focusInput,expression:"focusInput",arg:"subtree",modifiers:{childList:!0}}],staticClass:"paper-wysiwyg-bubble-menu-link",attrs:{editor:e.editor,"tippy-options":{placement:"top"}}},[e.editor.isActive("link")?n("div",{staticClass:"paper-wysiwyg-bubble-menu-inner"},[n("input",{directives:[{name:"model",rawName:"v-model",value:e.url,expression:"url"}],ref:"url",staticClass:"paper-wysiwyg-bubble-menu-text-input",attrs:{type:"text",placeholder:"Link url"},domProps:{value:e.url},on:{keydown:function(t){if(!t.type.indexOf("key")&&e._k(t.keyCode,"enter",13,t.key,"Enter"))return null;e.updateLink(),e.close();},input:function(t){t.target.composing||(e.url=t.target.value);}}}),e._v(" "),n("button",{staticClass:"paper-wysiwyg-bubble-menu-button",class:{"paper-wysiwyg-bubble-menu-button--active":e.new_window},attrs:{title:"Toggle if link opens in new window"},on:{click:function(t){e.new_window=!e.new_window,e.updateLink();}}},[n("paper-wysiwyg-icon",{attrs:{icon:"external_link"}})],1),e._v(" "),n("button",{staticClass:"paper-wysiwyg-bubble-menu-button",attrs:{title:"Remove link"},on:{click:function(t){return t.preventDefault(),e.destroy.apply(null,arguments)}}},[n("paper-wysiwyg-icon",{attrs:{icon:"close"}})],1)]):e._e()]):e._e()},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-bubble-menu-link",directives:{observer:_F.exports.observer},components:{PaperWysiwygIcon:xF,BubbleMenu:Cm},props:{editor:{type:Object,required:!0}},data:function(){return {url:"",title:"",style:"",styleOptions:uy,new_window:!1,markChange:!1}},mounted:function(){var e=this;this.editor.on("selectionUpdate",(function(t){var n=t.editor.getAttributes("link");e.url=n.href||"",e.title=n.title||null,e.style=n.class||uy[0].value,e.new_window="_blank"===n.target;}));},computed:{newWinButtonLabel:function(){return "Open in "+(this.new_window?"the same":"a new")+" tab"},titleButtonLabel:function(){return (this.title?"Edit":"Add")+" tooltip"}},methods:{updateLink:function(){var e={href:this.url,class:this.style,title:this.title,target:this.new_window?"_blank":null};this.editor.chain().focus().extendMarkRange("link").setLink(e).run();},newWindowToggle:function(){this.new_window=!this.new_window,this.updateLink();},destroy:function(){this.editor.chain().focus().unsetLink().run(),this.close();},close:function(){this.editor.chain().focus().blur();},focusInput:function(){var e=this;setTimeout((function(){var t;null===(t=e.$refs.url)||void 0===t||t.focus();}),100);}}},undefined,false,undefined,!1,void 0,void 0,void 0),LF=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.editor?n("bubble-menu",{staticClass:"paper-wysiwyg-bubble-menu-table",attrs:{editor:e.editor,"tippy-options":{placement:"top",arrow:e.arrow,getReferenceClientRect:e.getReferenceClientRect},shouldShow:e.shouldShow}},e._l(e.relevantMenu,(function(t,r){return n("span",["divider"!==r?n("paper-wysiwyg-bubble-menu-button",{key:t.name,attrs:{icon:t.icon,label:t.name,disabled:e.cantDoAction(r)},on:{click:function(t){return e.callAction(r)}}}):e._e(),e._v(" "),"divider"===r?n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}):e._e()],1)})),0):e._e()},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-bubble-menu-table",components:{BubbleMenu:Cm,PaperWysiwygIcon:xF,PaperWysiwygBubbleMenuButton:AF},props:{editor:{type:Object,required:!0}},data:function(){return {arrow:'<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>',menus:{table:{toggleHeaderColumn:{name:"Toggle header column",icon:"header_col"},toggleHeaderRow:{name:"Toggle header row",icon:"header_row"},divider:!0,deleteTable:{name:"Delete table",icon:"bin"}},row:{addRowBefore:{name:"Add row before",icon:"row_add_above"},addRowAfter:{name:"Add row after",icon:"row_add_below"},divider:!0,deleteRow:{name:"Delete row",icon:"bin"}},col:{addColumnBefore:{name:"Add column before",icon:"row_add_left"},addColumnAfter:{name:"Add column after",icon:"row_add_right"},divider:!0,deleteColumn:{name:"Delete Column",icon:"bin"}}}}},computed:{relevantMenu:function(){var e=this.editor.view.state.selection,t=e.isColSelection&&e.isColSelection(),n=e.isRowSelection&&e.isRowSelection();return t&&n?this.menus.table:n?this.menus.row:t?this.menus.col:null}},methods:{getReferenceClientRect:function(){var e=this.editor.view,t=e.state.selection;if(gp(e.state.selection)){var n=e.nodeDOM(t.from);if(n)return n.getBoundingClientRect()}var r=t.isColSelection&&t.isColSelection(),i=t.isRowSelection&&t.isRowSelection(),o=vp(e,t.from,t.to);return i&&(o.left=o.left-21,o.width=12,o.right=o.left+o.width),r&&(o.top-=16),o},cantDoAction:function(e){return !this.editor.can()[e]()},callAction:function(e){this[e]();},shouldShow:function(){var e=this.editor.view.state.selection;return hA(e)},addColumnBefore:function(){this.editor.chain().focus().addColumnBefore().run();},addColumnAfter:function(){this.editor.chain().focus().addColumnAfter().run();},deleteColumn:function(){this.editor.chain().focus().deleteColumn().run();},addRowBefore:function(){this.editor.chain().focus().addRowBefore().run();},addRowAfter:function(){this.editor.chain().focus().addRowAfter().run();},deleteRow:function(){this.editor.chain().focus().deleteRow().run();},deleteTable:function(){this.editor.chain().focus().deleteTable().run();},toggleHeaderColumn:function(){this.editor.chain().focus().toggleHeaderColumn().run();},toggleHeaderRow:function(){this.editor.chain().focus().toggleHeaderRow().run();},toggleHeaderCell:function(){this.editor.chain().focus().toggleHeaderCell().run();},fixTables:function(){},mergeCells:function(){},splitCell:function(){},mergeOrSplit:function(){}}},undefined,false,undefined,!1,void 0,void 0,void 0),RF=P,FF=$,BF=iT,IF=E(1..valueOf),PF=R,zF=ti,$F=E("".replace),jF="[\t\n\v\f\r                　\u2028\u2029\ufeff]",HF=RegExp("^"+jF+jF+"*"),VF=RegExp(jF+jF+"*$"),KF=function(e){return function(t){var n=zF(PF(t));return 1&e&&(n=$F(n,HF,"")),2&e&&(n=$F(n,VF,"")),n}},qF={start:KF(1),end:KF(2),trim:KF(3)},UF=s,WF=r,GF=E,JF=Fr,ZF=Hn,XF=Le,QF=function(e,t,n){var r,i;return BF&&RF(r=t.constructor)&&r!==n&&FF(i=r.prototype)&&i!==n.prototype&&BF(e,i),e},YF=q,eB=le,tB=rt,nB=o,rB=Vn.f,iB=i.f,oB=Ct.f,sB=IF,aB=qF.trim,lB=WF.Number,cB=lB.prototype,uB=WF.TypeError,dB=GF("".slice),hB=GF("".charCodeAt),pB=function(e){var t=tB(e,"number");return "bigint"==typeof t?t:fB(t)},fB=function(e){var t,n,r,i,o,s,a,l,c=tB(e,"number");if(eB(c))throw uB("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=aB(c),43===(t=hB(c,0))||45===t){if(88===(n=hB(c,2))||120===n)return NaN}else if(48===t){switch(hB(c,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return +c}for(s=(o=dB(c,2)).length,a=0;a<s;a++)if((l=hB(o,a))<48||l>i)return NaN;return parseInt(o,r)}return +c};if(JF("Number",!lB(" 0o1")||!lB("0b1")||lB("+0x1"))){for(var mB,gB=function(e){var t=arguments.length<1?0:lB(pB(e)),n=this;return YF(cB,n)&&nB((function(){sB(n);}))?QF(Object(t),n,gB):t},vB=UF?rB(lB):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),yB=0;vB.length>yB;yB++)XF(lB,mB=vB[yB])&&!XF(gB,mB)&&oB(gB,mB,iB(lB,mB));gB.prototype=cB,cB.constructor=gB,ZF(WF,"Number",gB,{constructor:!0});}var bB=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"paper-wysiwyg-bubble-menu__form"},[n("div",{staticClass:"paper-wysiwyg-bubble-menu__form-input"},[n("paper-wysiwyg-bubble-menu-button",{attrs:{icon:"arrow_left"},on:{click:e.submit}}),e._v(" "),"select"===e.type?n("select",{directives:[{name:"model",rawName:"v-model",value:e.valueMutable,expression:"valueMutable"}],on:{change:[function(t){var n=Array.prototype.filter.call(t.target.options,(function(e){return e.selected})).map((function(e){return "_value"in e?e._value:e.value}));e.valueMutable=t.target.multiple?n:n[0];},e.submit]}},e._l(e.options,(function(t){return n("option",{key:t.value,domProps:{value:t.value,textContent:e._s(t.label)}})})),0):"checkbox"===e.type?n("input",{directives:[{name:"model",rawName:"v-model",value:e.valueMutable,expression:"valueMutable"}],staticClass:"paper-wysiwyg-bubble-menu-text-input",attrs:{placeholder:e.placeholder,type:"checkbox"},domProps:{checked:Array.isArray(e.valueMutable)?e._i(e.valueMutable,null)>-1:e.valueMutable},on:{keypress:function(t){return !t.type.indexOf("key")&&e._k(t.keyCode,"enter",13,t.key,"Enter")?null:(t.preventDefault(),e.submit.apply(null,arguments))},blur:e.submit,change:function(t){var n=e.valueMutable,r=t.target,i=!!r.checked;if(Array.isArray(n)){var o=e._i(n,null);r.checked?o<0&&(e.valueMutable=n.concat([null])):o>-1&&(e.valueMutable=n.slice(0,o).concat(n.slice(o+1)));}else e.valueMutable=i;}}}):"radio"===e.type?n("input",{directives:[{name:"model",rawName:"v-model",value:e.valueMutable,expression:"valueMutable"}],staticClass:"paper-wysiwyg-bubble-menu-text-input",attrs:{placeholder:e.placeholder,type:"radio"},domProps:{checked:e._q(e.valueMutable,null)},on:{keypress:function(t){return !t.type.indexOf("key")&&e._k(t.keyCode,"enter",13,t.key,"Enter")?null:(t.preventDefault(),e.submit.apply(null,arguments))},blur:e.submit,change:function(t){e.valueMutable=null;}}}):n("input",{directives:[{name:"model",rawName:"v-model",value:e.valueMutable,expression:"valueMutable"}],staticClass:"paper-wysiwyg-bubble-menu-text-input",attrs:{placeholder:e.placeholder,type:e.type},domProps:{value:e.valueMutable},on:{keypress:function(t){return !t.type.indexOf("key")&&e._k(t.keyCode,"enter",13,t.key,"Enter")?null:(t.preventDefault(),e.submit.apply(null,arguments))},blur:e.submit,input:function(t){t.target.composing||(e.valueMutable=t.target.value);}}})],1),e._v(" "),n("div",{staticClass:"paper-wysiwyg-bubble-menu__form-description"},[e._t("description"),e._v(" "),e.description?n("p",[e._v(e._s(e.description))]):e._e()],2)])},staticRenderFns:[]},undefined,{name:"paper-wysiwyg-bubble-menu-form-input",components:{PaperWysiwygBubbleMenuButton:AF},props:{value:{type:[String,Number],default:""},type:{type:String,default:"text"},options:{type:Array,default:function(){return []}},description:{type:String,default:""},placeholder:{type:String,default:""}},data:function(){return {valueMutable:this.value}},methods:{submit:function(){this.$emit("input",this.valueMutable);}}},undefined,false,undefined,!1,void 0,void 0,void 0),wB={name:"paper-wysiwyg",components:{DistrictPaperWysiwygBubbleMenuImage:bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.editor?n("bubble-menu",{directives:[{name:"show",rawName:"v-show",value:e.editor.isActive("image"),expression:"editor.isActive('image')"}],staticClass:"paper-wysiwyg-bubble-menu paper-wysiwyg-bubble-menu-image",class:{"paper-wysiwyg-bubble-menu--form-open":e.formOpen},attrs:{editor:e.editor,"tippy-options":{placement:"bottom"}}},[n("div",[n("div",{directives:[{name:"show",rawName:"v-show",value:!e.formOpen,expression:"!formOpen"}],staticClass:"paper-wysiwyg-bubble-menu-toolbar"},[n("paper-wysiwyg-bubble-menu-button",{attrs:{icon:"link"},on:{click:function(t){e.formOpen="link";}}}),e._v(" "),n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}),e._v(" "),n("button",{staticClass:"paper-wysiwyg-bubble-menu-button-text",attrs:{title:e.altButtonLabel},domProps:{textContent:e._s(e.altButtonLabel)},on:{click:function(t){t.preventDefault(),e.formOpen="alt";}}}),e._v(" "),n("span",{staticClass:"paper-wysiwyg-bubble-menu-divider"}),e._v(" "),n("paper-wysiwyg-bubble-menu-button",{attrs:{icon:"bin"},on:{click:e.destroy}})],1),e._v(" "),n("paper-wysiwyg-bubble-menu-form-input",{directives:[{name:"show",rawName:"v-show",value:"link"===e.formOpen,expression:"formOpen === 'link'"}],key:e.link+"url",attrs:{placeholder:"https://example.com",description:"A URL to open when a user clicks on this image"},on:{input:e.update},model:{value:e.link,callback:function(t){e.link=t;},expression:"link"}}),e._v(" "),n("paper-wysiwyg-bubble-menu-form-input",{directives:[{name:"show",rawName:"v-show",value:"alt"===e.formOpen,expression:"formOpen === 'alt'"}],key:e.alt+"alt",attrs:{placeholder:e.altTextPlaceholder,description:e.altTextHelp},on:{input:e.update},model:{value:e.alt,callback:function(t){e.alt=t;},expression:"alt"}})],1)]):e._e()},staticRenderFns:[]},undefined,{name:"district-paper-wysiwyg-bubble-menu-image",components:{PaperWysiwygBubbleMenuButton:AF,PaperWysiwygBubbleMenuFormInput:bB,DistrictDistrictWysiwygBubbleMenuFormInput:bB,BubbleMenu:Cm},props:{editor:{type:Object,required:!0}},data:function(){return {alt:"",link:"",formOpen:"",altTextHelp:"Alternative Text (Alt Text or Alt Tag) is intended to convey the context of the image",altTextPlaceholder:"Describe the image with alt text"}},mounted:function(){var e=this;this.editor.on("selectionUpdate",(function(t){var n=t.editor;if(n.isActive("image")){var r=n.getAttributes("image");e.alt=r.alt,e.link=r["data-href"];}}));},computed:{altButtonLabel:function(){return (this.alt?"Edit":"Add")+" alt text"},linkButtonLabel:function(){return (this.link?"Edit":"Add")+" link"}},methods:{update:function(){this.editor.chain().setImage({alt:this.alt,"data-href":this.link}).run(),this.formOpen="";},destroy:function(){this.editor.chain().focus().deleteSelection().run();}}},undefined,false,undefined,!1,void 0,void 0,void 0),PaperWysiwygBubbleMenuLink:TF,PaperWysiwygBubbleMenuInline:NF,PaperWysiwygBlockMenu:OF,PaperWysiwygBubbleMenuTable:LF,EditorContent:xm,FloatingMenu:Sm},props:{value:{type:String,default:null},variant:{type:String,default:"default"},emptyText:{type:String,default:"Write something great..."},uploadUrl:{type:String,default:null},dark:{type:Boolean,default:!1}},data:function(){return {editor:null}},mounted:function(){this.editor=new Em({content:this.value,extensions:[Fg,iN.configure({placeholder:this.emptyText}),Mm,rv,hy,fy,Im,zT.configure({lowlight:aF}),PN.extend({addProseMirrorPlugins:function(){return [new Dl({props:{handlePaste:function(e,t){var n,r=Array.from((null===(n=t.clipboardData)||void 0===n?void 0:n.items)||[]),i=e.state.schema;return r.forEach((function(n){var r=n.getAsFile();if(0===n.type.indexOf("image"))t.preventDefault(),RT&&r&&RT(r,e._props).then((function(t){var n=i.nodes.image.create({src:t}),r=e.state.tr.replaceSelectionWith(n);e.dispatch(r);}));else {var o=new FileReader;if(o.onload=function(t){var n,r=i.nodes.image.create({src:null===(n=t.target)||void 0===n?void 0:n.result}),o=e.state.tr.replaceSelectionWith(r);e.dispatch(o);},!r)return;o.readAsDataURL(r);}})),!1},handleDOMEvents:{drop:function(e,t){var n,r;if(!(t.dataTransfer&&t.dataTransfer.files&&t.dataTransfer.files.length))return !1;var i=Array.from(null!==(n=null===(r=t.dataTransfer)||void 0===r?void 0:r.files)&&void 0!==n?n:[]).filter((function(e){return /image/i.test(e.type)}));if(0===i.length)return !1;t.preventDefault();var o=e.state.schema,s=e.posAtCoords({left:t.clientX,top:t.clientY});return !!s&&(i.forEach(function(){var t=lv(sv().mark((function t(n){var r,i,a;return sv().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(r=new FileReader,!RT){t.next=12;break}return t.t0=o.nodes.image,t.next=5,RT(n,e._props);case 5:t.t1=t.sent,t.t2={src:t.t1},i=t.t0.create.call(t.t0,t.t2),a=e.state.tr.insert(s.pos,i),e.dispatch(a),t.next=14;break;case 12:r.onload=function(t){var n,r=o.nodes.image.create({src:null===(n=t.target)||void 0===n?void 0:n.result}),i=e.state.tr.insert(s.pos,r);e.dispatch(i);},r.readAsDataURL(n);case 14:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()),!0)}}}})]}}),vF,dy.configure({openOnClick:!1}),kA.configure({resizable:!0}),CA,EA,xA,Qm,FN],onUpdate:this.contentUpdated,editorProps:{showBlockMenu:!1,uploadUrl:this.uploadUrl}});},methods:{contentUpdated:function(e){var t=e.editor;this.$emit("input",t.getHTML());},contentUpdatedRenderless:function(e){var t=e.editor;this.$emit("input",this.stripTags(t.getHTML()));},stripTags:function(e){return e.replace(/(<([^>]+)>)/gi,"")}},computed:{wrapperClass:function(){var e=["paper-wysiwyg"];return this.dark&&e.push("dark-mode"),e},showBlockMenu:function(){return this.editor&&!!this.editor.options.editorProps.showBlockMenu}},beforeDestroy:function(){this.editor.destroy();}},kB=bF({render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.editor?n("div",{class:e.wrapperClass},[n("paper-wysiwyg-bubble-menu-inline",{attrs:{editor:e.editor}}),e._v(" "),n("paper-wysiwyg-bubble-menu-link",{attrs:{editor:e.editor}}),e._v(" "),n("paper-wysiwyg-bubble-menu-table",{attrs:{editor:e.editor}}),e._v(" "),n("district-paper-wysiwyg-bubble-menu-image",{attrs:{editor:e.editor}}),e._v(" "),n("paper-wysiwyg-block-menu",{attrs:{editor:e.editor}}),e._v(" "),n("editor-content",{class:e.wrapperClass+"__editor",attrs:{editor:e.editor}})],1):e._e()},staticRenderFns:[]},undefined,wB,undefined,false,undefined,!1,void 0,void 0,void 0);

	Vue$1.component('paper-wysiwyg', kB);

	new Vue$1({
	  el: '#app',
	  data: {
	    content: '<h2>This is Paper WYSIWYG 🧾✏️</h2><p>Select text to change formatting, or click below then <strong>+</strong> to add something</p><p></p>'
	  }
	});

})();
